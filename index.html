<!DOCTYPE html><html lang="zh-CN" id="theme-dark-mode"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Yourname"><title>Hexo</title><meta name="description" content="A simple and beautiful blog"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Hexo</a></h3><div class="description"><p>A simple and beautiful blog</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/Lhcfl"><i class="fa fa-github"></i></a></li><li><a href="mailto:yourname@example.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/people/jin-xin-4-68"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Yourname</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-17-ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ARouter源码分析</a></h3></div><div class="post-content"><div class="card"><p><p>在阅读源码前，请先下载源码：<a target="_blank" rel="noopener" href="https://github.com/alibaba/ARouter">ARouter</a></p>
<p>最近阅读ARouter源码，发现这真的是一个非常优秀的框架。激发出兴趣来读一下他的源码，实际上，这个框架的结构非常简单。这个框架可以分为<strong>主流程</strong>和<strong>辅助流程</strong>来拆开分析。</p>
<p>主流程包含<strong>编译时</strong>和<strong>运行时</strong>两个部分，其中编译时主要做的是路由路径表的构建，运行时主要做的是路由路径表的加载；</p>
<p>辅助流程主要就是做<strong>启动优化</strong>。</p>
<h2 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h2><h3 id="1-编译时"><a href="#1-编译时" class="headerlink" title="1. 编译时"></a>1. 编译时</h3><p>这部分主要涉及到的是路由路径表的构建，其实现原理是<strong>APT</strong>，即<strong>注解处理器</strong>。</p>
<p>使用ARouter时候，需要在目标类上，通过**@Route<strong>注解进行标记，注解处理器处理的就是这个注解。打开源码路径下的<em>arouter-compiler</em>这个module，找到</strong>RouteProcessor<strong>，这个类就是用来处理</strong>@Route**注解的类。这里需要了解的知识，除了APT，还有java-poet，请自行了解这些。</p>
<p>Processor类的入口方法是<em>process</em>方法，这个方法返回true，则这个处理器已经完成了自己的任务，不会被重复调用。其他比较重要的方法有<em>getSupportedSourceVersion</em>，<em>getSupportedAnnotationTypes</em>等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;? <span class="keyword">extends</span> <span class="title class_">Element</span>&gt; routeElements = roundEnv.getElementsAnnotatedWith(Route.class);</span><br></pre></td></tr></table></figure>

<p>通过这个方法，获取所有被**@Route**标记的元素。</p>
<p>获取到<em>routeElements</em>后，在<em>parseRoutes</em>方法进行处理。我们以最常用的Activity为例，进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rootMap.clear();	<span class="comment">//用来分类存储标记元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来检测元素是否为对应的类型，通过Types.isSubtype()方法来检测。</span></span><br><span class="line"><span class="type">TypeMirror</span> <span class="variable">type_Activity</span> <span class="operator">=</span> elementUtils.getTypeElement(ACTIVITY).asType();</span><br><span class="line"><span class="type">TypeMirror</span> <span class="variable">type_Service</span> <span class="operator">=</span> elementUtils.getTypeElement(SERVICE).asType();</span><br><span class="line"><span class="type">TypeMirror</span> <span class="variable">fragmentTm</span> <span class="operator">=</span> elementUtils.getTypeElement(FRAGMENT).asType();</span><br><span class="line"><span class="type">TypeMirror</span> <span class="variable">fragmentTmV4</span> <span class="operator">=</span> elementUtils.getTypeElement(Consts.FRAGMENT_V4).asType();</span><br></pre></td></tr></table></figure>

<p>最后将分类号的元素信息，存储在成员变量groupMap中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Set&lt;RouteMeta&gt;&gt; groupMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>然后再通过这个groupMap，借助java-poet，来生成真实的类。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ARouter$$Group$$test</span> <span class="keyword">implements</span> <span class="title class_">IRouteGroup</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> &#123;</span><br><span class="line">    atlas.put(<span class="string">&quot;/test/activity1&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, <span class="string">&quot;/test/activity1&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">&quot;ser&quot;</span>, <span class="number">9</span>); put(<span class="string">&quot;ch&quot;</span>, <span class="number">5</span>); put(<span class="string">&quot;fl&quot;</span>, <span class="number">6</span>); put(<span class="string">&quot;dou&quot;</span>, <span class="number">7</span>); put(<span class="string">&quot;boy&quot;</span>, <span class="number">0</span>); put(<span class="string">&quot;url&quot;</span>, <span class="number">8</span>); put(<span class="string">&quot;pac&quot;</span>, <span class="number">10</span>); put(<span class="string">&quot;obj&quot;</span>, <span class="number">11</span>); put(<span class="string">&quot;name&quot;</span>, <span class="number">8</span>); put(<span class="string">&quot;objList&quot;</span>, <span class="number">11</span>); put(<span class="string">&quot;map&quot;</span>, <span class="number">11</span>); put(<span class="string">&quot;age&quot;</span>, <span class="number">3</span>); put(<span class="string">&quot;height&quot;</span>, <span class="number">3</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/test/activity2&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test2Activity.class, <span class="string">&quot;/test/activity2&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">&quot;key1&quot;</span>, <span class="number">8</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/test/activity3&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test3Activity.class, <span class="string">&quot;/test/activity3&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">&quot;name&quot;</span>, <span class="number">8</span>); put(<span class="string">&quot;boy&quot;</span>, <span class="number">0</span>); put(<span class="string">&quot;age&quot;</span>, <span class="number">3</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/test/activity4&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, <span class="string">&quot;/test/activity4&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/test/fragment&quot;</span>, RouteMeta.build(RouteType.FRAGMENT, BlankFragment.class, <span class="string">&quot;/test/fragment&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">&quot;obj&quot;</span>, <span class="number">11</span>); put(<span class="string">&quot;name&quot;</span>, <span class="number">8</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/test/webview&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, TestWebview.class, <span class="string">&quot;/test/webview&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-运行时"><a href="#2-运行时" class="headerlink" title="2. 运行时"></a>2. 运行时</h3><p>这部分主要做的是，在*ARouter.init()*时候，将上过程生成的路径表加载到内存中。</p>
<blockquote>
<p>如果你以官方demo程序验证这一步，需要将app&#x2F;build.gradle中的<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>这一行代码注释掉。</p>
</blockquote>
<p>我们以<em>ARouter.init</em>方法为入口，实际上最终实现init流程的是LogisticsCenter类的<em>init</em>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Context context, ThreadPoolExecutor tpe)</span> <span class="keyword">throws</span> HandlerException &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (registerByPlugin) &#123;</span><br><span class="line">    <span class="comment">//这是在辅助流程需要去讲的</span></span><br><span class="line">  	logger.info(TAG, <span class="string">&quot;Load router map by arouter-auto-register plugin.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Set&lt;String&gt; routerMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It will rebuild router map every times when debuggable.</span></span><br><span class="line">    <span class="keyword">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class="line">      logger.info(TAG, <span class="string">&quot;Run with debug mode or new install, rebuild router map.&quot;</span>);</span><br><span class="line">      <span class="comment">// These class was generated by arouter-compiler.</span></span><br><span class="line">      routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class="line">      <span class="keyword">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class="line">        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      PackageUtils.updateVersion(context);    <span class="comment">// Save new version name when router map update finishes.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      logger.info(TAG, <span class="string">&quot;Load router map from cache.&quot;</span>);</span><br><span class="line">      routerMap = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要着重看的是这一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br></pre></td></tr></table></figure>

<p>我们查看这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title function_">getFileNameByPackageName</span><span class="params">(Context context, <span class="keyword">final</span> String packageName)</span> <span class="keyword">throws</span> PackageManager.NameNotFoundException, IOException, InterruptedException &#123;</span><br><span class="line">  <span class="keyword">final</span> Set&lt;String&gt; classNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; paths = getSourcePaths(context);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">parserCtl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(paths.size());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> String path : paths) &#123;</span><br><span class="line">    Log.v(TAG, <span class="string">&quot;getFileNameByPackageName path=&quot;</span> + path);</span><br><span class="line">    DefaultPoolExecutor.getInstance().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DexFile</span> <span class="variable">dexfile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (path.endsWith(EXTRACTED_SUFFIX)) &#123;</span><br><span class="line">            <span class="comment">//NOT use new DexFile(path), because it will throw &quot;permission error in /data/dalvik-cache&quot;</span></span><br><span class="line">            dexfile = DexFile.loadDex(path, path + <span class="string">&quot;.tmp&quot;</span>, <span class="number">0</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dexfile = <span class="keyword">new</span> <span class="title class_">DexFile</span>(path);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Enumeration&lt;String&gt; dexEntries = dexfile.entries();</span><br><span class="line">          <span class="keyword">while</span> (dexEntries.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> dexEntries.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(packageName)) &#123;</span><br><span class="line">              Log.v(TAG, <span class="string">&quot;find CLASS NAME &quot;</span> + className);</span><br><span class="line">              classNames.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">          Log.e(<span class="string">&quot;ARouter&quot;</span>, <span class="string">&quot;Scan map file in dex files made error.&quot;</span>, ignore);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="literal">null</span> != dexfile) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              dexfile.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          parserCtl.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parserCtl.await();</span><br><span class="line"></span><br><span class="line">  Log.d(Consts.TAG, <span class="string">&quot;Filter &quot;</span> + classNames.size() + <span class="string">&quot; classes by packageName &lt;&quot;</span> + packageName + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> classNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意其中的<em>getSourcePaths</em>方法，这是从代码目录，来获取所有代码目录，然后在</p>
<p><em>getFileNameByPackageName</em>找出以<code>com.alibaba.android.arouter.routes</code>为开头包名的类，这些就是我们在步骤1中生成的辅助类。</p>
<p>这个方法结束后，回到<em>LogisticsCenter#init</em>方法，接下来要做的就是，把加载到的辅助类，通过反射生成对象，再调用其<em>loadTo</em>方法，将路由路径表加载到Warehouse类中去，方便以后的查询。</p>
<h2 id="辅助流程"><a href="#辅助流程" class="headerlink" title="辅助流程"></a>辅助流程</h2><p>在以上的流程中，有一个严重的问题，那就是执行<em>ARouter#init</em>方法的时间过长，以源码的demo为例，在InstantRun的情况下，OnePlus5T需要100多毫秒才能初始化完，这对于程序启动优化来说，是一个不可忽视的时间了。那么如何解决这个问题呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivity: init cost 134</span><br></pre></td></tr></table></figure>

<p>这就是在上一步中，要求你注释掉的代码起作用了，将<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>解除注释，让其发挥作用。</p>
<p>这里需要关注的module是<code>arouter-gradle-plugin</code>。</p>
<p>先来看一下，使用了<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>的神奇效果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivity: init cost 19</span><br></pre></td></tr></table></figure>

<p>通过优化，让<em>ARouter#init</em>消耗时间直接降低了一个数量级，那么<code>arouter-gradle-plugin</code>是怎么做到的呢？</p>
<p>这需要你先了解一下[ASM](&#x2F;android&#x2F;ASM.md)。简单来说，这是一种字节码编程技术，通过修改编译后的字节码的方式，来对原始逻辑增强。</p>
<p>我们再来看<em>ARouter#init</em>的最终实现类和方法<em>LogisticsCenter#init</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Context context, ThreadPoolExecutor tpe)</span> <span class="keyword">throws</span> HandlerException &#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startInit</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//billy.qi modified at 2017-12-06</span></span><br><span class="line">    <span class="comment">//load by plugin first</span></span><br><span class="line">    loadRouterMap();</span><br><span class="line">    <span class="keyword">if</span> (registerByPlugin) &#123;</span><br><span class="line">      logger.info(TAG, <span class="string">&quot;Load router map by arouter-auto-register plugin.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HandlerException</span>(TAG + <span class="string">&quot;ARouter init logistics center exception! [&quot;</span> + e.getMessage() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，当<code>registerByPlugin</code>为true的时候，则只是打印了一句日志，我们再看loadRouterMap()这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadRouterMap</span><span class="params">()</span> &#123;</span><br><span class="line">  registerByPlugin = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//auto generate register code by gradle plugin: arouter-auto-register</span></span><br><span class="line">  <span class="comment">// looks like below:</span></span><br><span class="line">  <span class="comment">// registerRouteRoot(new ARouter..Root..modulejava());</span></span><br><span class="line">  <span class="comment">// registerRouteRoot(new ARouter..Root..modulekotlin());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑非常简单，到底在哪里去加载的路由路径表呢？我们看这个方法的注释，发现，这个方法是被<code>arouter-auto-register</code>自动生成的。</p>
<p>我们打开<code>arouter-gradle-plugin/resources/META-INF/gradle-plugins</code>这个目录，可以看到，有一个<em>com.alibaba.arouter.properties</em>文件，查看其内容：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">implementation-class</span>=<span class="string">com.alibaba.android.arouter.register.launch.PluginLaunch</span></span><br></pre></td></tr></table></figure>

<p>这个<em>PluginLaunch</em>便是此gradle plugin的入口类。查看此类：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PluginLaunch</span> <span class="keyword">implements</span> <span class="title class_">Plugin</span>&lt;Project&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">void</span> apply(Project project) &#123;</span><br><span class="line">    <span class="keyword">def</span> isApp = project.plugins.hasPlugin(AppPlugin)</span><br><span class="line">    <span class="comment">//only application module needs this plugin to generate register code</span></span><br><span class="line">    <span class="keyword">if</span> (isApp) &#123;</span><br><span class="line">      Logger.make(project)</span><br><span class="line"></span><br><span class="line">      Logger.i(<span class="string">&#x27;Project enable arouter-register plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">def</span> android = project.extensions.getByType(AppExtension)</span><br><span class="line">      <span class="keyword">def</span> transformImpl = <span class="keyword">new</span> RegisterTransform(project)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//init arouter-auto-register settings</span></span><br><span class="line">      ArrayList&lt;ScanSetting&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>)</span><br><span class="line">      list.add(<span class="keyword">new</span> ScanSetting(<span class="string">&#x27;IRouteRoot&#x27;</span>))</span><br><span class="line">      list.add(<span class="keyword">new</span> ScanSetting(<span class="string">&#x27;IInterceptorGroup&#x27;</span>))</span><br><span class="line">      list.add(<span class="keyword">new</span> ScanSetting(<span class="string">&#x27;IProviderGroup&#x27;</span>))</span><br><span class="line">      RegisterTransform.registerList = list</span><br><span class="line">      <span class="comment">//register this plugin</span></span><br><span class="line">      android.registerTransform(transformImpl)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看其代码，可以发现，这里一共做了三件事：</p>
<ol>
<li>判断是否为app module，如果不是，则不做任何事，在app module下做2和3两步；</li>
<li>生成了一个RegisterTransform，并为其静态变量registerList赋值，<strong>注意此处赋值的registerList中包含的三个对象</strong>；</li>
<li>注册此RegisterTransform。</li>
</ol>
<p>接下来，就轮到<em>RegisterTransform</em>来执行了。</p>
<p>Transform类，简单来说，就是可以在编译时，扫描所有的jar和class，包括引用类库中的。在扫描过程中，就可以借助<strong>ASM</strong>技术对目标类进行更改。</p>
<p>我们看其入口方法<em>transform</em>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="type">void</span> transform(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, <span class="type">boolean</span> isIncremental) <span class="keyword">throws</span> IOException, TransformException, InterruptedException &#123;</span><br><span class="line">  inputs.each &#123; TransformInput input -&gt;</span><br><span class="line">    <span class="comment">// scan all jars</span></span><br><span class="line">    input.jarInputs.each &#123; JarInput jarInput -&gt;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (ScanUtil.shouldProcessPreDexJar(src.absolutePath)) &#123;</span><br><span class="line">        ScanUtil.scanJar(src, dest)</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt;</span><br><span class="line">    ...</span><br><span class="line">    directoryInput.file.eachFileRecurse &#123; File file -&gt;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span>(file.isFile() &amp;&amp; ScanUtil.shouldProcessClass(path))&#123;</span><br><span class="line">        ScanUtil.scanClass(file)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>省去了一些细节，只保留了主线逻辑，我们可以看到，其扫描到的jar和class都经过了ScanUtils的方法来处理，我们继续跟踪下去，会发现，<em>scanJar</em>也是循环调用的<em>scanClass</em>，这样我们直接看<em>scanClass</em>方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> scanClass(InputStream inputStream) &#123;</span><br><span class="line">  ClassReader cr = <span class="keyword">new</span> ClassReader(inputStream)</span><br><span class="line">  ClassWriter cw = <span class="keyword">new</span> ClassWriter(cr, <span class="number">0</span>)</span><br><span class="line">  ScanClassVisitor cv = <span class="keyword">new</span> ScanClassVisitor(Opcodes.ASM5, cw)</span><br><span class="line">  cr.accept(cv, ClassReader.EXPAND_FRAMES)</span><br><span class="line">  inputStream.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ScanClassVisitor</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">  ScanClassVisitor(<span class="type">int</span> api, ClassVisitor cv) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(api, cv)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> visit(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature,</span><br><span class="line">             String superName, String[] interfaces) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.visit(version, access, name, signature, superName, interfaces)</span><br><span class="line">    RegisterTransform.registerList.each &#123; ext -&gt;</span><br><span class="line">      <span class="keyword">if</span> (ext.interfaceName &amp;&amp; interfaces != <span class="literal">null</span>) &#123;</span><br><span class="line">        interfaces.each &#123; itName -&gt;</span><br><span class="line">          <span class="keyword">if</span> (itName == ext.interfaceName) &#123;</span><br><span class="line">            <span class="comment">//fix repeated inject init code when Multi-channel packaging</span></span><br><span class="line">            <span class="keyword">if</span> (!ext.classList.contains(name)) &#123;</span><br><span class="line">              ext.classList.add(name)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就又涉及到了ASM的知识，ScanClassVisitor是访问某个类的内部结构。</p>
<blockquote>
<p>version：类的版本；</p>
<p>access：表示类的访问权限，public，private，protected等；</p>
<p>name：类的名字；</p>
<p>signature：有无泛型；</p>
<p>superName：其父类；</p>
<p>interfaces：其实现的接口；</p>
</blockquote>
<p>在<em>ScanClassVisitor</em>中，并没有对类做修改，只是从遍历过的类中，把我们关心的类挑出来。那么，我们关心哪些类呢？</p>
<p>在<em>PluginLaunch</em>类中，我们注册了三个<em>ScanSettings</em>类，分别是<strong>IRouteRoot</strong>、<strong>IInterceptorGroup</strong>和<strong>IProviderGroup</strong>，也就是说，我们把实现了这三个接口的类，挑出来，加入到各自对应的ScanSettings类中记录起来。这三个接口是不是很熟悉？就是通过APT生成的用来记录路由路径表的类。</p>
<p>等收集好了这些记录的路径表信息后，就可以对<em>LogisticsCenter</em>通过ASM进行修改了。我们接着看<em>RegisterTransform#transform</em>方法中剩下的逻辑。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fileContainsInitClass) &#123;</span><br><span class="line">  registerList.each &#123; ext -&gt;</span><br><span class="line">    Logger.i(<span class="string">&#x27;Insert register code to file &#x27;</span> + fileContainsInitClass.absolutePath)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ext.classList.isEmpty()) &#123;</span><br><span class="line">      Logger.e(<span class="string">&quot;No class implements found for interface:&quot;</span> + ext.interfaceName)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ext.classList.each &#123;</span><br><span class="line">        Logger.i(it)</span><br><span class="line">      &#125;</span><br><span class="line">      RegisterCodeGenerator.insertInitCodeTo(ext)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意此处的insertInitCodeTo方法，这就是ASM修改的入口了。这里不对修改过程进行详细解释了。我们直接对比看<em>LogisticsCenter</em>修改前后关键代码的对比。</p>
<p>在<em>app&#x2F;build</em>目录下，找到生成的apk文件，通过AndroidStudio来查看其中的class，找到关键<em>LogisticsCenter</em>关键方法<em>loadRouterMap</em>。</p>
<blockquote>
<p>具体过程如下：</p>
<p>app&#x2F;build&#x2F;outputs&#x2F;apk&#x2F;debug&#x2F;app-debug.apk -&gt; classes.dex(双击) -&gt; 找到<em>LogisticsCenter#loadRouterMap</em>方法 -&gt; 右键: show Bytecode。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用apply plugin: &#x27;com.alibaba.arouter&#x27;</span></span><br><span class="line">.method <span class="keyword">private</span> <span class="keyword">static</span> <span class="title function_">loadRouterMap</span><span class="params">()</span>V</span><br><span class="line">    .registers <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">64</span></span><br><span class="line">    const/<span class="number">4</span> v0, <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">    sput-<span class="type">boolean</span> v0, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;registerByPlugin:Z</span><br><span class="line"></span><br><span class="line">    .line <span class="number">69</span></span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用apply plugin: &#x27;com.alibaba.arouter&#x27;</span></span><br><span class="line">.method <span class="keyword">private</span> <span class="keyword">static</span> <span class="title function_">loadRouterMap</span><span class="params">()</span>V</span><br><span class="line">    .registers <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">64</span></span><br><span class="line">    const/<span class="number">4</span> v0, <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">    sput-<span class="type">boolean</span> v0, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;registerByPlugin:Z</span><br><span class="line"></span><br><span class="line">    .line <span class="number">69</span></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$modulejava&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$modulekotlin&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$arouterapi&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$app&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Interceptors$$modulejava&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Interceptors$$app&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$modulejava&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$modulekotlin&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$arouterapi&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$app&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p>对比发现，使用<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>后，这个方法增加了很多代码，基本上就是在加载路由路径表。使用这个gradle插件的基本思想就是，将查找路由路径表的过程，从<strong>运行时</strong>提前到了<strong>编译时</strong>，这算是一种AOT(Ahead of time)思想。</p>
<p>将最耗时的查找过程提前，也就解决了ARouter初始化时间过长的问题。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 3382 words, 11 min 16 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-17-Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B01/">Glide源码分析与自我实现(一)——数据加载主流程</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>本文基于Glide 4.11.0</p>
</blockquote>
<p>阅读前请参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60425157">Glide 源码分析解读-基于最新版Glide 4.9.0</a>一文，该文章中，将Glide中各个部分的作用分析的非常好了。</p>
<p>Glide几乎是现在做Android图片加载的最佳选择了。如此优秀的一个框架是如何实现的呢？如果让我们自己来实现该怎么做呢？我们就通过自己实现一个低配版Glide的方式，来探究Glide中是如何实现的。</p>
<p>我们就称我们自己低配版Glide为<strong>Slide</strong>。那么Slide要实现哪些功能呢？简单来说，就是<strong>获取图片</strong>+<strong>界面显示</strong>。我们通过先构架大体框架，再分步丰富其中细节的方式，来构建Slide的整体结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR;</span><br><span class="line">A[获取图片] --&gt; C[Slide] --&gt; B[界面显示];</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(xxx).load(url).into(iv);</span><br></pre></td></tr></table></figure>

<p>这是Glide一个典型的最为简单的调用过程。那么在这个过程中发生了哪些事情呢？</p>
<p>我们可以通过这个链式调用的返回值发现，有如下过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">style A fill:#aaffcc</span><br><span class="line">style D fill:#ffaa99</span><br><span class="line">A(Glide) --&gt;|&quot;with(xxx)&quot;| B(RequestManager) --&gt;|&quot;load(xxx)&quot;| C(RequestBuilder) --&gt;|&quot;into(iv)&quot;| D(Target);</span><br></pre></td></tr></table></figure>

<h2 id="Glide-with-xxx-发生了什么事？"><a href="#Glide-with-xxx-发生了什么事？" class="headerlink" title="Glide.with(xxx)发生了什么事？"></a>Glide.with(xxx)发生了什么事？</h2><p>阅读源码发现，<code>Glide.with(xxx)</code>的最终实现类是<em>RequestManagerRetriever.java</em>类。继续跟踪，我们在这个类中，看到这样一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> RequestManager <span class="title function_">supportFragmentGet</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> FragmentManager fm,</span></span><br><span class="line"><span class="params">  <span class="meta">@Nullable</span> Fragment parentHint,</span></span><br><span class="line"><span class="params">  <span class="type">boolean</span> isParentVisible)</span> &#123;</span><br><span class="line">  <span class="type">SupportRequestManagerFragment</span> <span class="variable">current</span> <span class="operator">=</span> getSupportRequestManagerFragment(fm, parentHint);</span><br><span class="line">  <span class="type">RequestManager</span> <span class="variable">requestManager</span> <span class="operator">=</span> current.getRequestManager();</span><br><span class="line"></span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关注这个getSupportRequestManagerFragment方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getSupportRequestManagerFragment</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> SupportRequestManagerFragment <span class="title function_">getSupportRequestManagerFragment</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> <span class="keyword">final</span> FragmentManager fm, <span class="meta">@Nullable</span> Fragment parentHint)</span> &#123;</span><br><span class="line">  <span class="type">SupportRequestManagerFragment</span> <span class="variable">current</span> <span class="operator">=</span></span><br><span class="line">    (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">    current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">      current = <span class="keyword">new</span> <span class="title class_">SupportRequestManagerFragment</span>();</span><br><span class="line">      current.setParentFragmentHint(parentHint);</span><br><span class="line">      pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">      handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，这里是一个Glide检测到界面生命周期的关键了。<strong>Glide就是通过像当前Activity添加一个一个无UI的Fragment来探测生命周期的</strong>。</p>
<blockquote>
<p><strong>注意：</strong>在执行了添加fragment的语句<code>fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss()</code>后，又马上通过handler发送了一个一个message，这里需要熟悉Handler机制才能理解，简单来说，就是添加fragment操作，实际上也是通过handler执行的，这是一个异步的过程，如何检测到fragment已经添加完成了呢？就是在<code>commitAllowingStateLoss</code>后，马上去发送一条指定的消息，利用handler处理message的顺序性，来获知fragment已经添加完成。</p>
</blockquote>
<p>经过添加<em>SupportRequestManagerFragment</em>后，我们获得了探测当前界面生命周期的能力。</p>
<p>继续阅读<code>supportFragmentGet</code>方法代码，<strong>RequestManager</strong>是从<strong>SupportRequestManagerFragment</strong>拿到的，如果拿到的是空，则创建一个，设置到该fragment当中去。</p>
<h2 id="RequestManager-load-xxx-发生了什么？"><a href="#RequestManager-load-xxx-发生了什么？" class="headerlink" title="RequestManager.load(xxx)发生了什么？"></a>RequestManager.load(xxx)发生了什么？</h2><p>我们以<code>load(url)</code>为例，来探究这部分代码。</p>
<p>这个方法，返回的是<em>RequestBuilder</em>这个类，看名字就知道，这是一个构建者模式中的Builder类，主要是在添加各种配置项，比如RequestOptions、RequestListener等。</p>
<h2 id="RequestBuilder-into-iv-发生了什么？"><a href="#RequestBuilder-into-iv-发生了什么？" class="headerlink" title="RequestBuilder.into(iv)发生了什么？"></a>RequestBuilder.into(iv)发生了什么？</h2><p>其实，这里才是真正开始触发发起请求的地方。</p>
<h3 id="RequestBuilder"><a href="#RequestBuilder" class="headerlink" title="RequestBuilder"></a>RequestBuilder</h3><p>我们把<code>into(ImageView)</code>方法作为入口，一路跟踪，可以发现最终的实现是如下方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y <span class="keyword">extends</span> <span class="title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="title function_">into</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> Y target,</span></span><br><span class="line"><span class="params">  <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span><br><span class="line"><span class="params">  BaseRequestOptions&lt;?&gt; options,</span></span><br><span class="line"><span class="params">  Executor callbackExecutor)</span> &#123;</span><br><span class="line">  Preconditions.checkNotNull(target);</span><br><span class="line">  <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line"></span><br><span class="line">  <span class="type">Request</span> <span class="variable">previous</span> <span class="operator">=</span> target.getRequest();</span><br><span class="line">  <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">    <span class="comment">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class="line">    <span class="comment">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class="line">    <span class="comment">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class="line">    <span class="comment">// running, we can let it continue running without interruption.</span></span><br><span class="line">    <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">      <span class="comment">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class="line">      <span class="comment">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class="line">      <span class="comment">// that are done in the individual Request.</span></span><br><span class="line">      previous.begin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  target.setRequest(request);</span><br><span class="line">  requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是做了以下事情：</p>
<ol>
<li>是否已经有一个request在处理相同的请求，如果有，则判断是否正在运行，没有正在运行则开始运行；</li>
<li>如果没有一个request在处理此请求，则对target做一些清理操作，与之前的请求解绑，为当前target设置新的请求，然后requestManager开始追踪这个请求。</li>
</ol>
<p>接下来我们就按照<code>requestManager.track(target, request)</code>这段代码继续追踪。来到RequestManager的track方法。</p>
<h3 id="RequestManager"><a href="#RequestManager" class="headerlink" title="RequestManager"></a>RequestManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">track</span><span class="params">(<span class="meta">@NonNull</span> Target&lt;?&gt; target, <span class="meta">@NonNull</span> Request request)</span> &#123;</span><br><span class="line">  targetTracker.track(target);</span><br><span class="line">  requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，只有两个方法。</p>
<h4 id="TargetTracker"><a href="#TargetTracker" class="headerlink" title="TargetTracker"></a>TargetTracker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Target&lt;?&gt;&gt; targets =</span><br><span class="line">      Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;Target&lt;?&gt;, Boolean&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">track</span><span class="params">(<span class="meta">@NonNull</span> Target&lt;?&gt; target)</span> &#123;</span><br><span class="line">  targets.add(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把一个target存放在WeakHashMap中，因为target是与生命周期有关的东西，比如ImageView对应的<strong>ImageViewTarget</strong>，所以这么做是为了防止内存泄漏。</p>
<h4 id="RequestTracker"><a href="#RequestTracker" class="headerlink" title="RequestTracker"></a>RequestTracker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Starts tracking the given request. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runRequest</span><span class="params">(<span class="meta">@NonNull</span> Request request)</span> &#123;</span><br><span class="line">  requests.add(request);</span><br><span class="line">  <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">    request.begin();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    request.clear();</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;Paused, delaying request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pendingRequests.add(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是将暂停的request加入到pendingRequests中去，如果不是暂停的request，则调用其begin方法。</p>
<p>我们查看<em>Request</em>类的子类，可以看到下图。</p>
<p>![request_implementions](&#x2F;assets&#x2F;images&#x2F;request_implementions.jpg)</p>
<p>可以看到一共有4个类实现了<em>Request</em>类，其中<em>FakeRequest</em>类是用于测试的，不去考虑。其他三个类的作用如下：</p>
<ol>
<li><strong>ThumbnailRequestCoordinator:</strong> 用来加载thumbnail；</li>
<li><strong>ErrorRequestCoordinator:</strong> 用来加载错误时候，展示错误状态； </li>
<li><strong>SingleRequest:</strong> 这才是用来加载目标图片的request。</li>
</ol>
<p>我们重点去看SingleRequest的begin方法。</p>
<h3 id="SingleRequest"><a href="#SingleRequest" class="headerlink" title="SingleRequest"></a>SingleRequest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">    assertNotCallingCallbacks();</span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">if</span> (model == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        width = overrideWidth;</span><br><span class="line">        height = overrideHeight;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Only log at more verbose log levels if the user has set a fallback drawable, because</span></span><br><span class="line">      <span class="comment">// fallback Drawables indicate the user expects null models occasionally.</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">logLevel</span> <span class="operator">=</span> getFallbackDrawable() == <span class="literal">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class="line">      onLoadFailed(<span class="keyword">new</span> <span class="title class_">GlideException</span>(<span class="string">&quot;Received null model&quot;</span>), logLevel);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == Status.RUNNING) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot restart a running request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;re restarted after we&#x27;re complete (usually via something like a notifyDataSetChanged</span></span><br><span class="line">    <span class="comment">// that starts an identical request into the same Target or View), we can simply use the</span></span><br><span class="line">    <span class="comment">// resource and size we retrieved the last time around and skip obtaining a new size, starting</span></span><br><span class="line">    <span class="comment">// a new load etc. This does mean that users who want to restart a load because they expect</span></span><br><span class="line">    <span class="comment">// that the view size has changed will need to explicitly clear the View or Target before</span></span><br><span class="line">    <span class="comment">// starting the new load.</span></span><br><span class="line">    <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">      onResourceReady(</span><br><span class="line">        resource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restarts for requests that are neither complete nor running can be treated as new requests</span></span><br><span class="line">    <span class="comment">// and can run again from the beginning.</span></span><br><span class="line"></span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">      onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target.getSize(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">        &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">      target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">      logV(<span class="string">&quot;finished run method in &quot;</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码虽长，但是结构简单。主要做了以下事情：</p>
<ol>
<li>检查model是否是空，model就是要加载的数据来源，比如url、resourceId、File等；</li>
<li>判断request状态，不能重新开始一个正在运行的请求；</li>
<li>判断request状态，如果是已经完成的请求，则说明资源已经存在，直接调用<code>onResourceReady</code>方法并返回；</li>
<li>接下来就来到判断target尺寸的过程了，如果target尺寸已经确定，比如view尺寸measure结束后，则调用<code>onSizeReady</code>方法，<strong>注意：实际的网络请求就在这个onSizeReady方法中，因为只有target的尺寸确定了，才能进行请求并处理图片；</strong></li>
<li>如果尺寸未确定，则调用<code>target.getSize</code>方法去监听尺寸事件，具体可以参考<code>ViewTarget#getSize</code>方法，这是一个通过onPreDrawListener来监听尺寸的；</li>
<li>接下来回调<code>onLoadStarted</code>方法，并且显示加载过程状态。</li>
</ol>
<p>我们着重看网络请求那个分支，也就是<code>onSizeReady</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSizeReady</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">	loadStatus = engine.load(</span><br><span class="line">    glideContext,</span><br><span class="line">    model,</span><br><span class="line">    requestOptions.getSignature(),</span><br><span class="line">    <span class="built_in">this</span>.width,</span><br><span class="line">    <span class="built_in">this</span>.height,</span><br><span class="line">    requestOptions.getResourceClass(),</span><br><span class="line">    transcodeClass,</span><br><span class="line">    priority,</span><br><span class="line">    requestOptions.getDiskCacheStrategy(),</span><br><span class="line">    requestOptions.getTransformations(),</span><br><span class="line">    requestOptions.isTransformationRequired(),</span><br><span class="line">    requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">    requestOptions.getOptions(),</span><br><span class="line">    requestOptions.isMemoryCacheable(),</span><br><span class="line">    requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">    requestOptions.getUseAnimationPool(),</span><br><span class="line">    requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">    <span class="built_in">this</span>,</span><br><span class="line">    callbackExecutor</span><br><span class="line">  );</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码来了！这个<code>engine</code>就是Glide的核心。这个engine是在Glide初始化时候生成的一个实例。</p>
<h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>Engine不只是用于加载图片，而是一个任务执行核心引擎，它要执行的不只是请求远程图片的任务，包括解码任务等，它执行的实际上是一个个的job。</p>
<p>跟踪上一阶段中的<code>engine.load</code>方法，来到是这个方法的关键部分——调用<code>waitForExistingOrStartNewJob</code>。</p>
<p>在这个方法中，主要做了以下事情：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">A&#123;&#123;是否有一个job执行相同操作&#125;&#125; --&gt; |有|B[为此job添加新的回调];</span><br><span class="line">A --&gt; |无|C[添加并执行一个EngineJob];</span><br></pre></td></tr></table></figure>

<h4 id="EngineJob-start-decodeJob"><a href="#EngineJob-start-decodeJob" class="headerlink" title="EngineJob.start(decodeJob)"></a>EngineJob.start(decodeJob)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.decodeJob = decodeJob;</span><br><span class="line">  <span class="type">GlideExecutor</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">    decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class="line">  executor.execute(decodeJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里执行的是decodeJob。</p>
<blockquote>
<p>这里需要着重关注一点，就是<code>executor.execute(decodeJob)</code>的时候，就已经通过<em>GlideExecutor</em>的sourceExecutor.Builder创建了一个<strong>ThreadPoolExecutor</strong>，也就是在这里实现线程池异步执行任务。<strong>ThreadPoolExecutor</strong>并不是Glide提供的实现，而是在java.util.concurrent包下。</p>
</blockquote>
<h4 id="DecodeJob"><a href="#DecodeJob" class="headerlink" title="DecodeJob"></a>DecodeJob</h4><p>DecodeJob是一个<em>Runnable</em>类，所以，我们查看其run方法。</p>
<p>接下来的调用路径参考下图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">subgraph DecodeJob;</span><br><span class="line">A(run) --&gt; B[runWrapped] --&gt; C[runGenerators] --&gt; D[getNextGenerator];</span><br><span class="line">end;</span><br><span class="line">subgraph SourceGenerator</span><br><span class="line">D --&gt; E[startNext] --&gt; F[startNextLoad];</span><br><span class="line">end;</span><br><span class="line">subgraph HttpUrlFetcher</span><br><span class="line">F --&gt; G[loadData] --&gt; H[loadDataWithRedirects];</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p>经过这么长的调用链，我们终于来到了网络请求的部分，我们可以看到Glide原生使用的<em>HttpURLConnection</em>进行网络请求的。<strong>获取到InputStream后，在SourceGenerator中的cacheData方法进行缓存处理。</strong></p>
<h4 id="获取到数据后的处理"><a href="#获取到数据后的处理" class="headerlink" title="获取到数据后的处理"></a>获取到数据后的处理</h4><p>通过<code>DataFetcherGenerator.FetcherReadyCallback</code>可以探知到数据获取成功或者失败，如果获取成功，则在<code>DecodeJob#onDataFetcherReady</code>中处理。关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataFetcherReady</span><span class="params">(</span></span><br><span class="line"><span class="params">      Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey)</span> &#123;</span><br><span class="line">  .....</span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">    runReason = RunReason.DECODE_DATA;</span><br><span class="line">    callback.reschedule(<span class="built_in">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更改任务状态，重新执行此任务，则重新执行到<code>getNextGenerator</code>方法，此时则会返回<strong>DataCacheGenerator</strong>来处理从Disk缓存加载的任务。</p>
<h2 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h2><p>首先，图片来源有哪些？</p>
<ol>
<li>资源图片：drawable, assets, raw, mipmap这些程序中自带的图片；</li>
<li>本地图片：本地存储设备上的图片；</li>
<li>远端图片：我们服务器或者来自第三方服务器的图片，通过URL来获取。这就需要<strong>异步网络请求</strong>，请求结束以后，要<strong>缓存</strong>图片，避免重复请求远端图片，造成时间、网络的浪费。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[Slide];</span><br><span class="line">B([1. 资源图片]) --&gt; A;</span><br><span class="line">C([2. 本地图片]) --&gt; A;</span><br><span class="line">E&#123;缓存是否存在&#125; --&gt; |是,交给Slide|A;</span><br><span class="line">E --&gt; |否,网络请求|D([3. 远端图片]);</span><br><span class="line">D -.-&gt; |获取到图片并缓存|E;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>那么接下来，要丰富的细节，就来到了<strong>网络请求</strong>和<strong>缓存</strong>了。</p>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 2825 words, 9 min 25 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-17-Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B02/">Glide源码分析与自我实现(二)——缓存与BitmapPool</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>本文基于Glide 4.11.0</p>
</blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60426316">Glide 源码分析解读-缓存模块-基于最新版Glide 4.9.0</a></p>
<p><strong>注意：</strong>由于版本差异问题，本文有些部分与参考文章有差异。</p>
<p>缓存模块是Glide中非常重要的部分，Glide图片加载的高效性，几乎有一半功劳都在这里了。</p>
<p>一般来说，Glide有三级缓存，就是<strong>内存缓存</strong>、<strong>磁盘缓存</strong>和<strong>网络缓存</strong>。</p>
<p>先来看缓存流程图，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">style A fill:#99ccff</span><br><span class="line">style B1 fill:#aaffaa</span><br><span class="line">A(发起请求) --&gt; B&#123;1. 通过&lt;br&gt;ActiveResources&lt;br&gt;获取资源&#125; --&gt; |命中|B1([加载完成]);</span><br><span class="line">B --&gt; |未命中|C&#123;2. 通过&lt;br&gt;MemoryCache&lt;br&gt;获取资源&#125; --&gt; |命中|C1[缓存至&lt;br&gt;ActiveResources] --&gt; B1;</span><br><span class="line">C --&gt; |未命中|D&#123;3. 通过&lt;br&gt;DiskCache&lt;br&gt;获取资源&#125; --&gt; |命中|D1[缓存至&lt;br&gt;MemoryCache] --&gt; C1;</span><br><span class="line">D --&gt; |未命中|E[&quot;4. 通过数据源(网络、文件等)&lt;br&gt;加载数据&quot;] --&gt; E1[缓存至&lt;br&gt;DiskCache] --&gt; D1;</span><br></pre></td></tr></table></figure>

<h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>内存缓存主要靠三个部分组成：<strong>ActiveResources</strong>、<strong>MemoryCache</strong>和<strong>BitmapPool</strong>。</p>
<h3 id="ActiveResources"><a href="#ActiveResources" class="headerlink" title="ActiveResources"></a>ActiveResources</h3><p>ActiveResources表示当前正在活动中的资源。ActiveResources通过一个<code>Map&lt;Key, ResourceWeakReference&gt;</code>来保存活动中的资源，其中的ResourceWeakReference就是资源数据，在构建这个ResourceWeakReference的时候必须传入一个ReferenceQueue用来检测资源是否被回收。</p>
<blockquote>
<p><strong>Q1：如何探知WeakReference中的值被回收了呢？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">WeakReference</span> <span class="variable">wr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(value, queue);</span><br></pre></td></tr></table></figure>

<p>当构建WeakReference的时候，如果传入了queue参数，则在value被回收的时候，wr会被加入到queue中去，这样，通过检测queue中是否有值，就可以探知value是否被回收了。</p>
</blockquote>
<p>那么，在何时去探知ReferenceQueue中的值呢？我们查看ActiveResources的关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*构造方法中，通过monitorClearedResourcesExecutor执行了cleanReferenceQueue()方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ActiveResources(<span class="type">boolean</span> isActiveResourceRetentionAllowed) &#123;</span><br><span class="line">  <span class="built_in">this</span>(</span><br><span class="line">    isActiveResourceRetentionAllowed,</span><br><span class="line">    java.util.concurrent.Executors.newSingleThreadExecutor(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Runnable r)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                r.run();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;glide-active-resources&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">ActiveResources(</span><br><span class="line">  <span class="type">boolean</span> isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) &#123;</span><br><span class="line">  <span class="built_in">this</span>.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;</span><br><span class="line">  <span class="built_in">this</span>.monitorClearedResourcesExecutor = monitorClearedResourcesExecutor;</span><br><span class="line"></span><br><span class="line">  monitorClearedResourcesExecutor.execute(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        cleanReferenceQueue();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cleanReferenceQueue</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (!isShutdown) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">ResourceWeakReference</span> <span class="variable">ref</span> <span class="operator">=</span> (ResourceWeakReference) resourceReferenceQueue.remove();</span><br><span class="line">      cleanupActiveReference(ref);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This section for testing only.</span></span><br><span class="line">      <span class="type">DequeuedResourceCallback</span> <span class="variable">current</span> <span class="operator">=</span> cb;</span><br><span class="line">      <span class="keyword">if</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        current.onResourceDequeued();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// End for testing only.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过代码可以看出，<code>cleanReferenceQueue</code>是一个靠<code>isShutdown</code>变量控制的<strong>死循环</strong>方法，这个方法执行在一个优先级为<code>THREAD_PRIORITY_BACKGROUND</code>的线程上。</p>
<blockquote>
<p><strong>Q2：那么，既然是死循环方法，会不会过多的占用CPU资源呢？</strong></p>
<p>其实不会的，因为ReferenceQueue#remove是一个阻塞式的方法，如果没有元素可以被remove，则等待至有元素可以remove的时候，等待期间释放CPU。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong>此处与<strong>参考文章</strong>中的说法不同，这是因为版本差异。查看<a target="_blank" rel="noopener" href="https://github.com/bumptech/glide/commit/8f1ea5c07dff7ade8c49c324bcb5a7f40d0b4891#diff-c46e6c0760c04e74cb867c2bdf9cdee90ab279b119268478524c42cc743cb8a9">Glide update log hsitory</a>，可以看出<strong>出于避免在主线程做清理的原因</strong>，将清理任务放在了后台线程，而不是放在IdleHandler中。</p>
</blockquote>
<p><strong>那么被回收了的资源去哪里了呢？</strong></p>
<p>我们查看<code>cleanupActiveReference</code>方法，得知，通过<em>ResourceListener#onResourceReleased</em>回调，交给了<strong>Engine</strong>来处理，我们查看Engine的onResourceReleased方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResourceReleased</span><span class="params">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> &#123;</span><br><span class="line">  activeResources.deactivate(cacheKey);</span><br><span class="line">  <span class="keyword">if</span> (resource.isMemoryCacheable()) &#123;</span><br><span class="line">    cache.put(cacheKey, resource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resourceRecycler.recycle(resource, <span class="comment">/*forceNextFrame=*/</span> <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里我们发现，这里出现了两种情况：</p>
<ol>
<li>如果资源是<strong>MemoryCacheable</strong>的，则缓存在MemoryCache；</li>
<li>如果资源不是<strong>MemoryCacheable</strong>的，则交给ResourceRecycler调用Resource的recycle()方法来回收，如果此Resource为BitmapResource，则会将Bitmap回收到BitmapPool中去。</li>
</ol>
<p>在开始MemoryCache和BitmapPool前，需要先了解一下<strong>MemorySizeCalculator</strong>这个类，这个类是用来计算 BitmapPool 、ArrayPool 以及 MemoryCache <strong>大小</strong>的。</p>
<h3 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h3><p>MemoryCache的具体实现类是LruResourceCache，而实际的逻辑方法，都在其父类LruCache中，以put方法为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Y <span class="title function_">put</span><span class="params">(<span class="meta">@NonNull</span> T key, <span class="meta">@Nullable</span> Y item)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">itemSize</span> <span class="operator">=</span> getSize(item);</span><br><span class="line">  <span class="keyword">if</span> (itemSize &gt;= maxSize) &#123;</span><br><span class="line">    onItemEvicted(key, item);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">    currentSize += itemSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Nullable</span> Entry&lt;Y&gt; old = cache.put(key, item == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(item, itemSize));</span><br><span class="line">  <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">    currentSize -= old.size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!old.value.equals(item)) &#123;</span><br><span class="line">      onItemEvicted(key, old.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  evict();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> old != <span class="literal">null</span> ? old.value : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当有一个新的item被put进去以后，会替换出一个老的值old，如果old非为空，则需要将当前容量减去old的大小，如果old并非新的item，则需要通过onItemEvicted进行回调，通知有老值被<strong>“驱逐”</strong>了。最后还要执行一次evict方法，按照LRU算法，将超出maxSize的item<strong>“驱逐”</strong>出去，以确保在maxSize范围内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">  Map.Entry&lt;T, Entry&lt;Y&gt;&gt; last;</span><br><span class="line">  Iterator&lt;Map.Entry&lt;T, Entry&lt;Y&gt;&gt;&gt; cacheIterator;</span><br><span class="line">  <span class="keyword">while</span> (currentSize &gt; size) &#123;</span><br><span class="line">    cacheIterator = cache.entrySet().iterator();</span><br><span class="line">    last = cacheIterator.next();</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;Y&gt; toRemove = last.getValue();</span><br><span class="line">    currentSize -= toRemove.size;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">T</span> <span class="variable">key</span> <span class="operator">=</span> last.getKey();</span><br><span class="line">    cacheIterator.remove();</span><br><span class="line">    onItemEvicted(key, toRemove.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">evict</span><span class="params">()</span> &#123;</span><br><span class="line">  trimToSize(maxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被**”驱逐”*<em>的值去哪里了呢？我们查看</em>MemoryCache<em>类的源码，可以知道是通过</em>ResourceRemovedListener<em>回调给了</em>Engine<em>，在</em>Engine<em>中我们查看</em>onResourceRemoved*方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResourceRemoved</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Resource&lt;?&gt; resource)</span> &#123;</span><br><span class="line">  <span class="comment">// Avoid deadlock with RequestManagers when recycling triggers recursive clear() calls.</span></span><br><span class="line">  <span class="comment">// See b/145519760.</span></span><br><span class="line">  resourceRecycler.recycle(resource, <span class="comment">/*forceNextFrame=*/</span> <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这里同样是通过resourceRecycler进行了回收。在这里，则是交给resource自己的recycle()方法来处理，比如，<em>BitmapResource</em>是交给了<em>BitmapPool</em>进行处理。</p>
<h3 id="BitmapPool"><a href="#BitmapPool" class="headerlink" title="BitmapPool"></a>BitmapPool</h3><p>这里是专门用来存放被回收的Bitmap的，其中<strong>BitmapDrawableResource</strong>、<strong>BitmapResource</strong>都持有一个<strong>BitmapPool</strong>变量，在执行recycle()方法时候，调用*BitmapPool#put()*方法。我们来看一下这个BitmapPool的默认实现类<strong>LruBitmapPool</strong>的方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (bitmap == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Bitmap must not be null&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (bitmap.isRecycled()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot pool recycled bitmap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!bitmap.isMutable()</span><br><span class="line">      || strategy.getSize(bitmap) &gt; maxSize</span><br><span class="line">      || !allowedConfigs.contains(bitmap.getConfig())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(</span><br><span class="line">        TAG,</span><br><span class="line">        <span class="string">&quot;Reject bitmap from pool&quot;</span></span><br><span class="line">        + <span class="string">&quot;, bitmap: &quot;</span></span><br><span class="line">        + strategy.logBitmap(bitmap)</span><br><span class="line">        + <span class="string">&quot;, is mutable: &quot;</span></span><br><span class="line">        + bitmap.isMutable()</span><br><span class="line">        + <span class="string">&quot;, is allowed config: &quot;</span></span><br><span class="line">        + allowedConfigs.contains(bitmap.getConfig()));</span><br><span class="line">    &#125;</span><br><span class="line">    bitmap.recycle();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> strategy.getSize(bitmap);</span><br><span class="line">  strategy.put(bitmap);</span><br><span class="line">  tracker.add(bitmap);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看出，当Bitmap在三种情况下是不会被BitmapPool缓存起来的：</p>
<ol>
<li>这个bitmap是非mutable的，也就是说是不允许被复用的；</li>
<li>这一个bitmap的字节数大小已经超过了可以容纳的总大小；</li>
<li>BitmapPool中不允许的Config类型。</li>
</ol>
<p>在这种情况，bitmap就被直接recycle掉，而不是放入缓存等待下次使用。</p>
<p>如果不满足这三种情况，则会被strategy缓存起来，等待下次使用。</p>
<p>我们再看LruBitmapPool#get()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> Bitmap <span class="title function_">get</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, Bitmap.Config config)</span> &#123;</span><br><span class="line">  <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> getDirtyOrNull(width, height, config);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">    result.eraseColor(Color.TRANSPARENT);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = createBitmap(width, height, config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，当能够查询到符合条件的Bitmap的时候，会先通过eraseColor方法，将其变成透明图片，然后再交给调用者来使用；如果查询不到，则创建一个新图交给调用者来使用。</p>
<blockquote>
<p>LruBitmapPool的LruPoolStrategy变量，在KITKAT以及以上，是SizeConfigStrategy，在以下是AttributeStrategy，这是因为在KITKAT版本以下，Bitmap的复用需要尺寸的严格匹配，但是KITKAT及以上没有这个问题，只要被复用的图片尺寸比目标尺寸大就可以。</p>
</blockquote>
<h3 id="ArrayPool"><a href="#ArrayPool" class="headerlink" title="ArrayPool"></a>ArrayPool</h3><p>ArrayPool主要用在<strong>ThumbnailStreamOpener</strong>和<strong>ByteBufferGifDecoder</strong>中，具体的实现类为<strong>LruArrayPool</strong>。</p>
<p>在LruArrayPool中，通过groupedMap来缓存数据，而缓存数据的byte字节数是通过<strong>ArrayAdapterInterface</strong>来计算的，ArrayAdapterInterface是一个接口，实现类有两个：<strong>IntegerArrayAdapter</strong>和<strong>ByteArrayAdapter</strong>，分别对应缓存int[].class和byte[].class。</p>
<p>StreamGifDecoder和StreamBitmapDecoder都有一个ArrayPool成员。解码过程中需要用到byte[]，但不是直接new byte[]，而是调用<code>ArrayPool.get()</code>从对象池中拿，用完了归还。</p>
<h2 id="DiskCache"><a href="#DiskCache" class="headerlink" title="DiskCache"></a>DiskCache</h2><p>在上一章[Glide源码分析与自我实现(一)——数据加载主流程](&#x2F;源码分析系列&#x2F;Glide源码分析与自我实现2.md)中，提到过数据加载的主流程，其中一个非常重要的类是 <strong>DecodeJob</strong>，在这个类的<code>getNextGenerator</code>方法中，返回的<strong>SourceGenerator</strong>会用来加载远程数据，但是这个方法不止返回这一个<strong>DataFetcherGenerator</strong>类，这是一个通过条件判断，返回不同DataFetcherGenerator类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DataFetcherGenerator <span class="title function_">getNextGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourceCacheGenerator</span>(decodeHelper, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataCacheGenerator</span>(decodeHelper, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SourceGenerator</span>(decodeHelper, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unrecognized stage: &quot;</span> + stage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这是依次递进的<strong>有限状态机</strong>设计模式，当一个获取数据请求到来时候，此时是默认状态INITIALIZE，然后通过<code>getNextStage</code>方法判断下一个状态是什么，再按照新的状态获取DataFetcherGenerator，然后随着任务的执行，不断改变状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stage <span class="title function_">getNextStage</span><span class="params">(Stage current)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">        ? Stage.RESOURCE_CACHE</span><br><span class="line">        : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">        ? Stage.DATA_CACHE</span><br><span class="line">        : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="comment">// Skip loading from source if the user opted to only retrieve the resource from cache.</span></span><br><span class="line">      <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unrecognized stage: &quot;</span> + current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其状态变更顺序为INITIALIZE -&gt; RESOURCE_CACHE -&gt; DATA_CACHE -&gt; SOURCE，代表着ResourceCacheGenerator、DataCacheGenerator和SourceGenerator，当从ResourceCahce中拿不到数据，则向DataCacheGenerator请求数据，如果还是拿不到，则通过SourceGenerator去请求数据了。</p>
<p>在这个过程中，SourceGenerator向DiskCache中写入数据，ResourceCacheGenerator和DataCacheGenerator从DiskCache中读取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceCacheGenerator</span> <span class="keyword">implements</span> <span class="title class_">DataFetcherGenerator</span>,</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNext</span><span class="params">()</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      currentKey = <span class="keyword">new</span> <span class="title class_">ResourceCacheKey</span>(sourceId, helper.getSignature(), helper.getWidth(),</span><br><span class="line">          helper.getHeight(), transformation, resourceClass, helper.getOptions());</span><br><span class="line">      cacheFile = helper.getDiskCache().get(currentKey);</span><br><span class="line">      <span class="keyword">if</span> (cacheFile != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sourceKey = sourceId;</span><br><span class="line">        modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">        modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataCacheGenerator</span> <span class="keyword">implements</span> <span class="title class_">DataFetcherGenerator</span>,</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (modelLoaders == <span class="literal">null</span> || !hasNextModelLoader()) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="type">Key</span> <span class="variable">sourceId</span> <span class="operator">=</span> cacheKeys.get(sourceIdIndex);</span><br><span class="line">      <span class="type">Key</span> <span class="variable">originalKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataCacheKey</span>(sourceId, helper.getSignature());</span><br><span class="line">      cacheFile = helper.getDiskCache().get(originalKey);</span><br><span class="line">      <span class="keyword">if</span> (cacheFile != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sourceKey = sourceId;</span><br><span class="line">        modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">        modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceGenerator</span> <span class="keyword">implements</span> <span class="title class_">DataFetcherGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dataToCache != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> dataToCache;</span><br><span class="line">      dataToCache = <span class="literal">null</span>;</span><br><span class="line">      cacheData(data);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheData</span><span class="params">(Object dataToCache)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</span><br><span class="line">      DataCacheWriter&lt;Object&gt; writer =</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DataCacheWriter</span>&lt;&gt;(encoder, dataToCache, helper.getOptions());</span><br><span class="line">      originalKey = <span class="keyword">new</span> <span class="title class_">DataCacheKey</span>(loadData.sourceKey, helper.getSignature());</span><br><span class="line">      helper.getDiskCache().put(originalKey, writer);</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      loadData.fetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceCacheGenerator =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DataCacheGenerator</span>(Collections.singletonList(loadData.sourceKey), helper, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DiskCache的默认实现类是<strong>DiskLruCacheWrapper</strong>，其内部通过<strong>DiskLruCache</strong>来管理磁盘缓存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到现在，Glide主要部分已经分析的差不多了，实际上这个优秀的框架可挖的地方还有很多，比如通过[APT来实现很好的扩展](&#x2F;源码分析系列&#x2F;Glide源码分析与自我实现3.md)，框架中涉及多种涉及模式等。</p>
<blockquote>
<p>其中涉及到的涉及模式，比如无处不在的<strong>构建者模式</strong>和<strong>工厂模式</strong>，DecodeJob中的<strong>有限状态机模式</strong>，还有BitmapPool和ArrayPool中的<strong>享元模式</strong>，DiskLruCacheWrapper中的<strong>代理模式</strong>等。</p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.sunmoonblog.com/2018/07/27/glide-cache/">Glide缓存分析</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 2791 words, 9 min 18 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-17-Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B03/">Glide源码分析与自我实现(三)——APT的使用与GIF的优化</a></h3></div><div class="post-content"><div class="card"><p><p>项目Demo地址：<a target="_blank" rel="noopener" href="https://github.com/boybeak/GifHelper">GifHelper</a></p>
<p><strong>什么是APT？</strong></p>
<p><strong>APT</strong>是<strong>Annotation Processing Tool</strong>的简称，即<strong>编译时注解处理器</strong>。它是一个javac的工具，在编译时，通过注解，按照规则自动生成相关代码的工具。</p>
<p><strong>APT与Glide什么关系？</strong></p>
<p>我们通常通过在build.gradle加入这样一段代码来引入Glide库。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  google()</span><br><span class="line">  jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation <span class="string">&#x27;com.github.bumptech.glide:glide:4.11.0&#x27;</span></span><br><span class="line">  annotationProcessor <span class="string">&#x27;com.github.bumptech.glide:compiler:4.11.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个<code>annotationProcessor</code>，这就是对Glide提供的APT进行引用。我们查看Glide的源码结构，可以看到一个名为<em>annotation</em>的文件夹，这里就是与APT有关的部分。</p>
<p>![Glide Struct](&#x2F;assets&#x2F;images&#x2F;glide_struct.jpg)</p>
<p>接下来我们先通过GIF优化，看一看Glide的APT能实现的神奇效果，在这之后，再来分析Glide是如何通过APT实现的。</p>
<blockquote>
<p><strong>注意：</strong>如果使用kotlin需要先加入<code>apply plugin: &#39;kotlin-kapt&#39;</code>插件，并且将<code>annotationProcessor</code>改成<code>kapt</code>。</p>
</blockquote>
<h2 id="GIF优化"><a href="#GIF优化" class="headerlink" title="GIF优化"></a>GIF优化</h2><p><strong>为什么要优化GIF？</strong></p>
<p>有人可能会有疑问，Glide相比其他图片加载框架的优势之一，就是支持GIF，为什么还要做优化呢？</p>
<p>先看两个截图来对比优化前后的CPU和内存使用情况。</p>
<p>![优化前](&#x2F;assets&#x2F;images&#x2F;gif_before_optimization.png)</p>
<p>![优化后](&#x2F;assets&#x2F;images&#x2F;gif_after_optimization.png)</p>
<p>我们可以看出，优化后，CPU和内存状况都好了很多，那么我们是怎么做的呢？这就需要用到谷歌官方的两个库——<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/external/giflib/+/refs/heads/master">giflib</a>和<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/ex/+/refs/heads/master/framesequence/">FrameSequence</a>，这两个库需要我们自己编译成.so文件，具体可以参考示例项目<a target="_blank" rel="noopener" href="https://github.com/boybeak/GifHelper">GifHelper</a>。</p>
<p>我们查看GifHolder中的代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GifHolder</span>(v: View) : AbsHolder&lt;GifItem&gt;(v) &#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> gifIV = view&lt;ImageView&gt;(R.id.gifIV)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(item: <span class="type">GifItem</span>, position: <span class="type">Int</span>, absAdapter: <span class="type">AnyAdapter</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.useGifX) &#123;</span><br><span class="line">      <span class="comment">// 优化后的加载方式</span></span><br><span class="line">    	GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 优化前的加载方式</span></span><br><span class="line">      Glide.with(itemView).asGif().load(item.source()).into(gifIV)</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，加载后有这样一条语句：<code>GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</code>，也许你会懵逼，哪里有GlideApp？哪里有asGifX()方法？我引入Glide后怎么没有看到这两个东西？这就涉及到了APT的内容了。想要看Glide官方文档的可以看<a target="_blank" rel="noopener" href="http://bumptech.github.io/glide/doc/configuration.html#glidemodule">这里</a>。</p>
<p>一切的起因，要从**@GlideModule**这个注解说起，我们打开demo中的MyAppGlideModule类，可以看到这个类有一个@GlideModule注解。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAppGlideModule</span> : <span class="type">AppGlideModule</span>() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerComponents</span><span class="params">(context: <span class="type">Context</span>, glide: <span class="type">Glide</span>, registry: <span class="type">Registry</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.registerComponents(context, glide, registry)</span><br><span class="line">    registry.append(Registry.BUCKET_GIF, InputStream::<span class="keyword">class</span>.java,</span><br><span class="line">                    FrameSequenceDrawable::<span class="keyword">class</span>.java, GifDecoder(glide.bitmapPool))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再点开这个注解的源码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GlideModule &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the name of the class that will be used as a replacement for &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">   * com.bumptech.glide.Glide&#125; in Applications that depend on Glide&#x27;s generated code.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String <span class="title function_">glideName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;GlideApp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在看到“GlideApp”了，是glideName这个注解属性的默认值。我们来逐条分析一下这个注解类的相关信息：</p>
<ul>
<li><code>@Target(ElementType.TYPE)</code>：指明这个注解的作用对象——只对类生效；</li>
<li><code>@Retention(RetentionPolicy.CLASS)</code>：指明了这个注解的作用阶段——编译时记录在class文件中；</li>
<li><code>public @interface GlideModule</code>：这是一个注解接口，接口名<strong>GlideModule</strong>；</li>
<li><code>String glideName() default &quot;GlideApp&quot;</code>：这个注解接口需要一个名为<em>glideName</em>的属性，属性默认值为“GlideApp”。</li>
</ul>
<blockquote>
<p>RetentionPolicy：</p>
<ul>
<li><strong>SOURCE</strong>：这样的注解会被编译器擦除，只在编码阶段生效，目的是为了提示开发者，比如**@IntDef<strong>、</strong>@StringDef<strong>、</strong>@Visibility<strong>、</strong>@NonNull**；</li>
<li><strong>CLASS</strong>：记录在class文件中，编译时对编译器可见，运行时对VM不可见，这是RetentionPolicy的默认值，比如**@NotNull**;</li>
<li><strong>RUNTIME</strong>：记录在class文件中，在运行时需要反射获取其属性值，比如**@Column**。</li>
</ul>
</blockquote>
<p>就是这个**@GlideModule**属性，为我们生成了GlideApp类，这其中的生成过程，我们稍后再说，先把Gif优化的流程说完。</p>
<p>添加**@GlideModule**后，再次编译看，是否有了GlideApp这个类了。</p>
<p>我们再来看<em>MyAppGlideModule</em>中的代码，<code>registry.append</code>方法，这是为Glide添加一种解析类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* @param bucket 要添加的类型id.</span></span><br><span class="line"><span class="comment">* @param dataClass 要从什么数据进行解析。 (&#123;@link java.io.InputStream&#125;, &#123;@link</span></span><br><span class="line"><span class="comment">*     java.io.FileDescriptor&#125; etc).</span></span><br><span class="line"><span class="comment">* @param resourceClass 要解析成什么数据。 (&#123;@link android.graphics.Bitmap&#125;,</span></span><br><span class="line"><span class="comment">*     &#123;@link com.bumptech.glide.load.resource.gif.GifDrawable&#125; etc).</span></span><br><span class="line"><span class="comment">* @param decoder 用什么解码器进行解析 &#123;@link ResourceDecoder&#125;。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> &lt;Data, TResource&gt; Registry <span class="title function_">append</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> String bucket,</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> Class&lt;Data&gt; dataClass,</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> Class&lt;TResource&gt; resourceClass,</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> ResourceDecoder&lt;Data, TResource&gt; decoder)</span> &#123;</span><br><span class="line">  decoderRegistry.append(bucket, decoder, dataClass, resourceClass);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来就要引入谷歌官方的两个类库了，<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/ex/+/android-9.0.0_r16/framesequence/">FrameSquence</a>和<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/external/giflib/+/android-9.0.0_r16">giflib</a>。大家可以根据需要下载对应版本的库，不过这两个库的版本最好要对应。</p>
<p>下载后需要编译，项目结构参考<a target="_blank" rel="noopener" href="https://github.com/boybeak/GifHelper">GifHelper</a>项目中的framesequence&#x2F;src&#x2F;main&#x2F;jni文件夹。注意，需要将FrameSequence_gif.h中的include部分进行修改。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- #include &quot;config.h&quot;</span></span><br><span class="line"><span class="deletion">- #include &quot;gif_lib.h&quot;</span></span><br><span class="line">改成</span><br><span class="line"><span class="addition">+ #include &quot;giflib/config.h&quot;</span></span><br><span class="line"><span class="addition">+ #include &quot;giflib/gif_lib.h&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后执行ndk-build，则会在jni同级的目录下，生成一个libs文件夹，.so文件就在这里。</p>
<p>接下来需要去自定义GifDecoder.java了，直接上代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GifDecoder</span>(<span class="keyword">private</span> <span class="keyword">val</span> bmpPool: BitmapPool) : ResourceDecoder&lt;InputStream, FrameSequenceDrawable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> headerParser = DefaultImageHeaderParser()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handles</span><span class="params">(source: <span class="type">InputStream</span>, options: <span class="type">Options</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(options.<span class="keyword">get</span>(GifOptions.DISABLE_ANIMATION) ?: <span class="literal">true</span>)</span><br><span class="line">            &amp;&amp; headerParser.getType(source) == ImageHeaderParser.ImageType.GIF</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        source: <span class="type">InputStream</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        width: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        height: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        options: <span class="type">Options</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Resource&lt;FrameSequenceDrawable&gt;? &#123;</span><br><span class="line">        <span class="keyword">val</span> fs = FrameSequence.decodeStream(source)</span><br><span class="line">        <span class="keyword">val</span> fsd = FrameSequenceDrawable(fs, <span class="keyword">object</span> : FrameSequenceDrawable.BitmapProvider &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">acquireBitmap</span><span class="params">(minWidth: <span class="type">Int</span>, minHeight: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">                <span class="keyword">return</span> bmpPool.<span class="keyword">get</span>(minWidth, minHeight, Bitmap.Config.ARGB_8888)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">releaseBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>?)</span></span> &#123;</span><br><span class="line">                bmpPool.put(bitmap)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> GifResource(fsd)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类里只需要实现两个方法：<code>handles</code>和<code>decode</code>：</p>
<ul>
<li>handles：能否解析该输入源，能则返回true；</li>
<li>decode：如果handles返回true，则执行此方法，返回一个Resource对象包裹住目标类型对象。</li>
</ul>
<p>我们通过Glide自带的<em>ImageHeaderParser</em>来检测该输入流是否是gif图像的输入流，如果是且可以执行动画，则进行decode操作。</p>
<p>我们着重看decode方法，这里需要重点看的是，在构建<em>FrameSequenceDrawable</em>时候，传入了一个<em>BitmapProvider</em>对象，这就是提高Gif效率的关键，在这个<em>BitmapProvider</em>里面，我们通过BitmapPool，去寻找可用尺寸的Bitmap，通过<strong>池化</strong>的方式，减小了内存开销，增加里Bitmap利用率。</p>
<p>接下来看，如何添加<code>asGifX</code>方法。我们都知道，传统的Glide调用方式如下图：</p>
<p><code>Glide.with(itemView).asGif().load(item.source()).into(gifIV)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[Glide] --&gt;|&quot;with(xxx)&quot;| B[RequestManager] --&gt;|&quot;asGif&quot;| C[RequestBuilder];</span><br></pre></td></tr></table></figure>

<p>而新的方式却不同，如下图：</p>
<p><code>GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[GlideApp] --&gt;|&quot;with(xxx)&quot;| B[GlideRequests]  --&gt;|asGifX| C[GlideRequest];</span><br></pre></td></tr></table></figure>

<p>这其中的<em>GlideRequest</em>和<em>GlideRequest</em>，同样都是生成的类，其中GlideRequests继承自RequestManager，GlideRequest继承自RequestBuilder。</p>
<p>这两个类的生成，同样是**@GlideModule**的作用，但是<code>asGifX</code>这个方法是什么时候定义的呢？我们去查看<code>asGifX</code>这个方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> GifExtension#asGifX(RequestBuilder)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@CheckResult</span></span><br><span class="line"><span class="keyword">public</span> GlideRequest&lt;FrameSequenceDrawable&gt; <span class="title function_">asGifX</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (GlideRequest&lt;FrameSequenceDrawable&gt;) GifExtension.asGifX(<span class="built_in">this</span>.as(FrameSequenceDrawable.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到实际上这个类的具体实现，是依靠GifExtension类，我们去看这个类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GlideExtension</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GifExtension</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@GlideType(FrameSequenceDrawable.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RequestBuilder&lt;FrameSequenceDrawable&gt; <span class="title function_">asGifX</span><span class="params">(RequestBuilder&lt;FrameSequenceDrawable&gt; requestBuilder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> requestBuilder.apply(RequestOptions</span><br><span class="line">                .decodeTypeOf(FrameSequenceDrawable.class)</span><br><span class="line">                .lock());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GifExtension</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类需要我们自己实现，并且需要标记**@GlideExtension**注解，又是注解的功劳。</p>
<p>到此为止，Gif优化的主流程就全部讲完了，接下来就要看这两个注解——**@GlideModule<strong>和</strong>@GlideExtension**到底做了什么？</p>
<h2 id="GlideModule和-GlideExtension"><a href="#GlideModule和-GlideExtension" class="headerlink" title="@GlideModule和@GlideExtension"></a>@GlideModule和@GlideExtension</h2><p>源码在Glide项目的annotation&#x2F;compiler内，这种APT项目的入口文件标记在src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;gradle内，这其中有一个incremental.annotation.processors文件，我们查看其内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor,aggregating</span><br></pre></td></tr></table></figure>

<p>可以得知，程序入口在GlideAnnotationProcessor这个类，查看这个类的源码，我只提取了关键部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">GlideAnnotationProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> LibraryModuleProcessor libraryModuleProcessor;</span><br><span class="line">  <span class="keyword">private</span> AppModuleProcessor appModuleProcessor;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> isGeneratedAppGlideModuleWritten;</span><br><span class="line">  <span class="keyword">private</span> ExtensionProcessor extensionProcessor;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getSupportedAnnotationTypes</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    result.addAll(libraryModuleProcessor.getSupportedAnnotationTypes());</span><br><span class="line">    result.addAll(extensionProcessor.getSupportedAnnotationTypes());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment env)</span> &#123;</span><br><span class="line">    processorUtil.process();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newModulesWritten</span> <span class="operator">=</span> libraryModuleProcessor.processModules(env);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newExtensionWritten</span> <span class="operator">=</span> extensionProcessor.processExtensions(env);</span><br><span class="line">    appModuleProcessor.processModules(set, env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newExtensionWritten || newModulesWritten) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isGeneratedAppGlideModuleWritten) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot process annotations after writing AppGlideModule&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isGeneratedAppGlideModuleWritten) &#123;</span><br><span class="line">      isGeneratedAppGlideModuleWritten = appModuleProcessor.maybeWriteAppModule();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getSupportedAnnotationTypes</code>方法中标记了，支持哪些注解的解析，其中<code>libraryModuleProcessor.getSupportedAnnotationTypes()</code>中返回了**@GlideModule<strong>，<code>extensionProcessor.getSupportedAnnotationTypes()</code>中返回了</strong>@GlideExtension**。</li>
<li>process方法中开始了对注解的处理。</li>
</ul>
<p>注解的处理，需要你对<a target="_blank" rel="noopener" href="https://github.com/square/javapoet"><strong>javapoet</strong></a>有一点点了解，如果暂时不想去了解，你只需要知道，这个类库是通过字符串和占位符来生成Java代码的工具类库，因为接下来的生成代码工作，Glide就是通过这个类库来实现的。</p>
<p>具体的生成过程不再赘述，从入口类<em>GlideAnnotationProcessor</em>追踪下去，就能看到。</p>
<h2 id="为什么优化能提高效率？"><a href="#为什么优化能提高效率？" class="headerlink" title="为什么优化能提高效率？"></a>为什么优化能提高效率？</h2><p>Glide默认Gif加载方案，是通过GifDrawable来实现的，而GifDrawable是通过GifFrameLoader来加载帧数据的。具体代码分析可以看参考文章，我这里简单来说一下原因：</p>
<ul>
<li>默认方案是串行执行的，比如在加载显示第N帧，这一帧显示完毕，再去解析第N+1帧，当播放第N+1帧的时间窗口到了以后，如果已经解析完毕，则能正常显示，如果不能解析完毕，则会卡顿了；</li>
<li>GifFrameLoader内部是用了一个mainLooper的handler来进行流程控制，具体可以看GifFrameLoader里的代码，这种方式本身在时间上就不是准时的，与应用内其他各种系统共享mainLooper，如果其他事件执行占用时间较长，也会影响这里的效率了。</li>
</ul>
<p>我们再来说说优化方案，优化的原因也简单说一下：</p>
<ul>
<li>优化方案是<strong>并行+双缓冲</strong>执行的，在显示第N帧的BitmapA同时，会有一个后台线程在解析第N+1帧的BitmapB，当需要显示第N+1帧BitmapB的时候，两帧的Bitmap交换，BitmapA则进入后台线程去解析第N+2帧了；</li>
<li>在native去解析数据，效率更高；</li>
<li>通过BitmapPool提高了内存利用率。</li>
</ul>
<p>借用参考文章里的一张图</p>
<p>![Gif](&#x2F;assets&#x2F;images&#x2F;gif.webp)</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6854573219425288199">Glide加载Gif的卡顿优化思路分析</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 2802 words, 9 min 20 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-17-Jetpack%E4%B9%8BLifecycle%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Jetpack之Lifecycle源码分析</a></h3></div><div class="post-content"><div class="card"><p><p>这是一篇解析jetpack库中的<strong>Lifecycle</strong>库的分析文章。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> lifecycle_version = <span class="string">&quot;2.2.0&quot;</span></span><br><span class="line"><span class="comment">// Lifecycles only (without ViewModel or LiveData)</span></span><br><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;</span></span><br><span class="line"><span class="comment">// Annotation processor</span></span><br><span class="line">kapt <span class="string">&quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObserver</span> : <span class="type">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        lifecycle.addObserver(MyObserver())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很典型的Lifecycle库的使用过程，通过注解的方式，在<em>MyObserver</em>中声明对应的生命周期函数，然后将这个<em>MyObserver</em>实例添加到<em>MainActivity</em>的lifecycle中去。</p>
<p>看到与注解相关，熟悉框架源码的朋友可能已经知道如何去分析了，很可能用到<strong>注解处理器</strong>，与<a target="_blank" rel="noopener" href="https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><strong>ARouter</strong></a>类似，Lifecycle的工作流程也分成两部分——<strong>编译时</strong>和<strong>运行时</strong>。</p>
<p>简要的说，在编译时，生成<strong>LifecycleObserver</strong>的辅助类；在运行时，<em>addObserver</em>方法被调用后，解析出对应observer的辅助类。</p>
<h2 id="生命周期探知"><a href="#生命周期探知" class="headerlink" title="生命周期探知"></a>生命周期探知</h2><p>在正式详解这两个过程前，我们需要先要了解Lifecycle库是如何感知生命周期的呢？</p>
<p>读过Glide源码(附上<a target="_blank" rel="noopener" href="https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B01.html">Glide源码解读</a>)的同学可能知道，Glide感知生命周期是通过一个无UI的fragment来实现的，其实，Lifecycle也是这么做的。</p>
<p>对外提供生命周期的类，需要实现LifecycleOwner接口。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LifecycleOwner</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the Lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    Lifecycle getLifecycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以<em>AppCompatActivity</em>为例去查看它是如何实现的这个接口，我们查看其父类中有一个<em>ComponentActivity</em>类(AppCompatActivity -&gt; FragmentActivity -&gt; ComponentActivity)。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentActivity</span> <span class="title">extends</span> <span class="title">androidx</span>.<span class="title">core</span>.<span class="title">app</span>.<span class="title">ComponentActivity</span> <span class="title">implements</span></span><br><span class="line">        LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner,</span><br><span class="line">        SavedStateRegistryOwner,</span><br><span class="line">        OnBackPressedDispatcherOwner &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="meta">@Nullable</span> Bundle savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mSavedStateRegistryController.performRestore(savedInstanceState);</span><br><span class="line">        ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mContentLayoutId != <span class="number">0</span>) &#123;</span><br><span class="line">            setContentView(mContentLayoutId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意此处，有一个<em>ReportFragment</em>执行了injectIfNeededIn方法，在这个方法中，就是检测是否已经添加了这个<em>ReportFragment</em>，如果没添加则添加一个。继续查看这个<em>ReportFragment</em>的源码，可以在其生命周期函数中，执行了分发生命周期的流程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReportFragment</span> <span class="title">extends</span> <span class="title">Fragment</span> &#123;</span><br><span class="line">  static void dispatch(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Lifecycle.Event event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activity instanceof LifecycleRegistryOwner) &#123;</span><br><span class="line">      ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity instanceof LifecycleOwner) &#123; <span class="comment">// 3</span></span><br><span class="line">      Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">      <span class="keyword">if</span> (lifecycle instanceof LifecycleRegistry) &#123;</span><br><span class="line">        ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> void dispatchCreate(ActivityInitializationListener listener) &#123;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> void onActivityCreated(Bundle savedInstanceState) &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    dispatchCreate(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_CREATE); <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> void dispatch(<span class="meta">@NonNull</span> Lifecycle.Event event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">      <span class="comment">// Only dispatch events from ReportFragment on API levels prior</span></span><br><span class="line">      <span class="comment">// to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks</span></span><br><span class="line">      <span class="comment">// added in ReportFragment.injectIfNeededIn</span></span><br><span class="line">      dispatch(getActivity(), event); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看代码中我标注的注释顺序onActivityCreated -&gt; dispatch(Lifecycle.Event) -&gt; dispatch(Activity, Lifecycle.Event)，我们看到最后一个流程中，拿到<em>Lifecycle</em>对象后，判断是否为<em>LifecycleRegistry</em>类，如果是，则调用handleLifecycleEvent方法。这里，<em>ComponentActivity</em>提供的<em>Lifecycle</em>对象就是<em>LifecycleRegistry</em>类。</p>
<p>经过这样一个流程，我们就将感知生命周期的无UI的<em>ReportFragment</em>与执行事件的<em>LifecycleRegistry</em>进行了连接。这样我们就获得了感知生命周期的能力了。</p>
<p>那么具体是如何执行到<em>MyObserver</em>对应的生命周期的方法的呢？</p>
<blockquote>
<p>或许你看到这里，会觉得很简单，在<em>LifecycleRegistry</em>维护一个observer队列，然后在执行handleLifecycleEvent方法的时候，通过反射从<em>MyObserver</em>中筛选出带有**@OnLifecycleEvent**注解的方法，如果注解中的值与事件event相等，则通过method.invoke()来调用。</p>
<p>可是谷歌工程师并没有这么做，因为在执行事件时候，经过这么多反射，效率会很低。那么正确的流程是怎么样的？这就需要我们关注上面提到的两个流程了——<strong>编译时</strong>和<strong>运行时</strong>。</p>
</blockquote>
<h2 id="编译时"><a href="#编译时" class="headerlink" title="编译时"></a>编译时</h2><p>参考<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/lifecycle/lifecycle-compiler">Lifecycle-compiler</a>源码。</p>
<p>通过注解处理器，AS为我们生成了MyObserver的辅助类——<em>MyObserver_LifecycleAdapter</em>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObserver_LifecycleAdapter</span> <span class="keyword">implements</span> <span class="title class_">GeneratedAdapter</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> MyObserver mReceiver;</span><br><span class="line"></span><br><span class="line">  MyObserver_LifecycleAdapter(MyObserver receiver) &#123;</span><br><span class="line">    <span class="built_in">this</span>.mReceiver = receiver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callMethods</span><span class="params">(LifecycleOwner owner, Lifecycle.Event event, <span class="type">boolean</span> onAny,</span></span><br><span class="line"><span class="params">      MethodCallsLogger logger)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasLogger</span> <span class="operator">=</span> logger != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (onAny) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == Lifecycle.Event.ON_CREATE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">&quot;onCreate&quot;</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        mReceiver.onCreate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == Lifecycle.Event.ON_PAUSE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">&quot;onPause&quot;</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        mReceiver.onPause();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，实际的生命周期事件分发是在这里完成的。那么这个辅助类是在哪里被使用到的呢？</p>
<p>接下来就是<strong>运行时</strong>发挥作用的时候了。</p>
<h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><p>运行时的起点，是从<em>addObserver</em>开始的。</p>
<p>我们查看<em>LifecycleRegistry#addObserver</em>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FastSafeIterableMap</span>&lt;&gt;();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> &#123;</span><br><span class="line">  <span class="type">State</span> <span class="variable">initialState</span> <span class="operator">=</span> mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">  <span class="type">ObserverWithState</span> <span class="variable">statefulObserver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverWithState</span>(observer, initialState);</span><br><span class="line">  <span class="type">ObserverWithState</span> <span class="variable">previous</span> <span class="operator">=</span> mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，<em>LifecycleRegistry</em>中并不是直接维护observer对象，而是维护<em>ObserverWithState</em>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObserverWithState</span> &#123;</span><br><span class="line">  State mState;</span><br><span class="line">  LifecycleEventObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">  ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">    mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br><span class="line">    mState = initialState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> &#123;</span><br><span class="line">    <span class="type">State</span> <span class="variable">newState</span> <span class="operator">=</span> getStateAfter(event);</span><br><span class="line">    mState = min(mState, newState);</span><br><span class="line">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">    mState = newState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类的构造方法中，执行了一个<code>mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</code></p>
<p>在我们的案例中，这个方法返回了一个<em>SingleGeneratedAdapterObserver</em>类，我们查看这个类的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleGeneratedAdapterObserver</span> <span class="keyword">implements</span> <span class="title class_">LifecycleEventObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GeneratedAdapter mGeneratedAdapter;</span><br><span class="line"></span><br><span class="line">    SingleGeneratedAdapterObserver(GeneratedAdapter generatedAdapter) &#123;</span><br><span class="line">        mGeneratedAdapter = generatedAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source, <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">        mGeneratedAdapter.callMethods(source, event, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        mGeneratedAdapter.callMethods(source, event, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是在这里，调用了<em>MyObserver_LifecycleAdapter</em>的<em>callMethods</em>方法。</p>
<p>那么是如何找到<em>MyObserver_LifecycleAdapter</em>方法的呢？</p>
<p>在<em>Lifecycling</em>类中，通过observer的类名来找的，我们看到有这样的一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getAdapterName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> className.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;_&quot;</span>) + <span class="string">&quot;_LifecycleAdapter&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，整个流程就串起来了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编译时：生成<em>XXX_LifecycleAdapter</em>类，用来分发不同的生命周期事件。</p>
<p>运行时：在addObserver时候，通过类名找到这个<em>XXX_LifecycleAdapter</em>类，生成对象在<em>LifecycleRegistry</em>中进行维护；在ReportFragment方法中触发生命周期时候，调用<em>LifecycleRegistry</em>的<em>handleLifecycleEvent</em>方法进行具体的生命周期事件分发。</p>
<p>总体来看，其整个流程并不复杂，我们可以看到ARouter、Glide的影子，读过其他源码后，理解这个并不难。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 1563 words, 5 min 12 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-17-Jetpack%E4%B9%8BLiveData%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Jetpack之LiveData源码分析</a></h3></div><div class="post-content"><div class="card"><p><p>在阅读这篇文章前，需要先对[**Lifecycle**](&#x2F;源码分析系列&#x2F;Jetpack之Lifecycle源码分析.md)有所了解。</p>
<p>Lifecycle是LiveData的根基，先有了生命周期的管理，才能进行安全不泄漏的数据观察。</p>
<p>先要引入LiveData：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> activity_version = <span class="string">&quot;1.1.0&quot;</span></span><br><span class="line"><span class="comment">// Kotlin，引入这个扩展，可以使用by viewModels()方法</span></span><br><span class="line">implementation <span class="string">&quot;androidx.activity:activity-ktx:$activity_version&quot;</span></span><br></pre></td></tr></table></figure>

<p>典型的用法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> vm <span class="keyword">by</span> viewModels&lt;MainVM&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        vm.<span class="keyword">data</span>.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, it, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vm.start()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainVM</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span>.value = <span class="string">&quot;start&quot;</span></span><br><span class="line">        Thread &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">            <span class="keyword">data</span>.postValue(<span class="string">&quot;run after 2000ms&quot;</span>)</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这两段代码中，我们就可以看出典型的用法，主要是在三个方法上，<em>observe</em>、<em>setValue</em>和<em>postValue</em>。我们就从这三个方法入手去探究LiveData的工作机制。</p>
<h2 id="observe方法"><a href="#observe方法" class="headerlink" title="observe方法"></a>observe方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LiveData.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="built_in">super</span> T&gt; observer)</span> &#123;</span><br><span class="line">  assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">LifecycleBoundObserver</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleBoundObserver</span>(owner, observer);</span><br><span class="line">  <span class="type">ObserverWrapper</span> <span class="variable">existing</span> <span class="operator">=</span> mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">  <span class="keyword">if</span> (existing != <span class="literal">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                                       + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>只允许在主线程中监听数据变化，并且如果<em>LifecycleOwner</em>已经处于<strong>DESTROYED</strong>状态，则忽略这次监听请求。</li>
<li>以<em>LifecycleOwner</em>和<em>Observer</em>创建一个<em>LifecycleBoundObserver</em>对象，这个对象继承了<em>ObserverWrapper</em>类，同时实现了<em>LifecycleEventObserver</em>接口，看到这个接口，我们便明白了<em>LiveData</em>能够生命周期安全的监听数据变化的原因了。</li>
<li>这个<em>LifecycleBoundObserver</em>对象需要存储在一个<em>SafeIterableMap</em>当中去，在存储时候，会通过observer判断是否已经存在一个<em>ObserverWrapper</em>对象existing，如果已经存在则分为两种：a. 如果existing没有attach在owner上，则说明，existing已经attach在另外一个<em>LifecycleOwner</em>上了，这是不允许的，此时需要抛出异常；b. 如果没有attach在另外一个<em>LifecycleOwner</em>上，则说明此时监听的就是当前的owner上，则不需要再次添加监听，直接返回。如果existing不存在，则向owner.getLifecycle()添加监听。</li>
</ol>
<h2 id="setValue和postValue方法"><a href="#setValue和postValue方法" class="headerlink" title="setValue和postValue方法"></a>setValue和postValue方法</h2><p>在子线程中更新数据，需要调用postValue方法，实际上，这个方法就是通过一个MainHandler去post一个<em>Runnable</em>的方式切换到主线程中执行setValue方法。所以，我们重点看setValue方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LiveData.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">  assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">  mVersion++;</span><br><span class="line">  mData = value;</span><br><span class="line">  dispatchingValue(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意到的是<code>mVersion++</code>这句话，<em>LiveData</em>就是通过版本号来记录新的值的。继续看dispatchingValue方法。</p>
<h3 id="dispatchingValue"><a href="#dispatchingValue" class="headerlink" title="dispatchingValue"></a>dispatchingValue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class="comment">/* synthetic access */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mDispatchingValue) &#123;				<span class="comment">// ①</span></span><br><span class="line">    mDispatchInvalidated = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mDispatchingValue = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    mDispatchInvalidated = <span class="literal">false</span>;	<span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">if</span> (initiator != <span class="literal">null</span>) &#123;</span><br><span class="line">      considerNotify(initiator);</span><br><span class="line">      initiator = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="built_in">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">           mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">        considerNotify(iterator.next().getValue());</span><br><span class="line">        <span class="keyword">if</span> (mDispatchInvalidated) &#123; <span class="comment">// ③</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">  mDispatchingValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，涉及到两个方法，1. 第一个dispatchingValue —— 用来分发控制数据更新流程；2. considerNotify具体执行数据更新操作。</p>
<p>这个方法是双信号量控制分发流程，<strong>mDispatchingValue</strong>和<strong>mDispatchInvalidated</strong>，之所以这样设计，按照我的理解，是考虑到了dispatchingValue方法多线程重入的问题，但是依我看来，这样做没必要，因为这个方法的几处调用，都是在主线程上，不可能出现第一次调用没有执行完，就又被调用一次的可能，也可能是设计者考虑到未来的扩展或者在这个库涉及之初有多线程调用的情况才这样写的，先按照有重入可能来分析。</p>
<p>我们先要弄清这两个信号量的作用：mDispatchingValue表示是否正在执行分发数据更新的操作，mDispatchInvalidated表示是否中断正在进行的分发，开始新一轮分发。</p>
<p>这个方法是根据传入的参数，有两个执行流程，一个是执行具体某个ObserverWrapper的数据更新操作，另外一个就是批量更新所有observer的数据操作。我们以setValue触发的dispatchingValue(null)批量更新操作为例进行分析。</p>
<p>注意我在上段代码中的序号①②③注释，我们分步骤进行分析：</p>
<blockquote>
<p>假设，此时我们有两个observer。</p>
<p>初始状态 <strong>mDispatchingValue &#x3D; false, mDispatchInvalidated &#x3D; false</strong></p>
<p>当<strong>第一次</strong>调用开始后，会顺利通过①处判断，然后进入do - while循环，并且在②处先将mDispatchInvalidated信号量置为false，所以，一般情况下，这个while循环只会执行一次；</p>
<p>信号量：<strong>mDispatchingValue &#x3D; true, mDispatchInvalidated &#x3D; false</strong></p>
<p>由于initiator参数为null，所以会进入到else分支中的for循环中，这里需要注意的是，每一次for循环结束时候，都判断一次mDispatchInvalidated信号量，也就是注释③处；</p>
<p>假设我们执行了第一个observer后，dispatchingValue方法进行了<strong>第二次</strong>调用，由于此时mDispatchingValue信号量为true，所以会进入①处if条件判断语句，将mDispatchInvalidated信号量置为true并且直接return了；</p>
<p>信号量：<strong>mDispatchingValue &#x3D; true, mDispatchInvalidated &#x3D; true</strong></p>
<p>此时，第一次调用的for循环体就会因为mDispatchInvalidated变成了true，而退出for循环，while循环开始判断条件，同样因为mDispatchInvalidated为true，回再次执行while循环，执行新值更新；</p>
<p>最后退出dispatchingValue方法后，两个信号量都置为false。</p>
</blockquote>
<p>这样做的目的，或许是为了及时抛弃旧值通知，开始新值通知。</p>
<h3 id="considerNotify"><a href="#considerNotify" class="headerlink" title="considerNotify"></a>considerNotify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">considerNotify</span><span class="params">(ObserverWrapper observer)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">  <span class="comment">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class="line">  <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">  <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">    observer.activeStateChanged(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  observer.mLastVersion = mVersion;</span><br><span class="line">  observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是具体执行通知观察者值变化的地方。</p>
<p>那么LiveData是如何判断新值和旧值的呢？</p>
<p>在setValue方法中，有一个<code>mVersion++</code>语句，每次设置新值都会触发这个mVersion的自增，然后在considerNotify方法中，去校验observer是否处于active状态以及新值版本号与observer中的版本号，如果observer<strong>应当</strong>处于非active状态而仍然处于active状态(<strong>因为状态可能由于handler机制并没有及时变更</strong>)，则进行状态变更并返回，并且如果<code>observer.mLastVersion &gt;= mVersion</code>，则直接返回，因为此时observer已经更新过此值。<strong>也就是说，只有observer处于active状态且当前mVersion &gt; observer.mVersion的时候，才去通知observer更新值</strong>。</p>
<p>接下来，着重看一下<em>LifecycleBoundObserver</em>和<em>ObserverWrapper</em>这个两个类。</p>
<h2 id="LifecycleBoundObserver和ObserverWrapper"><a href="#LifecycleBoundObserver和ObserverWrapper" class="headerlink" title="LifecycleBoundObserver和ObserverWrapper"></a>LifecycleBoundObserver和ObserverWrapper</h2><p><em>ObserverWrapper</em>是<em>Observer</em>的抽象包装类，代码很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ObserverWrapper</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Observer&lt;? <span class="built_in">super</span> T&gt; mObserver;</span><br><span class="line">  <span class="type">boolean</span> mActive;</span><br><span class="line">  <span class="type">int</span> <span class="variable">mLastVersion</span> <span class="operator">=</span> START_VERSION;</span><br><span class="line"></span><br><span class="line">  ObserverWrapper(Observer&lt;? <span class="built_in">super</span> T&gt; observer) &#123;</span><br><span class="line">    mObserver = observer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">shouldBeActive</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">detachObserver</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">activeStateChanged</span><span class="params">(<span class="type">boolean</span> newActive)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class="line">    <span class="comment">// owner</span></span><br><span class="line">    mActive = newActive;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasInactive</span> <span class="operator">=</span> LiveData.<span class="built_in">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">    LiveData.<span class="built_in">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">      onActive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (LiveData.<span class="built_in">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">      onInactive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">      dispatchingValue(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在activeStateChanged方法中，先判断是否是状态的改变，如果<code>newActive == mActive</code>说明激活状态未改变，则直接返回；然后判断按照激活的observer数目和mActive状态，来判断LiveData的状态，并调用其空回调函数；最后如果mActive为true，则进行针对这个<em>ObserverWrapper</em>的事件分发。</p>
<p><em>ObserverWrapper</em>有两个子类，<em>LifecycleBoundObserver</em>和<em>AlwaysActiveObserver</em>，<em>AlwaysActiveObserver</em>是与生命周期无关的observer，需要谨慎使用，在适当的时候，通过removeObserver来删除，我们重点看<em>LifecycleBoundObserver</em>。</p>
<p><em>LifecycleBoundObserver</em>同时实现了<em>LifecycleEventObserver</em>，这就使得这个类具备了生命周期关联性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title class_">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title class_">LifecycleEventObserver</span> &#123;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">  LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="built_in">super</span> T&gt; observer) &#123;</span><br><span class="line">    <span class="built_in">super</span>(observer);</span><br><span class="line">    mOwner = owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">shouldBeActive</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">                             <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">      removeObserver(mObserver);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activeStateChanged(shouldBeActive());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">detachObserver</span><span class="params">()</span> &#123;</span><br><span class="line">    mOwner.getLifecycle().removeObserver(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在onStateChanged方法中，当生命周期处于<strong>DESTROYED</strong>状态时候，则删除这个observer。除此以外，当mOwner的生命周期处于<strong>STARTED</strong>之后的状态，则认为<code>shouldBeActive</code>，当生命周期函数onStateChanged被触发时候，将设置是否active。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过LiveData的这些特性，我们可以实现Activity - Fragment, Fragment - Fragment的通信，另外也可以做应用的事件总线，比如<strong>LiveEventBus</strong>。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 2284 words, 7 min 36 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-17-LeakCanary%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">LeakCanary原理分析</a></h3></div><div class="post-content"><div class="card"><p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="comment">// debugImplementation because LeakCanary should only run in debug builds.</span></span><br><span class="line">  debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.5&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要这样简单配置，就能接入LeakCanary内存泄漏分析，到底是怎样做到的？</p>
<p>我们将这个问题分成两个问题：</p>
<ol>
<li>如何<strong>自动</strong>进行初始化的；</li>
<li>如何检测到内存泄漏的。</li>
</ol>
<h2 id="如何自动进行初始化的"><a href="#如何自动进行初始化的" class="headerlink" title="如何自动进行初始化的"></a>如何自动进行初始化的</h2><p>这部分，我们可以分成两部分去理解——<strong>自动</strong>和<strong>初始化</strong>。</p>
<h3 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h3><p>这一切还要从<code>ActivityThread</code>说起。<code>ActivityThread</code>中，执行了一些应用启动的初始化工作，在<code>ActivityThread</code>源码中，我们可以看到其内部类<code>class H extends Handler</code>的<code>handleMessage</code>方法中，有很多与应用相关的一些基本操作，比如<strong>BIND_APPLICATION</strong>, <strong>EXIT_APPLICATION</strong>, <strong>CREATE_SERVICE</strong>, <strong>BIND_SERVICE</strong>等，其中需要我们关注的是<strong>BIND_APPLICATION</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">                    <span class="type">AppBindData</span> <span class="variable">data</span> <span class="operator">=</span> (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ....</span><br><span class="line">            &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，其中调用了<code>handleBindApplication</code>方法。进入这个方法查看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindApplication</span><span class="params">(AppBindData data)</span> &#123;</span><br><span class="line">  ....</span><br><span class="line">  Application app;</span><br><span class="line">  <span class="keyword">final</span> StrictMode.<span class="type">ThreadPolicy</span> <span class="variable">savedPolicy</span> <span class="operator">=</span> StrictMode.allowThreadDiskWrites();</span><br><span class="line">  <span class="keyword">final</span> StrictMode.<span class="type">ThreadPolicy</span> <span class="variable">writesAllowedPolicy</span> <span class="operator">=</span> StrictMode.getThreadPolicy();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class="line">    <span class="comment">// a restricted environment with the base application class.</span></span><br><span class="line">    app = data.info.makeApplication(data.restrictedBackupMode, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// Propagate autofill compat state</span></span><br><span class="line">    app.setAutofillOptions(data.autofillOptions);</span><br><span class="line">    <span class="comment">// Propagate Content Capture options</span></span><br><span class="line">    app.setContentCaptureOptions(data.contentCaptureOptions);</span><br><span class="line">    mInitialApplication = app;</span><br><span class="line">    <span class="comment">// don&#x27;t bring up providers in restricted mode; they may depend on the</span></span><br><span class="line">    <span class="comment">// app&#x27;s custom Application class</span></span><br><span class="line">    <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">        installContentProviders(app, data.providers);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class="line">    <span class="comment">// test thread at this point, and we don&#x27;t want that racing.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">        <span class="string">&quot;Exception thrown in onCreate() of &quot;</span></span><br><span class="line">        + data.instrumentationName + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">          <span class="string">&quot;Unable to create application &quot;</span> + app.getClass().getName()</span><br><span class="line">          + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// If the app targets &lt; O-MR1, or doesn&#x27;t change the thread policy</span></span><br><span class="line">    <span class="comment">// during startup, clobber the policy to maintain behavior of b/36951662</span></span><br><span class="line">    <span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class="line">        || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class="line">      StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个方法中，我们可以找到这样一段代码，需要重点关注的是，<code>ContentProvider</code>的初始化是先于<code>Application.onCreate</code>的，且是被<code>ActivityThread</code><strong>自动</strong>执行的。</p>
<p>接下来再看LeakCanary源码。找到<a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt"><strong>AppWatcherInstaller.kt</strong></a>这个类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Content providers are loaded before the application class is created. [AppWatcherInstaller] is</span></span><br><span class="line"><span class="comment"> * used to install [leakcanary.AppWatcher] on application start.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">AppWatcherInstaller</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">MainProcess</span> : <span class="type">AppWatcherInstaller</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span></span><br><span class="line"><span class="comment">   * [LeakCanaryProcess] automatically sets up the LeakCanary code</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LeakCanaryProcess</span> : <span class="type">AppWatcherInstaller</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    AppWatcher.manualInstall(application)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">query</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    uri: <span class="type">Uri</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    strings: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?,</span></span></span><br><span class="line"><span class="params"><span class="function">    s: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    strings1: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?,</span></span></span><br><span class="line"><span class="params"><span class="function">    s1: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: Cursor? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(uri: <span class="type">Uri</span>)</span></span>: String? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    uri: <span class="type">Uri</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentValues: <span class="type">ContentValues</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: Uri? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    uri: <span class="type">Uri</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    s: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    strings: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    uri: <span class="type">Uri</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentValues: <span class="type">ContentValues</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    s: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    strings: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这个类是一个<code>ContentProvider</code>的子类，其query, insert等方法根本没有实际作用，有实际作用的只有<code>onCreate</code>方法，在这个方法中，执行了<code>AppWatcher</code>的install工作。</p>
<p>这里我们就可以看出来，LeakCanary就是利用<code>ContentProvider</code>的<code>onCreate</code>方法自动执行的特性，来自动“安装”这个类库的。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>通过追踪<code>AppWatcher.manualInstall(application)</code>这句代码，我们可以追踪到<a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/blob/main/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt"><strong>InternalLeakCanary.kt</strong></a>的<code>install</code>方法，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">  checkMainThread()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>::application.isInitialized) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  InternalAppWatcher.application = application</span><br><span class="line">  <span class="keyword">if</span> (isDebuggableBuild) &#123;</span><br><span class="line">    SharkLog.logger = DefaultCanaryLog()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> configProvider = &#123; AppWatcher.config &#125;</span><br><span class="line">  ActivityDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">  FragmentDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">  onAppWatcherInstalled(application)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，先后执行了<code>ActivityDestroyWatcher.install</code>,<code>FragmentDestroyWatcher.install</code>和<code>onAppWatcherInstalled(application)</code>方法。</p>
<p>其中在<code>onAppWatcherInstalled</code>创建了LeakCanary图标的快捷方式，用于方便查看内存泄漏的路径信息。最终实现的具体过程可以查看<a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/blob/main/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt"><strong>InternalLeakCanary.kt</strong></a>的<code>addDynamicShortcut</code>方法。</p>
<p>其他的两段代码——<code>ActivityDestroyWatcher.install</code>和<code>FragmentDestroyWatcher.install</code>，分别对应着两个类——<code>ActivityDestroyWatcher</code>和<code>FragmentDestroyWatcher</code>。这两个类相对来说比较简单，主要工作就是执行了<code>application.registerActivityLifecycleCallbacks</code>这段代码，目的是为了监听每个Activity的onDestroy事件。这也是判断该Activity是否泄漏的开端。</p>
<p>以<code>ActivityDestroyWatcher</code>为例，其ActivityLifecycleCallback中代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (configProvider().watchActivities) &#123;</span><br><span class="line">          objectWatcher.watch(</span><br><span class="line">              activity, <span class="string">&quot;<span class="subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这其中，最终是<code>objectWatcher</code>来进行内存泄漏监控的。</p>
<h2 id="如何检测到内存泄漏的"><a href="#如何检测到内存泄漏的" class="headerlink" title="如何检测到内存泄漏的"></a>如何检测到内存泄漏的</h2><p>这里涉及到两个关键的类：**<a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt"><code>ObjectWatcher</code></a><strong>和</strong><a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt"><code>KeyedWeakReference</code></a>**。</p>
<p><code>KeyedWeakReference</code>是<code>WeakReference</code>的子类，添加了额外的属性，代码十分简单，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KeyedWeakReference</span>(</span><br><span class="line">  referent: Any,</span><br><span class="line">  <span class="keyword">val</span> key: String,</span><br><span class="line">  <span class="keyword">val</span> description: String,</span><br><span class="line">  <span class="keyword">val</span> watchUptimeMillis: <span class="built_in">Long</span>,</span><br><span class="line">  referenceQueue: ReferenceQueue&lt;Any&gt;</span><br><span class="line">) : WeakReference&lt;Any&gt;(</span><br><span class="line">    referent, referenceQueue</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn&#x27;t</span></span><br><span class="line"><span class="comment">   * been yet.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Volatile</span></span><br><span class="line">  <span class="keyword">var</span> retainedUptimeMillis = -<span class="number">1L</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="meta">@JvmStatic</span> <span class="keyword">var</span> heapDumpUptimeMillis = <span class="number">0L</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看<code>ObjectWatcher</code>中的<code>watchObject</code>方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Watches the provided [watchedObject].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> description Describes why the object is watched.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Synchronized</span> <span class="function"><span class="keyword">fun</span> <span class="title">watch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  watchedObject: <span class="type">Any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  description: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> key = UUID.randomUUID()</span><br><span class="line">      .toString()</span><br><span class="line">  <span class="keyword">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class="line">  <span class="keyword">val</span> reference =</span><br><span class="line">    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">  SharkLog.d &#123;</span><br><span class="line">    <span class="string">&quot;Watching &quot;</span> +</span><br><span class="line">        (<span class="keyword">if</span> (watchedObject <span class="keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="keyword">else</span> <span class="string">&quot;instance of <span class="subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +</span><br><span class="line">        (<span class="keyword">if</span> (description.isNotEmpty()) <span class="string">&quot; (<span class="variable">$description</span>)&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span>) +</span><br><span class="line">        <span class="string">&quot; with key <span class="variable">$key</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  watchedObjects[key] = reference</span><br><span class="line">  checkRetainedExecutor.execute &#123;</span><br><span class="line">    moveToRetained(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分为三步：</p>
<ol>
<li>执行<code>removeWeaklyReachableObjects()</code>方法，这个方法之后讲到；</li>
<li>生成一个<code>KeyedWeakReference</code>对象，并将这个对象添加到<code>watchedObjects</code>去；</li>
<li>定时执行<code>moveToRetained</code>方法。</li>
</ol>
<ul>
<li><p>我们先看第二步，生成<code>KeyedWeakReference</code>对象时候，传入了一个一个<code>ReferenceQueue</code>对象，这是检测对象是否被回收的关键。假如一个对象O，被弱引用WR持有的时候，同时这个弱引用WR在构造时候传入了一个<code>ReferenceQueue</code>对象Q，则这个对象O被回收时候，WR将会被添加到Q中去，这样，通过检测Q中有没有值，便可以知道O有没有被回收掉。这也就是第一步做的事。</p>
</li>
<li><p>接下来我们查看<code>removeWeaklyReachableObjects</code>方法中做了什么。</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeWeaklyReachableObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">  <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">  <span class="keyword">var</span> ref: KeyedWeakReference?</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ref = queue.poll() <span class="keyword">as</span> KeyedWeakReference?</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">      watchedObjects.remove(ref.key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，从queue中取值，取出来ref，则说明被ref修饰的对象已经被回收了，则将这个弱引用ref从<code>watchedObjects</code>清除掉。</p>
<ul>
<li>接下来到了第三步，这一步实际上是一个定时5秒(LeakCanary默认)去将watchedObjects中残留的引用，移入到<code>retainedObjects</code>中去。我们来看其中代码：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">  <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123;</span><br><span class="line">    retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class="line">    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这个任务的Executor实际实现在<a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt"><strong>InternalAppWatcher.kt</strong></a>中，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> checkRetainedExecutor = Executor &#123;</span><br><span class="line">  mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，在<code>moveToRetained</code>中，还是先执行了<code>removeWeaklyReachableObjects</code>这一方法。目的是再次清除已经被回收的对象。如果经过这一步，仍然有引用留在watchedObjects中，则可以认为，这些对象泄漏了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the objects that are currently considered retained. Useful for logging purposes.</span></span><br><span class="line"><span class="comment">   * Be careful with those objects and release them ASAP as you may creating longer lived leaks</span></span><br><span class="line"><span class="comment">   * then the one that are already there.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">val</span> retainedObjects: List&lt;Any&gt;</span><br><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> instances = mutableListOf&lt;Any&gt;()</span><br><span class="line">  <span class="keyword">for</span> (weakReference <span class="keyword">in</span> watchedObjects.values) &#123;</span><br><span class="line">    <span class="keyword">if</span> (weakReference.retainedUptimeMillis != -<span class="number">1L</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> instance = weakReference.<span class="keyword">get</span>()</span><br><span class="line">      <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">        instances.add(instance)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instances</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不要在发行版本中使用LeakCanary，因为一系列初始化动作，可能会导致应用启动较慢。如果要用，请使用LeakCanary-Object-Watcher，或者直接使用Buggly这样的成熟框架。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 1933 words, 6 min 26 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-17-LiveEventBus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">LiveEventBus源码分析</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>不再分析了，理解了LiveData后，不难理解这个框架。</p>
</blockquote>
<p>阅读本文前，请先阅读[《Jetpack之LiveData源码分析》](&#x2F;源码分析系列&#x2F;LiveEventBus源码分析.md)。因为<strong>LiveEventBus</strong>是基于<strong>LiveData</strong>构建的。</p>
<p>源码地址：<a target="_blank" rel="noopener" href="https://github.com/JeremyLiao/LiveEventBus">LiveEventBus</a></p>
<p>典型用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听消息</span></span><br><span class="line">LiveEventBus</span><br><span class="line">	.get(<span class="string">&quot;some_key&quot;</span>, String.class)</span><br><span class="line">	.observe(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;String&gt;() &#123;</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(<span class="meta">@Nullable</span> String s)</span> &#123;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">LiveEventBus</span><br><span class="line">	.get(<span class="string">&quot;some_key&quot;</span>)</span><br><span class="line">	.post(some_value);</span><br></pre></td></tr></table></figure>

<p>其实，这三个方法就是最核心的，get、observe和post。通过get获取一个Observable对象，通过observe进行监听，通过post发送消息。我们就从这三个方法入手去分析其源码。</p>
<h2 id="get方法分析"><a href="#get方法分析" class="headerlink" title="get方法分析"></a>get方法分析</h2><p>跟踪get方法，不难发现，是由<em>LiveEventBusCore</em>单例提供的with()方法返回的<em>Observable</em>，<em>LiveEventBusCore</em>中有一个名为bus的Map&lt;String, LiveEvent<Object>&gt;的成员变量，就是在这个变量中，以key - value的形式，保存了<em>Obserable</em>对象。observe方法与post方法都是由<em>Obserable</em>提供的。<em>Observable</em>是一个接口，它有一个唯一的实现类：<strong>LiveEvent</strong>。也就是说，observe方法与post方法的具体实现，都是由<em>LiveEvent</em>类提供。</p>
<p>主要代码如下：</p>
<p>##LiveEvent </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LiveEvent</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Observable</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LifecycleLiveData&lt;T&gt; liveData;	<span class="comment">// 继承自MutableLiveData，实现生命周期感知</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Observer, ObserverWrapper&lt;T&gt;&gt; observerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 存储ObserverWrapper对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">mainHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper()); <span class="comment">// 便于切换到主线程</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 进程内发送消息</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 发送的消息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ThreadUtils.isMainThread()) &#123;</span><br><span class="line">      postInternal(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mainHandler.post(<span class="keyword">new</span> <span class="title class_">PostValueTask</span>(value));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 注册一个Observer，生命周期感知，自动取消订阅</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> owner    LifecycleOwner</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> observer 观察者</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> LifecycleOwner owner, <span class="meta">@NonNull</span> <span class="keyword">final</span> Observer&lt;T&gt; observer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ThreadUtils.isMainThread()) &#123;</span><br><span class="line">      observeInternal(owner, observer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mainHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          observeInternal(owner, observer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>LiveEvent</em>中通过一个成员变量<code>Map&lt;Observer, ObserverWrapper&lt;T&gt;&gt; observerMap</code>来存储<em>ObserverWrapper</em>。</p>
<p><em>ObserverWrapper</em>是<strong>LiveData</strong>库中的<em>Observer</em>类的子类，</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 529 words, 1 min 45 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-17-%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6IRouter/">IRouter——自己手撸一个路由框架</a></h3></div><div class="post-content"><div class="card"><p><p>现在最流行的路由框架应该是阿里的ARouter，这几乎是组件化应用的必备了。但是ARouter用起来稍微有一点不爽，不爽在以下两点：</p>
<ol>
<li>没有一个规范化的api式的调用方式：项目大了，调用路由的方法分布在项目各处，难以查找；</li>
<li>对startActivityForResult支持不够友好：按照传统方式，在onActivityResult中处理，比较分散。</li>
</ol>
<p>基于以上问题，闲来无事，手撸一个自己的路由框架<a target="_blank" rel="noopener" href="https://github.com/boybeak/Routerfit">IRouter</a>，基本使用方式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IRouterService</span> &#123;</span><br><span class="line">    <span class="meta">@RouteTo(<span class="string">&quot;topic/detail&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">topicDetail</span><span class="params">(<span class="meta">@Key(<span class="string">&quot;topic&quot;</span>)</span> topic: <span class="type">Topic</span>)</span></span>: Navigator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> iRouter = IRouter.Builder()</span><br><span class="line">    .isDebug(BuildConfig.DEBUG)</span><br><span class="line">    .errorActivity(ErrorActivity::<span class="keyword">class</span>.java)</span><br><span class="line">    .build()</span><br><span class="line">    .create(IRouterService::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">iRouter.topicDetail(topic).startActivity(<span class="keyword">this</span><span class="symbol">@MainActivity</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"></span><br><span class="line">iRouter.topicDetail(topic).startActivityForResult(<span class="keyword">this</span>, <span class="number">100</span>) &#123; requestCode, resultCode, <span class="keyword">data</span> -&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的配置方式请参考<a target="_blank" rel="noopener" href="https://github.com/boybeak/Routerfit">IRouter</a>，本文主要是解析源码。</p>
<p>如此调用方式，很像是Retrofit的方式，打开一个activity就像请求一个api一样。从这里可以体现出解决了上述的两个痛点：</p>
<ol>
<li>类似API的调用方式，集中管理路由路径；</li>
<li>startActivityForResult中添加回调，哪里调用，就在哪里处理结果，结构紧凑。</li>
</ol>
<p>下面进入源码解析。</p>
<p>与<a target="_blank" rel="noopener" href="https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html">ARouter源码分析</a>这篇文章一样，我们分析时候要按照时态去分析这个框架在<strong>运行时</strong>和<strong>编译时</strong>做的事情。</p>
<h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><p>其实从上述调用的方式，有过热门开源框架源码阅读经验的，都能猜出个大概。</p>
<p>先从<strong>IRouter</strong>这个类创建<em>IRouterService</em>实例说起。使用过Retrofit的同学都知道，创建一个接口类，通过注解标注方法，不用提供具体的实现流程，就能完成网络请求。其实这并不难，这是通过动态代理实现的。我们来看IRouter.create的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">create</span><span class="params">(Class&lt;T&gt; tClass)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(tClass.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;tClass&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="keyword">return</span> parseMethod(method, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过动态代理，我们创建了一个<em>IRouterService</em>的实现类，这个类在调用相关方法的时候，比如<em>topicDetail</em>这个方法，都会经由<em>InvocationHandler</em>的<em>invoke</em>方法来代理完成。</p>
<p>接下来，从invoke中调用了parseMethod方法，这个方法比较简单，主要是用于解析方法注解和参数注解，取出其中的值，比如跳转路径path和参数的key - value键值对，<strong>通过path查询出相对应的Activity的class</strong>，这些值最终汇总起来，返回一个Navigator对象，这个就是真正要执行跳转的地方。</p>
<p>上面提到<em>通过path查询出Activity对应的class</em>，既然要查询，肯定要事先存储后才能被查询到。这就涉及到<strong>编译时</strong>做的工作了。</p>
<h2 id="编译时"><a href="#编译时" class="headerlink" title="编译时"></a>编译时</h2><h3 id="一、APT部分"><a href="#一、APT部分" class="headerlink" title="一、APT部分"></a>一、APT部分</h3><p>其实读过其他一些开源框架的人对这部分一定不会陌生。</p>
<p>这部分工作与ARouter类似，就是通过**@RoutePath**注解标记目标Activity，然后再通过注解处理器来获取到path - activity.class的对应关系，将这个对应关系，生成成一个类，我们查看一个生成的类的示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.boybeak.irouter.loader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.boybeak.irouter.core.BaseLoader;</span><br><span class="line"><span class="keyword">import</span> java.lang.Override;</span><br><span class="line"><span class="keyword">import</span> java.lang.String;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">V2ex$Topic$Loader</span> <span class="keyword">extends</span> <span class="title class_">BaseLoader</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getHeader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;topic&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadIntoMap</span><span class="params">()</span> &#123;</span><br><span class="line">    load(<span class="string">&quot;detail&quot;</span>, com.v2ex.activity.TopicActivity.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些所有生成的类在一个包名<code>com.github.boybeak.irouter.loader</code>底下，这很重要，因为我们要在接下来的过程，通过这个包名去筛选生成的loader类。</p>
<p>理解这部分，需要对APT(注解处理器)和java poet比较了解。</p>
<h3 id="二、ASM部分"><a href="#二、ASM部分" class="headerlink" title="二、ASM部分"></a>二、ASM部分</h3><p>不太了解ASM的，可以通过这篇文章<a target="_blank" rel="noopener" href="https://boybeak.github.io/android/ASM.html">ASM库介绍与使用</a>来了解，简单来说，ASM就是一款修改class文件的工具。能用来动态生成class文件，也可以修改已经存在的class文件。</p>
<p>有这样的利器，我们能做的事就太多了。</p>
<p>这部分，其实我就是参考了ARouter的做法，改成了自己的一些逻辑。</p>
<p>接下来我们要编写的是一个gradle plugin，我们主要是利用其中的<strong>Transform</strong>工具，官方解释在<a target="_blank" rel="noopener" href="https://developer.android.com/reference/tools/gradle-api/7.0/com/android/build/api/transform/Transform">这里</a>，其作用就是在编译时，会挨个遍历我们的源码、类库、jar包等。附上一个教程<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903891138674696">Gradle 学习之 Android 插件的 Transform API</a>。</p>
<p>Path - activity.class的对应关系是通过<strong>LoaderManager</strong>来查询的，我们看一下这个类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LoaderManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LoaderManager</span> <span class="variable">sManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoaderManager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LoaderManager <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, DelegateLoader&gt; loadersMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isInitialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LoaderManager</span><span class="params">()</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInitialized) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        load();</span><br><span class="line">        isInitialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadInto</span><span class="params">(BaseLoader loader)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> loader.getHeader();</span><br><span class="line">        obtainLoader(header).mergeOtherLoaders(loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DelegateLoader <span class="title function_">obtainLoader</span><span class="params">(String header)</span> &#123;</span><br><span class="line">        <span class="type">DelegateLoader</span> <span class="variable">delegateLoader</span> <span class="operator">=</span> loadersMap.get(header);</span><br><span class="line">        <span class="keyword">if</span> (delegateLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">            delegateLoader = <span class="keyword">new</span> <span class="title class_">DelegateLoader</span>(header);</span><br><span class="line">            loadersMap.put(header, delegateLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> delegateLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; get(String path) &#123;</span><br><span class="line">        String[] segments = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> segments[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">tail</span> <span class="operator">=</span> segments[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> loadersMap.get(header).getTargetClass(tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要注意其中的一个方法——<code>load</code>，我们看到，这个类在构建方法里调用了init方法，init里又调用了load方法，但是这个load方法却是留白的。这样调用有什么用呢？</p>
<p>其实这个留白方法是我们为ASM留的一个修改的入口。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;i-router-register&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在app.gradle中，使用这个插件，我们的transform就能顺利运行起来发挥作用了。</p>
<p>我们需要查看一下RegisterTransform的代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterTransform</span> <span class="keyword">extends</span> <span class="title class_">Transform</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(TransformInvocation transformInvocation)</span> <span class="keyword">throws</span> TransformException, InterruptedException, IOException &#123;</span><br><span class="line">    <span class="built_in">super</span>.transform(transformInvocation);</span><br><span class="line"></span><br><span class="line">    scanner.scan(transformInvocation, (loaderManagerJar, loaderManagerEntryName, loaders) -&gt; &#123;</span><br><span class="line">      Asm.getInstance().generateCode(loaderManagerJar, loaderManagerEntryName, loaders);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了Scanner来扫描TransformInvocation类，Scanner是我们自定义的类，主要作用就是通过包名和类名，查找我们的loader类和LoaderManager所在的jar包。我们查看其scan方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (TransformInput input : transformInvocation.getInputs()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (JarInput jarInput : input.getJarInputs()) &#123;</span><br><span class="line">    <span class="comment">// 这里处理第三方类库，引用的module和jar文件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (DirectoryInput directoryInput : input.getDirectoryInputs()) &#123;</span><br><span class="line">    <span class="comment">// 这里处理应用了这个plugin的module的相关class文件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">onScanFinish.onScanFinish(loaderManagerJar, loaderManagerEntryName, loaderClzList);</span><br></pre></td></tr></table></figure>

<p>通过回调，我们将查找到的loader类和LoaderManager所在jar返回给transform，并交由我们的asm工具来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASM</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HackMethodVisitor</span> <span class="keyword">extends</span> <span class="title class_">MethodVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; loaders = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HackMethodVisitor</span><span class="params">(<span class="type">int</span> api, MethodVisitor methodVisitor, List&lt;String&gt; loaders)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(api, methodVisitor);</span><br><span class="line">      <span class="built_in">this</span>.loaders = loaders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInsn</span><span class="params">(<span class="type">int</span> opcode)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (String loader : loaders) &#123;</span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</span><br><span class="line">        mv.visitTypeInsn(Opcodes.NEW, loader);</span><br><span class="line">        mv.visitInsn(Opcodes.DUP);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, loader, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class="string">&quot;com/github/boybeak/irouter/core/LoaderManager&quot;</span>, <span class="string">&quot;loadInto&quot;</span>, <span class="string">&quot;(Lcom/github/boybeak/irouter/core/BaseLoader;)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">super</span>.visitInsn(opcode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的修改逻辑就在HackMethodVisitor这个类中，注意其中的visitInsn方法，这就是ASM真正发挥作用的地方，这里的逻辑就是为loadInto方法添加加载loader的代码。</p>
<p>以demo中的v2ex为例，修改后的代码load代码如下：</p>
<p>![LoaderManager](&#x2F;assets&#x2F;images&#x2F;jd_loader_manager.jpg)</p>
<h2 id="最后一点细节"><a href="#最后一点细节" class="headerlink" title="最后一点细节"></a>最后一点细节</h2><p>到目前为止，主要的流程已经结束了，接下来是一些细节部分。</p>
<ul>
<li>LoaderManager在加载loader的时候，会针对path做归并，比如同为app&#x2F;main和app&#x2F;user被归并为一组，这样在使用的时候，可以按组做实际载入。</li>
<li>用于跳转的Navigator是有缓存的，用来减少查询次数，因为path - activity.class的对应关系并不是动态变化的，如果缓存中有已经用过的，则清空其intent的参数部分重复利用即可。</li>
<li>对于startActivityForResult的集中调用，可以参考我的另外一个开源项目——<a target="_blank" rel="noopener" href="https://github.com/boybeak/Starter">Starter</a>中的SAFR项目。这里在FragmentActivity中，通过一个fragment去代理了startActivityForResult的过程，从而拦截了回调结果；类似的，在非FragmentActivity中，通过了一个全透明的代理了此过程，这里学习了<strong>Glide</strong>通过一个fragment来探测生命周期的方式。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这样一个自己动手的过程，我们熟悉了的编写APT和gradle plugin的过程，学会了ASM的基本用法。</p>
<p>在这个项目中，学习了很多其他优秀开源项目的经验，比如：</p>
<ul>
<li>主流程是参考了ARouter，但是去掉了应用启动时候，从codeDir找到apk来解析路由路径的过程；</li>
<li>集中的api式调用，参考了Retrofit的动态代理；</li>
<li>通过Fragment拦截startActivityForResult的结果，参考了Glide向宿主activity添加无UI的Fragment的方式。</li>
</ul>
<p>因此，多读源码可以开拓思维，当自己想开发自己的工具框架时候，就可以信手拈来。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 2316 words, 7 min 43 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-19-AMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">AMS启动流程</a></h3></div><div class="post-content"><div class="card"><p><p>AMS是ActivityManagerService的简称，看名字，似乎是Activity的manager，实际上，它管理的可不只是Activity。</p>
<h2 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    style A fill:#fff</span><br><span class="line">    style F fill:#5befb9</span><br><span class="line">    Z&#123;&#123;Boot ROM&#125;&#125; --&gt; A([Boot Loader]);</span><br><span class="line">    A --&gt; B(Kernel);</span><br><span class="line">    B --&gt; C(&quot;init(pid=1)/C++ Framework Native&quot;);</span><br><span class="line">    C --&gt; D(Zygote/Android Runtime);</span><br><span class="line">    D --&gt; E(System Server/Java Framework);</span><br><span class="line">    E --&gt; F(Apps);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>面试题：一个应用启动，为什么不从init进程或者SystemServer进程fork，而是从Zygote进程fork。</strong></p>
<p><em>Zygote作为一个孵化器，可以提前加载一些资源，这样fork时给予<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/48147304">Copy-on-Write</a>机制创建的其他进程能够直接利用这些资源，而不用重新加载。比如system_server就可以直接使用Zygote中的JNI函数、共享库、常用的类以及主题资源。</em></p>
<p><em>SystemServer相比Zygote多运行了AMS、WMS等服务，这些对于一个应用程序来说是不需要的，另外fork对多线程不友好，仅会将发起调用的线程拷贝到子进程，这可能会导致死锁，而SystemServer中肯定是有很多多线程的。</em></p>
<p><strong>如何导致死锁的？</strong></p>
<p>在POSIX标准中，fork行为是这样的：赋值整个用户空间的数据（通常使用copy-on-write的策略，所以可以实现速度很快）以及所有系统对象，然后仅复制当前线程到子进程。这里：所有父进程中别的线程，到了子进程都是突然蒸发掉的。</p>
<p>对于锁来说，从OS看，每个锁都有一个所有者，即最后依次lock它的线程。假设这样一个环境，在fork之前，有一个子线程lock了某个锁，获得了对锁的所有权，fork以后，在子进程中，所有的额外线程都人间蒸发了，而锁却被正常赋值了，在子进程看来，这个锁没有主人，所以没有任何人可以对它解锁，当子进程中的某个线程想lock这个锁时候，不再有任何手段可以解开了，程序发生死锁。</p>
</blockquote>
<h2 id="Zygote集成启动"><a href="#Zygote集成启动" class="headerlink" title="Zygote集成启动"></a>Zygote集成启动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[&quot;init.cpp - main()&quot;] --&gt; B[解析init.zygote.rc];</span><br><span class="line">    B --&gt; C[&quot;启动main类型服务 do_class_start()&quot;];</span><br><span class="line">    C --&gt; D[&quot;启动zygote服务 start()&quot;];</span><br><span class="line">    D --&gt; E[&quot;创建Zygote进程 fork()&quot;];</span><br><span class="line">    E --&gt; |execv|F[&quot;app_main.cpp - main()&quot;];</span><br></pre></td></tr></table></figure>



<h2 id="System-Server进程启动"><a href="#System-Server进程启动" class="headerlink" title="System Server进程启动"></a>System Server进程启动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[&quot;app_main.cpp - main()&quot;] --&gt; B[&quot;AndroidRuntime.start()&quot;];</span><br><span class="line">    B --&gt; C[&quot;startVM()&quot;];</span><br><span class="line">    C --&gt; D[&quot;startReg()&quot;];</span><br><span class="line">    D --&gt; E[&quot;ZygoteInit.main()&quot;];</span><br><span class="line">    E --&gt; F[&quot;registerZygoteSocket()&quot;];</span><br><span class="line">    F --&gt; G[&quot;preload&quot;];</span><br><span class="line">    G --&gt; H[&quot;startSystemServer&quot;];</span><br><span class="line">    H --&gt; I[&quot;runSelectLoop&quot;];</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/services/java/com/android/server/SystemServer.java">SystemServer.java</a></p>
<h2 id="AMS启动流程"><a href="#AMS启动流程" class="headerlink" title="AMS启动流程"></a>AMS启动流程</h2><p><a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActivityManagerService.java">ActivityManagerService.java</a></p>
<p>在SystemServer的<code>startBootstrapServices</code>方法中，开始了AMS的启动。</p>
<h3 id="AMS启动过程中做了哪些事？"><a href="#AMS启动过程中做了哪些事？" class="headerlink" title="AMS启动过程中做了哪些事？"></a>AMS启动过程中做了哪些事？</h3><p>与<code>adb shell dumpsys</code>相关的一些process服务，比如<code>meminfo</code>、<code>gfxinfo</code>、<code>dbinfo</code>等，具体请参考<code>setSystemProcess</code>方法。</p>
<h2 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h2><p>ActivityStactSupervisor</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR;</span><br><span class="line">A[ActivityStactSupervisor] --&gt; B[mHomeStack];</span><br><span class="line">A --&gt; C[mFocusedStack];</span><br><span class="line">subgraph ActivityStack[&quot;ActivityStack&quot;]</span><br><span class="line">  subgraph TaskRecord</span><br><span class="line">    AR1[ActivityRecord]</span><br><span class="line">    AR2[ActivityRecord]</span><br><span class="line">    AR3[ActivityRecord]</span><br><span class="line">  end</span><br><span class="line">  subgraph TaskRecord2</span><br><span class="line">    AR4[ActivityRecord]</span><br><span class="line">    AR5[ActivityRecord]</span><br><span class="line">    AR6[ActivityRecord]</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line">B --&gt; ActivityStack;</span><br><span class="line">C --&gt; ActivityStack;</span><br></pre></td></tr></table></figure>

<p>Activity启动简图</p>
<blockquote>
<p>面试题：Zygote为什么不采用Binder机制进行IPC通信。</p>
<p>Binder机制中存在Binder线程池，是多线程的，如果Zygote采用Binder的话，就存在了上面说的fork多线程死锁问题了。其实严格来说，Binder机制不一定要多线程，所谓的Binder线程只不过是在循环读取Binder驱动消息而已，只注册一个Binder线程也是可以工作的，比如ServiceManager，实际上Zygote尽管没有采用Binder机制，它也不是单线程的，但它在fork前主动停止了其他线程，fork后重新启动了。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">  A([Launcher]) --&gt; B&#123;&quot;SystemServer - AMS&lt;br&gt;(app是否启动)&quot;&#125;;</span><br><span class="line">  B --&gt; |否, 请求创建app进程|C[Zygote];</span><br><span class="line">  B -.-&gt; |&quot;是, 1. ActivityManager.getService()&quot;|D(App):::app;</span><br><span class="line">  C --&gt;|fork| D</span><br><span class="line">  D --&gt;|&quot;2. mgr.attachApplication(mAppThread, startSeq)&quot;| B;</span><br><span class="line">	classDef app fill:#5befb9</span><br></pre></td></tr></table></figure>

<p>Activity启动细节图</p>
<p><strong>Launcher到AMS阶段</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">	participant A as Launcher</span><br><span class="line">	participant B as Activity</span><br><span class="line">	participant C as Instrumentation</span><br><span class="line">	participant D as IActivityManager</span><br><span class="line">	participant E as AMS</span><br><span class="line">	</span><br><span class="line">	A -&gt;&gt; B: startActivity</span><br><span class="line">	B --&gt; B: startActivityForResult</span><br><span class="line">	B -&gt;&gt; C: execStartActivity</span><br><span class="line">	C -&gt;&gt; D: startActivity</span><br><span class="line">	D -&gt;&gt; E: startActivity</span><br></pre></td></tr></table></figure>

<p><strong>AMS到ApplicationThread阶段</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">	participant A as AMS</span><br><span class="line">	participant B as ActivityStart</span><br><span class="line">	participant C as ActivityStackSupervisor</span><br><span class="line">	participant D as ActivityStack</span><br><span class="line">	participant E as ApplicationThread</span><br><span class="line">	A -&gt;&gt; A: startActivityStarter</span><br><span class="line">	A -&gt;&gt; B: startActivityMyWait</span><br><span class="line">	B -&gt;&gt; B: startActivityLocked</span><br><span class="line">	B -&gt;&gt; B: startActivity</span><br><span class="line">	B -&gt;&gt; B: startActivityUnchecked</span><br><span class="line">	B -&gt;&gt; C: startSpecificActivityLocked</span><br></pre></td></tr></table></figure>

<p><strong>ApplicationThread到Activity</strong></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 1162 words, 3 min 52 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">Next</a></li></ul></div></div></div></div><script src="/js/darkLightToggle.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>