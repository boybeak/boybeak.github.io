<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My New Hugo Site</title>
    <link>https://boybeak.github.io/public/posts/</link>
    <description>Recent content in Posts on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 03 Sep 2022 21:06:01 +0800</lastBuildDate><atom:link href="https://boybeak.github.io/public/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Glide源码分析与自我实现(一)——数据加载主流程</title>
      <link>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B01/</link>
      <pubDate>Sat, 03 Sep 2022 21:06:01 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B01/</guid>
      <description>Glide源码分析与自我实现(一)——数据加载主流程 本文基于Glide 4.11.0
阅读前请参考Glide 源码分析解读-基于最新版Glide 4.9.0一文，该文章中，将Glide中各个部分的作用分析的非常好了。
Glide几乎是现在做Android图片加载的最佳选择了。如此优秀的一个框架是如何实现的呢？如果让我们自己来实现该怎么做呢？我们就通过自己实现一个低配版Glide的方式，来探究Glide中是如何实现的。
我们就称我们自己低配版Glide为Slide。那么Slide要实现哪些功能呢？简单来说，就是获取图片+界面显示。我们通过先构架大体框架，再分步丰富其中细节的方式，来构建Slide的整体结构。
flowchart LR; A[获取图片] --&amp;gt; C[Slide] --&amp;gt; B[界面显示]; Glide.with(xxx).load(url).into(iv); 这是Glide一个典型的最为简单的调用过程。那么在这个过程中发生了哪些事情呢？
我们可以通过这个链式调用的返回值发现，有如下过程：
graph LR; style A fill:#aaffcc style D fill:#ffaa99 A(Glide) --&amp;gt;|&amp;#34;with(xxx)&amp;#34;| B(RequestManager) --&amp;gt;|&amp;#34;load(xxx)&amp;#34;| C(RequestBuilder) --&amp;gt;|&amp;#34;into(iv)&amp;#34;| D(Target); Glide.with(xxx)发生了什么事？ 阅读源码发现，Glide.with(xxx)的最终实现类是RequestManagerRetriever.java类。继续跟踪，我们在这个类中，看到这样一个方法。
@NonNull private RequestManager supportFragmentGet( @NonNull Context context, @NonNull FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) { SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint); RequestManager requestManager = current.getRequestManager(); ..... return requestManager; } 重点关注这个getSupportRequestManagerFragment方法。
//getSupportRequestManagerFragment @NonNull private SupportRequestManagerFragment getSupportRequestManagerFragment( @NonNull final FragmentManager fm, @Nullable Fragment parentHint) { SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.</description>
    </item>
    
    <item>
      <title>Glide源码分析与自我实现(三)——数据加载主流程</title>
      <link>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B03/</link>
      <pubDate>Sat, 03 Sep 2022 21:06:01 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B03/</guid>
      <description>Glide源码分析与自我实现(三)——APT的使用与GIF的优化 项目Demo地址：GifHelper
什么是APT？
APT是Annotation Processing Tool的简称，即编译时注解处理器。它是一个javac的工具，在编译时，通过注解，按照规则自动生成相关代码的工具。
APT与Glide什么关系？
我们通常通过在build.gradle加入这样一段代码来引入Glide库。
repositories { google() jcenter() } dependencies { implementation &amp;#39;com.github.bumptech.glide:glide:4.11.0&amp;#39; annotationProcessor &amp;#39;com.github.bumptech.glide:compiler:4.11.0&amp;#39; } 这里有一个annotationProcessor，这就是对Glide提供的APT进行引用。我们查看Glide的源码结构，可以看到一个名为annotation的文件夹，这里就是与APT有关的部分。
接下来我们先通过GIF优化，看一看Glide的APT能实现的神奇效果，在这之后，再来分析Glide是如何通过APT实现的。
**注意：**如果使用kotlin需要先加入apply plugin: &#39;kotlin-kapt&#39;插件，并且将annotationProcessor改成kapt。
GIF优化 为什么要优化GIF？
有人可能会有疑问，Glide相比其他图片加载框架的优势之一，就是支持GIF，为什么还要做优化呢？
先看两个截图来对比优化前后的CPU和内存使用情况。
我们可以看出，优化后，CPU和内存状况都好了很多，那么我们是怎么做的呢？这就需要用到谷歌官方的两个库——giflib和FrameSequence，这两个库需要我们自己编译成.so文件，具体可以参考示例项目GifHelper。
我们查看GifHolder中的代码。
class GifHolder(v: View) : AbsHolder&amp;lt;GifItem&amp;gt;(v) { ... private val gifIV = view&amp;lt;ImageView&amp;gt;(R.id.gifIV) override fun onBind(item: GifItem, position: Int, absAdapter: AnyAdapter) { if (item.useGifX) { // 优化后的加载方式 GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV) } else { // 优化前的加载方式 Glide.with(itemView).asGif().load(item.source()).into(gifIV) } .... } } 我们可以看到，加载后有这样一条语句：GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)，也许你会懵逼，哪里有GlideApp？哪里有asGifX()方法？我引入Glide后怎么没有看到这两个东西？这就涉及到了APT的内容了。想要看Glide官方文档的可以看这里。
一切的起因，要从**@GlideModule**这个注解说起，我们打开demo中的MyAppGlideModule类，可以看到这个类有一个@GlideModule注解。</description>
    </item>
    
    <item>
      <title>Glide源码分析与自我实现(二)——数据加载主流程</title>
      <link>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B02/</link>
      <pubDate>Sat, 03 Sep 2022 21:06:01 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B02/</guid>
      <description>Glide源码分析与自我实现(二)——缓存与BitmapPool 本文基于Glide 4.11.0
参考文章：Glide 源码分析解读-缓存模块-基于最新版Glide 4.9.0
**注意：**由于版本差异问题，本文有些部分与参考文章有差异。
缓存模块是Glide中非常重要的部分，Glide图片加载的高效性，几乎有一半功劳都在这里了。
一般来说，Glide有三级缓存，就是内存缓存、磁盘缓存和网络缓存。
先来看缓存流程图，如下：
graph TD; style A fill:#99ccff style B1 fill:#aaffaa A(发起请求) --&amp;gt; B{1. 通过&amp;lt;br&amp;gt;ActiveResources&amp;lt;br&amp;gt;获取资源} --&amp;gt; |命中|B1([加载完成]); B --&amp;gt; |未命中|C{2. 通过&amp;lt;br&amp;gt;MemoryCache&amp;lt;br&amp;gt;获取资源} --&amp;gt; |命中|C1[缓存至&amp;lt;br&amp;gt;ActiveResources] --&amp;gt; B1; C --&amp;gt; |未命中|D{3. 通过&amp;lt;br&amp;gt;DiskCache&amp;lt;br&amp;gt;获取资源} --&amp;gt; |命中|D1[缓存至&amp;lt;br&amp;gt;MemoryCache] --&amp;gt; C1; D --&amp;gt; |未命中|E[&amp;#34;4. 通过数据源(网络、文件等)&amp;lt;br&amp;gt;加载数据&amp;#34;] --&amp;gt; E1[缓存至&amp;lt;br&amp;gt;DiskCache] --&amp;gt; D1; 内存缓存 内存缓存主要靠三个部分组成：ActiveResources、MemoryCache和BitmapPool。
ActiveResources ActiveResources表示当前正在活动中的资源。ActiveResources通过一个Map&amp;lt;Key, ResourceWeakReference&amp;gt;来保存活动中的资源，其中的ResourceWeakReference就是资源数据，在构建这个ResourceWeakReference的时候必须传入一个ReferenceQueue用来检测资源是否被回收。
Q1：如何探知WeakReference中的值被回收了呢？
ReferenceQueue queue = ...; WeakReference wr = new WeakReference(value, queue); 当构建WeakReference的时候，如果传入了queue参数，则在value被回收的时候，wr会被加入到queue中去，这样，通过检测queue中是否有值，就可以探知value是否被回收了。
那么，在何时去探知ReferenceQueue中的值呢？我们查看ActiveResources的关键代码：
/*构造方法中，通过monitorClearedResourcesExecutor执行了cleanReferenceQueue()方法。 */ ActiveResources(boolean isActiveResourceRetentionAllowed) { this( isActiveResourceRetentionAllowed, java.</description>
    </item>
    
    <item>
      <title>Jetpack之Lifecycle源码分析</title>
      <link>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/jetpack%E4%B9%8Blifecycle%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 03 Sep 2022 21:06:01 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/jetpack%E4%B9%8Blifecycle%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>Jetpack之Lifecycle源码分析 这是一篇解析jetpack库中的Lifecycle库的分析文章。
def lifecycle_version = &amp;#34;2.2.0&amp;#34; // Lifecycles only (without ViewModel or LiveData) implementation &amp;#34;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&amp;#34; // Annotation processor kapt &amp;#34;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&amp;#34; class MyObserver : LifecycleObserver { @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun onCreate() { } @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) fun onPause() { } } class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) lifecycle.addObserver(MyObserver()) } } 这是一个很典型的Lifecycle库的使用过程，通过注解的方式，在MyObserver中声明对应的生命周期函数，然后将这个MyObserver实例添加到MainActivity的lifecycle中去。
看到与注解相关，熟悉框架源码的朋友可能已经知道如何去分析了，很可能用到注解处理器，与ARouter类似，Lifecycle的工作流程也分成两部分——编译时和运行时。
简要的说，在编译时，生成LifecycleObserver的辅助类；在运行时，addObserver方法被调用后，解析出对应observer的辅助类。
生命周期探知 在正式详解这两个过程前，我们需要先要了解Lifecycle库是如何感知生命周期的呢？
读过Glide源码(附上Glide源码解读)的同学可能知道，Glide感知生命周期是通过一个无UI的fragment来实现的，其实，Lifecycle也是这么做的。
对外提供生命周期的类，需要实现LifecycleOwner接口。
public interface LifecycleOwner { /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider.</description>
    </item>
    
    <item>
      <title>Jetpack之LiveData源码分析</title>
      <link>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/jetpack%E4%B9%8Blivedata%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 03 Sep 2022 21:06:01 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/jetpack%E4%B9%8Blivedata%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>Jetpack之LiveData源码分析 在阅读这篇文章前，需要先对Lifecycle有所了解。
Lifecycle是LiveData的根基，先有了生命周期的管理，才能进行安全不泄漏的数据观察。
先要引入LiveData：
implementation &amp;#34;androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0&amp;#34; def activity_version = &amp;#34;1.1.0&amp;#34; // Kotlin，引入这个扩展，可以使用by viewModels()方法 implementation &amp;#34;androidx.activity:activity-ktx:$activity_version&amp;#34; 典型的用法如下：
class MainActivity : AppCompatActivity() { private val vm by viewModels&amp;lt;MainVM&amp;gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) vm.data.observe(this) { Toast.makeText(this@MainActivity, it, Toast.LENGTH_SHORT).show() } vm.start() } } class MainVM : ViewModel() { val data = MutableLiveData&amp;lt;String&amp;gt;() fun start() { data.value = &amp;#34;start&amp;#34; Thread { Thread.sleep(2000) data.postValue(&amp;#34;run after 2000ms&amp;#34;) }.start() } } 从这两段代码中，我们就可以看出典型的用法，主要是在三个方法上，observe、setValue和postValue。我们就从这三个方法入手去探究LiveData的工作机制。
observe方法 // LiveData.java @MainThread public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&amp;lt;?</description>
    </item>
    
    <item>
      <title>LeakCanary原理分析</title>
      <link>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leakcanary%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 03 Sep 2022 21:06:01 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leakcanary%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
      <description>LeakCanary原理分析 dependencies { // debugImplementation because LeakCanary should only run in debug builds. debugImplementation &amp;#39;com.squareup.leakcanary:leakcanary-android:2.5&amp;#39; } 只需要这样简单配置，就能接入LeakCanary内存泄漏分析，到底是怎样做到的？
我们将这个问题分成两个问题：
如何自动进行初始化的； 如何检测到内存泄漏的。 如何自动进行初始化的 这部分，我们可以分成两部分去理解——自动和初始化。
自动 这一切还要从ActivityThread说起。ActivityThread中，执行了一些应用启动的初始化工作，在ActivityThread源码中，我们可以看到其内部类class H extends Handler的handleMessage方法中，有很多与应用相关的一些基本操作，比如BIND_APPLICATION, EXIT_APPLICATION, CREATE_SERVICE, BIND_SERVICE等，其中需要我们关注的是BIND_APPLICATION。
public void handleMessage(Message msg) { .... switch (msg.what) { case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &amp;#34;bindApplication&amp;#34;); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; .... } .... } 我们可以看到，其中调用了handleBindApplication方法。进入这个方法查看。
@UnsupportedAppUsage private void handleBindApplication(AppBindData data) { .... Application app; final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites(); final StrictMode.</description>
    </item>
    
    <item>
      <title>LiveEventBus源码分析</title>
      <link>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/liveeventbus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 03 Sep 2022 21:06:01 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/liveeventbus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>LiveEventBus源码分析 不再分析了，理解了LiveData后，不难理解这个框架。
阅读本文前，请先阅读《Jetpack之LiveData源码分析》。因为LiveEventBus是基于LiveData构建的。
源码地址：LiveEventBus
典型用法如下：
// 监听消息 LiveEventBus .get(&amp;#34;some_key&amp;#34;, String.class) .observe(this, new Observer&amp;lt;String&amp;gt;() { @Override public void onChanged(@Nullable String s) { } }); // 发送消息 LiveEventBus .get(&amp;#34;some_key&amp;#34;) .post(some_value); 其实，这三个方法就是最核心的，get、observe和post。通过get获取一个Observable对象，通过observe进行监听，通过post发送消息。我们就从这三个方法入手去分析其源码。
get方法分析 跟踪get方法，不难发现，是由LiveEventBusCore单例提供的with()方法返回的Observable，LiveEventBusCore中有一个名为bus的Map&amp;lt;String, LiveEvent&amp;gt;的成员变量，就是在这个变量中，以key - value的形式，保存了Obserable对象。observe方法与post方法都是由Obserable提供的。Observable是一个接口，它有一个唯一的实现类：LiveEvent。也就是说，observe方法与post方法的具体实现，都是由LiveEvent类提供。
主要代码如下：
##LiveEvent
private class LiveEvent&amp;lt;T&amp;gt; implements Observable&amp;lt;T&amp;gt; { @NonNull private final String key; private final LifecycleLiveData&amp;lt;T&amp;gt; liveData;	// 继承自MutableLiveData，实现生命周期感知 private final Map&amp;lt;Observer, ObserverWrapper&amp;lt;T&amp;gt;&amp;gt; observerMap = new HashMap&amp;lt;&amp;gt;(); // 存储ObserverWrapper对象 private final Handler mainHandler = new Handler(Looper.getMainLooper()); // 便于切换到主线程 /** * 进程内发送消息 * * @param value 发送的消息 */ @Override public void post(T value) { if (ThreadUtils.</description>
    </item>
    
    <item>
      <title>手撸一个路由框架IRouter</title>
      <link>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6irouter/</link>
      <pubDate>Sat, 03 Sep 2022 21:06:01 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6irouter/</guid>
      <description>IRouter——自己手撸一个路由框架 现在最流行的路由框架应该是阿里的ARouter，这几乎是组件化应用的必备了。但是ARouter用起来稍微有一点不爽，不爽在以下两点：
没有一个规范化的api式的调用方式：项目大了，调用路由的方法分布在项目各处，难以查找； 对startActivityForResult支持不够友好：按照传统方式，在onActivityResult中处理，比较分散。 基于以上问题，闲来无事，手撸一个自己的路由框架IRouter，基本使用方式如下：
interface IRouterService { @RouteTo(&amp;#34;topic/detail&amp;#34;) fun topicDetail(@Key(&amp;#34;topic&amp;#34;) topic: Topic): Navigator } val iRouter = IRouter.Builder() .isDebug(BuildConfig.DEBUG) .errorActivity(ErrorActivity::class.java) .build() .create(IRouterService::class.java) iRouter.topicDetail(topic).startActivity(this@MainActivity) // OR iRouter.topicDetail(topic).startActivityForResult(this, 100) { requestCode, resultCode, data -&amp;gt; } 具体的配置方式请参考IRouter，本文主要是解析源码。
如此调用方式，很像是Retrofit的方式，打开一个activity就像请求一个api一样。从这里可以体现出解决了上述的两个痛点：
类似API的调用方式，集中管理路由路径； startActivityForResult中添加回调，哪里调用，就在哪里处理结果，结构紧凑。 下面进入源码解析。
与ARouter源码分析这篇文章一样，我们分析时候要按照时态去分析这个框架在运行时和编译时做的事情。
运行时 其实从上述调用的方式，有过热门开源框架源码阅读经验的，都能猜出个大概。
先从IRouter这个类创建IRouterService实例说起。使用过Retrofit的同学都知道，创建一个接口类，通过注解标注方法，不用提供具体的实现流程，就能完成网络请求。其实这并不难，这是通过动态代理实现的。我们来看IRouter.create的代码：
public &amp;lt;T&amp;gt; T create(Class&amp;lt;T&amp;gt; tClass) { return (T) Proxy.newProxyInstance(tClass.getClassLoader(), new Class[]{tClass}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { return parseMethod(method, args); } }); } 通过动态代理，我们创建了一个IRouterService的实现类，这个类在调用相关方法的时候，比如topicDetail这个方法，都会经由InvocationHandler的invoke方法来代理完成。</description>
    </item>
    
    <item>
      <title>Activity启动流程</title>
      <link>https://boybeak.github.io/public/posts/android/activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sat, 03 Sep 2022 21:03:05 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/android/activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
      <description>#Activity启动流程
原文参考：Activity 启动流程分析(Android10)
graph TD; A(启动Activity) --&amp;gt; B[通过Binder调用AMS的startActivity方法] --&amp;gt; C[通过Intent获取到目标Activity] --&amp;gt; D{目标Activity是否启动} --&amp;gt; |是|E[通过Instrumentation创建Activity] --&amp;gt; F[回调Activity#attach] --&amp;gt; G[回调Activity#onCreate] --&amp;gt; H[准备显示Activity] --&amp;gt; I[Activity#onResume]; D --&amp;gt; |否|J[通过Zygote进程fork一个App进程]:::zygote --&amp;gt; K[创建Application并回调Application#onCreate]:::zygote --&amp;gt; L[启动ActivityThread主线程消息队列]:::zygote --&amp;gt; E; F --&amp;gt; M[创建Window对象并设置Window.Callback接收事件]:::wms; G --&amp;gt; N[Activity#setContentView] --&amp;gt; O[Window#setContentView]:::wms; H --&amp;gt; P[Window#addView]:::wms; classDef wms fill:#aaffff classDef zygote fill:#ffaa99 途中浅蓝色部分为WMS关联部分，橙色部分为目标App未启动情况下的流程。
Intent 解析到 Activity 调用 startActivity 之后，经过几步辗转最终会调用到 AMS 中，而 AMS 又会调用 ActivityStarter 来启动 Activity。 解析 Intent 的任务将由PackageManagerService#resolveIntent方法来处理。 Intent 匹配规则太负责了，我本意是想学习启动流程，所以就没深入进去看代码，就这样吧。</description>
    </item>
    
    <item>
      <title>AMS启动流程</title>
      <link>https://boybeak.github.io/public/posts/android/ams%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sat, 03 Sep 2022 21:03:05 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/android/ams%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
      <description>AMS启动流程 AMS是ActivityManagerService的简称，看名字，似乎是Activity的manager，实际上，它管理的可不只是Activity。
系统启动流程 graph TD; style A fill:#fff style F fill:#5befb9 Z{{Boot ROM}} --&amp;gt; A([Boot Loader]); A --&amp;gt; B(Kernel); B --&amp;gt; C(&amp;#34;init(pid=1)/C++ Framework Native&amp;#34;); C --&amp;gt; D(Zygote/Android Runtime); D --&amp;gt; E(System Server/Java Framework); E --&amp;gt; F(Apps); 面试题：一个应用启动，为什么不从init进程或者SystemServer进程fork，而是从Zygote进程fork。
Zygote作为一个孵化器，可以提前加载一些资源，这样fork时给予Copy-on-Write机制创建的其他进程能够直接利用这些资源，而不用重新加载。比如system_server就可以直接使用Zygote中的JNI函数、共享库、常用的类以及主题资源。
SystemServer相比Zygote多运行了AMS、WMS等服务，这些对于一个应用程序来说是不需要的，另外fork对多线程不友好，仅会将发起调用的线程拷贝到子进程，这可能会导致死锁，而SystemServer中肯定是有很多多线程的。
如何导致死锁的？
在POSIX标准中，fork行为是这样的：赋值整个用户空间的数据（通常使用copy-on-write的策略，所以可以实现速度很快）以及所有系统对象，然后仅复制当前线程到子进程。这里：所有父进程中别的线程，到了子进程都是突然蒸发掉的。
对于锁来说，从OS看，每个锁都有一个所有者，即最后依次lock它的线程。假设这样一个环境，在fork之前，有一个子线程lock了某个锁，获得了对锁的所有权，fork以后，在子进程中，所有的额外线程都人间蒸发了，而锁却被正常赋值了，在子进程看来，这个锁没有主人，所以没有任何人可以对它解锁，当子进程中的某个线程想lock这个锁时候，不再有任何手段可以解开了，程序发生死锁。
Zygote集成启动 graph TD; A[&amp;#34;init.cpp - main()&amp;#34;] --&amp;gt; B[解析init.zygote.rc]; B --&amp;gt; C[&amp;#34;启动main类型服务 do_class_start()&amp;#34;]; C --&amp;gt; D[&amp;#34;启动zygote服务 start()&amp;#34;]; D --&amp;gt; E[&amp;#34;创建Zygote进程 fork()&amp;#34;]; E --&amp;gt; |execv|F[&amp;#34;app_main.cpp - main()&amp;#34;]; System Server进程启动 graph TD; A[&amp;#34;app_main.</description>
    </item>
    
    <item>
      <title>Apk瘦身术</title>
      <link>https://boybeak.github.io/public/posts/android/apk%E7%98%A6%E8%BA%AB%E6%9C%AF/</link>
      <pubDate>Sat, 03 Sep 2022 21:03:05 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/android/apk%E7%98%A6%E8%BA%AB%E6%9C%AF/</guid>
      <description>Apk瘦身术 Apk瘦身主要从三方面入手：资源文件、源代码和第三方类库。
一、资源文件 1.1 删除无用资源文件 1.1.1 Lint工具 菜单 -&amp;gt; Analyze -&amp;gt; Run Inspection by Name，然后输入Unused resources便可以执行查找无用资源文件。自己根据需要进行删除。
1.1.2 shrinkResources buildTypes { release { // 不显示Log buildConfigField &amp;#34;boolean&amp;#34;, &amp;#34;LOG_DEBUG&amp;#34;, &amp;#34;false&amp;#34; //混淆 minifyEnabled true // 移除无用的resource文件 shrinkResources true proguardFiles getDefaultProguardFile(&amp;#39;proguard-android.txt&amp;#39;), &amp;#39;proguard-rules.pro&amp;#39; signingConfig signingConfigs.release } } 使用shrinkResources的前提是，打开混淆minifyEnabled，建议只在release版本开启，不然会使得编译速度变慢。
1.2 图标类资源图片矢量化 对于图标类资源，可以选择用vector-drawable来代替，通过AndroidStudio自带的转换工具可以将svg文件转换为vector-drawable文件。
具体操作为，在drawable相关文件夹上右键 -&amp;gt; New -&amp;gt; Vector Assert。
你也可以进行批量转换：工具地址
1.3 非图标类资源图片适当压缩与格式选择 1.3.1 使用tinypng有损压缩png图片 通过Tinypng官网上传压缩再下载，在保持alpha通道的情况下对png图片的压缩可达到1/3以内，且肉眼基本看不出差别。
1.3.2 使用jpg格式 对于非透明的大图，jpg会比png的大小和内存都更有优势，虽然不是绝对的，但是通常会减少到一半不止。
1.3.3 使用webp格式 webp格式支持透明度，压缩比比jpg高，但是显示效果却不输于jpg。缺点是在Android端的原生支持不好，从Android4.0+开始原生支持，但是不支持透明度，从Android4.3+开始支持带有透明度的webp。如果不需要兼容到这个版本，可以直接使用。
在Android studio中，在图片资源上右键可以转换为webp。详细参见创建 WebP 图片。
1.3.4 适当的压缩和尺寸 无论以上哪种格式图片，都可以通过选择合适的尺寸和适当的提高压缩率的方式，来进一步减少文件大小，进而减小apk文件的体积。</description>
    </item>
    
    <item>
      <title>App保活术</title>
      <link>https://boybeak.github.io/public/posts/android/app%E4%BF%9D%E6%B4%BB%E6%9C%AF/</link>
      <pubDate>Sat, 03 Sep 2022 21:03:05 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/android/app%E4%BF%9D%E6%B4%BB%E6%9C%AF/</guid>
      <description>App保活术 为什么要保活？
因为Android的Low memory killer机制，在系统内存不足的情况下，系统开始根据自身的一套进程回收机制结束一些进程，以便腾出内存给需要的进程。
如何判断内存不足？
判断的阈值在不同手机上是不一样的，一旦低于该阈值，系统就会杀死对应优先级的进程。
在adb shell下，通过如下命令来查看阈值：
cat /sys/module/lowmemorykiller/parameters/minfree 注意: 这可能需要root手机。
返回的结果如下示例：
18432, 23040, 27648, 32256, 55296, 80640 其单位为4kb，也就是内存1页大小。
该值表示的是剩余内存大小，优先级为从高到低，比如当内存小于18432*4kb时，杀死对应的优先级的进程。
graph TD; style 关键优先级 fill:#5befb9 style 高级优先级 fill:#6998c6 style 低优先级 fill:#d38a49 subgraph 关键优先级 A(前台进程) end A(前台进程) --&amp;gt; B(可见进程); subgraph 高级优先级 B --&amp;gt; C(服务进程); end C --&amp;gt; D(后台进程); subgraph 低优先级 D --&amp;gt; E(空进程); end 优先级从高到低依次是，前台进程、可见进程、服务进程、后台进程、空进程。
阈值有6个数，而进程有5种优先级，是如何对应呢？
实际上，第5个数是ContentProvider的阈值，其他的5个数与线程优先级对应。
如何判断线程的优先级？
cat /proc/&amp;lt;pid&amp;gt;/oom_adj 其中的应替换为对应的进程ID，从logcat中可以查看对应的pid。
取值范围绿色代表比较安全，红色代表比较容易被杀死，白色代表为系统进程。
1像素保活 监听锁屏广播，当屏幕关闭，偷偷创建一个1像素的activity，当屏幕开启，关闭掉这个1像素activity。
关键代码如下:
ScreenObserverService.java
//创建后台service，监听屏幕事件。 IntentFilter filter = new IntentFilter(Intent.</description>
    </item>
    
    <item>
      <title>ARouter源码分析</title>
      <link>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 03 Sep 2022 21:03:05 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>ARouter源码分析 在阅读源码前，请先下载源码：ARouter
最近阅读ARouter源码，发现这真的是一个非常优秀的框架。激发出兴趣来读一下他的源码，实际上，这个框架的结构非常简单。这个框架可以分为主流程和辅助流程来拆开分析。
主流程包含编译时和运行时两个部分，其中编译时主要做的是路由路径表的构建，运行时主要做的是路由路径表的加载；
辅助流程主要就是做启动优化。
主流程 1. 编译时 这部分主要涉及到的是路由路径表的构建，其实现原理是APT，即注解处理器。
使用ARouter时候，需要在目标类上，通过**@Route注解进行标记，注解处理器处理的就是这个注解。打开源码路径下的arouter-compiler这个module，找到RouteProcessor**，这个类就是用来处理**@Route**注解的类。这里需要了解的知识，除了APT，还有java-poet，请自行了解这些。
Processor类的入口方法是process方法，这个方法返回true，则这个处理器已经完成了自己的任务，不会被重复调用。其他比较重要的方法有getSupportedSourceVersion，getSupportedAnnotationTypes等。
Set&amp;lt;? extends Element&amp;gt; routeElements = roundEnv.getElementsAnnotatedWith(Route.class); 通过这个方法，获取所有被**@Route**标记的元素。
获取到routeElements后，在parseRoutes方法进行处理。我们以最常用的Activity为例，进行分析。
rootMap.clear();	//用来分类存储标记元素 // 用来检测元素是否为对应的类型，通过Types.isSubtype()方法来检测。 TypeMirror type_Activity = elementUtils.getTypeElement(ACTIVITY).asType(); TypeMirror type_Service = elementUtils.getTypeElement(SERVICE).asType(); TypeMirror fragmentTm = elementUtils.getTypeElement(FRAGMENT).asType(); TypeMirror fragmentTmV4 = elementUtils.getTypeElement(Consts.FRAGMENT_V4).asType(); 最后将分类号的元素信息，存储在成员变量groupMap中去。
private Map&amp;lt;String, Set&amp;lt;RouteMeta&amp;gt;&amp;gt; groupMap = new HashMap&amp;lt;&amp;gt;(); 然后再通过这个groupMap，借助java-poet，来生成真实的类。如下：
public class ARouter$$Group$$test implements IRouteGroup { @Override public void loadInto(Map&amp;lt;String, RouteMeta&amp;gt; atlas) { atlas.put(&amp;#34;/test/activity1&amp;#34;, RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, &amp;#34;/test/activity1&amp;#34;, &amp;#34;test&amp;#34;, new java.util.HashMap&amp;lt;String, Integer&amp;gt;(){{put(&amp;#34;ser&amp;#34;, 9); put(&amp;#34;ch&amp;#34;, 5); put(&amp;#34;fl&amp;#34;, 6); put(&amp;#34;dou&amp;#34;, 7); put(&amp;#34;boy&amp;#34;, 0); put(&amp;#34;url&amp;#34;, 8); put(&amp;#34;pac&amp;#34;, 10); put(&amp;#34;obj&amp;#34;, 11); put(&amp;#34;name&amp;#34;, 8); put(&amp;#34;objList&amp;#34;, 11); put(&amp;#34;map&amp;#34;, 11); put(&amp;#34;age&amp;#34;, 3); put(&amp;#34;height&amp;#34;, 3); }}, -1, -2147483648)); atlas.</description>
    </item>
    
    <item>
      <title>ASM库介绍与使用</title>
      <link>https://boybeak.github.io/public/posts/android/asm/</link>
      <pubDate>Sat, 03 Sep 2022 21:03:05 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/android/asm/</guid>
      <description>ASM库介绍与使用 原文
前面几篇文章介绍了 .class 文件的结构、JVM 如何加载 .class 文件、JVM 中如何执行方法的调用和访问者模式，其实前面几篇文章都是为这篇文章做铺垫的，如果不知道 .class 文件结构、也不知道在 JVM 中 .class 文件中的方法是如何被执行的，这篇文章中的有些部分可能会看不懂，所以推荐先看下前面几篇文章。 这篇文章主要介绍 ASM 库的结构、主要的 API，并且通过两个示例说明如何通过 ASM 修改 .class 文件中的方法和属性。
catalog.png
一. ASM 的结构 ASM 库是一款基于 Java 字节码层面的代码分析和修改工具。ASM 可以直接生产二进制的 class 文件，也可以在类被加载入 JVM 之前动态修改类行为。 ASM 库的结构如下所示：
asm_arch.png
Core：为其他包提供基础的读、写、转化Java字节码和定义的API，并且可以生成Java字节码和实现大部分字节码的转换，在 访问者模式和 ASM 中介绍的几个重要的类就在 Core API 中：ClassReader、ClassVisitor 和 ClassWriter 类. Tree：提供了 Java 字节码在内存中的表现 Commons：提供了一些常用的简化字节码生成、转换的类和适配器 Util：包含一些帮助类和简单的字节码修改类，有利于在开发或者测试中使用 XML：提供一个适配器将XML和SAX-comliant转化成字节码结构，可以允许使用XSLT去定义字节码转化 二. Core API 介绍 2.1 ClassVisitor 抽象类 如下所示，在 ClassVisitor 中提供了和类结构同名的一些方法，这些方法会对类中相应的部分进行操作，而且是有顺序的：visit [ visitSource ] [ visitOuterClass ] ( visitAnnotation | visitAttribute )* (visitInnerClass | visitField | visitMethod )* visitEnd</description>
    </item>
    
    <item>
      <title>Binder机制分析</title>
      <link>https://boybeak.github.io/public/posts/android/binder%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 03 Sep 2022 21:03:05 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/android/binder%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</guid>
      <description>Binder机制分析 参考文章：写给 Android 应用工程师的 Binder 原理剖析
实验代码：TheBinder
Binder机制可以说是Android的核心。提到Binder，可能会让你想到，通过bindService与Service进行通信(也可能是跨进程的通信)，实际上，Android中Binder的使用可以说是无处不在的，包括Activity跳转，详情可以参考AMS启动流程。
为什么要用Binder? 在Linux系统中，跨进程通信(IPC)方式有很多种，包括Socket、管道、共享内存等。可以Android为何最后选择Binder作为核心的跨进程通信的手段呢？
这需要从两方面去分析——性能和安全性。
1. 性能 首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。
2. 安全性 另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。
基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。
用一张表格来总结与对比各种IPC方式。
IPC方式 性能(内存拷贝次数) 安全性 Binder 1 通过UID/PID来保证 共享内存 0 操作非常复杂，难以保证 Socket/管道/消息队列 2 依靠上层协议做身份识别，非常不可靠 传统IPC是什么样的？ 先要了解一些基本概念——进程隔离、用户空间、内核空间、用户态、内核态。
上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：
进程隔离 进程空间划分：用户空间(User Space)/内核空间(Kernel Space) 系统调用：用户态/内核态 进程隔离 顾名思义，就是进程之间内存是不共享的。进程间要进行数据交换，就得采用**进程间通信(IPC)**机制。</description>
    </item>
    
    <item>
      <title>Intent.FLAG_ACTIVITY_***解密</title>
      <link>https://boybeak.github.io/public/posts/android/intent.flag_activity_%E5%88%B0%E5%BA%95%E8%83%BD%E5%B9%B2%E5%95%A5/</link>
      <pubDate>Sat, 03 Sep 2022 21:03:05 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/android/intent.flag_activity_%E5%88%B0%E5%BA%95%E8%83%BD%E5%B9%B2%E5%95%A5/</guid>
      <description>Intent.FLAG_ACTIVITY_***解密 最好先看这一篇Launch Mode。
我们将重点针对FLAG_ACTIVITY_NEW_TASK、FLAG_ACTIVITY_CLEAR_TASK、FLAG_ACTIVITY_CLEAR_TOP、FLAG_ACTIVITY_SINGLE_TOP四个flag进行讲解。
FLAG_ACTIVITY_NEW_TASK：
通过非Activity的Context启动一个Activity时候，要使用此flag，比如：ApplicationContext、Service等； 用于Launcher类应用启动其他应用的时候； 当试图通过这个flag启动一个activity的时候，如果后台已经有一个任务栈中有运行的一个此类activity实例，将不会创建一个新的activity，而是将整个栈置于前台，并保持上次的状态。比如从另一个应用启动这种场景，或者Notification中。 如果你想使用startActivityForResult，则千万不要在启动的intent添加这个flag。因为onActivityResult回调方法，不会在目标activity执行finish后调用，而是在启动目标activity的时候直接调用，并且收r到resultCode = RESULT_CANCELED。 FLAG_ACTIVITY_CLEAR_TOP：
如果在当前任务栈中已经有了目标类型activity，则再次通过添加了此flag的intent去启动此类型activity，会有两种情况。
比如有如下图示结构的任务栈:
graph LR; subgraph Task; D; C; B; A; end; 此时D通过一个添加了FLAG_ACTIVITY_CLEAR_TOP的intent去启动了B类型Activity，则C、D执行onDestroy出栈（不会执行finish，触发onDestroy），现在B在栈顶，有如下图示：
graph LR; subgraph Task; B; A; end; 接下来就有两种情况了。
情况一：intent中没有同时设置FLAG_ACTIVITY_SINGLE_TOP，并且B的launchMode是默认值。
B会finish掉再re-create一个新的B&amp;rsquo;放在B的位置上。
情况二：intent中设置了FLAG_ACTIVITY_SINGLE_TOP或者是其他类型的launchMode。
B不会finish（调用finish方法，onDestroy会被触发）掉，而是直接调用其onNewIntent()方法。
或许你认为情况二这与launchMode中的singleTop或者singleTask类似，实则不然，其一，singleTop没有清空压在它上边activity的能力；其二，singleTask收到taskAffinity影响。
与FLAG_ACTIVITY_NEW_TASK配合使用。如果想启动一个任务栈的root位置的activity，也就是栈低activity，同时设置这两个值，它会将整个任务栈放置于前台，并且清空其他activit，适用于从Notification启动Activity。
FLAG_ACTIVITY_CLEAR_TASK：这个flag很特殊，只能于FLAG_ACTIVITY_NEW_TASK配合使用。要启动的目标activity的任务栈如果已经存在并且不为空，则将所有activity出栈（不会调用finish方法，onDestroy会被触发），然后创建一个目标类型activity作为这个栈的root。
FLAG_ACTIVITY_SINGLE_TOP：这个flag与launchMode中的singleTop几乎一样，当要启动一个activity时候，如果栈顶就是目标类型activity，则不会创建一个新的activity，而是直接调用栈顶的这个activity的onNewIntent()方法。</description>
    </item>
    
    <item>
      <title>Launch Mode</title>
      <link>https://boybeak.github.io/public/posts/android/launchmode/</link>
      <pubDate>Sat, 03 Sep 2022 21:03:05 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/android/launchmode/</guid>
      <description>Launch Mode 此文是阅读《Android 面试黑洞——当我按下 Home 键再切回来，会发生什么？》一文后的总结，视频地址Bilibili、Youtube。
演示代码：
在正式讲解launchMode前，先要理解三个概念：ActivityStack, TaskRecord, ActivityRecord。
graph LR; style TaskRecord-A fill:#aaddff; style TaskRecord-B fill:#aaddff; subgraph ActivityStack subgraph TaskRecord-A A[ActivityRecord-1] B[ActivityRecord-2] end subgraph TaskRecord-B C[ActivityRecord-3] D[ActivityRecord-4] end end 他们的一般结构是这样的。
通过adb命令可以查看当前的ActivityStack、TaskRecord和ActivityRecord的结构。
adb shell dumpsys activity 结果如下(搜索ACTIVITY MANAGER STARTER (dumpsys activity containers))：
... ACTIVITY MANAGER STARTER (dumpsys activity containers) com.android.server.am.ActivityStackSupervisor@299f1c5 type=undefined mode=fullscreen #0 ActivityDisplay={0 numStacks=2} type=undefined mode=fullscreen #1 ActivityStack{694271a stackId=0 type=home mode=fullscreen visible=true translucent=false, 1 tasks} type=home mode=fullscreen #0 TaskRecord{e42980e #2 I=com.</description>
    </item>
    
    <item>
      <title>MVC</title>
      <link>https://boybeak.github.io/public/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvc/</link>
      <pubDate>Sat, 03 Sep 2022 21:03:05 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvc/</guid>
      <description>MVC stateDiagram-v2 Model --&amp;gt; View View --&amp;gt; Controller Controller --&amp;gt; Model Model --&amp;gt; Controller Controller --&amp;gt; View View --&amp;gt; Model Android中的MVC实际上非常混乱，Activity实际上本身是controller的角色，但是同时又充当了model和view。如果这样写，项目小的时候还可以，但是当项目越来越大的时候，为了能更好的解耦，为了适配将来的更改，需要引入MVP或者MVVM。
需要注意的是，一个项目中，并不是只能有一种开发模式，在不同功能模块完全可以用不同模式，甚至可以混用。</description>
    </item>
    
    <item>
      <title>MVP究极进化</title>
      <link>https://boybeak.github.io/public/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvp/</link>
      <pubDate>Sat, 03 Sep 2022 21:03:05 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvp/</guid>
      <description>MVP究极进化 MVP demo
graph TD; A(View) --&amp;gt; B(Presenter); B --&amp;gt; C(Model); C --&amp;gt; B; B --&amp;gt; A; MVP通过一个在view与model层中间架设一个presenter层，实现view与model的解耦，这样数据的归数据，界面的归界面。
对于Android而言，Activity就只作为view存在，只需要知道自己要怎么更新UI就好了，不需要知道如何请求数据等操作，而model只管请求数据等操作，他们中间靠一个presenter连接，互相不需要知道对方的存在。
这样做的好处显而易见，就是解耦，但是坏处就是，从以前mvc的一个类变成至少三个类，如果产品设计规范设计的好，修改起来也是很容易，但是如果产品规范设计的不好，就会陷入频繁更改，而且更改时候会更繁琐。
为了能更好的绑定View、Model和Presenter三者的关系，我们通常还会需要一个第四者——Contact。这样做的目的，是为了编码方便，能一目了然的看出到底是那些View、Model和Presenter存在“契约”关系。
public interface IUserContact { public interface IUserView { void showUser(User user); } public interface IUserPresenter&amp;lt;IUserView, IUserModel&amp;gt; { } public interface IUserModel { void getUser(); } } 一般结构如上，一目了然的，通过IUserContact将IUserView、IUserPresenter和IUserModel绑定了起来，注意其中的IUserPresenter的泛型结构。
上边只显示了一组与User有关的mvp结构，如果又有其他的mvp结构呢？我们为了能够更好的适应不同场景，会把M、V、P三方进行抽象，如下：
public interface IView { Context getContext(); } public interface IModel { } public interface IPresenter&amp;lt;V extends IView, M extends IModel&amp;gt; { void attachView(V v); void detachView(); V getView(); } 所以上面的User相关的mvp结构应该改成如下：</description>
    </item>
    
    <item>
      <title>发布Android库到MavenCentral教程</title>
      <link>https://boybeak.github.io/public/posts/android/mavencentral/</link>
      <pubDate>Sat, 03 Sep 2022 21:03:05 +0800</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/android/mavencentral/</guid>
      <description>发布Android库到MavenCentral教程 JCenter已经宣布，即将在2020年5月1日，停止新的库的提交，在2022年2月21号以前，连库的解析服务也停止，所以，把以前的库或者未来的新库替换到MavenCentral是当务之急了。
我参考的教程来自以下两篇文章：
Publishing your first Android library to MavenCentral
Android库发布到Maven Central全攻略
Demo项目地址：
EasyPack
建议英文能力强的直接第一篇，我是在第二篇遇到问题时候，找到了第一篇文章解决了问题，因为第二篇里用的windows环境，我用的mac环境。
一、 Sonatype Jira相关设置 首先，先去Sonatype Jira这个地址注册一个SonatypeJira的账号；
其次，账号创建后，登录，然后在这个页面https://issues.sonatype.org/projects 点击Create创建一个issue，如下图：
这里group id最好使用你的github地址，这样比较容易验证，如果你想用自己单独的域名，需要做更多的操作。很繁琐，不建议这样做。
创建以后，会有管理员处理你的这个issue，等待管理员回复你的issue，他会告诉你，要在你的github创建一个repo，repo的名字是这个issue的id，比如我的是OSSRH-66052。管理员回复我的如下图：
你创建好repo后，回复管理员就好了，等待这个issue的状态变成RESOLVED状态。
这样，你就创建好了一个issue，用来承接对应group id下所有的库。
二、Gradle的准备 在你项目根目录下的build.gradle文件添加classpath。
buildscript { ext { kotlin_version = &amp;#34;1.4.31&amp;#34; appcompat = &amp;#34;1.2.0&amp;#34; dokka_version = &amp;#39;1.4.10.2&amp;#39; } repositories { google() mavenCentral() } dependencies { classpath &amp;#39;com.android.tools.build:gradle:4.1.3&amp;#39; classpath &amp;#34;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&amp;#34; classpath &amp;#34;org.jetbrains.dokka:dokka-gradle-plugin:$dokka_version&amp;#34; //新添加的这一classpath } } 在你要提交的module下的build.gradle文件中，尾部追加如下代码：
ext { PUBLISH_ARTIFACT_ID = &amp;#34;你的artifact_id，一般是module的名字&amp;#34; } apply from: &amp;#39;../publish.gradle&amp;#39; 在根目录下创建publish.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://boybeak.github.io/public/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvvm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://boybeak.github.io/public/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mvvm/</guid>
      <description>MVVM </description>
    </item>
    
  </channel>
</rss>
