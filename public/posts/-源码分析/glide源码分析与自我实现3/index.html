<!DOCTYPE html>






































<html
  class="not-ready text-sm lg:text-base"
  style="--bg: #faf6f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>Glide源码分析与自我实现(三)——数据加载主流程 - My New Hugo Site</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="Glide源码分析与自我实现(三)——APT的使用与GIF的优化 项目Demo地址：GifHelper
什么是APT？
APT是Annotation Processing Tool的简称，即编译时注解处理器。它是一个javac的工具，在编译时，通过注解，按照规则自动生成相关代码的工具。
APT与Glide什么关系？
我们通常通过在build.gradle加入这样一段代码来引入Glide库。
repositories { google() jcenter() } dependencies { implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39; annotationProcessor &#39;com.github.bumptech.glide:compiler:4.11.0&#39; } 这里有一个annotationProcessor，这就是对Glide提供的APT进行引用。我们查看Glide的源码结构，可以看到一个名为annotation的文件夹，这里就是与APT有关的部分。
接下来我们先通过GIF优化，看一看Glide的APT能实现的神奇效果，在这之后，再来分析Glide是如何通过APT实现的。
**注意：**如果使用kotlin需要先加入apply plugin: &#39;kotlin-kapt&#39;插件，并且将annotationProcessor改成kapt。
GIF优化 为什么要优化GIF？
有人可能会有疑问，Glide相比其他图片加载框架的优势之一，就是支持GIF，为什么还要做优化呢？
先看两个截图来对比优化前后的CPU和内存使用情况。
我们可以看出，优化后，CPU和内存状况都好了很多，那么我们是怎么做的呢？这就需要用到谷歌官方的两个库——giflib和FrameSequence，这两个库需要我们自己编译成.so文件，具体可以参考示例项目GifHelper。
我们查看GifHolder中的代码。
class GifHolder(v: View) : AbsHolder&lt;GifItem&gt;(v) { ... private val gifIV = view&lt;ImageView&gt;(R.id.gifIV) override fun onBind(item: GifItem, position: Int, absAdapter: AnyAdapter) { if (item.useGifX) { // 优化后的加载方式 GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV) } else { // 优化前的加载方式 Glide.with(itemView).asGif().load(item.source()).into(gifIV) } .... } } 我们可以看到，加载后有这样一条语句：GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)，也许你会懵逼，哪里有GlideApp？哪里有asGifX()方法？我引入Glide后怎么没有看到这两个东西？这就涉及到了APT的内容了。想要看Glide官方文档的可以看这里。
一切的起因，要从**@GlideModule**这个注解说起，我们打开demo中的MyAppGlideModule类，可以看到这个类有一个@GlideModule注解。" />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://boybeak.github.io/public/main.min.css" />

  

  
  
  
    
  
  <link
    rel="preload"
    as="image"
    href="https://boybeak.github.io/public/theme.png"
  />

  
  
  
  <link rel="preload" as="image" href="https://www.gravatar.com/avatar/6fd8df4abe41f17fd8e2dd7d97b5cc8c?s=160&amp;d=identicon" />
  
  

  
  <link rel="preload" as="image" href="https://boybeak.github.io/public/twitter.svg" />
  
  <link rel="preload" as="image" href="https://boybeak.github.io/public/github.svg" />
  
  <link rel="preload" as="image" href="https://boybeak.github.io/public/instagram.svg" />
  
  <link rel="preload" as="image" href="https://boybeak.github.io/public/rss.svg" />
  

  
  <link rel="icon" href="https://boybeak.github.io/public/favicon.ico" />
  <link rel="apple-touch-icon" href="https://boybeak.github.io/public/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.101.0" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="Glide源码分析与自我实现(三)——数据加载主流程" />
<meta property="og:description" content="Glide源码分析与自我实现(三)——APT的使用与GIF的优化 项目Demo地址：GifHelper
什么是APT？
APT是Annotation Processing Tool的简称，即编译时注解处理器。它是一个javac的工具，在编译时，通过注解，按照规则自动生成相关代码的工具。
APT与Glide什么关系？
我们通常通过在build.gradle加入这样一段代码来引入Glide库。
repositories { google() jcenter() } dependencies { implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39; annotationProcessor &#39;com.github.bumptech.glide:compiler:4.11.0&#39; } 这里有一个annotationProcessor，这就是对Glide提供的APT进行引用。我们查看Glide的源码结构，可以看到一个名为annotation的文件夹，这里就是与APT有关的部分。
接下来我们先通过GIF优化，看一看Glide的APT能实现的神奇效果，在这之后，再来分析Glide是如何通过APT实现的。
**注意：**如果使用kotlin需要先加入apply plugin: &#39;kotlin-kapt&#39;插件，并且将annotationProcessor改成kapt。
GIF优化 为什么要优化GIF？
有人可能会有疑问，Glide相比其他图片加载框架的优势之一，就是支持GIF，为什么还要做优化呢？
先看两个截图来对比优化前后的CPU和内存使用情况。
我们可以看出，优化后，CPU和内存状况都好了很多，那么我们是怎么做的呢？这就需要用到谷歌官方的两个库——giflib和FrameSequence，这两个库需要我们自己编译成.so文件，具体可以参考示例项目GifHelper。
我们查看GifHolder中的代码。
class GifHolder(v: View) : AbsHolder&lt;GifItem&gt;(v) { ... private val gifIV = view&lt;ImageView&gt;(R.id.gifIV) override fun onBind(item: GifItem, position: Int, absAdapter: AnyAdapter) { if (item.useGifX) { // 优化后的加载方式 GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV) } else { // 优化前的加载方式 Glide.with(itemView).asGif().load(item.source()).into(gifIV) } .... } } 我们可以看到，加载后有这样一条语句：GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)，也许你会懵逼，哪里有GlideApp？哪里有asGifX()方法？我引入Glide后怎么没有看到这两个东西？这就涉及到了APT的内容了。想要看Glide官方文档的可以看这里。
一切的起因，要从**@GlideModule**这个注解说起，我们打开demo中的MyAppGlideModule类，可以看到这个类有一个@GlideModule注解。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B03/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-03T21:06:01+08:00" />
<meta property="article:modified_time" content="2022-09-03T21:06:01+08:00" />


  
  <meta itemprop="name" content="Glide源码分析与自我实现(三)——数据加载主流程">
<meta itemprop="description" content="Glide源码分析与自我实现(三)——APT的使用与GIF的优化 项目Demo地址：GifHelper
什么是APT？
APT是Annotation Processing Tool的简称，即编译时注解处理器。它是一个javac的工具，在编译时，通过注解，按照规则自动生成相关代码的工具。
APT与Glide什么关系？
我们通常通过在build.gradle加入这样一段代码来引入Glide库。
repositories { google() jcenter() } dependencies { implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39; annotationProcessor &#39;com.github.bumptech.glide:compiler:4.11.0&#39; } 这里有一个annotationProcessor，这就是对Glide提供的APT进行引用。我们查看Glide的源码结构，可以看到一个名为annotation的文件夹，这里就是与APT有关的部分。
接下来我们先通过GIF优化，看一看Glide的APT能实现的神奇效果，在这之后，再来分析Glide是如何通过APT实现的。
**注意：**如果使用kotlin需要先加入apply plugin: &#39;kotlin-kapt&#39;插件，并且将annotationProcessor改成kapt。
GIF优化 为什么要优化GIF？
有人可能会有疑问，Glide相比其他图片加载框架的优势之一，就是支持GIF，为什么还要做优化呢？
先看两个截图来对比优化前后的CPU和内存使用情况。
我们可以看出，优化后，CPU和内存状况都好了很多，那么我们是怎么做的呢？这就需要用到谷歌官方的两个库——giflib和FrameSequence，这两个库需要我们自己编译成.so文件，具体可以参考示例项目GifHelper。
我们查看GifHolder中的代码。
class GifHolder(v: View) : AbsHolder&lt;GifItem&gt;(v) { ... private val gifIV = view&lt;ImageView&gt;(R.id.gifIV) override fun onBind(item: GifItem, position: Int, absAdapter: AnyAdapter) { if (item.useGifX) { // 优化后的加载方式 GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV) } else { // 优化前的加载方式 Glide.with(itemView).asGif().load(item.source()).into(gifIV) } .... } } 我们可以看到，加载后有这样一条语句：GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)，也许你会懵逼，哪里有GlideApp？哪里有asGifX()方法？我引入Glide后怎么没有看到这两个东西？这就涉及到了APT的内容了。想要看Glide官方文档的可以看这里。
一切的起因，要从**@GlideModule**这个注解说起，我们打开demo中的MyAppGlideModule类，可以看到这个类有一个@GlideModule注解。"><meta itemprop="datePublished" content="2022-09-03T21:06:01+08:00" />
<meta itemprop="dateModified" content="2022-09-03T21:06:01+08:00" />
<meta itemprop="wordCount" content="480">
<meta itemprop="keywords" content="untagged," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Glide源码分析与自我实现(三)——数据加载主流程"/>
<meta name="twitter:description" content="Glide源码分析与自我实现(三)——APT的使用与GIF的优化 项目Demo地址：GifHelper
什么是APT？
APT是Annotation Processing Tool的简称，即编译时注解处理器。它是一个javac的工具，在编译时，通过注解，按照规则自动生成相关代码的工具。
APT与Glide什么关系？
我们通常通过在build.gradle加入这样一段代码来引入Glide库。
repositories { google() jcenter() } dependencies { implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39; annotationProcessor &#39;com.github.bumptech.glide:compiler:4.11.0&#39; } 这里有一个annotationProcessor，这就是对Glide提供的APT进行引用。我们查看Glide的源码结构，可以看到一个名为annotation的文件夹，这里就是与APT有关的部分。
接下来我们先通过GIF优化，看一看Glide的APT能实现的神奇效果，在这之后，再来分析Glide是如何通过APT实现的。
**注意：**如果使用kotlin需要先加入apply plugin: &#39;kotlin-kapt&#39;插件，并且将annotationProcessor改成kapt。
GIF优化 为什么要优化GIF？
有人可能会有疑问，Glide相比其他图片加载框架的优势之一，就是支持GIF，为什么还要做优化呢？
先看两个截图来对比优化前后的CPU和内存使用情况。
我们可以看出，优化后，CPU和内存状况都好了很多，那么我们是怎么做的呢？这就需要用到谷歌官方的两个库——giflib和FrameSequence，这两个库需要我们自己编译成.so文件，具体可以参考示例项目GifHelper。
我们查看GifHolder中的代码。
class GifHolder(v: View) : AbsHolder&lt;GifItem&gt;(v) { ... private val gifIV = view&lt;ImageView&gt;(R.id.gifIV) override fun onBind(item: GifItem, position: Int, absAdapter: AnyAdapter) { if (item.useGifX) { // 优化后的加载方式 GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV) } else { // 优化前的加载方式 Glide.with(itemView).asGif().load(item.source()).into(gifIV) } .... } } 我们可以看到，加载后有这样一条语句：GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)，也许你会懵逼，哪里有GlideApp？哪里有asGifX()方法？我引入Glide后怎么没有看到这两个东西？这就涉及到了APT的内容了。想要看Glide官方文档的可以看这里。
一切的起因，要从**@GlideModule**这个注解说起，我们打开demo中的MyAppGlideModule类，可以看到这个类有一个@GlideModule注解。"/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href="https://boybeak.github.io/public"
      >My New Hugo Site</a
    >
    <a
      class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
    ></a>
  </div>

  <a
    class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
  ></a>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = `"#faf6f1"`.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    const darkVal = localStorage.getItem('dark');
    setDark(darkVal ? darkVal === 'true' : darkScheme.matches);

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href=" https://twitter.com/YOUR_TWITTER_ID "
        target="_blank"
      ></a>
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href=" https://github.com/YOUR_GITHUB_ID "
        target="_blank"
      ></a>
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./instagram.svg)"
        href=" https://instagram.com/YOUR_INSTAGRAM_ID "
        target="_blank"
      ></a>
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href=" https://boybeak.github.io/public/index.xml "
        target="_blank"
      ></a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"
    >
      

<article>
  <header class="mb-20">
    <h1 class="!my-0 pb-2.5">Glide源码分析与自我实现(三)——数据加载主流程</h1>

    
    <div class="text-sm opacity-60">
      
      <time>Sep 3, 2022</time>
      
      
    </div>
    
  </header>

  <section><h1 id="glide源码分析与自我实现三apt的使用与gif的优化">Glide源码分析与自我实现(三)——APT的使用与GIF的优化</h1>
<p>项目Demo地址：<a href="https://github.com/boybeak/GifHelper">GifHelper</a></p>
<p><strong>什么是APT？</strong></p>
<p><strong>APT</strong>是<strong>Annotation Processing Tool</strong>的简称，即<strong>编译时注解处理器</strong>。它是一个javac的工具，在编译时，通过注解，按照规则自动生成相关代码的工具。</p>
<p><strong>APT与Glide什么关系？</strong></p>
<p>我们通常通过在build.gradle加入这样一段代码来引入Glide库。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-groovy" data-lang="groovy"><span style="display:flex;"><span>repositories <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  google<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  jcenter<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dependencies <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  implementation <span style="color:#e6db74">&#39;com.github.bumptech.glide:glide:4.11.0&#39;</span>
</span></span><span style="display:flex;"><span>  annotationProcessor <span style="color:#e6db74">&#39;com.github.bumptech.glide:compiler:4.11.0&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>这里有一个<code>annotationProcessor</code>，这就是对Glide提供的APT进行引用。我们查看Glide的源码结构，可以看到一个名为<em>annotation</em>的文件夹，这里就是与APT有关的部分。</p>
<p><img src="%7B%7Bsite.base_url%7D%7D/assets/images/glide_struct.jpg" alt="Glide Struct"></p>
<p>接下来我们先通过GIF优化，看一看Glide的APT能实现的神奇效果，在这之后，再来分析Glide是如何通过APT实现的。</p>
<blockquote>
<p>**注意：**如果使用kotlin需要先加入<code>apply plugin: 'kotlin-kapt'</code>插件，并且将<code>annotationProcessor</code>改成<code>kapt</code>。</p>
</blockquote>
<h2 id="gif优化">GIF优化</h2>
<p><strong>为什么要优化GIF？</strong></p>
<p>有人可能会有疑问，Glide相比其他图片加载框架的优势之一，就是支持GIF，为什么还要做优化呢？</p>
<p>先看两个截图来对比优化前后的CPU和内存使用情况。</p>
<p><img src="%7B%7Bsite.base_url%7D%7D/assets/images/gif_before_optimization.png" alt="优化前"></p>
<p><img src="%7B%7Bsite.base_url%7D%7D/assets/images/gif_after_optimization.png" alt="优化后"></p>
<p>我们可以看出，优化后，CPU和内存状况都好了很多，那么我们是怎么做的呢？这就需要用到谷歌官方的两个库——<a href="https://android.googlesource.com/platform/external/giflib/+/refs/heads/master">giflib</a>和<a href="https://android.googlesource.com/platform/frameworks/ex/+/refs/heads/master/framesequence/">FrameSequence</a>，这两个库需要我们自己编译成.so文件，具体可以参考示例项目<a href="https://github.com/boybeak/GifHelper">GifHelper</a>。</p>
<p>我们查看GifHolder中的代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GifHolder</span>(v: View) : AbsHolder&lt;GifItem&gt;(v) {
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> gifIV = view&lt;ImageView&gt;(R.id.gifIV)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">onBind</span>(item: GifItem, position: Int, absAdapter: AnyAdapter) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (item.useGifX) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 优化后的加载方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    	GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 优化前的加载方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      Glide.with(itemView).asGif().load(item.source()).into(gifIV)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">....</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们可以看到，加载后有这样一条语句：<code>GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</code>，也许你会懵逼，哪里有GlideApp？哪里有asGifX()方法？我引入Glide后怎么没有看到这两个东西？这就涉及到了APT的内容了。想要看Glide官方文档的可以看<a href="http://bumptech.github.io/glide/doc/configuration.html#glidemodule">这里</a>。</p>
<p>一切的起因，要从**@GlideModule**这个注解说起，我们打开demo中的MyAppGlideModule类，可以看到这个类有一个@GlideModule注解。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@GlideModule</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyAppGlideModule</span> : AppGlideModule() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">registerComponents</span>(context: Context, glide: Glide, registry: Registry) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">super</span>.registerComponents(context, glide, registry)
</span></span><span style="display:flex;"><span>    registry.append(Registry.BUCKET_GIF, InputStream<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>.java,
</span></span><span style="display:flex;"><span>                    FrameSequenceDrawable<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>.java, GifDecoder(glide.bitmapPool))
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们再点开这个注解的源码，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Target</span><span style="color:#f92672">(</span>ElementType<span style="color:#f92672">.</span><span style="color:#a6e22e">TYPE</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Retention</span><span style="color:#f92672">(</span>RetentionPolicy<span style="color:#f92672">.</span><span style="color:#a6e22e">CLASS</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">@interface</span> GlideModule <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Returns the name of the class that will be used as a replacement for {@code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * com.bumptech.glide.Glide} in Applications that depend on Glide&#39;s generated code.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   */</span>
</span></span><span style="display:flex;"><span>  String <span style="color:#a6e22e">glideName</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">default</span> <span style="color:#e6db74">&#34;GlideApp&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>我们现在看到“GlideApp”了，是glideName这个注解属性的默认值。我们来逐条分析一下这个注解类的相关信息：</p>
<ul>
<li><code>@Target(ElementType.TYPE)</code>：指明这个注解的作用对象——只对类生效；</li>
<li><code>@Retention(RetentionPolicy.CLASS)</code>：指明了这个注解的作用阶段——编译时记录在class文件中；</li>
<li><code>public @interface GlideModule</code>：这是一个注解接口，接口名<strong>GlideModule</strong>；</li>
<li><code>String glideName() default &quot;GlideApp&quot;</code>：这个注解接口需要一个名为<em>glideName</em>的属性，属性默认值为“GlideApp”。</li>
</ul>
<blockquote>
<p>RetentionPolicy：</p>
<ul>
<li><strong>SOURCE</strong>：这样的注解会被编译器擦除，只在编码阶段生效，目的是为了提示开发者，比如**@IntDef**、<strong>@StringDef</strong>、<strong>@Visibility</strong>、<strong>@NonNull</strong>；</li>
<li><strong>CLASS</strong>：记录在class文件中，编译时对编译器可见，运行时对VM不可见，这是RetentionPolicy的默认值，比如**@NotNull**;</li>
<li><strong>RUNTIME</strong>：记录在class文件中，在运行时需要反射获取其属性值，比如**@Column**。</li>
</ul>
</blockquote>
<p>就是这个**@GlideModule**属性，为我们生成了GlideApp类，这其中的生成过程，我们稍后再说，先把Gif优化的流程说完。</p>
<p>添加**@GlideModule**后，再次编译看，是否有了GlideApp这个类了。</p>
<p>我们再来看<em>MyAppGlideModule</em>中的代码，<code>registry.append</code>方法，这是为Glide添加一种解析类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param bucket 要添加的类型id.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param dataClass 要从什么数据进行解析。 ({@link java.io.InputStream}, {@link
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*     java.io.FileDescriptor} etc).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param resourceClass 要解析成什么数据。 ({@link android.graphics.Bitmap},
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*     {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param decoder 用什么解码器进行解析 {@link ResourceDecoder}。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@NonNull</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#f92672">&lt;</span>Data<span style="color:#f92672">,</span> TResource<span style="color:#f92672">&gt;</span> Registry <span style="color:#a6e22e">append</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@NonNull</span> String bucket<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@NonNull</span> Class<span style="color:#f92672">&lt;</span>Data<span style="color:#f92672">&gt;</span> dataClass<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@NonNull</span> Class<span style="color:#f92672">&lt;</span>TResource<span style="color:#f92672">&gt;</span> resourceClass<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@NonNull</span> ResourceDecoder<span style="color:#f92672">&lt;</span>Data<span style="color:#f92672">,</span> TResource<span style="color:#f92672">&gt;</span> decoder<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  decoderRegistry<span style="color:#f92672">.</span><span style="color:#a6e22e">append</span><span style="color:#f92672">(</span>bucket<span style="color:#f92672">,</span> decoder<span style="color:#f92672">,</span> dataClass<span style="color:#f92672">,</span> resourceClass<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>接下来就要引入谷歌官方的两个类库了，<a href="https://android.googlesource.com/platform/frameworks/ex/+/android-9.0.0_r16/framesequence/">FrameSquence</a>和<a href="https://android.googlesource.com/platform/external/giflib/+/android-9.0.0_r16">giflib</a>。大家可以根据需要下载对应版本的库，不过这两个库的版本最好要对应。</p>
<p>下载后需要编译，项目结构参考<a href="https://github.com/boybeak/GifHelper">GifHelper</a>项目中的framesequence/src/main/jni文件夹。注意，需要将FrameSequence_gif.h中的include部分进行修改。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">- #include &#34;config.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">- #include &#34;gif_lib.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span>改成
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">+ #include &#34;giflib/config.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+ #include &#34;giflib/gif_lib.h&#34;
</span></span></span></code></pre></div><p>然后执行ndk-build，则会在jni同级的目录下，生成一个libs文件夹，.so文件就在这里。</p>
<p>接下来需要去自定义GifDecoder.java了，直接上代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GifDecoder</span>(<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> bmpPool: BitmapPool) : ResourceDecoder&lt;InputStream, FrameSequenceDrawable&gt; {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> headerParser = DefaultImageHeaderParser()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">handles</span>(source: InputStream, options: Options): Boolean {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> !(options.<span style="color:#66d9ef">get</span>(GifOptions.DISABLE_ANIMATION) <span style="color:#f92672">?:</span> <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;&amp;</span> headerParser.getType(source) <span style="color:#f92672">==</span> ImageHeaderParser.ImageType.GIF
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">decode</span>(
</span></span><span style="display:flex;"><span>        source: InputStream,
</span></span><span style="display:flex;"><span>        width: Int,
</span></span><span style="display:flex;"><span>        height: Int,
</span></span><span style="display:flex;"><span>        options: Options
</span></span><span style="display:flex;"><span>    ): Resource&lt;FrameSequenceDrawable&gt;? {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> fs = FrameSequence.decodeStream(source)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> fsd = FrameSequenceDrawable(fs, <span style="color:#66d9ef">object</span> <span style="color:#960050;background-color:#1e0010">: </span><span style="color:#a6e22e">FrameSequenceDrawable</span>.BitmapProvider {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">acquireBitmap</span>(minWidth: Int, minHeight: Int): Bitmap {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> bmpPool.<span style="color:#66d9ef">get</span>(minWidth, minHeight, Bitmap.Config.ARGB_8888)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">releaseBitmap</span>(bitmap: Bitmap?) {
</span></span><span style="display:flex;"><span>                bmpPool.put(bitmap)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> GifResource(fsd)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个类里只需要实现两个方法：<code>handles</code>和<code>decode</code>：</p>
<ul>
<li>handles：能否解析该输入源，能则返回true；</li>
<li>decode：如果handles返回true，则执行此方法，返回一个Resource对象包裹住目标类型对象。</li>
</ul>
<p>我们通过Glide自带的<em>ImageHeaderParser</em>来检测该输入流是否是gif图像的输入流，如果是且可以执行动画，则进行decode操作。</p>
<p>我们着重看decode方法，这里需要重点看的是，在构建<em>FrameSequenceDrawable</em>时候，传入了一个<em>BitmapProvider</em>对象，这就是提高Gif效率的关键，在这个<em>BitmapProvider</em>里面，我们通过BitmapPool，去寻找可用尺寸的Bitmap，通过<strong>池化</strong>的方式，减小了内存开销，增加里Bitmap利用率。</p>
<p>接下来看，如何添加<code>asGifX</code>方法。我们都知道，传统的Glide调用方式如下图：</p>
<p><code>Glide.with(itemView).asGif().load(item.source()).into(gifIV)</code></p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR;
A[Glide] --&gt;|&#34;with(xxx)&#34;| B[RequestManager] --&gt;|&#34;asGif&#34;| C[RequestBuilder];
</code></pre><p>而新的方式却不同，如下图：</p>
<p><code>GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</code></p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR;
A[GlideApp] --&gt;|&#34;with(xxx)&#34;| B[GlideRequests]  --&gt;|asGifX| C[GlideRequest];
</code></pre><p>这其中的<em>GlideRequest</em>和<em>GlideRequest</em>，同样都是生成的类，其中GlideRequests继承自RequestManager，GlideRequest继承自RequestBuilder。</p>
<p>这两个类的生成，同样是**@GlideModule**的作用，但是<code>asGifX</code>这个方法是什么时候定义的呢？我们去查看<code>asGifX</code>这个方法的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @see GifExtension#asGifX(RequestBuilder)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@NonNull</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@CheckResult</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> GlideRequest<span style="color:#f92672">&lt;</span>FrameSequenceDrawable<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">asGifX</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>GlideRequest<span style="color:#f92672">&lt;</span>FrameSequenceDrawable<span style="color:#f92672">&gt;)</span> GifExtension<span style="color:#f92672">.</span><span style="color:#a6e22e">asGifX</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">as</span><span style="color:#f92672">(</span>FrameSequenceDrawable<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>我们看到实际上这个类的具体实现，是依靠GifExtension类，我们去看这个类的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@GlideExtension</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GifExtension</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@NonNull</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@GlideType</span><span style="color:#f92672">(</span>FrameSequenceDrawable<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> RequestBuilder<span style="color:#f92672">&lt;</span>FrameSequenceDrawable<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">asGifX</span><span style="color:#f92672">(</span>RequestBuilder<span style="color:#f92672">&lt;</span>FrameSequenceDrawable<span style="color:#f92672">&gt;</span> requestBuilder<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> requestBuilder<span style="color:#f92672">.</span><span style="color:#a6e22e">apply</span><span style="color:#f92672">(</span>RequestOptions
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">.</span><span style="color:#a6e22e">decodeTypeOf</span><span style="color:#f92672">(</span>FrameSequenceDrawable<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">GifExtension</span><span style="color:#f92672">(){}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>这个类需要我们自己实现，并且需要标记**@GlideExtension**注解，又是注解的功劳。</p>
<p>到此为止，Gif优化的主流程就全部讲完了，接下来就要看这两个注解——<strong>@GlideModule</strong>和**@GlideExtension**到底做了什么？</p>
<h2 id="glidemodule和glideextension">@GlideModule和@GlideExtension</h2>
<p>源码在Glide项目的annotation/compiler内，这种APT项目的入口文件标记在src/main/resources/META-INF/gradle内，这其中有一个incremental.annotation.processors文件，我们查看其内容：</p>
<pre tabindex="0"><code>com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor,aggregating
</code></pre><p>可以得知，程序入口在GlideAnnotationProcessor这个类，查看这个类的源码，我只提取了关键部分：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GlideAnnotationProcessor</span> <span style="color:#66d9ef">extends</span> AbstractProcessor <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> LibraryModuleProcessor libraryModuleProcessor<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> AppModuleProcessor appModuleProcessor<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> isGeneratedAppGlideModuleWritten<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> ExtensionProcessor extensionProcessor<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> Set<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getSupportedAnnotationTypes</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    Set<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;&gt;();</span>
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span><span style="color:#a6e22e">addAll</span><span style="color:#f92672">(</span>libraryModuleProcessor<span style="color:#f92672">.</span><span style="color:#a6e22e">getSupportedAnnotationTypes</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span><span style="color:#a6e22e">addAll</span><span style="color:#f92672">(</span>extensionProcessor<span style="color:#f92672">.</span><span style="color:#a6e22e">getSupportedAnnotationTypes</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">process</span><span style="color:#f92672">(</span>Set<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> TypeElement<span style="color:#f92672">&gt;</span> set<span style="color:#f92672">,</span> RoundEnvironment env<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    processorUtil<span style="color:#f92672">.</span><span style="color:#a6e22e">process</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> newModulesWritten <span style="color:#f92672">=</span> libraryModuleProcessor<span style="color:#f92672">.</span><span style="color:#a6e22e">processModules</span><span style="color:#f92672">(</span>env<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> newExtensionWritten <span style="color:#f92672">=</span> extensionProcessor<span style="color:#f92672">.</span><span style="color:#a6e22e">processExtensions</span><span style="color:#f92672">(</span>env<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    appModuleProcessor<span style="color:#f92672">.</span><span style="color:#a6e22e">processModules</span><span style="color:#f92672">(</span>set<span style="color:#f92672">,</span> env<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newExtensionWritten <span style="color:#f92672">||</span> newModulesWritten<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isGeneratedAppGlideModuleWritten<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Cannot process annotations after writing AppGlideModule&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>isGeneratedAppGlideModuleWritten<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      isGeneratedAppGlideModuleWritten <span style="color:#f92672">=</span> appModuleProcessor<span style="color:#f92672">.</span><span style="color:#a6e22e">maybeWriteAppModule</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ul>
<li><code>getSupportedAnnotationTypes</code>方法中标记了，支持哪些注解的解析，其中<code>libraryModuleProcessor.getSupportedAnnotationTypes()</code>中返回了**@GlideModule**，<code>extensionProcessor.getSupportedAnnotationTypes()</code>中返回了**@GlideExtension**。</li>
<li>process方法中开始了对注解的处理。</li>
</ul>
<p>注解的处理，需要你对<a href="https://github.com/square/javapoet"><strong>javapoet</strong></a>有一点点了解，如果暂时不想去了解，你只需要知道，这个类库是通过字符串和占位符来生成Java代码的工具类库，因为接下来的生成代码工作，Glide就是通过这个类库来实现的。</p>
<p>具体的生成过程不再赘述，从入口类<em>GlideAnnotationProcessor</em>追踪下去，就能看到。</p>
<h2 id="为什么优化能提高效率">为什么优化能提高效率？</h2>
<p>Glide默认Gif加载方案，是通过GifDrawable来实现的，而GifDrawable是通过GifFrameLoader来加载帧数据的。具体代码分析可以看参考文章，我这里简单来说一下原因：</p>
<ul>
<li>默认方案是串行执行的，比如在加载显示第N帧，这一帧显示完毕，再去解析第N+1帧，当播放第N+1帧的时间窗口到了以后，如果已经解析完毕，则能正常显示，如果不能解析完毕，则会卡顿了；</li>
<li>GifFrameLoader内部是用了一个mainLooper的handler来进行流程控制，具体可以看GifFrameLoader里的代码，这种方式本身在时间上就不是准时的，与应用内其他各种系统共享mainLooper，如果其他事件执行占用时间较长，也会影响这里的效率了。</li>
</ul>
<p>我们再来说说优化方案，优化的原因也简单说一下：</p>
<ul>
<li>优化方案是<strong>并行+双缓冲</strong>执行的，在显示第N帧的BitmapA同时，会有一个后台线程在解析第N+1帧的BitmapB，当需要显示第N+1帧BitmapB的时候，两帧的Bitmap交换，BitmapA则进入后台线程去解析第N+2帧了；</li>
<li>在native去解析数据，效率更高；</li>
<li>通过BitmapPool提高了内存利用率。</li>
</ul>
<p>借用参考文章里的一张图</p>
<p><img src="%7B%7Bsite.base_url%7D%7D/assets/images/.gif.webp" alt="Gif"></p>
<h2 id="参考文章">参考文章</h2>
<p><a href="https://juejin.im/post/6854573219425288199">Glide加载Gif的卡顿优化思路分析</a></p>
</section>

  
  
  <footer class="mt-12 flex flex-wrap">
     
    <a
      class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]"
      href="https://boybeak.github.io/public/tags/untagged"
      >untagged</a
    >
    
  </footer>
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a class="flex w-1/2 items-center p-6 pr-3 no-underline" href="https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B01/"
      ><span class="mr-1.5">←</span><span>Glide源码分析与自我实现(一)——数据加载主流程</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline"
      href="https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B02/"
      ><span>Glide源码分析与自我实现(二)——数据加载主流程</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
  <div id="disqus_thread"></div>
  <script>
    const disqusShortname = 'YOUR_DISQUS_SHORTNAME';
    const script = document.createElement('script');
    script.src = 'https://' + disqusShortname + '.disqus.com/embed.js';
    script.setAttribute('data-timestamp', +new Date());
    document.head.appendChild(script);
  </script>
  
</article>


    </main>

    <footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60">
  <div class="mr-auto">
    &copy; 2022
    <a class="link" href="https://boybeak.github.io/public">My New Hugo Site</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank">Powered by Hugo️️</a
  >️
  <a class="link" href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank"
    >▷ Paper 6</a
  >
</footer>

  </body>
</html>
