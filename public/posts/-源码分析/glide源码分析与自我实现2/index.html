<!DOCTYPE html>






































<html
  class="not-ready text-sm lg:text-base"
  style="--bg: #faf6f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>Glide源码分析与自我实现(二)——数据加载主流程 - My New Hugo Site</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="Glide源码分析与自我实现(二)——缓存与BitmapPool 本文基于Glide 4.11.0
参考文章：Glide 源码分析解读-缓存模块-基于最新版Glide 4.9.0
**注意：**由于版本差异问题，本文有些部分与参考文章有差异。
缓存模块是Glide中非常重要的部分，Glide图片加载的高效性，几乎有一半功劳都在这里了。
一般来说，Glide有三级缓存，就是内存缓存、磁盘缓存和网络缓存。
先来看缓存流程图，如下：
graph TD; style A fill:#99ccff style B1 fill:#aaffaa A(发起请求) --&gt; B{1. 通过&lt;br&gt;ActiveResources&lt;br&gt;获取资源} --&gt; |命中|B1([加载完成]); B --&gt; |未命中|C{2. 通过&lt;br&gt;MemoryCache&lt;br&gt;获取资源} --&gt; |命中|C1[缓存至&lt;br&gt;ActiveResources] --&gt; B1; C --&gt; |未命中|D{3. 通过&lt;br&gt;DiskCache&lt;br&gt;获取资源} --&gt; |命中|D1[缓存至&lt;br&gt;MemoryCache] --&gt; C1; D --&gt; |未命中|E[&#34;4. 通过数据源(网络、文件等)&lt;br&gt;加载数据&#34;] --&gt; E1[缓存至&lt;br&gt;DiskCache] --&gt; D1; 内存缓存 内存缓存主要靠三个部分组成：ActiveResources、MemoryCache和BitmapPool。
ActiveResources ActiveResources表示当前正在活动中的资源。ActiveResources通过一个Map&lt;Key, ResourceWeakReference&gt;来保存活动中的资源，其中的ResourceWeakReference就是资源数据，在构建这个ResourceWeakReference的时候必须传入一个ReferenceQueue用来检测资源是否被回收。
Q1：如何探知WeakReference中的值被回收了呢？
ReferenceQueue queue = ...; WeakReference wr = new WeakReference(value, queue); 当构建WeakReference的时候，如果传入了queue参数，则在value被回收的时候，wr会被加入到queue中去，这样，通过检测queue中是否有值，就可以探知value是否被回收了。
那么，在何时去探知ReferenceQueue中的值呢？我们查看ActiveResources的关键代码：
/*构造方法中，通过monitorClearedResourcesExecutor执行了cleanReferenceQueue()方法。 */ ActiveResources(boolean isActiveResourceRetentionAllowed) { this( isActiveResourceRetentionAllowed, java." />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://boybeak.github.io/public/main.min.css" />

  

  
  
  
    
  
  <link
    rel="preload"
    as="image"
    href="https://boybeak.github.io/public/theme.png"
  />

  
  
  
  <link rel="preload" as="image" href="https://www.gravatar.com/avatar/6fd8df4abe41f17fd8e2dd7d97b5cc8c?s=160&amp;d=identicon" />
  
  

  
  <link rel="preload" as="image" href="https://boybeak.github.io/public/twitter.svg" />
  
  <link rel="preload" as="image" href="https://boybeak.github.io/public/github.svg" />
  
  <link rel="preload" as="image" href="https://boybeak.github.io/public/instagram.svg" />
  
  <link rel="preload" as="image" href="https://boybeak.github.io/public/rss.svg" />
  

  
  <link rel="icon" href="https://boybeak.github.io/public/favicon.ico" />
  <link rel="apple-touch-icon" href="https://boybeak.github.io/public/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.101.0" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="Glide源码分析与自我实现(二)——数据加载主流程" />
<meta property="og:description" content="Glide源码分析与自我实现(二)——缓存与BitmapPool 本文基于Glide 4.11.0
参考文章：Glide 源码分析解读-缓存模块-基于最新版Glide 4.9.0
**注意：**由于版本差异问题，本文有些部分与参考文章有差异。
缓存模块是Glide中非常重要的部分，Glide图片加载的高效性，几乎有一半功劳都在这里了。
一般来说，Glide有三级缓存，就是内存缓存、磁盘缓存和网络缓存。
先来看缓存流程图，如下：
graph TD; style A fill:#99ccff style B1 fill:#aaffaa A(发起请求) --&gt; B{1. 通过&lt;br&gt;ActiveResources&lt;br&gt;获取资源} --&gt; |命中|B1([加载完成]); B --&gt; |未命中|C{2. 通过&lt;br&gt;MemoryCache&lt;br&gt;获取资源} --&gt; |命中|C1[缓存至&lt;br&gt;ActiveResources] --&gt; B1; C --&gt; |未命中|D{3. 通过&lt;br&gt;DiskCache&lt;br&gt;获取资源} --&gt; |命中|D1[缓存至&lt;br&gt;MemoryCache] --&gt; C1; D --&gt; |未命中|E[&#34;4. 通过数据源(网络、文件等)&lt;br&gt;加载数据&#34;] --&gt; E1[缓存至&lt;br&gt;DiskCache] --&gt; D1; 内存缓存 内存缓存主要靠三个部分组成：ActiveResources、MemoryCache和BitmapPool。
ActiveResources ActiveResources表示当前正在活动中的资源。ActiveResources通过一个Map&lt;Key, ResourceWeakReference&gt;来保存活动中的资源，其中的ResourceWeakReference就是资源数据，在构建这个ResourceWeakReference的时候必须传入一个ReferenceQueue用来检测资源是否被回收。
Q1：如何探知WeakReference中的值被回收了呢？
ReferenceQueue queue = ...; WeakReference wr = new WeakReference(value, queue); 当构建WeakReference的时候，如果传入了queue参数，则在value被回收的时候，wr会被加入到queue中去，这样，通过检测queue中是否有值，就可以探知value是否被回收了。
那么，在何时去探知ReferenceQueue中的值呢？我们查看ActiveResources的关键代码：
/*构造方法中，通过monitorClearedResourcesExecutor执行了cleanReferenceQueue()方法。 */ ActiveResources(boolean isActiveResourceRetentionAllowed) { this( isActiveResourceRetentionAllowed, java." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B02/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-03T21:06:01+08:00" />
<meta property="article:modified_time" content="2022-09-03T21:06:01+08:00" />


  
  <meta itemprop="name" content="Glide源码分析与自我实现(二)——数据加载主流程">
<meta itemprop="description" content="Glide源码分析与自我实现(二)——缓存与BitmapPool 本文基于Glide 4.11.0
参考文章：Glide 源码分析解读-缓存模块-基于最新版Glide 4.9.0
**注意：**由于版本差异问题，本文有些部分与参考文章有差异。
缓存模块是Glide中非常重要的部分，Glide图片加载的高效性，几乎有一半功劳都在这里了。
一般来说，Glide有三级缓存，就是内存缓存、磁盘缓存和网络缓存。
先来看缓存流程图，如下：
graph TD; style A fill:#99ccff style B1 fill:#aaffaa A(发起请求) --&gt; B{1. 通过&lt;br&gt;ActiveResources&lt;br&gt;获取资源} --&gt; |命中|B1([加载完成]); B --&gt; |未命中|C{2. 通过&lt;br&gt;MemoryCache&lt;br&gt;获取资源} --&gt; |命中|C1[缓存至&lt;br&gt;ActiveResources] --&gt; B1; C --&gt; |未命中|D{3. 通过&lt;br&gt;DiskCache&lt;br&gt;获取资源} --&gt; |命中|D1[缓存至&lt;br&gt;MemoryCache] --&gt; C1; D --&gt; |未命中|E[&#34;4. 通过数据源(网络、文件等)&lt;br&gt;加载数据&#34;] --&gt; E1[缓存至&lt;br&gt;DiskCache] --&gt; D1; 内存缓存 内存缓存主要靠三个部分组成：ActiveResources、MemoryCache和BitmapPool。
ActiveResources ActiveResources表示当前正在活动中的资源。ActiveResources通过一个Map&lt;Key, ResourceWeakReference&gt;来保存活动中的资源，其中的ResourceWeakReference就是资源数据，在构建这个ResourceWeakReference的时候必须传入一个ReferenceQueue用来检测资源是否被回收。
Q1：如何探知WeakReference中的值被回收了呢？
ReferenceQueue queue = ...; WeakReference wr = new WeakReference(value, queue); 当构建WeakReference的时候，如果传入了queue参数，则在value被回收的时候，wr会被加入到queue中去，这样，通过检测queue中是否有值，就可以探知value是否被回收了。
那么，在何时去探知ReferenceQueue中的值呢？我们查看ActiveResources的关键代码：
/*构造方法中，通过monitorClearedResourcesExecutor执行了cleanReferenceQueue()方法。 */ ActiveResources(boolean isActiveResourceRetentionAllowed) { this( isActiveResourceRetentionAllowed, java."><meta itemprop="datePublished" content="2022-09-03T21:06:01+08:00" />
<meta itemprop="dateModified" content="2022-09-03T21:06:01+08:00" />
<meta itemprop="wordCount" content="779">
<meta itemprop="keywords" content="untagged," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Glide源码分析与自我实现(二)——数据加载主流程"/>
<meta name="twitter:description" content="Glide源码分析与自我实现(二)——缓存与BitmapPool 本文基于Glide 4.11.0
参考文章：Glide 源码分析解读-缓存模块-基于最新版Glide 4.9.0
**注意：**由于版本差异问题，本文有些部分与参考文章有差异。
缓存模块是Glide中非常重要的部分，Glide图片加载的高效性，几乎有一半功劳都在这里了。
一般来说，Glide有三级缓存，就是内存缓存、磁盘缓存和网络缓存。
先来看缓存流程图，如下：
graph TD; style A fill:#99ccff style B1 fill:#aaffaa A(发起请求) --&gt; B{1. 通过&lt;br&gt;ActiveResources&lt;br&gt;获取资源} --&gt; |命中|B1([加载完成]); B --&gt; |未命中|C{2. 通过&lt;br&gt;MemoryCache&lt;br&gt;获取资源} --&gt; |命中|C1[缓存至&lt;br&gt;ActiveResources] --&gt; B1; C --&gt; |未命中|D{3. 通过&lt;br&gt;DiskCache&lt;br&gt;获取资源} --&gt; |命中|D1[缓存至&lt;br&gt;MemoryCache] --&gt; C1; D --&gt; |未命中|E[&#34;4. 通过数据源(网络、文件等)&lt;br&gt;加载数据&#34;] --&gt; E1[缓存至&lt;br&gt;DiskCache] --&gt; D1; 内存缓存 内存缓存主要靠三个部分组成：ActiveResources、MemoryCache和BitmapPool。
ActiveResources ActiveResources表示当前正在活动中的资源。ActiveResources通过一个Map&lt;Key, ResourceWeakReference&gt;来保存活动中的资源，其中的ResourceWeakReference就是资源数据，在构建这个ResourceWeakReference的时候必须传入一个ReferenceQueue用来检测资源是否被回收。
Q1：如何探知WeakReference中的值被回收了呢？
ReferenceQueue queue = ...; WeakReference wr = new WeakReference(value, queue); 当构建WeakReference的时候，如果传入了queue参数，则在value被回收的时候，wr会被加入到queue中去，这样，通过检测queue中是否有值，就可以探知value是否被回收了。
那么，在何时去探知ReferenceQueue中的值呢？我们查看ActiveResources的关键代码：
/*构造方法中，通过monitorClearedResourcesExecutor执行了cleanReferenceQueue()方法。 */ ActiveResources(boolean isActiveResourceRetentionAllowed) { this( isActiveResourceRetentionAllowed, java."/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href="https://boybeak.github.io/public"
      >My New Hugo Site</a
    >
    <a
      class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
    ></a>
  </div>

  <a
    class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
  ></a>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = `"#faf6f1"`.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    const darkVal = localStorage.getItem('dark');
    setDark(darkVal ? darkVal === 'true' : darkScheme.matches);

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href=" https://twitter.com/YOUR_TWITTER_ID "
        target="_blank"
      ></a>
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href=" https://github.com/YOUR_GITHUB_ID "
        target="_blank"
      ></a>
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./instagram.svg)"
        href=" https://instagram.com/YOUR_INSTAGRAM_ID "
        target="_blank"
      ></a>
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href=" https://boybeak.github.io/public/index.xml "
        target="_blank"
      ></a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"
    >
      

<article>
  <header class="mb-20">
    <h1 class="!my-0 pb-2.5">Glide源码分析与自我实现(二)——数据加载主流程</h1>

    
    <div class="text-sm opacity-60">
      
      <time>Sep 3, 2022</time>
      
      
    </div>
    
  </header>

  <section><h1 id="glide源码分析与自我实现二缓存与bitmappool">Glide源码分析与自我实现(二)——缓存与BitmapPool</h1>
<blockquote>
<p>本文基于Glide 4.11.0</p>
</blockquote>
<p>参考文章：<a href="https://zhuanlan.zhihu.com/p/60426316">Glide 源码分析解读-缓存模块-基于最新版Glide 4.9.0</a></p>
<p>**注意：**由于版本差异问题，本文有些部分与参考文章有差异。</p>
<p>缓存模块是Glide中非常重要的部分，Glide图片加载的高效性，几乎有一半功劳都在这里了。</p>
<p>一般来说，Glide有三级缓存，就是<strong>内存缓存</strong>、<strong>磁盘缓存</strong>和<strong>网络缓存</strong>。</p>
<p>先来看缓存流程图，如下：</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph TD;
style A fill:#99ccff
style B1 fill:#aaffaa
A(发起请求) --&gt; B{1. 通过&lt;br&gt;ActiveResources&lt;br&gt;获取资源} --&gt; |命中|B1([加载完成]);
B --&gt; |未命中|C{2. 通过&lt;br&gt;MemoryCache&lt;br&gt;获取资源} --&gt; |命中|C1[缓存至&lt;br&gt;ActiveResources] --&gt; B1;
C --&gt; |未命中|D{3. 通过&lt;br&gt;DiskCache&lt;br&gt;获取资源} --&gt; |命中|D1[缓存至&lt;br&gt;MemoryCache] --&gt; C1;
D --&gt; |未命中|E[&#34;4. 通过数据源(网络、文件等)&lt;br&gt;加载数据&#34;] --&gt; E1[缓存至&lt;br&gt;DiskCache] --&gt; D1;
</code></pre><h2 id="内存缓存">内存缓存</h2>
<p>内存缓存主要靠三个部分组成：<strong>ActiveResources</strong>、<strong>MemoryCache</strong>和<strong>BitmapPool</strong>。</p>
<h3 id="activeresources">ActiveResources</h3>
<p>ActiveResources表示当前正在活动中的资源。ActiveResources通过一个<code>Map&lt;Key, ResourceWeakReference&gt;</code>来保存活动中的资源，其中的ResourceWeakReference就是资源数据，在构建这个ResourceWeakReference的时候必须传入一个ReferenceQueue用来检测资源是否被回收。</p>
<blockquote>
<p><strong>Q1：如何探知WeakReference中的值被回收了呢？</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ReferenceQueue queue <span style="color:#f92672">=</span> <span style="color:#f92672">...;</span>
</span></span><span style="display:flex;"><span>WeakReference wr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> WeakReference<span style="color:#f92672">(</span>value<span style="color:#f92672">,</span> queue<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>当构建WeakReference的时候，如果传入了queue参数，则在value被回收的时候，wr会被加入到queue中去，这样，通过检测queue中是否有值，就可以探知value是否被回收了。</p>
</blockquote>
<p>那么，在何时去探知ReferenceQueue中的值呢？我们查看ActiveResources的关键代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/*构造方法中，通过monitorClearedResourcesExecutor执行了cleanReferenceQueue()方法。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>ActiveResources<span style="color:#f92672">(</span><span style="color:#66d9ef">boolean</span> isActiveResourceRetentionAllowed<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>    isActiveResourceRetentionAllowed<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>    java<span style="color:#f92672">.</span><span style="color:#a6e22e">util</span><span style="color:#f92672">.</span><span style="color:#a6e22e">concurrent</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Executors</span><span style="color:#f92672">.</span><span style="color:#a6e22e">newSingleThreadExecutor</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">new</span> ThreadFactory<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> Thread <span style="color:#a6e22e">newThread</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@NonNull</span> <span style="color:#66d9ef">final</span> Runnable r<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                Process<span style="color:#f92672">.</span><span style="color:#a6e22e">setThreadPriority</span><span style="color:#f92672">(</span>Process<span style="color:#f92672">.</span><span style="color:#a6e22e">THREAD_PRIORITY_BACKGROUND</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                r<span style="color:#f92672">.</span><span style="color:#a6e22e">run</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">},</span>
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;glide-active-resources&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}));</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@VisibleForTesting</span>
</span></span><span style="display:flex;"><span>ActiveResources<span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">boolean</span> isActiveResourceRetentionAllowed<span style="color:#f92672">,</span> Executor monitorClearedResourcesExecutor<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">isActiveResourceRetentionAllowed</span> <span style="color:#f92672">=</span> isActiveResourceRetentionAllowed<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">monitorClearedResourcesExecutor</span> <span style="color:#f92672">=</span> monitorClearedResourcesExecutor<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  monitorClearedResourcesExecutor<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        cleanReferenceQueue<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cleanReferenceQueue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>isShutdown<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      ResourceWeakReference ref <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>ResourceWeakReference<span style="color:#f92672">)</span> resourceReferenceQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>      cleanupActiveReference<span style="color:#f92672">(</span>ref<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// This section for testing only.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      DequeuedResourceCallback current <span style="color:#f92672">=</span> cb<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        current<span style="color:#f92672">.</span><span style="color:#a6e22e">onResourceDequeued</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// End for testing only.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">interrupt</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>我们通过代码可以看出，<code>cleanReferenceQueue</code>是一个靠<code>isShutdown</code>变量控制的<strong>死循环</strong>方法，这个方法执行在一个优先级为<code>THREAD_PRIORITY_BACKGROUND</code>的线程上。</p>
<blockquote>
<p><strong>Q2：那么，既然是死循环方法，会不会过多的占用CPU资源呢？</strong></p>
<p>其实不会的，因为ReferenceQueue#remove是一个阻塞式的方法，如果没有元素可以被remove，则等待至有元素可以remove的时候，等待期间释放CPU。</p>
</blockquote>
<blockquote>
<p><strong>注意：<strong>此处与</strong>参考文章</strong>中的说法不同，这是因为版本差异。查看<a href="https://github.com/bumptech/glide/commit/8f1ea5c07dff7ade8c49c324bcb5a7f40d0b4891#diff-c46e6c0760c04e74cb867c2bdf9cdee90ab279b119268478524c42cc743cb8a9">Glide update log hsitory</a>，可以看出<strong>出于避免在主线程做清理的原因</strong>，将清理任务放在了后台线程，而不是放在IdleHandler中。</p>
</blockquote>
<p><strong>那么被回收了的资源去哪里了呢？</strong></p>
<p>我们查看<code>cleanupActiveReference</code>方法，得知，通过<em>ResourceListener#onResourceReleased</em>回调，交给了<strong>Engine</strong>来处理，我们查看Engine的onResourceReleased方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onResourceReleased</span><span style="color:#f92672">(</span>Key cacheKey<span style="color:#f92672">,</span> EngineResource<span style="color:#f92672">&lt;?&gt;</span> resource<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  activeResources<span style="color:#f92672">.</span><span style="color:#a6e22e">deactivate</span><span style="color:#f92672">(</span>cacheKey<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>resource<span style="color:#f92672">.</span><span style="color:#a6e22e">isMemoryCacheable</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    cache<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>cacheKey<span style="color:#f92672">,</span> resource<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    resourceRecycler<span style="color:#f92672">.</span><span style="color:#a6e22e">recycle</span><span style="color:#f92672">(</span>resource<span style="color:#f92672">,</span> <span style="color:#75715e">/*forceNextFrame=*/</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>从这里我们发现，这里出现了两种情况：</p>
<ol>
<li>如果资源是<strong>MemoryCacheable</strong>的，则缓存在MemoryCache；</li>
<li>如果资源不是<strong>MemoryCacheable</strong>的，则交给ResourceRecycler调用Resource的recycle()方法来回收，如果此Resource为BitmapResource，则会将Bitmap回收到BitmapPool中去。</li>
</ol>
<p>在开始MemoryCache和BitmapPool前，需要先了解一下<strong>MemorySizeCalculator</strong>这个类，这个类是用来计算 BitmapPool 、ArrayPool 以及 MemoryCache <strong>大小</strong>的。</p>
<h3 id="memorycache">MemoryCache</h3>
<p>MemoryCache的具体实现类是LruResourceCache，而实际的逻辑方法，都在其父类LruCache中，以put方法为例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Nullable</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> Y <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@NonNull</span> T key<span style="color:#f92672">,</span> <span style="color:#a6e22e">@Nullable</span> Y item<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> itemSize <span style="color:#f92672">=</span> getSize<span style="color:#f92672">(</span>item<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>itemSize <span style="color:#f92672">&gt;=</span> maxSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    onItemEvicted<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> item<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>item <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    currentSize <span style="color:#f92672">+=</span> itemSize<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Nullable</span> Entry<span style="color:#f92672">&lt;</span>Y<span style="color:#f92672">&gt;</span> old <span style="color:#f92672">=</span> cache<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> item <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> Entry<span style="color:#f92672">&lt;&gt;(</span>item<span style="color:#f92672">,</span> itemSize<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>old <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    currentSize <span style="color:#f92672">-=</span> old<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>old<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>item<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      onItemEvicted<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> old<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  evict<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> old <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> old<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>当有一个新的item被put进去以后，会替换出一个老的值old，如果old非为空，则需要将当前容量减去old的大小，如果old并非新的item，则需要通过onItemEvicted进行回调，通知有老值被**“驱逐”<strong>了。最后还要执行一次evict方法，按照LRU算法，将超出maxSize的item</strong>“驱逐”**出去，以确保在maxSize范围内。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">trimToSize</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> size<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">,</span> Entry<span style="color:#f92672">&lt;</span>Y<span style="color:#f92672">&gt;&gt;</span> last<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  Iterator<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">,</span> Entry<span style="color:#f92672">&lt;</span>Y<span style="color:#f92672">&gt;&gt;&gt;</span> cacheIterator<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>currentSize <span style="color:#f92672">&gt;</span> size<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    cacheIterator <span style="color:#f92672">=</span> cache<span style="color:#f92672">.</span><span style="color:#a6e22e">entrySet</span><span style="color:#f92672">().</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    last <span style="color:#f92672">=</span> cacheIterator<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> Entry<span style="color:#f92672">&lt;</span>Y<span style="color:#f92672">&gt;</span> toRemove <span style="color:#f92672">=</span> last<span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    currentSize <span style="color:#f92672">-=</span> toRemove<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> T key <span style="color:#f92672">=</span> last<span style="color:#f92672">.</span><span style="color:#a6e22e">getKey</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    cacheIterator<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    onItemEvicted<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> toRemove<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">evict</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  trimToSize<span style="color:#f92672">(</span>maxSize<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>被**&ldquo;驱逐&rdquo;**的值去哪里了呢？我们查看<em>MemoryCache</em>类的源码，可以知道是通过<em>ResourceRemovedListener</em>回调给了<em>Engine</em>，在<em>Engine</em>中我们查看<em>onResourceRemoved</em>方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onResourceRemoved</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@NonNull</span> <span style="color:#66d9ef">final</span> Resource<span style="color:#f92672">&lt;?&gt;</span> resource<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Avoid deadlock with RequestManagers when recycling triggers recursive clear() calls.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// See b/145519760.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  resourceRecycler<span style="color:#f92672">.</span><span style="color:#a6e22e">recycle</span><span style="color:#f92672">(</span>resource<span style="color:#f92672">,</span> <span style="color:#75715e">/*forceNextFrame=*/</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>我们可以看到，这里同样是通过resourceRecycler进行了回收。在这里，则是交给resource自己的recycle()方法来处理，比如，<em>BitmapResource</em>是交给了<em>BitmapPool</em>进行处理。</p>
<h3 id="bitmappool">BitmapPool</h3>
<p>这里是专门用来存放被回收的Bitmap的，其中<strong>BitmapDrawableResource</strong>、<strong>BitmapResource</strong>都持有一个<strong>BitmapPool</strong>变量，在执行recycle()方法时候，调用*BitmapPool#put()*方法。我们来看一下这个BitmapPool的默认实现类<strong>LruBitmapPool</strong>的方法实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>Bitmap bitmap<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>bitmap <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Bitmap must not be null&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>bitmap<span style="color:#f92672">.</span><span style="color:#a6e22e">isRecycled</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Cannot pool recycled bitmap&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>bitmap<span style="color:#f92672">.</span><span style="color:#a6e22e">isMutable</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">||</span> strategy<span style="color:#f92672">.</span><span style="color:#a6e22e">getSize</span><span style="color:#f92672">(</span>bitmap<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> maxSize
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>allowedConfigs<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>bitmap<span style="color:#f92672">.</span><span style="color:#a6e22e">getConfig</span><span style="color:#f92672">()))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Log<span style="color:#f92672">.</span><span style="color:#a6e22e">isLoggable</span><span style="color:#f92672">(</span>TAG<span style="color:#f92672">,</span> Log<span style="color:#f92672">.</span><span style="color:#a6e22e">VERBOSE</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      Log<span style="color:#f92672">.</span><span style="color:#a6e22e">v</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>        TAG<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;Reject bitmap from pool&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, bitmap: &#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">+</span> strategy<span style="color:#f92672">.</span><span style="color:#a6e22e">logBitmap</span><span style="color:#f92672">(</span>bitmap<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, is mutable: &#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">+</span> bitmap<span style="color:#f92672">.</span><span style="color:#a6e22e">isMutable</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, is allowed config: &#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">+</span> allowedConfigs<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>bitmap<span style="color:#f92672">.</span><span style="color:#a6e22e">getConfig</span><span style="color:#f92672">()));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    bitmap<span style="color:#f92672">.</span><span style="color:#a6e22e">recycle</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> strategy<span style="color:#f92672">.</span><span style="color:#a6e22e">getSize</span><span style="color:#f92672">(</span>bitmap<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  strategy<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>bitmap<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  tracker<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>bitmap<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>这里我们可以看出，当Bitmap在三种情况下是不会被BitmapPool缓存起来的：</p>
<ol>
<li>这个bitmap是非mutable的，也就是说是不允许被复用的；</li>
<li>这一个bitmap的字节数大小已经超过了可以容纳的总大小；</li>
<li>BitmapPool中不允许的Config类型。</li>
</ol>
<p>在这种情况，bitmap就被直接recycle掉，而不是放入缓存等待下次使用。</p>
<p>如果不满足这三种情况，则会被strategy缓存起来，等待下次使用。</p>
<p>我们再看LruBitmapPool#get()方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@NonNull</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> Bitmap <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> width<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> height<span style="color:#f92672">,</span> Bitmap<span style="color:#f92672">.</span><span style="color:#a6e22e">Config</span> config<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  Bitmap result <span style="color:#f92672">=</span> getDirtyOrNull<span style="color:#f92672">(</span>width<span style="color:#f92672">,</span> height<span style="color:#f92672">,</span> config<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>result <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    result<span style="color:#f92672">.</span><span style="color:#a6e22e">eraseColor</span><span style="color:#f92672">(</span>Color<span style="color:#f92672">.</span><span style="color:#a6e22e">TRANSPARENT</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> createBitmap<span style="color:#f92672">(</span>width<span style="color:#f92672">,</span> height<span style="color:#f92672">,</span> config<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>我们可以看到，当能够查询到符合条件的Bitmap的时候，会先通过eraseColor方法，将其变成透明图片，然后再交给调用者来使用；如果查询不到，则创建一个新图交给调用者来使用。</p>
<blockquote>
<p>LruBitmapPool的LruPoolStrategy变量，在KITKAT以及以上，是SizeConfigStrategy，在以下是AttributeStrategy，这是因为在KITKAT版本以下，Bitmap的复用需要尺寸的严格匹配，但是KITKAT及以上没有这个问题，只要被复用的图片尺寸比目标尺寸大就可以。</p>
</blockquote>
<h3 id="arraypool">ArrayPool</h3>
<p>ArrayPool主要用在<strong>ThumbnailStreamOpener</strong>和<strong>ByteBufferGifDecoder</strong>中，具体的实现类为<strong>LruArrayPool</strong>。</p>
<p>在LruArrayPool中，通过groupedMap来缓存数据，而缓存数据的byte字节数是通过<strong>ArrayAdapterInterface</strong>来计算的，ArrayAdapterInterface是一个接口，实现类有两个：<strong>IntegerArrayAdapter</strong>和<strong>ByteArrayAdapter</strong>，分别对应缓存int[].class和byte[].class。</p>
<p>StreamGifDecoder和StreamBitmapDecoder都有一个ArrayPool成员。解码过程中需要用到byte[]，但不是直接new byte[]，而是调用<code>ArrayPool.get()</code>从对象池中拿，用完了归还。</p>
<h2 id="diskcache">DiskCache</h2>
<p>在上一章<a href="%7B%7Bsite.base_url%7D%7D/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B02.md">Glide源码分析与自我实现(一)——数据加载主流程</a>中，提到过数据加载的主流程，其中一个非常重要的类是 <strong>DecodeJob</strong>，在这个类的<code>getNextGenerator</code>方法中，返回的<strong>SourceGenerator</strong>会用来加载远程数据，但是这个方法不止返回这一个<strong>DataFetcherGenerator</strong>类，这是一个通过条件判断，返回不同DataFetcherGenerator类的方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> DataFetcherGenerator <span style="color:#a6e22e">getNextGenerator</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> <span style="color:#f92672">(</span>stage<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> RESOURCE_CACHE<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ResourceCacheGenerator<span style="color:#f92672">(</span>decodeHelper<span style="color:#f92672">,</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> DATA_CACHE<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> DataCacheGenerator<span style="color:#f92672">(</span>decodeHelper<span style="color:#f92672">,</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> SOURCE<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> SourceGenerator<span style="color:#f92672">(</span>decodeHelper<span style="color:#f92672">,</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> FINISHED<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalStateException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Unrecognized stage: &#34;</span> <span style="color:#f92672">+</span> stage<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>实际上，这是依次递进的<strong>有限状态机</strong>设计模式，当一个获取数据请求到来时候，此时是默认状态INITIALIZE，然后通过<code>getNextStage</code>方法判断下一个状态是什么，再按照新的状态获取DataFetcherGenerator，然后随着任务的执行，不断改变状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Stage <span style="color:#a6e22e">getNextStage</span><span style="color:#f92672">(</span>Stage current<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> <span style="color:#f92672">(</span>current<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> INITIALIZE<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> diskCacheStrategy<span style="color:#f92672">.</span><span style="color:#a6e22e">decodeCachedResource</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">?</span> Stage<span style="color:#f92672">.</span><span style="color:#a6e22e">RESOURCE_CACHE</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> getNextStage<span style="color:#f92672">(</span>Stage<span style="color:#f92672">.</span><span style="color:#a6e22e">RESOURCE_CACHE</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> RESOURCE_CACHE<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> diskCacheStrategy<span style="color:#f92672">.</span><span style="color:#a6e22e">decodeCachedData</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">?</span> Stage<span style="color:#f92672">.</span><span style="color:#a6e22e">DATA_CACHE</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> getNextStage<span style="color:#f92672">(</span>Stage<span style="color:#f92672">.</span><span style="color:#a6e22e">DATA_CACHE</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> DATA_CACHE<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Skip loading from source if the user opted to only retrieve the resource from cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> onlyRetrieveFromCache <span style="color:#f92672">?</span> Stage<span style="color:#f92672">.</span><span style="color:#a6e22e">FINISHED</span> <span style="color:#f92672">:</span> Stage<span style="color:#f92672">.</span><span style="color:#a6e22e">SOURCE</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> SOURCE<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> FINISHED<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> Stage<span style="color:#f92672">.</span><span style="color:#a6e22e">FINISHED</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Unrecognized stage: &#34;</span> <span style="color:#f92672">+</span> current<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>其状态变更顺序为INITIALIZE -&gt; RESOURCE_CACHE -&gt; DATA_CACHE -&gt; SOURCE，代表着ResourceCacheGenerator、DataCacheGenerator和SourceGenerator，当从ResourceCahce中拿不到数据，则向DataCacheGenerator请求数据，如果还是拿不到，则通过SourceGenerator去请求数据了。</p>
<p>在这个过程中，SourceGenerator向DiskCache中写入数据，ResourceCacheGenerator和DataCacheGenerator从DiskCache中读取数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResourceCacheGenerator</span> <span style="color:#66d9ef">implements</span> DataFetcherGenerator<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">startNext</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>      currentKey <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ResourceCacheKey<span style="color:#f92672">(</span>sourceId<span style="color:#f92672">,</span> helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getSignature</span><span style="color:#f92672">(),</span> helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getWidth</span><span style="color:#f92672">(),</span>
</span></span><span style="display:flex;"><span>          helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getHeight</span><span style="color:#f92672">(),</span> transformation<span style="color:#f92672">,</span> resourceClass<span style="color:#f92672">,</span> helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getOptions</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>      cacheFile <span style="color:#f92672">=</span> helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getDiskCache</span><span style="color:#f92672">().</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>currentKey<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cacheFile <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">sourceKey</span> <span style="color:#f92672">=</span> sourceId<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        modelLoaders <span style="color:#f92672">=</span> helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getModelLoaders</span><span style="color:#f92672">(</span>cacheFile<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        modelLoaderIndex <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DataCacheGenerator</span> <span style="color:#66d9ef">implements</span> DataFetcherGenerator<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">startNext</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>modelLoaders <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>hasNextModelLoader<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>      Key sourceId <span style="color:#f92672">=</span> cacheKeys<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>sourceIdIndex<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      Key originalKey <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DataCacheKey<span style="color:#f92672">(</span>sourceId<span style="color:#f92672">,</span> helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getSignature</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>      cacheFile <span style="color:#f92672">=</span> helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getDiskCache</span><span style="color:#f92672">().</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>originalKey<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cacheFile <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">sourceKey</span> <span style="color:#f92672">=</span> sourceId<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        modelLoaders <span style="color:#f92672">=</span> helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getModelLoaders</span><span style="color:#f92672">(</span>cacheFile<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        modelLoaderIndex <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SourceGenerator</span> <span style="color:#66d9ef">implements</span> DataFetcherGenerator <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">startNext</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>dataToCache <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      Object data <span style="color:#f92672">=</span> dataToCache<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      dataToCache <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      cacheData<span style="color:#f92672">(</span>data<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cacheData</span><span style="color:#f92672">(</span>Object dataToCache<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> startTime <span style="color:#f92672">=</span> LogTime<span style="color:#f92672">.</span><span style="color:#a6e22e">getLogTime</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      Encoder<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> encoder <span style="color:#f92672">=</span> helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getSourceEncoder</span><span style="color:#f92672">(</span>dataToCache<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      DataCacheWriter<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> writer <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">new</span> DataCacheWriter<span style="color:#f92672">&lt;&gt;(</span>encoder<span style="color:#f92672">,</span> dataToCache<span style="color:#f92672">,</span> helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getOptions</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>      originalKey <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DataCacheKey<span style="color:#f92672">(</span>loadData<span style="color:#f92672">.</span><span style="color:#a6e22e">sourceKey</span><span style="color:#f92672">,</span> helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getSignature</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>      helper<span style="color:#f92672">.</span><span style="color:#a6e22e">getDiskCache</span><span style="color:#f92672">().</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>originalKey<span style="color:#f92672">,</span> writer<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      loadData<span style="color:#f92672">.</span><span style="color:#a6e22e">fetcher</span><span style="color:#f92672">.</span><span style="color:#a6e22e">cleanup</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sourceCacheGenerator <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> DataCacheGenerator<span style="color:#f92672">(</span>Collections<span style="color:#f92672">.</span><span style="color:#a6e22e">singletonList</span><span style="color:#f92672">(</span>loadData<span style="color:#f92672">.</span><span style="color:#a6e22e">sourceKey</span><span style="color:#f92672">),</span> helper<span style="color:#f92672">,</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>DiskCache的默认实现类是<strong>DiskLruCacheWrapper</strong>，其内部通过<strong>DiskLruCache</strong>来管理磁盘缓存。</p>
<h2 id="总结">总结</h2>
<p>到现在，Glide主要部分已经分析的差不多了，实际上这个优秀的框架可挖的地方还有很多，比如通过<a href="%7B%7Bsite.base_url%7D%7D/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B03.md">APT来实现很好的扩展</a>，框架中涉及多种涉及模式等。</p>
<blockquote>
<p>其中涉及到的涉及模式，比如无处不在的<strong>构建者模式</strong>和<strong>工厂模式</strong>，DecodeJob中的<strong>有限状态机模式</strong>，还有BitmapPool和ArrayPool中的<strong>享元模式</strong>，DiskLruCacheWrapper中的<strong>代理模式</strong>等。</p>
</blockquote>
<h2 id="参考文章">参考文章</h2>
<p><a href="https://www.sunmoonblog.com/2018/07/27/glide-cache/">Glide缓存分析</a></p>
</section>

  
  
  <footer class="mt-12 flex flex-wrap">
     
    <a
      class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]"
      href="https://boybeak.github.io/public/tags/untagged"
      >untagged</a
    >
    
  </footer>
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a class="flex w-1/2 items-center p-6 pr-3 no-underline" href="https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B03/"
      ><span class="mr-1.5">←</span><span>Glide源码分析与自我实现(三)——数据加载主流程</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline"
      href="https://boybeak.github.io/public/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/jetpack%E4%B9%8Blifecycle%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
      ><span>Jetpack之Lifecycle源码分析</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
  <div id="disqus_thread"></div>
  <script>
    const disqusShortname = 'YOUR_DISQUS_SHORTNAME';
    const script = document.createElement('script');
    script.src = 'https://' + disqusShortname + '.disqus.com/embed.js';
    script.setAttribute('data-timestamp', +new Date());
    document.head.appendChild(script);
  </script>
  
</article>


    </main>

    <footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60">
  <div class="mr-auto">
    &copy; 2022
    <a class="link" href="https://boybeak.github.io/public">My New Hugo Site</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank">Powered by Hugo️️</a
  >️
  <a class="link" href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank"
    >▷ Paper 6</a
  >
</footer>

  </body>
</html>
