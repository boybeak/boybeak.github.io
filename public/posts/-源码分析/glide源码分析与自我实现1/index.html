<!DOCTYPE html>






































<html
  class="not-ready text-sm lg:text-base"
  style="--bg: #faf6f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>Glide源码分析与自我实现(一)——数据加载主流程 - My New Hugo Site</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="Glide源码分析与自我实现(一)——数据加载主流程 本文基于Glide 4.11.0
阅读前请参考Glide 源码分析解读-基于最新版Glide 4.9.0一文，该文章中，将Glide中各个部分的作用分析的非常好了。
Glide几乎是现在做Android图片加载的最佳选择了。如此优秀的一个框架是如何实现的呢？如果让我们自己来实现该怎么做呢？我们就通过自己实现一个低配版Glide的方式，来探究Glide中是如何实现的。
我们就称我们自己低配版Glide为Slide。那么Slide要实现哪些功能呢？简单来说，就是获取图片&#43;界面显示。我们通过先构架大体框架，再分步丰富其中细节的方式，来构建Slide的整体结构。
flowchart LR; A[获取图片] --&gt; C[Slide] --&gt; B[界面显示]; Glide.with(xxx).load(url).into(iv); 这是Glide一个典型的最为简单的调用过程。那么在这个过程中发生了哪些事情呢？
我们可以通过这个链式调用的返回值发现，有如下过程：
graph LR; style A fill:#aaffcc style D fill:#ffaa99 A(Glide) --&gt;|&#34;with(xxx)&#34;| B(RequestManager) --&gt;|&#34;load(xxx)&#34;| C(RequestBuilder) --&gt;|&#34;into(iv)&#34;| D(Target); Glide.with(xxx)发生了什么事？ 阅读源码发现，Glide.with(xxx)的最终实现类是RequestManagerRetriever.java类。继续跟踪，我们在这个类中，看到这样一个方法。
@NonNull private RequestManager supportFragmentGet( @NonNull Context context, @NonNull FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) { SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint); RequestManager requestManager = current.getRequestManager(); ..... return requestManager; } 重点关注这个getSupportRequestManagerFragment方法。
//getSupportRequestManagerFragment @NonNull private SupportRequestManagerFragment getSupportRequestManagerFragment( @NonNull final FragmentManager fm, @Nullable Fragment parentHint) { SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm." />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://boybeak.github.io/main.min.css" />

  

  
  
  
    
  
  <link
    rel="preload"
    as="image"
    href="https://boybeak.github.io/theme.png"
  />

  
  
  
  <link rel="preload" as="image" href="https://www.gravatar.com/avatar/6fd8df4abe41f17fd8e2dd7d97b5cc8c?s=160&amp;d=identicon" />
  
  

  
  <link rel="preload" as="image" href="https://boybeak.github.io/twitter.svg" />
  
  <link rel="preload" as="image" href="https://boybeak.github.io/github.svg" />
  
  <link rel="preload" as="image" href="https://boybeak.github.io/instagram.svg" />
  
  <link rel="preload" as="image" href="https://boybeak.github.io/rss.svg" />
  

  
  <link rel="icon" href="https://boybeak.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://boybeak.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.101.0" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="Glide源码分析与自我实现(一)——数据加载主流程" />
<meta property="og:description" content="Glide源码分析与自我实现(一)——数据加载主流程 本文基于Glide 4.11.0
阅读前请参考Glide 源码分析解读-基于最新版Glide 4.9.0一文，该文章中，将Glide中各个部分的作用分析的非常好了。
Glide几乎是现在做Android图片加载的最佳选择了。如此优秀的一个框架是如何实现的呢？如果让我们自己来实现该怎么做呢？我们就通过自己实现一个低配版Glide的方式，来探究Glide中是如何实现的。
我们就称我们自己低配版Glide为Slide。那么Slide要实现哪些功能呢？简单来说，就是获取图片&#43;界面显示。我们通过先构架大体框架，再分步丰富其中细节的方式，来构建Slide的整体结构。
flowchart LR; A[获取图片] --&gt; C[Slide] --&gt; B[界面显示]; Glide.with(xxx).load(url).into(iv); 这是Glide一个典型的最为简单的调用过程。那么在这个过程中发生了哪些事情呢？
我们可以通过这个链式调用的返回值发现，有如下过程：
graph LR; style A fill:#aaffcc style D fill:#ffaa99 A(Glide) --&gt;|&#34;with(xxx)&#34;| B(RequestManager) --&gt;|&#34;load(xxx)&#34;| C(RequestBuilder) --&gt;|&#34;into(iv)&#34;| D(Target); Glide.with(xxx)发生了什么事？ 阅读源码发现，Glide.with(xxx)的最终实现类是RequestManagerRetriever.java类。继续跟踪，我们在这个类中，看到这样一个方法。
@NonNull private RequestManager supportFragmentGet( @NonNull Context context, @NonNull FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) { SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint); RequestManager requestManager = current.getRequestManager(); ..... return requestManager; } 重点关注这个getSupportRequestManagerFragment方法。
//getSupportRequestManagerFragment @NonNull private SupportRequestManagerFragment getSupportRequestManagerFragment( @NonNull final FragmentManager fm, @Nullable Fragment parentHint) { SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://boybeak.github.io/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B01/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-03T21:06:01+08:00" />
<meta property="article:modified_time" content="2022-09-03T21:06:01+08:00" />


  
  <meta itemprop="name" content="Glide源码分析与自我实现(一)——数据加载主流程">
<meta itemprop="description" content="Glide源码分析与自我实现(一)——数据加载主流程 本文基于Glide 4.11.0
阅读前请参考Glide 源码分析解读-基于最新版Glide 4.9.0一文，该文章中，将Glide中各个部分的作用分析的非常好了。
Glide几乎是现在做Android图片加载的最佳选择了。如此优秀的一个框架是如何实现的呢？如果让我们自己来实现该怎么做呢？我们就通过自己实现一个低配版Glide的方式，来探究Glide中是如何实现的。
我们就称我们自己低配版Glide为Slide。那么Slide要实现哪些功能呢？简单来说，就是获取图片&#43;界面显示。我们通过先构架大体框架，再分步丰富其中细节的方式，来构建Slide的整体结构。
flowchart LR; A[获取图片] --&gt; C[Slide] --&gt; B[界面显示]; Glide.with(xxx).load(url).into(iv); 这是Glide一个典型的最为简单的调用过程。那么在这个过程中发生了哪些事情呢？
我们可以通过这个链式调用的返回值发现，有如下过程：
graph LR; style A fill:#aaffcc style D fill:#ffaa99 A(Glide) --&gt;|&#34;with(xxx)&#34;| B(RequestManager) --&gt;|&#34;load(xxx)&#34;| C(RequestBuilder) --&gt;|&#34;into(iv)&#34;| D(Target); Glide.with(xxx)发生了什么事？ 阅读源码发现，Glide.with(xxx)的最终实现类是RequestManagerRetriever.java类。继续跟踪，我们在这个类中，看到这样一个方法。
@NonNull private RequestManager supportFragmentGet( @NonNull Context context, @NonNull FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) { SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint); RequestManager requestManager = current.getRequestManager(); ..... return requestManager; } 重点关注这个getSupportRequestManagerFragment方法。
//getSupportRequestManagerFragment @NonNull private SupportRequestManagerFragment getSupportRequestManagerFragment( @NonNull final FragmentManager fm, @Nullable Fragment parentHint) { SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm."><meta itemprop="datePublished" content="2022-09-03T21:06:01+08:00" />
<meta itemprop="dateModified" content="2022-09-03T21:06:01+08:00" />
<meta itemprop="wordCount" content="782">
<meta itemprop="keywords" content="untagged," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Glide源码分析与自我实现(一)——数据加载主流程"/>
<meta name="twitter:description" content="Glide源码分析与自我实现(一)——数据加载主流程 本文基于Glide 4.11.0
阅读前请参考Glide 源码分析解读-基于最新版Glide 4.9.0一文，该文章中，将Glide中各个部分的作用分析的非常好了。
Glide几乎是现在做Android图片加载的最佳选择了。如此优秀的一个框架是如何实现的呢？如果让我们自己来实现该怎么做呢？我们就通过自己实现一个低配版Glide的方式，来探究Glide中是如何实现的。
我们就称我们自己低配版Glide为Slide。那么Slide要实现哪些功能呢？简单来说，就是获取图片&#43;界面显示。我们通过先构架大体框架，再分步丰富其中细节的方式，来构建Slide的整体结构。
flowchart LR; A[获取图片] --&gt; C[Slide] --&gt; B[界面显示]; Glide.with(xxx).load(url).into(iv); 这是Glide一个典型的最为简单的调用过程。那么在这个过程中发生了哪些事情呢？
我们可以通过这个链式调用的返回值发现，有如下过程：
graph LR; style A fill:#aaffcc style D fill:#ffaa99 A(Glide) --&gt;|&#34;with(xxx)&#34;| B(RequestManager) --&gt;|&#34;load(xxx)&#34;| C(RequestBuilder) --&gt;|&#34;into(iv)&#34;| D(Target); Glide.with(xxx)发生了什么事？ 阅读源码发现，Glide.with(xxx)的最终实现类是RequestManagerRetriever.java类。继续跟踪，我们在这个类中，看到这样一个方法。
@NonNull private RequestManager supportFragmentGet( @NonNull Context context, @NonNull FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) { SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint); RequestManager requestManager = current.getRequestManager(); ..... return requestManager; } 重点关注这个getSupportRequestManagerFragment方法。
//getSupportRequestManagerFragment @NonNull private SupportRequestManagerFragment getSupportRequestManagerFragment( @NonNull final FragmentManager fm, @Nullable Fragment parentHint) { SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm."/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold" href="https://boybeak.github.io/"
      >My New Hugo Site</a
    >
    <a
      class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
    ></a>
  </div>

  <a
    class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
  ></a>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = `"#faf6f1"`.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    const darkVal = localStorage.getItem('dark');
    setDark(darkVal ? darkVal === 'true' : darkScheme.matches);

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href=" https://twitter.com/YOUR_TWITTER_ID "
        target="_blank"
      ></a>
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href=" https://github.com/YOUR_GITHUB_ID "
        target="_blank"
      ></a>
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./instagram.svg)"
        href=" https://instagram.com/YOUR_INSTAGRAM_ID "
        target="_blank"
      ></a>
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href=" https://boybeak.github.io/index.xml "
        target="_blank"
      ></a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"
    >
      

<article>
  <header class="mb-20">
    <h1 class="!my-0 pb-2.5">Glide源码分析与自我实现(一)——数据加载主流程</h1>

    
    <div class="text-sm opacity-60">
      
      <time>Sep 3, 2022</time>
      
      
    </div>
    
  </header>

  <section><h1 id="glide源码分析与自我实现一数据加载主流程">Glide源码分析与自我实现(一)——数据加载主流程</h1>
<blockquote>
<p>本文基于Glide 4.11.0</p>
</blockquote>
<p>阅读前请参考<a href="https://zhuanlan.zhihu.com/p/60425157">Glide 源码分析解读-基于最新版Glide 4.9.0</a>一文，该文章中，将Glide中各个部分的作用分析的非常好了。</p>
<p>Glide几乎是现在做Android图片加载的最佳选择了。如此优秀的一个框架是如何实现的呢？如果让我们自己来实现该怎么做呢？我们就通过自己实现一个低配版Glide的方式，来探究Glide中是如何实现的。</p>
<p>我们就称我们自己低配版Glide为<strong>Slide</strong>。那么Slide要实现哪些功能呢？简单来说，就是<strong>获取图片</strong>+<strong>界面显示</strong>。我们通过先构架大体框架，再分步丰富其中细节的方式，来构建Slide的整体结构。</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">flowchart LR;
A[获取图片] --&gt; C[Slide] --&gt; B[界面显示];
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Glide<span style="color:#f92672">.</span><span style="color:#a6e22e">with</span><span style="color:#f92672">(</span>xxx<span style="color:#f92672">).</span><span style="color:#a6e22e">load</span><span style="color:#f92672">(</span>url<span style="color:#f92672">).</span><span style="color:#a6e22e">into</span><span style="color:#f92672">(</span>iv<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>这是Glide一个典型的最为简单的调用过程。那么在这个过程中发生了哪些事情呢？</p>
<p>我们可以通过这个链式调用的返回值发现，有如下过程：</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR;
style A fill:#aaffcc
style D fill:#ffaa99
A(Glide) --&gt;|&#34;with(xxx)&#34;| B(RequestManager) --&gt;|&#34;load(xxx)&#34;| C(RequestBuilder) --&gt;|&#34;into(iv)&#34;| D(Target);
</code></pre><h2 id="glidewithxxx发生了什么事">Glide.with(xxx)发生了什么事？</h2>
<p>阅读源码发现，<code>Glide.with(xxx)</code>的最终实现类是<em>RequestManagerRetriever.java</em>类。继续跟踪，我们在这个类中，看到这样一个方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@NonNull</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> RequestManager <span style="color:#a6e22e">supportFragmentGet</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@NonNull</span> Context context<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@NonNull</span> FragmentManager fm<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Nullable</span> Fragment parentHint<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">boolean</span> isParentVisible<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  SupportRequestManagerFragment current <span style="color:#f92672">=</span> getSupportRequestManagerFragment<span style="color:#f92672">(</span>fm<span style="color:#f92672">,</span> parentHint<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  RequestManager requestManager <span style="color:#f92672">=</span> current<span style="color:#f92672">.</span><span style="color:#a6e22e">getRequestManager</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">.....</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> requestManager<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>重点关注这个getSupportRequestManagerFragment方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//getSupportRequestManagerFragment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">@NonNull</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> SupportRequestManagerFragment <span style="color:#a6e22e">getSupportRequestManagerFragment</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@NonNull</span> <span style="color:#66d9ef">final</span> FragmentManager fm<span style="color:#f92672">,</span> <span style="color:#a6e22e">@Nullable</span> Fragment parentHint<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  SupportRequestManagerFragment current <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">(</span>SupportRequestManagerFragment<span style="color:#f92672">)</span> fm<span style="color:#f92672">.</span><span style="color:#a6e22e">findFragmentByTag</span><span style="color:#f92672">(</span>FRAGMENT_TAG<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    current <span style="color:#f92672">=</span> pendingSupportRequestManagerFragments<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>fm<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      current <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SupportRequestManagerFragment<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>      current<span style="color:#f92672">.</span><span style="color:#a6e22e">setParentFragmentHint</span><span style="color:#f92672">(</span>parentHint<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      pendingSupportRequestManagerFragments<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>fm<span style="color:#f92672">,</span> current<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      fm<span style="color:#f92672">.</span><span style="color:#a6e22e">beginTransaction</span><span style="color:#f92672">().</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>current<span style="color:#f92672">,</span> FRAGMENT_TAG<span style="color:#f92672">).</span><span style="color:#a6e22e">commitAllowingStateLoss</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>      handler<span style="color:#f92672">.</span><span style="color:#a6e22e">obtainMessage</span><span style="color:#f92672">(</span>ID_REMOVE_SUPPORT_FRAGMENT_MANAGER<span style="color:#f92672">,</span> fm<span style="color:#f92672">).</span><span style="color:#a6e22e">sendToTarget</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> current<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>其实，这里是一个Glide检测到界面生命周期的关键了。<strong>Glide就是通过像当前Activity添加一个一个无UI的Fragment来探测生命周期的</strong>。</p>
<blockquote>
<p>**注意：**在执行了添加fragment的语句<code>fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss()</code>后，又马上通过handler发送了一个一个message，这里需要熟悉Handler机制才能理解，简单来说，就是添加fragment操作，实际上也是通过handler执行的，这是一个异步的过程，如何检测到fragment已经添加完成了呢？就是在<code>commitAllowingStateLoss</code>后，马上去发送一条指定的消息，利用handler处理message的顺序性，来获知fragment已经添加完成。</p>
</blockquote>
<p>经过添加<em>SupportRequestManagerFragment</em>后，我们获得了探测当前界面生命周期的能力。</p>
<p>继续阅读<code>supportFragmentGet</code>方法代码，<strong>RequestManager</strong>是从<strong>SupportRequestManagerFragment</strong>拿到的，如果拿到的是空，则创建一个，设置到该fragment当中去。</p>
<h2 id="requestmanagerloadxxx发生了什么">RequestManager.load(xxx)发生了什么？</h2>
<p>我们以<code>load(url)</code>为例，来探究这部分代码。</p>
<p>这个方法，返回的是<em>RequestBuilder</em>这个类，看名字就知道，这是一个构建者模式中的Builder类，主要是在添加各种配置项，比如RequestOptions、RequestListener等。</p>
<h2 id="requestbuilderintoiv发生了什么">RequestBuilder.into(iv)发生了什么？</h2>
<p>其实，这里才是真正开始触发发起请求的地方。</p>
<h3 id="requestbuilder">RequestBuilder</h3>
<p>我们把<code>into(ImageView)</code>方法作为入口，一路跟踪，可以发现最终的实现是如下方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#f92672">&lt;</span>Y <span style="color:#66d9ef">extends</span> Target<span style="color:#f92672">&lt;</span>TranscodeType<span style="color:#f92672">&gt;&gt;</span> Y <span style="color:#a6e22e">into</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@NonNull</span> Y target<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">@Nullable</span> RequestListener<span style="color:#f92672">&lt;</span>TranscodeType<span style="color:#f92672">&gt;</span> targetListener<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>  BaseRequestOptions<span style="color:#f92672">&lt;?&gt;</span> options<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>  Executor callbackExecutor<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  Preconditions<span style="color:#f92672">.</span><span style="color:#a6e22e">checkNotNull</span><span style="color:#f92672">(</span>target<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>isModelSet<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;You must call #load() before calling #into()&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Request request <span style="color:#f92672">=</span> buildRequest<span style="color:#f92672">(</span>target<span style="color:#f92672">,</span> targetListener<span style="color:#f92672">,</span> options<span style="color:#f92672">,</span> callbackExecutor<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Request previous <span style="color:#f92672">=</span> target<span style="color:#f92672">.</span><span style="color:#a6e22e">getRequest</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>request<span style="color:#f92672">.</span><span style="color:#a6e22e">isEquivalentTo</span><span style="color:#f92672">(</span>previous<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isSkipMemoryCacheWithCompletePreviousRequest<span style="color:#f92672">(</span>options<span style="color:#f92672">,</span> previous<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If the request is completed, beginning again will ensure the result is re-delivered,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// triggering RequestListeners and Targets. If the request is failed, beginning again will
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// restart the request, giving it another chance to complete. If the request is already
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// running, we can let it continue running without interruption.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>Preconditions<span style="color:#f92672">.</span><span style="color:#a6e22e">checkNotNull</span><span style="color:#f92672">(</span>previous<span style="color:#f92672">).</span><span style="color:#a6e22e">isRunning</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Use the previous request rather than the new one to allow for optimizations like skipping
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// that are done in the individual Request.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      previous<span style="color:#f92672">.</span><span style="color:#a6e22e">begin</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> target<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  requestManager<span style="color:#f92672">.</span><span style="color:#a6e22e">clear</span><span style="color:#f92672">(</span>target<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  target<span style="color:#f92672">.</span><span style="color:#a6e22e">setRequest</span><span style="color:#f92672">(</span>request<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  requestManager<span style="color:#f92672">.</span><span style="color:#a6e22e">track</span><span style="color:#f92672">(</span>target<span style="color:#f92672">,</span> request<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> target<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>这个方法主要是做了以下事情：</p>
<ol>
<li>是否已经有一个request在处理相同的请求，如果有，则判断是否正在运行，没有正在运行则开始运行；</li>
<li>如果没有一个request在处理此请求，则对target做一些清理操作，与之前的请求解绑，为当前target设置新的请求，然后requestManager开始追踪这个请求。</li>
</ol>
<p>接下来我们就按照<code>requestManager.track(target, request)</code>这段代码继续追踪。来到RequestManager的track方法。</p>
<h3 id="requestmanager">RequestManager</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">track</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@NonNull</span> Target<span style="color:#f92672">&lt;?&gt;</span> target<span style="color:#f92672">,</span> <span style="color:#a6e22e">@NonNull</span> Request request<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  targetTracker<span style="color:#f92672">.</span><span style="color:#a6e22e">track</span><span style="color:#f92672">(</span>target<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  requestTracker<span style="color:#f92672">.</span><span style="color:#a6e22e">runRequest</span><span style="color:#f92672">(</span>request<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>这个方法很简单，只有两个方法。</p>
<h4 id="targettracker">TargetTracker</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Set<span style="color:#f92672">&lt;</span>Target<span style="color:#f92672">&lt;?&gt;&gt;</span> targets <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      Collections<span style="color:#f92672">.</span><span style="color:#a6e22e">newSetFromMap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> WeakHashMap<span style="color:#f92672">&lt;</span>Target<span style="color:#f92672">&lt;?&gt;,</span> Boolean<span style="color:#f92672">&gt;());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">track</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@NonNull</span> Target<span style="color:#f92672">&lt;?&gt;</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  targets<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>target<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>这里把一个target存放在WeakHashMap中，因为target是与生命周期有关的东西，比如ImageView对应的<strong>ImageViewTarget</strong>，所以这么做是为了防止内存泄漏。</p>
<h4 id="requesttracker">RequestTracker</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/** Starts tracking the given request. */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">runRequest</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@NonNull</span> Request request<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  requests<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>request<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>isPaused<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    request<span style="color:#f92672">.</span><span style="color:#a6e22e">begin</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    request<span style="color:#f92672">.</span><span style="color:#a6e22e">clear</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Log<span style="color:#f92672">.</span><span style="color:#a6e22e">isLoggable</span><span style="color:#f92672">(</span>TAG<span style="color:#f92672">,</span> Log<span style="color:#f92672">.</span><span style="color:#a6e22e">VERBOSE</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      Log<span style="color:#f92672">.</span><span style="color:#a6e22e">v</span><span style="color:#f92672">(</span>TAG<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Paused, delaying request&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    pendingRequests<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>request<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>这里是将暂停的request加入到pendingRequests中去，如果不是暂停的request，则调用其begin方法。</p>
<p>我们查看<em>Request</em>类的子类，可以看到下图。</p>
<p><img src="%7B%7Bsite.base_url%7D%7D/assets/images/request_implementions.jpg" alt="request_implementions"></p>
<p>可以看到一共有4个类实现了<em>Request</em>类，其中<em>FakeRequest</em>类是用于测试的，不去考虑。其他三个类的作用如下：</p>
<ol>
<li><strong>ThumbnailRequestCoordinator:</strong> 用来加载thumbnail；</li>
<li><strong>ErrorRequestCoordinator:</strong> 用来加载错误时候，展示错误状态；</li>
<li><strong>SingleRequest:</strong> 这才是用来加载目标图片的request。</li>
</ol>
<p>我们重点去看SingleRequest的begin方法。</p>
<h3 id="singlerequest">SingleRequest</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">begin</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>requestLock<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    assertNotCallingCallbacks<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    stateVerifier<span style="color:#f92672">.</span><span style="color:#a6e22e">throwIfRecycled</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    startTime <span style="color:#f92672">=</span> LogTime<span style="color:#f92672">.</span><span style="color:#a6e22e">getLogTime</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>model <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Util<span style="color:#f92672">.</span><span style="color:#a6e22e">isValidDimensions</span><span style="color:#f92672">(</span>overrideWidth<span style="color:#f92672">,</span> overrideHeight<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        width <span style="color:#f92672">=</span> overrideWidth<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        height <span style="color:#f92672">=</span> overrideHeight<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Only log at more verbose log levels if the user has set a fallback drawable, because
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// fallback Drawables indicate the user expects null models occasionally.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">int</span> logLevel <span style="color:#f92672">=</span> getFallbackDrawable<span style="color:#f92672">()</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">?</span> Log<span style="color:#f92672">.</span><span style="color:#a6e22e">WARN</span> <span style="color:#f92672">:</span> Log<span style="color:#f92672">.</span><span style="color:#a6e22e">DEBUG</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      onLoadFailed<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> GlideException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Received null model&#34;</span><span style="color:#f92672">),</span> logLevel<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>status <span style="color:#f92672">==</span> Status<span style="color:#f92672">.</span><span style="color:#a6e22e">RUNNING</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Cannot restart a running request&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If we&#39;re restarted after we&#39;re complete (usually via something like a notifyDataSetChanged
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// that starts an identical request into the same Target or View), we can simply use the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// resource and size we retrieved the last time around and skip obtaining a new size, starting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// a new load etc. This does mean that users who want to restart a load because they expect
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// that the view size has changed will need to explicitly clear the View or Target before
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// starting the new load.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>status <span style="color:#f92672">==</span> Status<span style="color:#f92672">.</span><span style="color:#a6e22e">COMPLETE</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      onResourceReady<span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>        resource<span style="color:#f92672">,</span> DataSource<span style="color:#f92672">.</span><span style="color:#a6e22e">MEMORY_CACHE</span><span style="color:#f92672">,</span> <span style="color:#75715e">/* isLoadedFromAlternateCacheKey= */</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Restarts for requests that are neither complete nor running can be treated as new requests
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// and can run again from the beginning.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">=</span> Status<span style="color:#f92672">.</span><span style="color:#a6e22e">WAITING_FOR_SIZE</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Util<span style="color:#f92672">.</span><span style="color:#a6e22e">isValidDimensions</span><span style="color:#f92672">(</span>overrideWidth<span style="color:#f92672">,</span> overrideHeight<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      onSizeReady<span style="color:#f92672">(</span>overrideWidth<span style="color:#f92672">,</span> overrideHeight<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      target<span style="color:#f92672">.</span><span style="color:#a6e22e">getSize</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>status <span style="color:#f92672">==</span> Status<span style="color:#f92672">.</span><span style="color:#a6e22e">RUNNING</span> <span style="color:#f92672">||</span> status <span style="color:#f92672">==</span> Status<span style="color:#f92672">.</span><span style="color:#a6e22e">WAITING_FOR_SIZE</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;&amp;</span> canNotifyStatusChanged<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      target<span style="color:#f92672">.</span><span style="color:#a6e22e">onLoadStarted</span><span style="color:#f92672">(</span>getPlaceholderDrawable<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>IS_VERBOSE_LOGGABLE<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      logV<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;finished run method in &#34;</span> <span style="color:#f92672">+</span> LogTime<span style="color:#f92672">.</span><span style="color:#a6e22e">getElapsedMillis</span><span style="color:#f92672">(</span>startTime<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>代码虽长，但是结构简单。主要做了以下事情：</p>
<ol>
<li>检查model是否是空，model就是要加载的数据来源，比如url、resourceId、File等；</li>
<li>判断request状态，不能重新开始一个正在运行的请求；</li>
<li>判断request状态，如果是已经完成的请求，则说明资源已经存在，直接调用<code>onResourceReady</code>方法并返回；</li>
<li>接下来就来到判断target尺寸的过程了，如果target尺寸已经确定，比如view尺寸measure结束后，则调用<code>onSizeReady</code>方法，<strong>注意：实际的网络请求就在这个onSizeReady方法中，因为只有target的尺寸确定了，才能进行请求并处理图片；</strong></li>
<li>如果尺寸未确定，则调用<code>target.getSize</code>方法去监听尺寸事件，具体可以参考<code>ViewTarget#getSize</code>方法，这是一个通过onPreDrawListener来监听尺寸的；</li>
<li>接下来回调<code>onLoadStarted</code>方法，并且显示加载过程状态。</li>
</ol>
<p>我们着重看网络请求那个分支，也就是<code>onSizeReady</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onSizeReady</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> width<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> height<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span>	loadStatus <span style="color:#f92672">=</span> engine<span style="color:#f92672">.</span><span style="color:#a6e22e">load</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>    glideContext<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>    model<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>    requestOptions<span style="color:#f92672">.</span><span style="color:#a6e22e">getSignature</span><span style="color:#f92672">(),</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">width</span><span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">height</span><span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>    requestOptions<span style="color:#f92672">.</span><span style="color:#a6e22e">getResourceClass</span><span style="color:#f92672">(),</span>
</span></span><span style="display:flex;"><span>    transcodeClass<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>    priority<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>    requestOptions<span style="color:#f92672">.</span><span style="color:#a6e22e">getDiskCacheStrategy</span><span style="color:#f92672">(),</span>
</span></span><span style="display:flex;"><span>    requestOptions<span style="color:#f92672">.</span><span style="color:#a6e22e">getTransformations</span><span style="color:#f92672">(),</span>
</span></span><span style="display:flex;"><span>    requestOptions<span style="color:#f92672">.</span><span style="color:#a6e22e">isTransformationRequired</span><span style="color:#f92672">(),</span>
</span></span><span style="display:flex;"><span>    requestOptions<span style="color:#f92672">.</span><span style="color:#a6e22e">isScaleOnlyOrNoTransform</span><span style="color:#f92672">(),</span>
</span></span><span style="display:flex;"><span>    requestOptions<span style="color:#f92672">.</span><span style="color:#a6e22e">getOptions</span><span style="color:#f92672">(),</span>
</span></span><span style="display:flex;"><span>    requestOptions<span style="color:#f92672">.</span><span style="color:#a6e22e">isMemoryCacheable</span><span style="color:#f92672">(),</span>
</span></span><span style="display:flex;"><span>    requestOptions<span style="color:#f92672">.</span><span style="color:#a6e22e">getUseUnlimitedSourceGeneratorsPool</span><span style="color:#f92672">(),</span>
</span></span><span style="display:flex;"><span>    requestOptions<span style="color:#f92672">.</span><span style="color:#a6e22e">getUseAnimationPool</span><span style="color:#f92672">(),</span>
</span></span><span style="display:flex;"><span>    requestOptions<span style="color:#f92672">.</span><span style="color:#a6e22e">getOnlyRetrieveFromCache</span><span style="color:#f92672">(),</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>    callbackExecutor
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>关键代码来了！这个<code>engine</code>就是Glide的核心。这个engine是在Glide初始化时候生成的一个实例。</p>
<h3 id="engine">Engine</h3>
<p>Engine不只是用于加载图片，而是一个任务执行核心引擎，它要执行的不只是请求远程图片的任务，包括解码任务等，它执行的实际上是一个个的job。</p>
<p>跟踪上一阶段中的<code>engine.load</code>方法，来到是这个方法的关键部分——调用<code>waitForExistingOrStartNewJob</code>。</p>
<p>在这个方法中，主要做了以下事情：</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph TD;
A{{是否有一个job执行相同操作}} --&gt; |有|B[为此job添加新的回调];
A --&gt; |无|C[添加并执行一个EngineJob];
</code></pre><h4 id="enginejobstartdecodejob">EngineJob.start(decodeJob)</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">start</span><span style="color:#f92672">(</span>DecodeJob<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> decodeJob<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">decodeJob</span> <span style="color:#f92672">=</span> decodeJob<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  GlideExecutor executor <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    decodeJob<span style="color:#f92672">.</span><span style="color:#a6e22e">willDecodeFromCache</span><span style="color:#f92672">()</span> <span style="color:#f92672">?</span> diskCacheExecutor <span style="color:#f92672">:</span> getActiveSourceExecutor<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>  executor<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span>decodeJob<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>这里执行的是decodeJob。</p>
<blockquote>
<p>这里需要着重关注一点，就是<code>executor.execute(decodeJob)</code>的时候，就已经通过<em>GlideExecutor</em>的sourceExecutor.Builder创建了一个<strong>ThreadPoolExecutor</strong>，也就是在这里实现线程池异步执行任务。<strong>ThreadPoolExecutor</strong>并不是Glide提供的实现，而是在java.util.concurrent包下。</p>
</blockquote>
<h4 id="decodejob">DecodeJob</h4>
<p>DecodeJob是一个<em>Runnable</em>类，所以，我们查看其run方法。</p>
<p>接下来的调用路径参考下图。</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph TD;
subgraph DecodeJob;
A(run) --&gt; B[runWrapped] --&gt; C[runGenerators] --&gt; D[getNextGenerator];
end;
subgraph SourceGenerator
D --&gt; E[startNext] --&gt; F[startNextLoad];
end;
subgraph HttpUrlFetcher
F --&gt; G[loadData] --&gt; H[loadDataWithRedirects];
end;
</code></pre><p>经过这么长的调用链，我们终于来到了网络请求的部分，我们可以看到Glide原生使用的<em>HttpURLConnection</em>进行网络请求的。<strong>获取到InputStream后，在SourceGenerator中的cacheData方法进行缓存处理。</strong></p>
<h4 id="获取到数据后的处理">获取到数据后的处理</h4>
<p>通过<code>DataFetcherGenerator.FetcherReadyCallback</code>可以探知到数据获取成功或者失败，如果获取成功，则在<code>DecodeJob#onDataFetcherReady</code>中处理。关键代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onDataFetcherReady</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>      Key sourceKey<span style="color:#f92672">,</span> Object data<span style="color:#f92672">,</span> DataFetcher<span style="color:#f92672">&lt;?&gt;</span> fetcher<span style="color:#f92672">,</span> DataSource dataSource<span style="color:#f92672">,</span> Key attemptedKey<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">.....</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> currentThread<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    runReason <span style="color:#f92672">=</span> RunReason<span style="color:#f92672">.</span><span style="color:#a6e22e">DECODE_DATA</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    callback<span style="color:#f92672">.</span><span style="color:#a6e22e">reschedule</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.....</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>更改任务状态，重新执行此任务，则重新执行到<code>getNextGenerator</code>方法，此时则会返回<strong>DataCacheGenerator</strong>来处理从Disk缓存加载的任务。</p>
<h2 id="获取图片">获取图片</h2>
<p>首先，图片来源有哪些？</p>
<ol>
<li>资源图片：drawable, assets, raw, mipmap这些程序中自带的图片；</li>
<li>本地图片：本地存储设备上的图片；</li>
<li>远端图片：我们服务器或者来自第三方服务器的图片，通过URL来获取。这就需要<strong>异步网络请求</strong>，请求结束以后，要<strong>缓存</strong>图片，避免重复请求远端图片，造成时间、网络的浪费。</li>
</ol>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR;
A[Slide];
B([1. 资源图片]) --&gt; A;
C([2. 本地图片]) --&gt; A;
E{缓存是否存在} --&gt; |是,交给Slide|A;
E --&gt; |否,网络请求|D([3. 远端图片]);
D -.-&gt; |获取到图片并缓存|E;
</code></pre><p>那么接下来，要丰富的细节，就来到了<strong>网络请求</strong>和<strong>缓存</strong>了。</p>
<h3 id="网络请求">网络请求</h3>
<h3 id="缓存">缓存</h3>
</section>

  
  
  <footer class="mt-12 flex flex-wrap">
     
    <a
      class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]"
      href="https://boybeak.github.io/tags/untagged"
      >untagged</a
    >
    
  </footer>
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline"
      href="https://boybeak.github.io/posts/-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B03/"
      ><span>Glide源码分析与自我实现(三)——数据加载主流程</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
  <div id="disqus_thread"></div>
  <script>
    const disqusShortname = 'YOUR_DISQUS_SHORTNAME';
    const script = document.createElement('script');
    script.src = 'https://' + disqusShortname + '.disqus.com/embed.js';
    script.setAttribute('data-timestamp', +new Date());
    document.head.appendChild(script);
  </script>
  
</article>


    </main>

    <footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60">
  <div class="mr-auto">
    &copy; 2022
    <a class="link" href="https://boybeak.github.io/">My New Hugo Site</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank">Powered by Hugo️️</a
  >️
  <a class="link" href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank"
    >▷ Paper 6</a
  >
</footer>

  </body>
</html>
