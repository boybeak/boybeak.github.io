<!DOCTYPE html><html lang="zh-CN" id="theme-light-mode"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="boybeak"><title>HikingMan</title><meta name="description" content="不是去哪里，而是去看日出"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon-32x32.png"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-search" onclick="openWindow();"></a></li><li><a class="fa fa-sun-o" onclick="darkLightToggle();"></a></li></div><div class="avatar"><img src="/images/logo.jpg"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo-large.png" style="width:192px;" alt="favicon"><h3 title=""><a href="/">HikingMan</a></h3><div class="description"><p>不是去哪里，而是去看日出</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/boybeak"><i class="fa fa-github"></i></a></li><li><a href="mailto:boybeak@gmail.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/gao-yun-fei-65"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> boybeak</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/01/01/2022-09-17-Jetpack%E4%B9%8BLiveData%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Jetpack之LiveData源码分析</a></h3></div><div class="post-content"><div class="card"><p><p>在阅读这篇文章前，需要先对[**Lifecycle**](&#x2F;源码分析系列&#x2F;Jetpack之Lifecycle源码分析.md)有所了解。</p>
<p>Lifecycle是LiveData的根基，先有了生命周期的管理，才能进行安全不泄漏的数据观察。</p>
<p>先要引入LiveData：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> activity_version = <span class="string">&quot;1.1.0&quot;</span></span><br><span class="line"><span class="comment">// Kotlin，引入这个扩展，可以使用by viewModels()方法</span></span><br><span class="line">implementation <span class="string">&quot;androidx.activity:activity-ktx:$activity_version&quot;</span></span><br></pre></td></tr></table></figure>

<p>典型的用法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> vm <span class="keyword">by</span> viewModels&lt;MainVM&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        vm.<span class="keyword">data</span>.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, it, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vm.start()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainVM</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span>.value = <span class="string">&quot;start&quot;</span></span><br><span class="line">        Thread &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">            <span class="keyword">data</span>.postValue(<span class="string">&quot;run after 2000ms&quot;</span>)</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这两段代码中，我们就可以看出典型的用法，主要是在三个方法上，<em>observe</em>、<em>setValue</em>和<em>postValue</em>。我们就从这三个方法入手去探究LiveData的工作机制。</p>
<h2 id="observe方法"><a href="#observe方法" class="headerlink" title="observe方法"></a>observe方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LiveData.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="built_in">super</span> T&gt; observer)</span> &#123;</span><br><span class="line">  assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">LifecycleBoundObserver</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleBoundObserver</span>(owner, observer);</span><br><span class="line">  <span class="type">ObserverWrapper</span> <span class="variable">existing</span> <span class="operator">=</span> mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">  <span class="keyword">if</span> (existing != <span class="literal">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                                       + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>只允许在主线程中监听数据变化，并且如果<em>LifecycleOwner</em>已经处于<strong>DESTROYED</strong>状态，则忽略这次监听请求。</li>
<li>以<em>LifecycleOwner</em>和<em>Observer</em>创建一个<em>LifecycleBoundObserver</em>对象，这个对象继承了<em>ObserverWrapper</em>类，同时实现了<em>LifecycleEventObserver</em>接口，看到这个接口，我们便明白了<em>LiveData</em>能够生命周期安全的监听数据变化的原因了。</li>
<li>这个<em>LifecycleBoundObserver</em>对象需要存储在一个<em>SafeIterableMap</em>当中去，在存储时候，会通过observer判断是否已经存在一个<em>ObserverWrapper</em>对象existing，如果已经存在则分为两种：a. 如果existing没有attach在owner上，则说明，existing已经attach在另外一个<em>LifecycleOwner</em>上了，这是不允许的，此时需要抛出异常；b. 如果没有attach在另外一个<em>LifecycleOwner</em>上，则说明此时监听的就是当前的owner上，则不需要再次添加监听，直接返回。如果existing不存在，则向owner.getLifecycle()添加监听。</li>
</ol>
<h2 id="setValue和postValue方法"><a href="#setValue和postValue方法" class="headerlink" title="setValue和postValue方法"></a>setValue和postValue方法</h2><p>在子线程中更新数据，需要调用postValue方法，实际上，这个方法就是通过一个MainHandler去post一个<em>Runnable</em>的方式切换到主线程中执行setValue方法。所以，我们重点看setValue方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LiveData.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">  assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">  mVersion++;</span><br><span class="line">  mData = value;</span><br><span class="line">  dispatchingValue(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意到的是<code>mVersion++</code>这句话，<em>LiveData</em>就是通过版本号来记录新的值的。继续看dispatchingValue方法。</p>
<h3 id="dispatchingValue"><a href="#dispatchingValue" class="headerlink" title="dispatchingValue"></a>dispatchingValue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class="comment">/* synthetic access */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mDispatchingValue) &#123;				<span class="comment">// ①</span></span><br><span class="line">    mDispatchInvalidated = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mDispatchingValue = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    mDispatchInvalidated = <span class="literal">false</span>;	<span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">if</span> (initiator != <span class="literal">null</span>) &#123;</span><br><span class="line">      considerNotify(initiator);</span><br><span class="line">      initiator = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="built_in">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">           mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">        considerNotify(iterator.next().getValue());</span><br><span class="line">        <span class="keyword">if</span> (mDispatchInvalidated) &#123; <span class="comment">// ③</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">  mDispatchingValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，涉及到两个方法，1. 第一个dispatchingValue —— 用来分发控制数据更新流程；2. considerNotify具体执行数据更新操作。</p>
<p>这个方法是双信号量控制分发流程，<strong>mDispatchingValue</strong>和<strong>mDispatchInvalidated</strong>，之所以这样设计，按照我的理解，是考虑到了dispatchingValue方法多线程重入的问题，但是依我看来，这样做没必要，因为这个方法的几处调用，都是在主线程上，不可能出现第一次调用没有执行完，就又被调用一次的可能，也可能是设计者考虑到未来的扩展或者在这个库涉及之初有多线程调用的情况才这样写的，先按照有重入可能来分析。</p>
<p>我们先要弄清这两个信号量的作用：mDispatchingValue表示是否正在执行分发数据更新的操作，mDispatchInvalidated表示是否中断正在进行的分发，开始新一轮分发。</p>
<p>这个方法是根据传入的参数，有两个执行流程，一个是执行具体某个ObserverWrapper的数据更新操作，另外一个就是批量更新所有observer的数据操作。我们以setValue触发的dispatchingValue(null)批量更新操作为例进行分析。</p>
<p>注意我在上段代码中的序号①②③注释，我们分步骤进行分析：</p>
<blockquote>
<p>假设，此时我们有两个observer。</p>
<p>初始状态 <strong>mDispatchingValue &#x3D; false, mDispatchInvalidated &#x3D; false</strong></p>
<p>当<strong>第一次</strong>调用开始后，会顺利通过①处判断，然后进入do - while循环，并且在②处先将mDispatchInvalidated信号量置为false，所以，一般情况下，这个while循环只会执行一次；</p>
<p>信号量：<strong>mDispatchingValue &#x3D; true, mDispatchInvalidated &#x3D; false</strong></p>
<p>由于initiator参数为null，所以会进入到else分支中的for循环中，这里需要注意的是，每一次for循环结束时候，都判断一次mDispatchInvalidated信号量，也就是注释③处；</p>
<p>假设我们执行了第一个observer后，dispatchingValue方法进行了<strong>第二次</strong>调用，由于此时mDispatchingValue信号量为true，所以会进入①处if条件判断语句，将mDispatchInvalidated信号量置为true并且直接return了；</p>
<p>信号量：<strong>mDispatchingValue &#x3D; true, mDispatchInvalidated &#x3D; true</strong></p>
<p>此时，第一次调用的for循环体就会因为mDispatchInvalidated变成了true，而退出for循环，while循环开始判断条件，同样因为mDispatchInvalidated为true，回再次执行while循环，执行新值更新；</p>
<p>最后退出dispatchingValue方法后，两个信号量都置为false。</p>
</blockquote>
<p>这样做的目的，或许是为了及时抛弃旧值通知，开始新值通知。</p>
<h3 id="considerNotify"><a href="#considerNotify" class="headerlink" title="considerNotify"></a>considerNotify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">considerNotify</span><span class="params">(ObserverWrapper observer)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">  <span class="comment">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class="line">  <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">  <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">    observer.activeStateChanged(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  observer.mLastVersion = mVersion;</span><br><span class="line">  observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是具体执行通知观察者值变化的地方。</p>
<p>那么LiveData是如何判断新值和旧值的呢？</p>
<p>在setValue方法中，有一个<code>mVersion++</code>语句，每次设置新值都会触发这个mVersion的自增，然后在considerNotify方法中，去校验observer是否处于active状态以及新值版本号与observer中的版本号，如果observer<strong>应当</strong>处于非active状态而仍然处于active状态(<strong>因为状态可能由于handler机制并没有及时变更</strong>)，则进行状态变更并返回，并且如果<code>observer.mLastVersion &gt;= mVersion</code>，则直接返回，因为此时observer已经更新过此值。<strong>也就是说，只有observer处于active状态且当前mVersion &gt; observer.mVersion的时候，才去通知observer更新值</strong>。</p>
<p>接下来，着重看一下<em>LifecycleBoundObserver</em>和<em>ObserverWrapper</em>这个两个类。</p>
<h2 id="LifecycleBoundObserver和ObserverWrapper"><a href="#LifecycleBoundObserver和ObserverWrapper" class="headerlink" title="LifecycleBoundObserver和ObserverWrapper"></a>LifecycleBoundObserver和ObserverWrapper</h2><p><em>ObserverWrapper</em>是<em>Observer</em>的抽象包装类，代码很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ObserverWrapper</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> Observer&lt;? <span class="built_in">super</span> T&gt; mObserver;</span><br><span class="line">  <span class="type">boolean</span> mActive;</span><br><span class="line">  <span class="type">int</span> <span class="variable">mLastVersion</span> <span class="operator">=</span> START_VERSION;</span><br><span class="line"></span><br><span class="line">  ObserverWrapper(Observer&lt;? <span class="built_in">super</span> T&gt; observer) &#123;</span><br><span class="line">    mObserver = observer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">shouldBeActive</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">detachObserver</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">activeStateChanged</span><span class="params">(<span class="type">boolean</span> newActive)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class="line">    <span class="comment">// owner</span></span><br><span class="line">    mActive = newActive;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasInactive</span> <span class="operator">=</span> LiveData.<span class="built_in">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">    LiveData.<span class="built_in">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">      onActive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (LiveData.<span class="built_in">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">      onInactive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">      dispatchingValue(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在activeStateChanged方法中，先判断是否是状态的改变，如果<code>newActive == mActive</code>说明激活状态未改变，则直接返回；然后判断按照激活的observer数目和mActive状态，来判断LiveData的状态，并调用其空回调函数；最后如果mActive为true，则进行针对这个<em>ObserverWrapper</em>的事件分发。</p>
<p><em>ObserverWrapper</em>有两个子类，<em>LifecycleBoundObserver</em>和<em>AlwaysActiveObserver</em>，<em>AlwaysActiveObserver</em>是与生命周期无关的observer，需要谨慎使用，在适当的时候，通过removeObserver来删除，我们重点看<em>LifecycleBoundObserver</em>。</p>
<p><em>LifecycleBoundObserver</em>同时实现了<em>LifecycleEventObserver</em>，这就使得这个类具备了生命周期关联性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title class_">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title class_">LifecycleEventObserver</span> &#123;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">  LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="built_in">super</span> T&gt; observer) &#123;</span><br><span class="line">    <span class="built_in">super</span>(observer);</span><br><span class="line">    mOwner = owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">shouldBeActive</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">                             <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">      removeObserver(mObserver);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activeStateChanged(shouldBeActive());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">detachObserver</span><span class="params">()</span> &#123;</span><br><span class="line">    mOwner.getLifecycle().removeObserver(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在onStateChanged方法中，当生命周期处于<strong>DESTROYED</strong>状态时候，则删除这个observer。除此以外，当mOwner的生命周期处于<strong>STARTED</strong>之后的状态，则认为<code>shouldBeActive</code>，当生命周期函数onStateChanged被触发时候，将设置是否active。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过LiveData的这些特性，我们可以实现Activity - Fragment, Fragment - Fragment的通信，另外也可以做应用的事件总线，比如<strong>LiveEventBus</strong>。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-01-01</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 2284 words, 7 min 36 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/12/27/2022-09-17-Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B02/">Glide源码分析与自我实现(二)——缓存与BitmapPool</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>本文基于Glide 4.11.0</p>
</blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60426316">Glide 源码分析解读-缓存模块-基于最新版Glide 4.9.0</a></p>
<p><strong>注意：</strong>由于版本差异问题，本文有些部分与参考文章有差异。</p>
<p>缓存模块是Glide中非常重要的部分，Glide图片加载的高效性，几乎有一半功劳都在这里了。</p>
<p>一般来说，Glide有三级缓存，就是<strong>内存缓存</strong>、<strong>磁盘缓存</strong>和<strong>网络缓存</strong>。</p>
<p>先来看缓存流程图，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">style A fill:#99ccff</span><br><span class="line">style B1 fill:#aaffaa</span><br><span class="line">A(发起请求) --&gt; B&#123;1. 通过&lt;br&gt;ActiveResources&lt;br&gt;获取资源&#125; --&gt; |命中|B1([加载完成]);</span><br><span class="line">B --&gt; |未命中|C&#123;2. 通过&lt;br&gt;MemoryCache&lt;br&gt;获取资源&#125; --&gt; |命中|C1[缓存至&lt;br&gt;ActiveResources] --&gt; B1;</span><br><span class="line">C --&gt; |未命中|D&#123;3. 通过&lt;br&gt;DiskCache&lt;br&gt;获取资源&#125; --&gt; |命中|D1[缓存至&lt;br&gt;MemoryCache] --&gt; C1;</span><br><span class="line">D --&gt; |未命中|E[&quot;4. 通过数据源(网络、文件等)&lt;br&gt;加载数据&quot;] --&gt; E1[缓存至&lt;br&gt;DiskCache] --&gt; D1;</span><br></pre></td></tr></table></figure>

<h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>内存缓存主要靠三个部分组成：<strong>ActiveResources</strong>、<strong>MemoryCache</strong>和<strong>BitmapPool</strong>。</p>
<h3 id="ActiveResources"><a href="#ActiveResources" class="headerlink" title="ActiveResources"></a>ActiveResources</h3><p>ActiveResources表示当前正在活动中的资源。ActiveResources通过一个<code>Map&lt;Key, ResourceWeakReference&gt;</code>来保存活动中的资源，其中的ResourceWeakReference就是资源数据，在构建这个ResourceWeakReference的时候必须传入一个ReferenceQueue用来检测资源是否被回收。</p>
<blockquote>
<p><strong>Q1：如何探知WeakReference中的值被回收了呢？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">WeakReference</span> <span class="variable">wr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(value, queue);</span><br></pre></td></tr></table></figure>

<p>当构建WeakReference的时候，如果传入了queue参数，则在value被回收的时候，wr会被加入到queue中去，这样，通过检测queue中是否有值，就可以探知value是否被回收了。</p>
</blockquote>
<p>那么，在何时去探知ReferenceQueue中的值呢？我们查看ActiveResources的关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*构造方法中，通过monitorClearedResourcesExecutor执行了cleanReferenceQueue()方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ActiveResources(<span class="type">boolean</span> isActiveResourceRetentionAllowed) &#123;</span><br><span class="line">  <span class="built_in">this</span>(</span><br><span class="line">    isActiveResourceRetentionAllowed,</span><br><span class="line">    java.util.concurrent.Executors.newSingleThreadExecutor(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Runnable r)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                r.run();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;glide-active-resources&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">ActiveResources(</span><br><span class="line">  <span class="type">boolean</span> isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) &#123;</span><br><span class="line">  <span class="built_in">this</span>.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;</span><br><span class="line">  <span class="built_in">this</span>.monitorClearedResourcesExecutor = monitorClearedResourcesExecutor;</span><br><span class="line"></span><br><span class="line">  monitorClearedResourcesExecutor.execute(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        cleanReferenceQueue();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cleanReferenceQueue</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (!isShutdown) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">ResourceWeakReference</span> <span class="variable">ref</span> <span class="operator">=</span> (ResourceWeakReference) resourceReferenceQueue.remove();</span><br><span class="line">      cleanupActiveReference(ref);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This section for testing only.</span></span><br><span class="line">      <span class="type">DequeuedResourceCallback</span> <span class="variable">current</span> <span class="operator">=</span> cb;</span><br><span class="line">      <span class="keyword">if</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        current.onResourceDequeued();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// End for testing only.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过代码可以看出，<code>cleanReferenceQueue</code>是一个靠<code>isShutdown</code>变量控制的<strong>死循环</strong>方法，这个方法执行在一个优先级为<code>THREAD_PRIORITY_BACKGROUND</code>的线程上。</p>
<blockquote>
<p><strong>Q2：那么，既然是死循环方法，会不会过多的占用CPU资源呢？</strong></p>
<p>其实不会的，因为ReferenceQueue#remove是一个阻塞式的方法，如果没有元素可以被remove，则等待至有元素可以remove的时候，等待期间释放CPU。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong>此处与<strong>参考文章</strong>中的说法不同，这是因为版本差异。查看<a target="_blank" rel="noopener" href="https://github.com/bumptech/glide/commit/8f1ea5c07dff7ade8c49c324bcb5a7f40d0b4891#diff-c46e6c0760c04e74cb867c2bdf9cdee90ab279b119268478524c42cc743cb8a9">Glide update log hsitory</a>，可以看出<strong>出于避免在主线程做清理的原因</strong>，将清理任务放在了后台线程，而不是放在IdleHandler中。</p>
</blockquote>
<p><strong>那么被回收了的资源去哪里了呢？</strong></p>
<p>我们查看<code>cleanupActiveReference</code>方法，得知，通过<em>ResourceListener#onResourceReleased</em>回调，交给了<strong>Engine</strong>来处理，我们查看Engine的onResourceReleased方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResourceReleased</span><span class="params">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> &#123;</span><br><span class="line">  activeResources.deactivate(cacheKey);</span><br><span class="line">  <span class="keyword">if</span> (resource.isMemoryCacheable()) &#123;</span><br><span class="line">    cache.put(cacheKey, resource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resourceRecycler.recycle(resource, <span class="comment">/*forceNextFrame=*/</span> <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里我们发现，这里出现了两种情况：</p>
<ol>
<li>如果资源是<strong>MemoryCacheable</strong>的，则缓存在MemoryCache；</li>
<li>如果资源不是<strong>MemoryCacheable</strong>的，则交给ResourceRecycler调用Resource的recycle()方法来回收，如果此Resource为BitmapResource，则会将Bitmap回收到BitmapPool中去。</li>
</ol>
<p>在开始MemoryCache和BitmapPool前，需要先了解一下<strong>MemorySizeCalculator</strong>这个类，这个类是用来计算 BitmapPool 、ArrayPool 以及 MemoryCache <strong>大小</strong>的。</p>
<h3 id="MemoryCache"><a href="#MemoryCache" class="headerlink" title="MemoryCache"></a>MemoryCache</h3><p>MemoryCache的具体实现类是LruResourceCache，而实际的逻辑方法，都在其父类LruCache中，以put方法为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Y <span class="title function_">put</span><span class="params">(<span class="meta">@NonNull</span> T key, <span class="meta">@Nullable</span> Y item)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">itemSize</span> <span class="operator">=</span> getSize(item);</span><br><span class="line">  <span class="keyword">if</span> (itemSize &gt;= maxSize) &#123;</span><br><span class="line">    onItemEvicted(key, item);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">    currentSize += itemSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Nullable</span> Entry&lt;Y&gt; old = cache.put(key, item == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(item, itemSize));</span><br><span class="line">  <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">    currentSize -= old.size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!old.value.equals(item)) &#123;</span><br><span class="line">      onItemEvicted(key, old.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  evict();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> old != <span class="literal">null</span> ? old.value : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当有一个新的item被put进去以后，会替换出一个老的值old，如果old非为空，则需要将当前容量减去old的大小，如果old并非新的item，则需要通过onItemEvicted进行回调，通知有老值被<strong>“驱逐”</strong>了。最后还要执行一次evict方法，按照LRU算法，将超出maxSize的item<strong>“驱逐”</strong>出去，以确保在maxSize范围内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">  Map.Entry&lt;T, Entry&lt;Y&gt;&gt; last;</span><br><span class="line">  Iterator&lt;Map.Entry&lt;T, Entry&lt;Y&gt;&gt;&gt; cacheIterator;</span><br><span class="line">  <span class="keyword">while</span> (currentSize &gt; size) &#123;</span><br><span class="line">    cacheIterator = cache.entrySet().iterator();</span><br><span class="line">    last = cacheIterator.next();</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;Y&gt; toRemove = last.getValue();</span><br><span class="line">    currentSize -= toRemove.size;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">T</span> <span class="variable">key</span> <span class="operator">=</span> last.getKey();</span><br><span class="line">    cacheIterator.remove();</span><br><span class="line">    onItemEvicted(key, toRemove.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">evict</span><span class="params">()</span> &#123;</span><br><span class="line">  trimToSize(maxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被**”驱逐”*<em>的值去哪里了呢？我们查看</em>MemoryCache<em>类的源码，可以知道是通过</em>ResourceRemovedListener<em>回调给了</em>Engine<em>，在</em>Engine<em>中我们查看</em>onResourceRemoved*方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResourceRemoved</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Resource&lt;?&gt; resource)</span> &#123;</span><br><span class="line">  <span class="comment">// Avoid deadlock with RequestManagers when recycling triggers recursive clear() calls.</span></span><br><span class="line">  <span class="comment">// See b/145519760.</span></span><br><span class="line">  resourceRecycler.recycle(resource, <span class="comment">/*forceNextFrame=*/</span> <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这里同样是通过resourceRecycler进行了回收。在这里，则是交给resource自己的recycle()方法来处理，比如，<em>BitmapResource</em>是交给了<em>BitmapPool</em>进行处理。</p>
<h3 id="BitmapPool"><a href="#BitmapPool" class="headerlink" title="BitmapPool"></a>BitmapPool</h3><p>这里是专门用来存放被回收的Bitmap的，其中<strong>BitmapDrawableResource</strong>、<strong>BitmapResource</strong>都持有一个<strong>BitmapPool</strong>变量，在执行recycle()方法时候，调用*BitmapPool#put()*方法。我们来看一下这个BitmapPool的默认实现类<strong>LruBitmapPool</strong>的方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (bitmap == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Bitmap must not be null&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (bitmap.isRecycled()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot pool recycled bitmap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!bitmap.isMutable()</span><br><span class="line">      || strategy.getSize(bitmap) &gt; maxSize</span><br><span class="line">      || !allowedConfigs.contains(bitmap.getConfig())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(</span><br><span class="line">        TAG,</span><br><span class="line">        <span class="string">&quot;Reject bitmap from pool&quot;</span></span><br><span class="line">        + <span class="string">&quot;, bitmap: &quot;</span></span><br><span class="line">        + strategy.logBitmap(bitmap)</span><br><span class="line">        + <span class="string">&quot;, is mutable: &quot;</span></span><br><span class="line">        + bitmap.isMutable()</span><br><span class="line">        + <span class="string">&quot;, is allowed config: &quot;</span></span><br><span class="line">        + allowedConfigs.contains(bitmap.getConfig()));</span><br><span class="line">    &#125;</span><br><span class="line">    bitmap.recycle();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> strategy.getSize(bitmap);</span><br><span class="line">  strategy.put(bitmap);</span><br><span class="line">  tracker.add(bitmap);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看出，当Bitmap在三种情况下是不会被BitmapPool缓存起来的：</p>
<ol>
<li>这个bitmap是非mutable的，也就是说是不允许被复用的；</li>
<li>这一个bitmap的字节数大小已经超过了可以容纳的总大小；</li>
<li>BitmapPool中不允许的Config类型。</li>
</ol>
<p>在这种情况，bitmap就被直接recycle掉，而不是放入缓存等待下次使用。</p>
<p>如果不满足这三种情况，则会被strategy缓存起来，等待下次使用。</p>
<p>我们再看LruBitmapPool#get()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> Bitmap <span class="title function_">get</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, Bitmap.Config config)</span> &#123;</span><br><span class="line">  <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> getDirtyOrNull(width, height, config);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">    result.eraseColor(Color.TRANSPARENT);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = createBitmap(width, height, config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，当能够查询到符合条件的Bitmap的时候，会先通过eraseColor方法，将其变成透明图片，然后再交给调用者来使用；如果查询不到，则创建一个新图交给调用者来使用。</p>
<blockquote>
<p>LruBitmapPool的LruPoolStrategy变量，在KITKAT以及以上，是SizeConfigStrategy，在以下是AttributeStrategy，这是因为在KITKAT版本以下，Bitmap的复用需要尺寸的严格匹配，但是KITKAT及以上没有这个问题，只要被复用的图片尺寸比目标尺寸大就可以。</p>
</blockquote>
<h3 id="ArrayPool"><a href="#ArrayPool" class="headerlink" title="ArrayPool"></a>ArrayPool</h3><p>ArrayPool主要用在<strong>ThumbnailStreamOpener</strong>和<strong>ByteBufferGifDecoder</strong>中，具体的实现类为<strong>LruArrayPool</strong>。</p>
<p>在LruArrayPool中，通过groupedMap来缓存数据，而缓存数据的byte字节数是通过<strong>ArrayAdapterInterface</strong>来计算的，ArrayAdapterInterface是一个接口，实现类有两个：<strong>IntegerArrayAdapter</strong>和<strong>ByteArrayAdapter</strong>，分别对应缓存int[].class和byte[].class。</p>
<p>StreamGifDecoder和StreamBitmapDecoder都有一个ArrayPool成员。解码过程中需要用到byte[]，但不是直接new byte[]，而是调用<code>ArrayPool.get()</code>从对象池中拿，用完了归还。</p>
<h2 id="DiskCache"><a href="#DiskCache" class="headerlink" title="DiskCache"></a>DiskCache</h2><p>在上一章[Glide源码分析与自我实现(一)——数据加载主流程](&#x2F;源码分析系列&#x2F;Glide源码分析与自我实现2.md)中，提到过数据加载的主流程，其中一个非常重要的类是 <strong>DecodeJob</strong>，在这个类的<code>getNextGenerator</code>方法中，返回的<strong>SourceGenerator</strong>会用来加载远程数据，但是这个方法不止返回这一个<strong>DataFetcherGenerator</strong>类，这是一个通过条件判断，返回不同DataFetcherGenerator类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DataFetcherGenerator <span class="title function_">getNextGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourceCacheGenerator</span>(decodeHelper, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataCacheGenerator</span>(decodeHelper, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SourceGenerator</span>(decodeHelper, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unrecognized stage: &quot;</span> + stage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这是依次递进的<strong>有限状态机</strong>设计模式，当一个获取数据请求到来时候，此时是默认状态INITIALIZE，然后通过<code>getNextStage</code>方法判断下一个状态是什么，再按照新的状态获取DataFetcherGenerator，然后随着任务的执行，不断改变状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stage <span class="title function_">getNextStage</span><span class="params">(Stage current)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">        ? Stage.RESOURCE_CACHE</span><br><span class="line">        : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">        ? Stage.DATA_CACHE</span><br><span class="line">        : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="comment">// Skip loading from source if the user opted to only retrieve the resource from cache.</span></span><br><span class="line">      <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unrecognized stage: &quot;</span> + current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其状态变更顺序为INITIALIZE -&gt; RESOURCE_CACHE -&gt; DATA_CACHE -&gt; SOURCE，代表着ResourceCacheGenerator、DataCacheGenerator和SourceGenerator，当从ResourceCahce中拿不到数据，则向DataCacheGenerator请求数据，如果还是拿不到，则通过SourceGenerator去请求数据了。</p>
<p>在这个过程中，SourceGenerator向DiskCache中写入数据，ResourceCacheGenerator和DataCacheGenerator从DiskCache中读取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceCacheGenerator</span> <span class="keyword">implements</span> <span class="title class_">DataFetcherGenerator</span>,</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNext</span><span class="params">()</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      currentKey = <span class="keyword">new</span> <span class="title class_">ResourceCacheKey</span>(sourceId, helper.getSignature(), helper.getWidth(),</span><br><span class="line">          helper.getHeight(), transformation, resourceClass, helper.getOptions());</span><br><span class="line">      cacheFile = helper.getDiskCache().get(currentKey);</span><br><span class="line">      <span class="keyword">if</span> (cacheFile != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sourceKey = sourceId;</span><br><span class="line">        modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">        modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataCacheGenerator</span> <span class="keyword">implements</span> <span class="title class_">DataFetcherGenerator</span>,</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (modelLoaders == <span class="literal">null</span> || !hasNextModelLoader()) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="type">Key</span> <span class="variable">sourceId</span> <span class="operator">=</span> cacheKeys.get(sourceIdIndex);</span><br><span class="line">      <span class="type">Key</span> <span class="variable">originalKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataCacheKey</span>(sourceId, helper.getSignature());</span><br><span class="line">      cacheFile = helper.getDiskCache().get(originalKey);</span><br><span class="line">      <span class="keyword">if</span> (cacheFile != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sourceKey = sourceId;</span><br><span class="line">        modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class="line">        modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SourceGenerator</span> <span class="keyword">implements</span> <span class="title class_">DataFetcherGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dataToCache != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> dataToCache;</span><br><span class="line">      dataToCache = <span class="literal">null</span>;</span><br><span class="line">      cacheData(data);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheData</span><span class="params">(Object dataToCache)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</span><br><span class="line">      DataCacheWriter&lt;Object&gt; writer =</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DataCacheWriter</span>&lt;&gt;(encoder, dataToCache, helper.getOptions());</span><br><span class="line">      originalKey = <span class="keyword">new</span> <span class="title class_">DataCacheKey</span>(loadData.sourceKey, helper.getSignature());</span><br><span class="line">      helper.getDiskCache().put(originalKey, writer);</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      loadData.fetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceCacheGenerator =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DataCacheGenerator</span>(Collections.singletonList(loadData.sourceKey), helper, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DiskCache的默认实现类是<strong>DiskLruCacheWrapper</strong>，其内部通过<strong>DiskLruCache</strong>来管理磁盘缓存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到现在，Glide主要部分已经分析的差不多了，实际上这个优秀的框架可挖的地方还有很多，比如通过[APT来实现很好的扩展](&#x2F;源码分析系列&#x2F;Glide源码分析与自我实现3.md)，框架中涉及多种涉及模式等。</p>
<blockquote>
<p>其中涉及到的涉及模式，比如无处不在的<strong>构建者模式</strong>和<strong>工厂模式</strong>，DecodeJob中的<strong>有限状态机模式</strong>，还有BitmapPool和ArrayPool中的<strong>享元模式</strong>，DiskLruCacheWrapper中的<strong>代理模式</strong>等。</p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.sunmoonblog.com/2018/07/27/glide-cache/">Glide缓存分析</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-12-27</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 2791 words, 9 min 18 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/12/27/2022-09-17-Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B03/">Glide源码分析与自我实现(三)——APT的使用与GIF的优化</a></h3></div><div class="post-content"><div class="card"><p><p>项目Demo地址：<a target="_blank" rel="noopener" href="https://github.com/boybeak/GifHelper">GifHelper</a></p>
<p><strong>什么是APT？</strong></p>
<p><strong>APT</strong>是<strong>Annotation Processing Tool</strong>的简称，即<strong>编译时注解处理器</strong>。它是一个javac的工具，在编译时，通过注解，按照规则自动生成相关代码的工具。</p>
<p><strong>APT与Glide什么关系？</strong></p>
<p>我们通常通过在build.gradle加入这样一段代码来引入Glide库。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  google()</span><br><span class="line">  jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation <span class="string">&#x27;com.github.bumptech.glide:glide:4.11.0&#x27;</span></span><br><span class="line">  annotationProcessor <span class="string">&#x27;com.github.bumptech.glide:compiler:4.11.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个<code>annotationProcessor</code>，这就是对Glide提供的APT进行引用。我们查看Glide的源码结构，可以看到一个名为<em>annotation</em>的文件夹，这里就是与APT有关的部分。</p>
<p><img src="/images/glide_struct.jpg" alt="Glide Struct"></p>
<p>接下来我们先通过GIF优化，看一看Glide的APT能实现的神奇效果，在这之后，再来分析Glide是如何通过APT实现的。</p>
<blockquote>
<p><strong>注意：</strong>如果使用kotlin需要先加入<code>apply plugin: &#39;kotlin-kapt&#39;</code>插件，并且将<code>annotationProcessor</code>改成<code>kapt</code>。</p>
</blockquote>
<h2 id="GIF优化"><a href="#GIF优化" class="headerlink" title="GIF优化"></a>GIF优化</h2><p><strong>为什么要优化GIF？</strong></p>
<p>有人可能会有疑问，Glide相比其他图片加载框架的优势之一，就是支持GIF，为什么还要做优化呢？</p>
<p>先看两个截图来对比优化前后的CPU和内存使用情况。</p>
<p><img src="/images/gif_before_optimization.png" alt="优化前"></p>
<p><img src="/images/gif_after_optimization.png" alt="优化后"></p>
<p>我们可以看出，优化后，CPU和内存状况都好了很多，那么我们是怎么做的呢？这就需要用到谷歌官方的两个库——<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/external/giflib/+/refs/heads/master">giflib</a>和<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/ex/+/refs/heads/master/framesequence/">FrameSequence</a>，这两个库需要我们自己编译成.so文件，具体可以参考示例项目<a target="_blank" rel="noopener" href="https://github.com/boybeak/GifHelper">GifHelper</a>。</p>
<p>我们查看GifHolder中的代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GifHolder</span>(v: View) : AbsHolder&lt;GifItem&gt;(v) &#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> gifIV = view&lt;ImageView&gt;(R.id.gifIV)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(item: <span class="type">GifItem</span>, position: <span class="type">Int</span>, absAdapter: <span class="type">AnyAdapter</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.useGifX) &#123;</span><br><span class="line">      <span class="comment">// 优化后的加载方式</span></span><br><span class="line">    	GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 优化前的加载方式</span></span><br><span class="line">      Glide.with(itemView).asGif().load(item.source()).into(gifIV)</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，加载后有这样一条语句：<code>GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</code>，也许你会懵逼，哪里有GlideApp？哪里有asGifX()方法？我引入Glide后怎么没有看到这两个东西？这就涉及到了APT的内容了。想要看Glide官方文档的可以看<a target="_blank" rel="noopener" href="http://bumptech.github.io/glide/doc/configuration.html#glidemodule">这里</a>。</p>
<p>一切的起因，要从**@GlideModule**这个注解说起，我们打开demo中的MyAppGlideModule类，可以看到这个类有一个@GlideModule注解。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAppGlideModule</span> : <span class="type">AppGlideModule</span>() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerComponents</span><span class="params">(context: <span class="type">Context</span>, glide: <span class="type">Glide</span>, registry: <span class="type">Registry</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.registerComponents(context, glide, registry)</span><br><span class="line">    registry.append(Registry.BUCKET_GIF, InputStream::<span class="keyword">class</span>.java,</span><br><span class="line">                    FrameSequenceDrawable::<span class="keyword">class</span>.java, GifDecoder(glide.bitmapPool))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再点开这个注解的源码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GlideModule &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the name of the class that will be used as a replacement for &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">   * com.bumptech.glide.Glide&#125; in Applications that depend on Glide&#x27;s generated code.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String <span class="title function_">glideName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;GlideApp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在看到“GlideApp”了，是glideName这个注解属性的默认值。我们来逐条分析一下这个注解类的相关信息：</p>
<ul>
<li><code>@Target(ElementType.TYPE)</code>：指明这个注解的作用对象——只对类生效；</li>
<li><code>@Retention(RetentionPolicy.CLASS)</code>：指明了这个注解的作用阶段——编译时记录在class文件中；</li>
<li><code>public @interface GlideModule</code>：这是一个注解接口，接口名<strong>GlideModule</strong>；</li>
<li><code>String glideName() default &quot;GlideApp&quot;</code>：这个注解接口需要一个名为<em>glideName</em>的属性，属性默认值为“GlideApp”。</li>
</ul>
<blockquote>
<p>RetentionPolicy：</p>
<ul>
<li><strong>SOURCE</strong>：这样的注解会被编译器擦除，只在编码阶段生效，目的是为了提示开发者，比如**@IntDef<strong>、</strong>@StringDef<strong>、</strong>@Visibility<strong>、</strong>@NonNull**；</li>
<li><strong>CLASS</strong>：记录在class文件中，编译时对编译器可见，运行时对VM不可见，这是RetentionPolicy的默认值，比如**@NotNull**;</li>
<li><strong>RUNTIME</strong>：记录在class文件中，在运行时需要反射获取其属性值，比如**@Column**。</li>
</ul>
</blockquote>
<p>就是这个**@GlideModule**属性，为我们生成了GlideApp类，这其中的生成过程，我们稍后再说，先把Gif优化的流程说完。</p>
<p>添加**@GlideModule**后，再次编译看，是否有了GlideApp这个类了。</p>
<p>我们再来看<em>MyAppGlideModule</em>中的代码，<code>registry.append</code>方法，这是为Glide添加一种解析类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* @param bucket 要添加的类型id.</span></span><br><span class="line"><span class="comment">* @param dataClass 要从什么数据进行解析。 (&#123;@link java.io.InputStream&#125;, &#123;@link</span></span><br><span class="line"><span class="comment">*     java.io.FileDescriptor&#125; etc).</span></span><br><span class="line"><span class="comment">* @param resourceClass 要解析成什么数据。 (&#123;@link android.graphics.Bitmap&#125;,</span></span><br><span class="line"><span class="comment">*     &#123;@link com.bumptech.glide.load.resource.gif.GifDrawable&#125; etc).</span></span><br><span class="line"><span class="comment">* @param decoder 用什么解码器进行解析 &#123;@link ResourceDecoder&#125;。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> &lt;Data, TResource&gt; Registry <span class="title function_">append</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> String bucket,</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> Class&lt;Data&gt; dataClass,</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> Class&lt;TResource&gt; resourceClass,</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> ResourceDecoder&lt;Data, TResource&gt; decoder)</span> &#123;</span><br><span class="line">  decoderRegistry.append(bucket, decoder, dataClass, resourceClass);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来就要引入谷歌官方的两个类库了，<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/ex/+/android-9.0.0_r16/framesequence/">FrameSquence</a>和<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/external/giflib/+/android-9.0.0_r16">giflib</a>。大家可以根据需要下载对应版本的库，不过这两个库的版本最好要对应。</p>
<p>下载后需要编译，项目结构参考<a target="_blank" rel="noopener" href="https://github.com/boybeak/GifHelper">GifHelper</a>项目中的framesequence&#x2F;src&#x2F;main&#x2F;jni文件夹。注意，需要将FrameSequence_gif.h中的include部分进行修改。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- #include &quot;config.h&quot;</span></span><br><span class="line"><span class="deletion">- #include &quot;gif_lib.h&quot;</span></span><br><span class="line">改成</span><br><span class="line"><span class="addition">+ #include &quot;giflib/config.h&quot;</span></span><br><span class="line"><span class="addition">+ #include &quot;giflib/gif_lib.h&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后执行ndk-build，则会在jni同级的目录下，生成一个libs文件夹，.so文件就在这里。</p>
<p>接下来需要去自定义GifDecoder.java了，直接上代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GifDecoder</span>(<span class="keyword">private</span> <span class="keyword">val</span> bmpPool: BitmapPool) : ResourceDecoder&lt;InputStream, FrameSequenceDrawable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> headerParser = DefaultImageHeaderParser()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handles</span><span class="params">(source: <span class="type">InputStream</span>, options: <span class="type">Options</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(options.<span class="keyword">get</span>(GifOptions.DISABLE_ANIMATION) ?: <span class="literal">true</span>)</span><br><span class="line">            &amp;&amp; headerParser.getType(source) == ImageHeaderParser.ImageType.GIF</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        source: <span class="type">InputStream</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        width: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        height: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        options: <span class="type">Options</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Resource&lt;FrameSequenceDrawable&gt;? &#123;</span><br><span class="line">        <span class="keyword">val</span> fs = FrameSequence.decodeStream(source)</span><br><span class="line">        <span class="keyword">val</span> fsd = FrameSequenceDrawable(fs, <span class="keyword">object</span> : FrameSequenceDrawable.BitmapProvider &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">acquireBitmap</span><span class="params">(minWidth: <span class="type">Int</span>, minHeight: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">                <span class="keyword">return</span> bmpPool.<span class="keyword">get</span>(minWidth, minHeight, Bitmap.Config.ARGB_8888)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">releaseBitmap</span><span class="params">(bitmap: <span class="type">Bitmap</span>?)</span></span> &#123;</span><br><span class="line">                bmpPool.put(bitmap)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> GifResource(fsd)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类里只需要实现两个方法：<code>handles</code>和<code>decode</code>：</p>
<ul>
<li>handles：能否解析该输入源，能则返回true；</li>
<li>decode：如果handles返回true，则执行此方法，返回一个Resource对象包裹住目标类型对象。</li>
</ul>
<p>我们通过Glide自带的<em>ImageHeaderParser</em>来检测该输入流是否是gif图像的输入流，如果是且可以执行动画，则进行decode操作。</p>
<p>我们着重看decode方法，这里需要重点看的是，在构建<em>FrameSequenceDrawable</em>时候，传入了一个<em>BitmapProvider</em>对象，这就是提高Gif效率的关键，在这个<em>BitmapProvider</em>里面，我们通过BitmapPool，去寻找可用尺寸的Bitmap，通过<strong>池化</strong>的方式，减小了内存开销，增加里Bitmap利用率。</p>
<p>接下来看，如何添加<code>asGifX</code>方法。我们都知道，传统的Glide调用方式如下图：</p>
<p><code>Glide.with(itemView).asGif().load(item.source()).into(gifIV)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[Glide] --&gt;|&quot;with(xxx)&quot;| B[RequestManager] --&gt;|&quot;asGif&quot;| C[RequestBuilder];</span><br></pre></td></tr></table></figure>

<p>而新的方式却不同，如下图：</p>
<p><code>GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[GlideApp] --&gt;|&quot;with(xxx)&quot;| B[GlideRequests]  --&gt;|asGifX| C[GlideRequest];</span><br></pre></td></tr></table></figure>

<p>这其中的<em>GlideRequest</em>和<em>GlideRequest</em>，同样都是生成的类，其中GlideRequests继承自RequestManager，GlideRequest继承自RequestBuilder。</p>
<p>这两个类的生成，同样是**@GlideModule**的作用，但是<code>asGifX</code>这个方法是什么时候定义的呢？我们去查看<code>asGifX</code>这个方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> GifExtension#asGifX(RequestBuilder)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@CheckResult</span></span><br><span class="line"><span class="keyword">public</span> GlideRequest&lt;FrameSequenceDrawable&gt; <span class="title function_">asGifX</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (GlideRequest&lt;FrameSequenceDrawable&gt;) GifExtension.asGifX(<span class="built_in">this</span>.as(FrameSequenceDrawable.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到实际上这个类的具体实现，是依靠GifExtension类，我们去看这个类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GlideExtension</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GifExtension</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@GlideType(FrameSequenceDrawable.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RequestBuilder&lt;FrameSequenceDrawable&gt; <span class="title function_">asGifX</span><span class="params">(RequestBuilder&lt;FrameSequenceDrawable&gt; requestBuilder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> requestBuilder.apply(RequestOptions</span><br><span class="line">                .decodeTypeOf(FrameSequenceDrawable.class)</span><br><span class="line">                .lock());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GifExtension</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类需要我们自己实现，并且需要标记**@GlideExtension**注解，又是注解的功劳。</p>
<p>到此为止，Gif优化的主流程就全部讲完了，接下来就要看这两个注解——**@GlideModule<strong>和</strong>@GlideExtension**到底做了什么？</p>
<h2 id="GlideModule和-GlideExtension"><a href="#GlideModule和-GlideExtension" class="headerlink" title="@GlideModule和@GlideExtension"></a>@GlideModule和@GlideExtension</h2><p>源码在Glide项目的annotation&#x2F;compiler内，这种APT项目的入口文件标记在src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;gradle内，这其中有一个incremental.annotation.processors文件，我们查看其内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor,aggregating</span><br></pre></td></tr></table></figure>

<p>可以得知，程序入口在GlideAnnotationProcessor这个类，查看这个类的源码，我只提取了关键部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">GlideAnnotationProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> LibraryModuleProcessor libraryModuleProcessor;</span><br><span class="line">  <span class="keyword">private</span> AppModuleProcessor appModuleProcessor;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> isGeneratedAppGlideModuleWritten;</span><br><span class="line">  <span class="keyword">private</span> ExtensionProcessor extensionProcessor;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getSupportedAnnotationTypes</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    result.addAll(libraryModuleProcessor.getSupportedAnnotationTypes());</span><br><span class="line">    result.addAll(extensionProcessor.getSupportedAnnotationTypes());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment env)</span> &#123;</span><br><span class="line">    processorUtil.process();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newModulesWritten</span> <span class="operator">=</span> libraryModuleProcessor.processModules(env);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newExtensionWritten</span> <span class="operator">=</span> extensionProcessor.processExtensions(env);</span><br><span class="line">    appModuleProcessor.processModules(set, env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newExtensionWritten || newModulesWritten) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isGeneratedAppGlideModuleWritten) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot process annotations after writing AppGlideModule&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isGeneratedAppGlideModuleWritten) &#123;</span><br><span class="line">      isGeneratedAppGlideModuleWritten = appModuleProcessor.maybeWriteAppModule();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getSupportedAnnotationTypes</code>方法中标记了，支持哪些注解的解析，其中<code>libraryModuleProcessor.getSupportedAnnotationTypes()</code>中返回了**@GlideModule<strong>，<code>extensionProcessor.getSupportedAnnotationTypes()</code>中返回了</strong>@GlideExtension**。</li>
<li>process方法中开始了对注解的处理。</li>
</ul>
<p>注解的处理，需要你对<a target="_blank" rel="noopener" href="https://github.com/square/javapoet"><strong>javapoet</strong></a>有一点点了解，如果暂时不想去了解，你只需要知道，这个类库是通过字符串和占位符来生成Java代码的工具类库，因为接下来的生成代码工作，Glide就是通过这个类库来实现的。</p>
<p>具体的生成过程不再赘述，从入口类<em>GlideAnnotationProcessor</em>追踪下去，就能看到。</p>
<h2 id="为什么优化能提高效率？"><a href="#为什么优化能提高效率？" class="headerlink" title="为什么优化能提高效率？"></a>为什么优化能提高效率？</h2><p>Glide默认Gif加载方案，是通过GifDrawable来实现的，而GifDrawable是通过GifFrameLoader来加载帧数据的。具体代码分析可以看参考文章，我这里简单来说一下原因：</p>
<ul>
<li>默认方案是串行执行的，比如在加载显示第N帧，这一帧显示完毕，再去解析第N+1帧，当播放第N+1帧的时间窗口到了以后，如果已经解析完毕，则能正常显示，如果不能解析完毕，则会卡顿了；</li>
<li>GifFrameLoader内部是用了一个mainLooper的handler来进行流程控制，具体可以看GifFrameLoader里的代码，这种方式本身在时间上就不是准时的，与应用内其他各种系统共享mainLooper，如果其他事件执行占用时间较长，也会影响这里的效率了。</li>
</ul>
<p>我们再来说说优化方案，优化的原因也简单说一下：</p>
<ul>
<li>优化方案是<strong>并行+双缓冲</strong>执行的，在显示第N帧的BitmapA同时，会有一个后台线程在解析第N+1帧的BitmapB，当需要显示第N+1帧BitmapB的时候，两帧的Bitmap交换，BitmapA则进入后台线程去解析第N+2帧了；</li>
<li>在native去解析数据，效率更高；</li>
<li>通过BitmapPool提高了内存利用率。</li>
</ul>
<p>借用参考文章里的一张图</p>
<p><img src="/images/gif.webp" alt="Gif"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6854573219425288199">Glide加载Gif的卡顿优化思路分析</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-12-27</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 2748 words, 9 min 9 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/12/16/2022-09-17-Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B01/">Glide源码分析与自我实现(一)——数据加载主流程</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>本文基于Glide 4.11.0</p>
</blockquote>
<p>阅读前请参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60425157">Glide 源码分析解读-基于最新版Glide 4.9.0</a>一文，该文章中，将Glide中各个部分的作用分析的非常好了。</p>
<p>Glide几乎是现在做Android图片加载的最佳选择了。如此优秀的一个框架是如何实现的呢？如果让我们自己来实现该怎么做呢？我们就通过自己实现一个低配版Glide的方式，来探究Glide中是如何实现的。</p>
<p>我们就称我们自己低配版Glide为<strong>Slide</strong>。那么Slide要实现哪些功能呢？简单来说，就是<strong>获取图片</strong>+<strong>界面显示</strong>。我们通过先构架大体框架，再分步丰富其中细节的方式，来构建Slide的整体结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR;</span><br><span class="line">A[获取图片] --&gt; C[Slide] --&gt; B[界面显示];</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(xxx).load(url).into(iv);</span><br></pre></td></tr></table></figure>

<p>这是Glide一个典型的最为简单的调用过程。那么在这个过程中发生了哪些事情呢？</p>
<p>我们可以通过这个链式调用的返回值发现，有如下过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">style A fill:#aaffcc</span><br><span class="line">style D fill:#ffaa99</span><br><span class="line">A(Glide) --&gt;|&quot;with(xxx)&quot;| B(RequestManager) --&gt;|&quot;load(xxx)&quot;| C(RequestBuilder) --&gt;|&quot;into(iv)&quot;| D(Target);</span><br></pre></td></tr></table></figure>

<h2 id="Glide-with-xxx-发生了什么事？"><a href="#Glide-with-xxx-发生了什么事？" class="headerlink" title="Glide.with(xxx)发生了什么事？"></a>Glide.with(xxx)发生了什么事？</h2><p>阅读源码发现，<code>Glide.with(xxx)</code>的最终实现类是<em>RequestManagerRetriever.java</em>类。继续跟踪，我们在这个类中，看到这样一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> RequestManager <span class="title function_">supportFragmentGet</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> FragmentManager fm,</span></span><br><span class="line"><span class="params">  <span class="meta">@Nullable</span> Fragment parentHint,</span></span><br><span class="line"><span class="params">  <span class="type">boolean</span> isParentVisible)</span> &#123;</span><br><span class="line">  <span class="type">SupportRequestManagerFragment</span> <span class="variable">current</span> <span class="operator">=</span> getSupportRequestManagerFragment(fm, parentHint);</span><br><span class="line">  <span class="type">RequestManager</span> <span class="variable">requestManager</span> <span class="operator">=</span> current.getRequestManager();</span><br><span class="line"></span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关注这个getSupportRequestManagerFragment方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getSupportRequestManagerFragment</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> SupportRequestManagerFragment <span class="title function_">getSupportRequestManagerFragment</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> <span class="keyword">final</span> FragmentManager fm, <span class="meta">@Nullable</span> Fragment parentHint)</span> &#123;</span><br><span class="line">  <span class="type">SupportRequestManagerFragment</span> <span class="variable">current</span> <span class="operator">=</span></span><br><span class="line">    (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">    current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">      current = <span class="keyword">new</span> <span class="title class_">SupportRequestManagerFragment</span>();</span><br><span class="line">      current.setParentFragmentHint(parentHint);</span><br><span class="line">      pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">      handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，这里是一个Glide检测到界面生命周期的关键了。<strong>Glide就是通过像当前Activity添加一个一个无UI的Fragment来探测生命周期的</strong>。</p>
<blockquote>
<p><strong>注意：</strong>在执行了添加fragment的语句<code>fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss()</code>后，又马上通过handler发送了一个一个message，这里需要熟悉Handler机制才能理解，简单来说，就是添加fragment操作，实际上也是通过handler执行的，这是一个异步的过程，如何检测到fragment已经添加完成了呢？就是在<code>commitAllowingStateLoss</code>后，马上去发送一条指定的消息，利用handler处理message的顺序性，来获知fragment已经添加完成。</p>
</blockquote>
<p>经过添加<em>SupportRequestManagerFragment</em>后，我们获得了探测当前界面生命周期的能力。</p>
<p>继续阅读<code>supportFragmentGet</code>方法代码，<strong>RequestManager</strong>是从<strong>SupportRequestManagerFragment</strong>拿到的，如果拿到的是空，则创建一个，设置到该fragment当中去。</p>
<h2 id="RequestManager-load-xxx-发生了什么？"><a href="#RequestManager-load-xxx-发生了什么？" class="headerlink" title="RequestManager.load(xxx)发生了什么？"></a>RequestManager.load(xxx)发生了什么？</h2><p>我们以<code>load(url)</code>为例，来探究这部分代码。</p>
<p>这个方法，返回的是<em>RequestBuilder</em>这个类，看名字就知道，这是一个构建者模式中的Builder类，主要是在添加各种配置项，比如RequestOptions、RequestListener等。</p>
<h2 id="RequestBuilder-into-iv-发生了什么？"><a href="#RequestBuilder-into-iv-发生了什么？" class="headerlink" title="RequestBuilder.into(iv)发生了什么？"></a>RequestBuilder.into(iv)发生了什么？</h2><p>其实，这里才是真正开始触发发起请求的地方。</p>
<h3 id="RequestBuilder"><a href="#RequestBuilder" class="headerlink" title="RequestBuilder"></a>RequestBuilder</h3><p>我们把<code>into(ImageView)</code>方法作为入口，一路跟踪，可以发现最终的实现是如下方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y <span class="keyword">extends</span> <span class="title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="title function_">into</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="meta">@NonNull</span> Y target,</span></span><br><span class="line"><span class="params">  <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span><br><span class="line"><span class="params">  BaseRequestOptions&lt;?&gt; options,</span></span><br><span class="line"><span class="params">  Executor callbackExecutor)</span> &#123;</span><br><span class="line">  Preconditions.checkNotNull(target);</span><br><span class="line">  <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line"></span><br><span class="line">  <span class="type">Request</span> <span class="variable">previous</span> <span class="operator">=</span> target.getRequest();</span><br><span class="line">  <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">    <span class="comment">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class="line">    <span class="comment">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class="line">    <span class="comment">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class="line">    <span class="comment">// running, we can let it continue running without interruption.</span></span><br><span class="line">    <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">      <span class="comment">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class="line">      <span class="comment">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class="line">      <span class="comment">// that are done in the individual Request.</span></span><br><span class="line">      previous.begin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  target.setRequest(request);</span><br><span class="line">  requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是做了以下事情：</p>
<ol>
<li>是否已经有一个request在处理相同的请求，如果有，则判断是否正在运行，没有正在运行则开始运行；</li>
<li>如果没有一个request在处理此请求，则对target做一些清理操作，与之前的请求解绑，为当前target设置新的请求，然后requestManager开始追踪这个请求。</li>
</ol>
<p>接下来我们就按照<code>requestManager.track(target, request)</code>这段代码继续追踪。来到RequestManager的track方法。</p>
<h3 id="RequestManager"><a href="#RequestManager" class="headerlink" title="RequestManager"></a>RequestManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">track</span><span class="params">(<span class="meta">@NonNull</span> Target&lt;?&gt; target, <span class="meta">@NonNull</span> Request request)</span> &#123;</span><br><span class="line">  targetTracker.track(target);</span><br><span class="line">  requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，只有两个方法。</p>
<h4 id="TargetTracker"><a href="#TargetTracker" class="headerlink" title="TargetTracker"></a>TargetTracker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Target&lt;?&gt;&gt; targets =</span><br><span class="line">      Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;Target&lt;?&gt;, Boolean&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">track</span><span class="params">(<span class="meta">@NonNull</span> Target&lt;?&gt; target)</span> &#123;</span><br><span class="line">  targets.add(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把一个target存放在WeakHashMap中，因为target是与生命周期有关的东西，比如ImageView对应的<strong>ImageViewTarget</strong>，所以这么做是为了防止内存泄漏。</p>
<h4 id="RequestTracker"><a href="#RequestTracker" class="headerlink" title="RequestTracker"></a>RequestTracker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Starts tracking the given request. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runRequest</span><span class="params">(<span class="meta">@NonNull</span> Request request)</span> &#123;</span><br><span class="line">  requests.add(request);</span><br><span class="line">  <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">    request.begin();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    request.clear();</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;Paused, delaying request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pendingRequests.add(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是将暂停的request加入到pendingRequests中去，如果不是暂停的request，则调用其begin方法。</p>
<p>我们查看<em>Request</em>类的子类，可以看到下图。</p>
<p><img src="/images/request_implementions.jpg" alt="request_implementions"></p>
<p>可以看到一共有4个类实现了<em>Request</em>类，其中<em>FakeRequest</em>类是用于测试的，不去考虑。其他三个类的作用如下：</p>
<ol>
<li><strong>ThumbnailRequestCoordinator:</strong> 用来加载thumbnail；</li>
<li><strong>ErrorRequestCoordinator:</strong> 用来加载错误时候，展示错误状态； </li>
<li><strong>SingleRequest:</strong> 这才是用来加载目标图片的request。</li>
</ol>
<p>我们重点去看SingleRequest的begin方法。</p>
<h3 id="SingleRequest"><a href="#SingleRequest" class="headerlink" title="SingleRequest"></a>SingleRequest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">    assertNotCallingCallbacks();</span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">if</span> (model == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        width = overrideWidth;</span><br><span class="line">        height = overrideHeight;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Only log at more verbose log levels if the user has set a fallback drawable, because</span></span><br><span class="line">      <span class="comment">// fallback Drawables indicate the user expects null models occasionally.</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">logLevel</span> <span class="operator">=</span> getFallbackDrawable() == <span class="literal">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class="line">      onLoadFailed(<span class="keyword">new</span> <span class="title class_">GlideException</span>(<span class="string">&quot;Received null model&quot;</span>), logLevel);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == Status.RUNNING) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot restart a running request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;re restarted after we&#x27;re complete (usually via something like a notifyDataSetChanged</span></span><br><span class="line">    <span class="comment">// that starts an identical request into the same Target or View), we can simply use the</span></span><br><span class="line">    <span class="comment">// resource and size we retrieved the last time around and skip obtaining a new size, starting</span></span><br><span class="line">    <span class="comment">// a new load etc. This does mean that users who want to restart a load because they expect</span></span><br><span class="line">    <span class="comment">// that the view size has changed will need to explicitly clear the View or Target before</span></span><br><span class="line">    <span class="comment">// starting the new load.</span></span><br><span class="line">    <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">      onResourceReady(</span><br><span class="line">        resource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restarts for requests that are neither complete nor running can be treated as new requests</span></span><br><span class="line">    <span class="comment">// and can run again from the beginning.</span></span><br><span class="line"></span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">      onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target.getSize(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">        &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">      target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">      logV(<span class="string">&quot;finished run method in &quot;</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码虽长，但是结构简单。主要做了以下事情：</p>
<ol>
<li>检查model是否是空，model就是要加载的数据来源，比如url、resourceId、File等；</li>
<li>判断request状态，不能重新开始一个正在运行的请求；</li>
<li>判断request状态，如果是已经完成的请求，则说明资源已经存在，直接调用<code>onResourceReady</code>方法并返回；</li>
<li>接下来就来到判断target尺寸的过程了，如果target尺寸已经确定，比如view尺寸measure结束后，则调用<code>onSizeReady</code>方法，<strong>注意：实际的网络请求就在这个onSizeReady方法中，因为只有target的尺寸确定了，才能进行请求并处理图片；</strong></li>
<li>如果尺寸未确定，则调用<code>target.getSize</code>方法去监听尺寸事件，具体可以参考<code>ViewTarget#getSize</code>方法，这是一个通过onPreDrawListener来监听尺寸的；</li>
<li>接下来回调<code>onLoadStarted</code>方法，并且显示加载过程状态。</li>
</ol>
<p>我们着重看网络请求那个分支，也就是<code>onSizeReady</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSizeReady</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">	loadStatus = engine.load(</span><br><span class="line">    glideContext,</span><br><span class="line">    model,</span><br><span class="line">    requestOptions.getSignature(),</span><br><span class="line">    <span class="built_in">this</span>.width,</span><br><span class="line">    <span class="built_in">this</span>.height,</span><br><span class="line">    requestOptions.getResourceClass(),</span><br><span class="line">    transcodeClass,</span><br><span class="line">    priority,</span><br><span class="line">    requestOptions.getDiskCacheStrategy(),</span><br><span class="line">    requestOptions.getTransformations(),</span><br><span class="line">    requestOptions.isTransformationRequired(),</span><br><span class="line">    requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">    requestOptions.getOptions(),</span><br><span class="line">    requestOptions.isMemoryCacheable(),</span><br><span class="line">    requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">    requestOptions.getUseAnimationPool(),</span><br><span class="line">    requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">    <span class="built_in">this</span>,</span><br><span class="line">    callbackExecutor</span><br><span class="line">  );</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码来了！这个<code>engine</code>就是Glide的核心。这个engine是在Glide初始化时候生成的一个实例。</p>
<h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>Engine不只是用于加载图片，而是一个任务执行核心引擎，它要执行的不只是请求远程图片的任务，包括解码任务等，它执行的实际上是一个个的job。</p>
<p>跟踪上一阶段中的<code>engine.load</code>方法，来到是这个方法的关键部分——调用<code>waitForExistingOrStartNewJob</code>。</p>
<p>在这个方法中，主要做了以下事情：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">A&#123;&#123;是否有一个job执行相同操作&#125;&#125; --&gt; |有|B[为此job添加新的回调];</span><br><span class="line">A --&gt; |无|C[添加并执行一个EngineJob];</span><br></pre></td></tr></table></figure>

<h4 id="EngineJob-start-decodeJob"><a href="#EngineJob-start-decodeJob" class="headerlink" title="EngineJob.start(decodeJob)"></a>EngineJob.start(decodeJob)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.decodeJob = decodeJob;</span><br><span class="line">  <span class="type">GlideExecutor</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">    decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class="line">  executor.execute(decodeJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里执行的是decodeJob。</p>
<blockquote>
<p>这里需要着重关注一点，就是<code>executor.execute(decodeJob)</code>的时候，就已经通过<em>GlideExecutor</em>的sourceExecutor.Builder创建了一个<strong>ThreadPoolExecutor</strong>，也就是在这里实现线程池异步执行任务。<strong>ThreadPoolExecutor</strong>并不是Glide提供的实现，而是在java.util.concurrent包下。</p>
</blockquote>
<h4 id="DecodeJob"><a href="#DecodeJob" class="headerlink" title="DecodeJob"></a>DecodeJob</h4><p>DecodeJob是一个<em>Runnable</em>类，所以，我们查看其run方法。</p>
<p>接下来的调用路径参考下图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">subgraph DecodeJob;</span><br><span class="line">A(run) --&gt; B[runWrapped] --&gt; C[runGenerators] --&gt; D[getNextGenerator];</span><br><span class="line">end;</span><br><span class="line">subgraph SourceGenerator</span><br><span class="line">D --&gt; E[startNext] --&gt; F[startNextLoad];</span><br><span class="line">end;</span><br><span class="line">subgraph HttpUrlFetcher</span><br><span class="line">F --&gt; G[loadData] --&gt; H[loadDataWithRedirects];</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p>经过这么长的调用链，我们终于来到了网络请求的部分，我们可以看到Glide原生使用的<em>HttpURLConnection</em>进行网络请求的。<strong>获取到InputStream后，在SourceGenerator中的cacheData方法进行缓存处理。</strong></p>
<h4 id="获取到数据后的处理"><a href="#获取到数据后的处理" class="headerlink" title="获取到数据后的处理"></a>获取到数据后的处理</h4><p>通过<code>DataFetcherGenerator.FetcherReadyCallback</code>可以探知到数据获取成功或者失败，如果获取成功，则在<code>DecodeJob#onDataFetcherReady</code>中处理。关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataFetcherReady</span><span class="params">(</span></span><br><span class="line"><span class="params">      Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey)</span> &#123;</span><br><span class="line">  .....</span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">    runReason = RunReason.DECODE_DATA;</span><br><span class="line">    callback.reschedule(<span class="built_in">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更改任务状态，重新执行此任务，则重新执行到<code>getNextGenerator</code>方法，此时则会返回<strong>DataCacheGenerator</strong>来处理从Disk缓存加载的任务。</p>
<h2 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h2><p>首先，图片来源有哪些？</p>
<ol>
<li>资源图片：drawable, assets, raw, mipmap这些程序中自带的图片；</li>
<li>本地图片：本地存储设备上的图片；</li>
<li>远端图片：我们服务器或者来自第三方服务器的图片，通过URL来获取。这就需要<strong>异步网络请求</strong>，请求结束以后，要<strong>缓存</strong>图片，避免重复请求远端图片，造成时间、网络的浪费。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A[Slide];</span><br><span class="line">B([1. 资源图片]) --&gt; A;</span><br><span class="line">C([2. 本地图片]) --&gt; A;</span><br><span class="line">E&#123;缓存是否存在&#125; --&gt; |是,交给Slide|A;</span><br><span class="line">E --&gt; |否,网络请求|D([3. 远端图片]);</span><br><span class="line">D -.-&gt; |获取到图片并缓存|E;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>那么接下来，要丰富的细节，就来到了<strong>网络请求</strong>和<strong>缓存</strong>了。</p>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-12-16</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 2812 words, 9 min 22 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/12/13/2022-09-19-Apk%E7%98%A6%E8%BA%AB%E6%9C%AF/">Apk瘦身术</a></h3></div><div class="post-content"><div class="card"><p><p>Apk瘦身主要从三方面入手：资源文件、源代码和第三方类库。</p>
<h2 id="一、资源文件"><a href="#一、资源文件" class="headerlink" title="一、资源文件"></a>一、资源文件</h2><h3 id="1-1-删除无用资源文件"><a href="#1-1-删除无用资源文件" class="headerlink" title="1.1 删除无用资源文件"></a>1.1 删除无用资源文件</h3><h4 id="1-1-1-Lint工具"><a href="#1-1-1-Lint工具" class="headerlink" title="1.1.1 Lint工具"></a>1.1.1 Lint工具</h4><p>菜单 -&gt; Analyze -&gt; Run Inspection by Name，然后输入Unused resources便可以执行查找无用资源文件。自己根据需要进行删除。</p>
<h4 id="1-1-2-shrinkResources"><a href="#1-1-2-shrinkResources" class="headerlink" title="1.1.2 shrinkResources"></a>1.1.2 shrinkResources</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">  release &#123;</span><br><span class="line">    <span class="comment">// 不显示Log</span></span><br><span class="line">    buildConfigField <span class="string">&quot;boolean&quot;</span>, <span class="string">&quot;LOG_DEBUG&quot;</span>, <span class="string">&quot;false&quot;</span></span><br><span class="line">    <span class="comment">//混淆</span></span><br><span class="line">    minifyEnabled <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 移除无用的resource文件</span></span><br><span class="line">    shrinkResources <span class="literal">true</span></span><br><span class="line">    proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">    signingConfig signingConfigs.release</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用shrinkResources的前提是，打开混淆minifyEnabled，建议只在release版本开启，不然会使得编译速度变慢。</p>
<h3 id="1-2-图标类资源图片矢量化"><a href="#1-2-图标类资源图片矢量化" class="headerlink" title="1.2 图标类资源图片矢量化"></a>1.2 图标类资源图片矢量化</h3><p>对于图标类资源，可以选择用vector-drawable来代替，通过AndroidStudio自带的转换工具可以将svg文件转换为vector-drawable文件。</p>
<blockquote>
<p>具体操作为，在drawable相关文件夹上右键 -&gt; New -&gt; Vector Assert。</p>
</blockquote>
<p>你也可以进行批量转换：<a target="_blank" rel="noopener" href="https://github.com/vdmeer/svg2vector">工具地址</a></p>
<h3 id="1-3-非图标类资源图片适当压缩与格式选择"><a href="#1-3-非图标类资源图片适当压缩与格式选择" class="headerlink" title="1.3 非图标类资源图片适当压缩与格式选择"></a>1.3 非图标类资源图片适当压缩与格式选择</h3><h4 id="1-3-1-使用tinypng有损压缩png图片"><a href="#1-3-1-使用tinypng有损压缩png图片" class="headerlink" title="1.3.1 使用tinypng有损压缩png图片"></a>1.3.1 使用tinypng有损压缩png图片</h4><p>通过<a target="_blank" rel="noopener" href="http://tinypng.com/">Tinypng</a>官网上传压缩再下载，在保持alpha通道的情况下对png图片的压缩可达到1&#x2F;3以内，且肉眼基本看不出差别。</p>
<h4 id="1-3-2-使用jpg格式"><a href="#1-3-2-使用jpg格式" class="headerlink" title="1.3.2 使用jpg格式"></a>1.3.2 使用jpg格式</h4><p>对于非透明的大图，jpg会比png的大小和内存都更有优势，虽然不是绝对的，但是通常会减少到一半不止。</p>
<h4 id="1-3-3-使用webp格式"><a href="#1-3-3-使用webp格式" class="headerlink" title="1.3.3 使用webp格式"></a>1.3.3 使用webp格式</h4><p>webp格式支持透明度，压缩比比jpg高，但是显示效果却不输于jpg。缺点是在Android端的原生支持不好，从Android4.0+开始原生支持，但是不支持透明度，从Android4.3+开始支持带有透明度的webp。如果不需要兼容到这个版本，可以直接使用。</p>
<p>在Android studio中，在图片资源上右键可以转换为webp。详细参见<a target="_blank" rel="noopener" href="https://developer.android.com/studio/write/convert-webp">创建 WebP 图片</a>。</p>
<h4 id="1-3-4-适当的压缩和尺寸"><a href="#1-3-4-适当的压缩和尺寸" class="headerlink" title="1.3.4 适当的压缩和尺寸"></a>1.3.4 适当的压缩和尺寸</h4><p>无论以上哪种格式图片，都可以通过选择合适的尺寸和适当的提高压缩率的方式，来进一步减少文件大小，进而减小apk文件的体积。</p>
<h4 id="1-3-5-帧动画尽可能使用lottie"><a href="#1-3-5-帧动画尽可能使用lottie" class="headerlink" title="1.3.5 帧动画尽可能使用lottie"></a>1.3.5 帧动画尽可能使用lottie</h4><p><a target="_blank" rel="noopener" href="https://github.com/airbnb/lottie-android">Lottie</a>是Aribnb开源的动画库，通过json文件来进行展示动画，动画文件可以通过Adobe AE来制作。</p>
<h3 id="1-4-有限国际化"><a href="#1-4-有限国际化" class="headerlink" title="1.4 有限国际化"></a>1.4 有限国际化</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    resConfigs <span class="string">&quot;zh&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-第三方库中大尺寸的无用资源同名替换"><a href="#1-5-第三方库中大尺寸的无用资源同名替换" class="headerlink" title="1.5 第三方库中大尺寸的无用资源同名替换"></a>1.5 第三方库中大尺寸的无用资源同名替换</h3><p>如果在第三方类库中，存在用不到的图片资源文件，可以通过1x1像素的同名图片进行替换。</p>
<h3 id="1-6-使用AndResGuard"><a href="#1-6-使用AndResGuard" class="headerlink" title="1.6 使用AndResGuard"></a>1.6 使用AndResGuard</h3><p><a target="_blank" rel="noopener" href="https://github.com/shwenzhang/AndResGuard">AndResGuard</a>，在gradle文件中就可以直接使用，非常方便。</p>
<h2 id="二、源代码"><a href="#二、源代码" class="headerlink" title="二、源代码"></a>二、源代码</h2><h3 id="2-1-开启混淆"><a href="#2-1-开启混淆" class="headerlink" title="2.1 开启混淆"></a>2.1 开启混淆</h3><p>这是基本操作了，无需多言。</p>
<h3 id="2-2-手动修改开源代码"><a href="#2-2-手动修改开源代码" class="headerlink" title="2.2 手动修改开源代码"></a>2.2 手动修改开源代码</h3><p>将开源代码中我们不需要的类或者方法等删除掉，但是这需要对开源代码非常了解，而且确保版本兼容性，将来开源库升级或者随着我们产品需求变更对开源库的要求也改变了，都会影响对开源库的修改，不建议使用。</p>
<h2 id="三、第三方类库"><a href="#三、第三方类库" class="headerlink" title="三、第三方类库"></a>三、第三方类库</h2><h3 id="3-1-动态库"><a href="#3-1-动态库" class="headerlink" title="3.1 动态库"></a>3.1 动态库</h3><h4 id="3-1-1-删除非必要平台so库"><a href="#3-1-1-删除非必要平台so库" class="headerlink" title="3.1.1 删除非必要平台so库"></a>3.1.1 删除非必要平台so库</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ndk &#123;</span><br><span class="line">  <span class="comment">//设置支持的so库架构</span></span><br><span class="line">  abiFilters <span class="string">&quot;armeabi-v7a&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上，对于手机来说，支持armeabi-v7a就足够了。</p>
<h4 id="3-1-2-动态加载so库"><a href="#3-1-2-动态加载so库" class="headerlink" title="3.1.2 动态加载so库"></a>3.1.2 动态加载so库</h4><p>如果不是一启动应用就需要初始化的so库，完全可以在需要的时候再下载这个so文件，再通过以下代码进行加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  System.loadLibrary(<span class="string">&quot;path/to/lib.so&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h3><p>将不需要在启动就加载的功能模块，通过插件化，在用户使用的时候再从服务器加载。</p>
<h3 id="删除class文件的debug-items"><a href="#删除class文件的debug-items" class="headerlink" title="删除class文件的debug items"></a>删除class文件的debug items</h3><p>不建议使用，这种做法，事倍功半。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-12-13</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 1029 words, 3 min 25 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/11/28/2022-09-17-ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ARouter源码分析</a></h3></div><div class="post-content"><div class="card"><p><p>在阅读源码前，请先下载源码：<a target="_blank" rel="noopener" href="https://github.com/alibaba/ARouter">ARouter</a></p>
<p>最近阅读ARouter源码，发现这真的是一个非常优秀的框架。激发出兴趣来读一下他的源码，实际上，这个框架的结构非常简单。这个框架可以分为<strong>主流程</strong>和<strong>辅助流程</strong>来拆开分析。</p>
<p>主流程包含<strong>编译时</strong>和<strong>运行时</strong>两个部分，其中编译时主要做的是路由路径表的构建，运行时主要做的是路由路径表的加载；</p>
<p>辅助流程主要就是做<strong>启动优化</strong>。</p>
<h2 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h2><h3 id="1-编译时"><a href="#1-编译时" class="headerlink" title="1. 编译时"></a>1. 编译时</h3><p>这部分主要涉及到的是路由路径表的构建，其实现原理是<strong>APT</strong>，即<strong>注解处理器</strong>。</p>
<p>使用ARouter时候，需要在目标类上，通过**@Route<strong>注解进行标记，注解处理器处理的就是这个注解。打开源码路径下的<em>arouter-compiler</em>这个module，找到</strong>RouteProcessor<strong>，这个类就是用来处理</strong>@Route**注解的类。这里需要了解的知识，除了APT，还有java-poet，请自行了解这些。</p>
<p>Processor类的入口方法是<em>process</em>方法，这个方法返回true，则这个处理器已经完成了自己的任务，不会被重复调用。其他比较重要的方法有<em>getSupportedSourceVersion</em>，<em>getSupportedAnnotationTypes</em>等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;? <span class="keyword">extends</span> <span class="title class_">Element</span>&gt; routeElements = roundEnv.getElementsAnnotatedWith(Route.class);</span><br></pre></td></tr></table></figure>

<p>通过这个方法，获取所有被**@Route**标记的元素。</p>
<p>获取到<em>routeElements</em>后，在<em>parseRoutes</em>方法进行处理。我们以最常用的Activity为例，进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rootMap.clear();	<span class="comment">//用来分类存储标记元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来检测元素是否为对应的类型，通过Types.isSubtype()方法来检测。</span></span><br><span class="line"><span class="type">TypeMirror</span> <span class="variable">type_Activity</span> <span class="operator">=</span> elementUtils.getTypeElement(ACTIVITY).asType();</span><br><span class="line"><span class="type">TypeMirror</span> <span class="variable">type_Service</span> <span class="operator">=</span> elementUtils.getTypeElement(SERVICE).asType();</span><br><span class="line"><span class="type">TypeMirror</span> <span class="variable">fragmentTm</span> <span class="operator">=</span> elementUtils.getTypeElement(FRAGMENT).asType();</span><br><span class="line"><span class="type">TypeMirror</span> <span class="variable">fragmentTmV4</span> <span class="operator">=</span> elementUtils.getTypeElement(Consts.FRAGMENT_V4).asType();</span><br></pre></td></tr></table></figure>

<p>最后将分类号的元素信息，存储在成员变量groupMap中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Set&lt;RouteMeta&gt;&gt; groupMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>然后再通过这个groupMap，借助java-poet，来生成真实的类。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ARouter$$Group$$test</span> <span class="keyword">implements</span> <span class="title class_">IRouteGroup</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> &#123;</span><br><span class="line">    atlas.put(<span class="string">&quot;/test/activity1&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, <span class="string">&quot;/test/activity1&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">&quot;ser&quot;</span>, <span class="number">9</span>); put(<span class="string">&quot;ch&quot;</span>, <span class="number">5</span>); put(<span class="string">&quot;fl&quot;</span>, <span class="number">6</span>); put(<span class="string">&quot;dou&quot;</span>, <span class="number">7</span>); put(<span class="string">&quot;boy&quot;</span>, <span class="number">0</span>); put(<span class="string">&quot;url&quot;</span>, <span class="number">8</span>); put(<span class="string">&quot;pac&quot;</span>, <span class="number">10</span>); put(<span class="string">&quot;obj&quot;</span>, <span class="number">11</span>); put(<span class="string">&quot;name&quot;</span>, <span class="number">8</span>); put(<span class="string">&quot;objList&quot;</span>, <span class="number">11</span>); put(<span class="string">&quot;map&quot;</span>, <span class="number">11</span>); put(<span class="string">&quot;age&quot;</span>, <span class="number">3</span>); put(<span class="string">&quot;height&quot;</span>, <span class="number">3</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/test/activity2&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test2Activity.class, <span class="string">&quot;/test/activity2&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">&quot;key1&quot;</span>, <span class="number">8</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/test/activity3&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test3Activity.class, <span class="string">&quot;/test/activity3&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">&quot;name&quot;</span>, <span class="number">8</span>); put(<span class="string">&quot;boy&quot;</span>, <span class="number">0</span>); put(<span class="string">&quot;age&quot;</span>, <span class="number">3</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/test/activity4&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, <span class="string">&quot;/test/activity4&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/test/fragment&quot;</span>, RouteMeta.build(RouteType.FRAGMENT, BlankFragment.class, <span class="string">&quot;/test/fragment&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">&quot;obj&quot;</span>, <span class="number">11</span>); put(<span class="string">&quot;name&quot;</span>, <span class="number">8</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/test/webview&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, TestWebview.class, <span class="string">&quot;/test/webview&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-运行时"><a href="#2-运行时" class="headerlink" title="2. 运行时"></a>2. 运行时</h3><p>这部分主要做的是，在*ARouter.init()*时候，将上过程生成的路径表加载到内存中。</p>
<blockquote>
<p>如果你以官方demo程序验证这一步，需要将app&#x2F;build.gradle中的<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>这一行代码注释掉。</p>
</blockquote>
<p>我们以<em>ARouter.init</em>方法为入口，实际上最终实现init流程的是LogisticsCenter类的<em>init</em>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Context context, ThreadPoolExecutor tpe)</span> <span class="keyword">throws</span> HandlerException &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (registerByPlugin) &#123;</span><br><span class="line">    <span class="comment">//这是在辅助流程需要去讲的</span></span><br><span class="line">  	logger.info(TAG, <span class="string">&quot;Load router map by arouter-auto-register plugin.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Set&lt;String&gt; routerMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It will rebuild router map every times when debuggable.</span></span><br><span class="line">    <span class="keyword">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class="line">      logger.info(TAG, <span class="string">&quot;Run with debug mode or new install, rebuild router map.&quot;</span>);</span><br><span class="line">      <span class="comment">// These class was generated by arouter-compiler.</span></span><br><span class="line">      routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class="line">      <span class="keyword">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class="line">        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      PackageUtils.updateVersion(context);    <span class="comment">// Save new version name when router map update finishes.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      logger.info(TAG, <span class="string">&quot;Load router map from cache.&quot;</span>);</span><br><span class="line">      routerMap = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要着重看的是这一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br></pre></td></tr></table></figure>

<p>我们查看这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title function_">getFileNameByPackageName</span><span class="params">(Context context, <span class="keyword">final</span> String packageName)</span> <span class="keyword">throws</span> PackageManager.NameNotFoundException, IOException, InterruptedException &#123;</span><br><span class="line">  <span class="keyword">final</span> Set&lt;String&gt; classNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; paths = getSourcePaths(context);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">parserCtl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(paths.size());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> String path : paths) &#123;</span><br><span class="line">    Log.v(TAG, <span class="string">&quot;getFileNameByPackageName path=&quot;</span> + path);</span><br><span class="line">    DefaultPoolExecutor.getInstance().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DexFile</span> <span class="variable">dexfile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (path.endsWith(EXTRACTED_SUFFIX)) &#123;</span><br><span class="line">            <span class="comment">//NOT use new DexFile(path), because it will throw &quot;permission error in /data/dalvik-cache&quot;</span></span><br><span class="line">            dexfile = DexFile.loadDex(path, path + <span class="string">&quot;.tmp&quot;</span>, <span class="number">0</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dexfile = <span class="keyword">new</span> <span class="title class_">DexFile</span>(path);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Enumeration&lt;String&gt; dexEntries = dexfile.entries();</span><br><span class="line">          <span class="keyword">while</span> (dexEntries.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> dexEntries.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(packageName)) &#123;</span><br><span class="line">              Log.v(TAG, <span class="string">&quot;find CLASS NAME &quot;</span> + className);</span><br><span class="line">              classNames.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">          Log.e(<span class="string">&quot;ARouter&quot;</span>, <span class="string">&quot;Scan map file in dex files made error.&quot;</span>, ignore);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="literal">null</span> != dexfile) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              dexfile.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          parserCtl.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parserCtl.await();</span><br><span class="line"></span><br><span class="line">  Log.d(Consts.TAG, <span class="string">&quot;Filter &quot;</span> + classNames.size() + <span class="string">&quot; classes by packageName &lt;&quot;</span> + packageName + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> classNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意其中的<em>getSourcePaths</em>方法，这是从代码目录，来获取所有代码目录，然后在</p>
<p><em>getFileNameByPackageName</em>找出以<code>com.alibaba.android.arouter.routes</code>为开头包名的类，这些就是我们在步骤1中生成的辅助类。</p>
<p>这个方法结束后，回到<em>LogisticsCenter#init</em>方法，接下来要做的就是，把加载到的辅助类，通过反射生成对象，再调用其<em>loadTo</em>方法，将路由路径表加载到Warehouse类中去，方便以后的查询。</p>
<h2 id="辅助流程"><a href="#辅助流程" class="headerlink" title="辅助流程"></a>辅助流程</h2><p>在以上的流程中，有一个严重的问题，那就是执行<em>ARouter#init</em>方法的时间过长，以源码的demo为例，在InstantRun的情况下，OnePlus5T需要100多毫秒才能初始化完，这对于程序启动优化来说，是一个不可忽视的时间了。那么如何解决这个问题呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivity: init cost 134</span><br></pre></td></tr></table></figure>

<p>这就是在上一步中，要求你注释掉的代码起作用了，将<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>解除注释，让其发挥作用。</p>
<p>这里需要关注的module是<code>arouter-gradle-plugin</code>。</p>
<p>先来看一下，使用了<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>的神奇效果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivity: init cost 19</span><br></pre></td></tr></table></figure>

<p>通过优化，让<em>ARouter#init</em>消耗时间直接降低了一个数量级，那么<code>arouter-gradle-plugin</code>是怎么做到的呢？</p>
<p>这需要你先了解一下[ASM](&#x2F;android&#x2F;ASM.md)。简单来说，这是一种字节码编程技术，通过修改编译后的字节码的方式，来对原始逻辑增强。</p>
<p>我们再来看<em>ARouter#init</em>的最终实现类和方法<em>LogisticsCenter#init</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Context context, ThreadPoolExecutor tpe)</span> <span class="keyword">throws</span> HandlerException &#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startInit</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//billy.qi modified at 2017-12-06</span></span><br><span class="line">    <span class="comment">//load by plugin first</span></span><br><span class="line">    loadRouterMap();</span><br><span class="line">    <span class="keyword">if</span> (registerByPlugin) &#123;</span><br><span class="line">      logger.info(TAG, <span class="string">&quot;Load router map by arouter-auto-register plugin.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HandlerException</span>(TAG + <span class="string">&quot;ARouter init logistics center exception! [&quot;</span> + e.getMessage() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，当<code>registerByPlugin</code>为true的时候，则只是打印了一句日志，我们再看loadRouterMap()这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadRouterMap</span><span class="params">()</span> &#123;</span><br><span class="line">  registerByPlugin = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//auto generate register code by gradle plugin: arouter-auto-register</span></span><br><span class="line">  <span class="comment">// looks like below:</span></span><br><span class="line">  <span class="comment">// registerRouteRoot(new ARouter..Root..modulejava());</span></span><br><span class="line">  <span class="comment">// registerRouteRoot(new ARouter..Root..modulekotlin());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑非常简单，到底在哪里去加载的路由路径表呢？我们看这个方法的注释，发现，这个方法是被<code>arouter-auto-register</code>自动生成的。</p>
<p>我们打开<code>arouter-gradle-plugin/resources/META-INF/gradle-plugins</code>这个目录，可以看到，有一个<em>com.alibaba.arouter.properties</em>文件，查看其内容：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">implementation-class</span>=<span class="string">com.alibaba.android.arouter.register.launch.PluginLaunch</span></span><br></pre></td></tr></table></figure>

<p>这个<em>PluginLaunch</em>便是此gradle plugin的入口类。查看此类：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PluginLaunch</span> <span class="keyword">implements</span> <span class="title class_">Plugin</span>&lt;Project&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">void</span> apply(Project project) &#123;</span><br><span class="line">    <span class="keyword">def</span> isApp = project.plugins.hasPlugin(AppPlugin)</span><br><span class="line">    <span class="comment">//only application module needs this plugin to generate register code</span></span><br><span class="line">    <span class="keyword">if</span> (isApp) &#123;</span><br><span class="line">      Logger.make(project)</span><br><span class="line"></span><br><span class="line">      Logger.i(<span class="string">&#x27;Project enable arouter-register plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">def</span> android = project.extensions.getByType(AppExtension)</span><br><span class="line">      <span class="keyword">def</span> transformImpl = <span class="keyword">new</span> RegisterTransform(project)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//init arouter-auto-register settings</span></span><br><span class="line">      ArrayList&lt;ScanSetting&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>)</span><br><span class="line">      list.add(<span class="keyword">new</span> ScanSetting(<span class="string">&#x27;IRouteRoot&#x27;</span>))</span><br><span class="line">      list.add(<span class="keyword">new</span> ScanSetting(<span class="string">&#x27;IInterceptorGroup&#x27;</span>))</span><br><span class="line">      list.add(<span class="keyword">new</span> ScanSetting(<span class="string">&#x27;IProviderGroup&#x27;</span>))</span><br><span class="line">      RegisterTransform.registerList = list</span><br><span class="line">      <span class="comment">//register this plugin</span></span><br><span class="line">      android.registerTransform(transformImpl)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看其代码，可以发现，这里一共做了三件事：</p>
<ol>
<li>判断是否为app module，如果不是，则不做任何事，在app module下做2和3两步；</li>
<li>生成了一个RegisterTransform，并为其静态变量registerList赋值，<strong>注意此处赋值的registerList中包含的三个对象</strong>；</li>
<li>注册此RegisterTransform。</li>
</ol>
<p>接下来，就轮到<em>RegisterTransform</em>来执行了。</p>
<p>Transform类，简单来说，就是可以在编译时，扫描所有的jar和class，包括引用类库中的。在扫描过程中，就可以借助<strong>ASM</strong>技术对目标类进行更改。</p>
<p>我们看其入口方法<em>transform</em>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="type">void</span> transform(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, <span class="type">boolean</span> isIncremental) <span class="keyword">throws</span> IOException, TransformException, InterruptedException &#123;</span><br><span class="line">  inputs.each &#123; TransformInput input -&gt;</span><br><span class="line">    <span class="comment">// scan all jars</span></span><br><span class="line">    input.jarInputs.each &#123; JarInput jarInput -&gt;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (ScanUtil.shouldProcessPreDexJar(src.absolutePath)) &#123;</span><br><span class="line">        ScanUtil.scanJar(src, dest)</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt;</span><br><span class="line">    ...</span><br><span class="line">    directoryInput.file.eachFileRecurse &#123; File file -&gt;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span>(file.isFile() &amp;&amp; ScanUtil.shouldProcessClass(path))&#123;</span><br><span class="line">        ScanUtil.scanClass(file)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>省去了一些细节，只保留了主线逻辑，我们可以看到，其扫描到的jar和class都经过了ScanUtils的方法来处理，我们继续跟踪下去，会发现，<em>scanJar</em>也是循环调用的<em>scanClass</em>，这样我们直接看<em>scanClass</em>方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> scanClass(InputStream inputStream) &#123;</span><br><span class="line">  ClassReader cr = <span class="keyword">new</span> ClassReader(inputStream)</span><br><span class="line">  ClassWriter cw = <span class="keyword">new</span> ClassWriter(cr, <span class="number">0</span>)</span><br><span class="line">  ScanClassVisitor cv = <span class="keyword">new</span> ScanClassVisitor(Opcodes.ASM5, cw)</span><br><span class="line">  cr.accept(cv, ClassReader.EXPAND_FRAMES)</span><br><span class="line">  inputStream.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ScanClassVisitor</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">  ScanClassVisitor(<span class="type">int</span> api, ClassVisitor cv) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(api, cv)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> visit(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature,</span><br><span class="line">             String superName, String[] interfaces) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.visit(version, access, name, signature, superName, interfaces)</span><br><span class="line">    RegisterTransform.registerList.each &#123; ext -&gt;</span><br><span class="line">      <span class="keyword">if</span> (ext.interfaceName &amp;&amp; interfaces != <span class="literal">null</span>) &#123;</span><br><span class="line">        interfaces.each &#123; itName -&gt;</span><br><span class="line">          <span class="keyword">if</span> (itName == ext.interfaceName) &#123;</span><br><span class="line">            <span class="comment">//fix repeated inject init code when Multi-channel packaging</span></span><br><span class="line">            <span class="keyword">if</span> (!ext.classList.contains(name)) &#123;</span><br><span class="line">              ext.classList.add(name)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就又涉及到了ASM的知识，ScanClassVisitor是访问某个类的内部结构。</p>
<blockquote>
<p>version：类的版本；</p>
<p>access：表示类的访问权限，public，private，protected等；</p>
<p>name：类的名字；</p>
<p>signature：有无泛型；</p>
<p>superName：其父类；</p>
<p>interfaces：其实现的接口；</p>
</blockquote>
<p>在<em>ScanClassVisitor</em>中，并没有对类做修改，只是从遍历过的类中，把我们关心的类挑出来。那么，我们关心哪些类呢？</p>
<p>在<em>PluginLaunch</em>类中，我们注册了三个<em>ScanSettings</em>类，分别是<strong>IRouteRoot</strong>、<strong>IInterceptorGroup</strong>和<strong>IProviderGroup</strong>，也就是说，我们把实现了这三个接口的类，挑出来，加入到各自对应的ScanSettings类中记录起来。这三个接口是不是很熟悉？就是通过APT生成的用来记录路由路径表的类。</p>
<p>等收集好了这些记录的路径表信息后，就可以对<em>LogisticsCenter</em>通过ASM进行修改了。我们接着看<em>RegisterTransform#transform</em>方法中剩下的逻辑。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fileContainsInitClass) &#123;</span><br><span class="line">  registerList.each &#123; ext -&gt;</span><br><span class="line">    Logger.i(<span class="string">&#x27;Insert register code to file &#x27;</span> + fileContainsInitClass.absolutePath)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ext.classList.isEmpty()) &#123;</span><br><span class="line">      Logger.e(<span class="string">&quot;No class implements found for interface:&quot;</span> + ext.interfaceName)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ext.classList.each &#123;</span><br><span class="line">        Logger.i(it)</span><br><span class="line">      &#125;</span><br><span class="line">      RegisterCodeGenerator.insertInitCodeTo(ext)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意此处的insertInitCodeTo方法，这就是ASM修改的入口了。这里不对修改过程进行详细解释了。我们直接对比看<em>LogisticsCenter</em>修改前后关键代码的对比。</p>
<p>在<em>app&#x2F;build</em>目录下，找到生成的apk文件，通过AndroidStudio来查看其中的class，找到关键<em>LogisticsCenter</em>关键方法<em>loadRouterMap</em>。</p>
<blockquote>
<p>具体过程如下：</p>
<p>app&#x2F;build&#x2F;outputs&#x2F;apk&#x2F;debug&#x2F;app-debug.apk -&gt; classes.dex(双击) -&gt; 找到<em>LogisticsCenter#loadRouterMap</em>方法 -&gt; 右键: show Bytecode。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用apply plugin: &#x27;com.alibaba.arouter&#x27;</span></span><br><span class="line">.method <span class="keyword">private</span> <span class="keyword">static</span> <span class="title function_">loadRouterMap</span><span class="params">()</span>V</span><br><span class="line">    .registers <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">64</span></span><br><span class="line">    const/<span class="number">4</span> v0, <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">    sput-<span class="type">boolean</span> v0, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;registerByPlugin:Z</span><br><span class="line"></span><br><span class="line">    .line <span class="number">69</span></span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用apply plugin: &#x27;com.alibaba.arouter&#x27;</span></span><br><span class="line">.method <span class="keyword">private</span> <span class="keyword">static</span> <span class="title function_">loadRouterMap</span><span class="params">()</span>V</span><br><span class="line">    .registers <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    .line <span class="number">64</span></span><br><span class="line">    const/<span class="number">4</span> v0, <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">    sput-<span class="type">boolean</span> v0, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;registerByPlugin:Z</span><br><span class="line"></span><br><span class="line">    .line <span class="number">69</span></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$modulejava&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$modulekotlin&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$arouterapi&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$app&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Interceptors$$modulejava&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Interceptors$$app&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$modulejava&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$modulekotlin&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$arouterapi&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    const-string v0, <span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$app&quot;</span></span><br><span class="line"></span><br><span class="line">    invoke-<span class="keyword">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p>对比发现，使用<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>后，这个方法增加了很多代码，基本上就是在加载路由路径表。使用这个gradle插件的基本思想就是，将查找路由路径表的过程，从<strong>运行时</strong>提前到了<strong>编译时</strong>，这算是一种AOT(Ahead of time)思想。</p>
<p>将最耗时的查找过程提前，也就解决了ARouter初始化时间过长的问题。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-11-28</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 3382 words, 11 min 16 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/11/23/2022-09-19-ASM/">ASM库介绍与使用</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/905be2a9a700">原文</a></p>
</blockquote>
<p>前面几篇文章介绍了 .class 文件的结构、JVM 如何加载 .class 文件、JVM 中如何执行方法的调用和访问者模式，其实前面几篇文章都是为这篇文章做铺垫的，如果不知道 .class 文件结构、也不知道在 JVM 中 .class 文件中的方法是如何被执行的，这篇文章中的有些部分可能会看不懂，所以推荐先看下前面几篇文章。<br> 这篇文章主要介绍 ASM 库的结构、主要的 API，并且通过两个示例说明如何通过 ASM 修改 .class 文件中的方法和属性。</p>
<p><img src="/images/ezgif-6-73b502b11e16.jpg" alt="img"></p>
<p>catalog.png</p>
<h3 id="一-ASM-的结构"><a href="#一-ASM-的结构" class="headerlink" title="一. ASM 的结构"></a>一. ASM 的结构</h3><p>ASM 库是一款基于 Java 字节码层面的代码分析和修改工具。ASM 可以直接生产二进制的 class 文件，也可以在类被加载入 JVM 之前动态修改类行为。<br> ASM 库的结构如下所示：</p>
<p><img src="/images/4179925-d4f950ec94a12cde.webp" alt="img"></p>
<p>asm_arch.png</p>
<ul>
<li>Core：为其他包提供基础的读、写、转化Java字节码和定义的API，并且可以生成Java字节码和实现大部分字节码的转换，在 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4b8cb0b3204">访问者模式和 ASM</a> 中介绍的几个重要的类就在 Core API 中：ClassReader、ClassVisitor 和 ClassWriter 类.</li>
<li>Tree：提供了 Java 字节码在内存中的表现</li>
<li>Commons：提供了一些常用的简化字节码生成、转换的类和适配器</li>
<li>Util：包含一些帮助类和简单的字节码修改类，有利于在开发或者测试中使用</li>
<li>XML：提供一个适配器将XML和SAX-comliant转化成字节码结构，可以允许使用XSLT去定义字节码转化</li>
</ul>
<h3 id="二-Core-API-介绍"><a href="#二-Core-API-介绍" class="headerlink" title="二. Core API 介绍"></a>二. Core API 介绍</h3><h4 id="2-1-ClassVisitor-抽象类"><a href="#2-1-ClassVisitor-抽象类" class="headerlink" title="2.1 ClassVisitor 抽象类"></a>2.1 ClassVisitor 抽象类</h4><p>如下所示，在 ClassVisitor 中提供了和类结构同名的一些方法，这些方法会对类中相应的部分进行操作，而且是有顺序的：visit [ visitSource ] [ visitOuterClass ] ( visitAnnotation | visitAttribute )* (visitInnerClass | visitField | visitMethod )* visitEnd</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature, String superName, String[] interfaces)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitSource</span><span class="params">(String source, String debug)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitOuterClass</span><span class="params">(String owner, String name, String desc)</span>;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class="params">(String desc, <span class="type">boolean</span> visible)</span>;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitTypeAnnotation</span><span class="params">(<span class="type">int</span> typeRef, TypePath typePath, String desc, <span class="type">boolean</span> visible)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitAttribute</span><span class="params">(Attribute attr)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInnerClass</span><span class="params">(String name, String outerName, String innerName, <span class="type">int</span> access)</span>;</span><br><span class="line">    <span class="keyword">public</span> FieldVisitor <span class="title function_">visitField</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, Object value)</span>;</span><br><span class="line">    <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, String[] exceptions)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>void visit(int version, int access, String name, String signature, String superName, String[] interfaces)<br> 该方法是当扫描类时第一个调用的方法，主要用于类声明使用。下面是对方法中各个参数的示意：visit( 类版本 , 修饰符 , 类名 , 泛型信息 , 继承的父类 , 实现的接口)</li>
<li>AnnotationVisitor visitAnnotation(String desc, boolean visible)<br> 该方法是当扫描器扫描到类注解声明时进行调用。下面是对方法中各个参数的示意：visitAnnotation(注解类型 , 注解是否可以在 JVM 中可见)。</li>
<li>FieldVisitor visitField(int access, String name, String desc, String signature, Object value)<br> 该方法是当扫描器扫描到类中字段时进行调用。下面是对方法中各个参数的示意：visitField(修饰符 , 字段名 , 字段类型 , 泛型描述 , 默认值)</li>
<li>MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions)<br> 该方法是当扫描器扫描到类的方法时进行调用。下面是对方法中各个参数的示意：visitMethod(修饰符 , 方法名 , 方法签名 , 泛型信息 , 抛出的异常)</li>
<li>void visitEnd()<br> 该方法是当扫描器完成类扫描时才会调用，如果想在类中追加某些方法</li>
</ol>
<h4 id="2-2-ClassReader-类"><a href="#2-2-ClassReader-类" class="headerlink" title="2.2 ClassReader 类"></a>2.2 ClassReader 类</h4><p>这个类会将 .class 文件读入到 ClassReader 中的字节数组中，它的 accept 方法接受一个 ClassVisitor 实现类，并按照顺序调用 ClassVisitor 中的方法</p>
<h4 id="2-3-ClassWriter-类"><a href="#2-3-ClassWriter-类" class="headerlink" title="2.3 ClassWriter 类"></a>2.3 ClassWriter 类</h4><p>ClassWriter 是一个 ClassVisitor 的子类，是和 ClassReader 对应的类，ClassReader 是将 .class 文件读入到一个字节数组中，ClassWriter 是将修改后的类的字节码内容以字节数组的形式输出。</p>
<h4 id="2-4-MethodVisitor-amp-AdviceAdapter"><a href="#2-4-MethodVisitor-amp-AdviceAdapter" class="headerlink" title="2.4 MethodVisitor &amp; AdviceAdapter"></a>2.4 MethodVisitor &amp; AdviceAdapter</h4><p>MethodVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Method 时就转入 MethodVisitor 接口处理。<br> AdviceAdapter 是 MethodVisitor 的子类，使用 AdviceAdapter 可以更方便的修改方法的字节码。<br> AdviceAdapter 的方法如下所示：</p>
<p><img src="/images/4179925-f5a428b729962860.webp" alt="img"></p>
<p>AdviceAdapter.png</p>
<p>其中比较重要的几个方法如下：</p>
<ol>
<li>void visitCode()：表示 ASM 开始扫描这个方法</li>
<li>void onMethodEnter()：进入这个方法</li>
<li>void onMethodExit()：即将从这个方法出去</li>
<li>void onVisitEnd()：表示方法扫码完毕</li>
</ol>
<h4 id="2-5-FieldVisitor-抽象类"><a href="#2-5-FieldVisitor-抽象类" class="headerlink" title="2.5 FieldVisitor 抽象类"></a>2.5 FieldVisitor 抽象类</h4><p>FieldVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Field 时就转入 FieldVisitor 接口处理。和分析 MethodVisitor 的方法一样，也可以查看源码注释进行学习，这里不再详细介绍</p>
<h4 id="2-6-操作流程"><a href="#2-6-操作流程" class="headerlink" title="2.6 操作流程"></a>2.6 操作流程</h4><ol>
<li>需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中</li>
<li>然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写</li>
<li>需要事件过滤器 ClassVisitor。在调用 ClassVisitor 的某些方法时会产生一个新的 XXXVisitor 对象，当我们需要修改对应的内容时只要实现自己的 XXXVisitor 并返回就可以了</li>
</ol>
<h3 id="三-示例"><a href="#三-示例" class="headerlink" title="三. 示例"></a>三. 示例</h3><h4 id="3-1-修改类中方法的字节码"><a href="#3-1-修改类中方法的字节码" class="headerlink" title="3.1 修改类中方法的字节码"></a>3.1 修改类中方法的字节码</h4><p>假如现在我们有一个 HelloWorld 类，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lijiankun24.asmpractice.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>javac HelloWorld.java</code> 和 <code>javap -verbose HelloWorld.class</code> 可以查看到 sayName() 方法的字节码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: ldc2_w        #<span class="number">2</span>                  <span class="comment">// long 2000l</span></span><br><span class="line">       <span class="number">3</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method java/lang/Thread.sleep:(J)V</span></span><br><span class="line">       <span class="number">6</span>: <span class="keyword">goto</span>          <span class="number">14</span></span><br><span class="line">       <span class="number">9</span>: astore_1</span><br><span class="line">      <span class="number">10</span>: aload_1</span><br><span class="line">      <span class="number">11</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/InterruptedException.printStackTrace:()V</span></span><br><span class="line">      <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">6</span>     <span class="number">9</span>   Class java/lang/InterruptedException</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">8</span>: <span class="number">6</span></span><br><span class="line">      line <span class="number">6</span>: <span class="number">9</span></span><br><span class="line">      line <span class="number">7</span>: <span class="number">10</span></span><br><span class="line">      line <span class="number">9</span>: <span class="number">14</span></span><br><span class="line">    StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">      frame_type = <span class="number">73</span> <span class="comment">/* same_locals_1_stack_item */</span></span><br><span class="line">        stack = [ <span class="keyword">class</span> java/lang/InterruptedException ]</span><br><span class="line">      frame_type = <span class="number">4</span> <span class="comment">/* same */</span></span><br></pre></td></tr></table></figure>

<p>我们通过 ASM 修改 HelloWorld.class 字节码文件，实现统计方法执行时间的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CostTime</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        redefinePersonClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">redefinePersonClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.lijiankun24.asmpractice.demo.HelloWorld&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lijiankun/Desktop/HelloWorld.class&quot;</span>);</span><br><span class="line">            <span class="type">ClassReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(inputStream);                               <span class="comment">// 1. 创建 ClassReader 读入 .class 文件到内存中</span></span><br><span class="line">            <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(reader, ClassWriter.COMPUTE_MAXS);                 <span class="comment">// 2. 创建 ClassWriter 对象，将操作之后的字节码的字节数组回写</span></span><br><span class="line">            <span class="type">ClassVisitor</span> <span class="variable">change</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeVisitor</span>(writer);                                        <span class="comment">// 3. 创建自定义的 ClassVisitor 对象</span></span><br><span class="line">            reader.accept(change, ClassReader.EXPAND_FRAMES);                                       <span class="comment">// 4. 将 ClassVisitor 对象传入 ClassReader 中</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>().defineClass(className, writer.toByteArray());</span><br><span class="line">            <span class="type">Object</span> <span class="variable">personObj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">nameMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">            nameMethod.invoke(personObj, <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] code = writer.toByteArray();                                                               <span class="comment">// 获取修改后的 class 文件对应的字节数组</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/lijiankun/Desktop/HelloWorld2.class&quot;</span>);    <span class="comment">// 将二进制流写到本地磁盘上</span></span><br><span class="line">                fos.write(code);</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;Failure!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChangeVisitor</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">        ChangeVisitor(ClassVisitor classVisitor) &#123;</span><br><span class="line">            <span class="built_in">super</span>(Opcodes.ASM5, classVisitor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;</span><br><span class="line">            <span class="type">MethodVisitor</span> <span class="variable">methodVisitor</span> <span class="operator">=</span> <span class="built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> methodVisitor;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChangeAdapter</span>(Opcodes.ASM4, methodVisitor, access, name, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChangeAdapter</span> <span class="keyword">extends</span> <span class="title class_">AdviceAdapter</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">startTimeId</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        ChangeAdapter(<span class="type">int</span> api, MethodVisitor mv, <span class="type">int</span> access, String name, String desc) &#123;</span><br><span class="line">            <span class="built_in">super</span>(api, mv, access, name, desc);</span><br><span class="line">            methodName = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMethodEnter</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onMethodEnter();</span><br><span class="line">            startTimeId = newLocal(Type.LONG_TYPE);</span><br><span class="line">            mv.visitMethodInsn(INVOKESTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;currentTimeMillis&quot;</span>, <span class="string">&quot;()J&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitIntInsn(LSTORE, startTimeId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMethodExit</span><span class="params">(<span class="type">int</span> opcode)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onMethodExit(opcode);</span><br><span class="line">            <span class="type">int</span> <span class="variable">durationId</span> <span class="operator">=</span> newLocal(Type.LONG_TYPE);</span><br><span class="line">            mv.visitMethodInsn(INVOKESTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;currentTimeMillis&quot;</span>, <span class="string">&quot;()J&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitVarInsn(LLOAD, startTimeId);</span><br><span class="line">            mv.visitInsn(LSUB);</span><br><span class="line">            mv.visitVarInsn(LSTORE, durationId);</span><br><span class="line">            mv.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class="line">            mv.visitTypeInsn(NEW, <span class="string">&quot;java/lang/StringBuilder&quot;</span>);</span><br><span class="line">            mv.visitInsn(DUP);</span><br><span class="line">            mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitLdcInsn(<span class="string">&quot;The cost time of &quot;</span> + methodName + <span class="string">&quot; is &quot;</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitVarInsn(LLOAD, durationId);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(J)Ljava/lang/StringBuilder;&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下图所示</p>
<p><img src="/images/4179925-32ee7bd0974a4679.webp" alt="img"></p>
<p>Class.png</p>
<p>反编译 HelloWorld2.class 文件的内容如下所示</p>
<p><img src="/images/4179925-af582100631d7eec.webp" alt="img"></p>
<p>Class1.png</p>
<h4 id="3-2-修改类中属性的字节码"><a href="#3-2-修改类中属性的字节码" class="headerlink" title="3.2 修改类中属性的字节码"></a>3.2 修改类中属性的字节码</h4><p>这一节中我们将展示一下如何使用 Core API 对类中的属性进行操作。</p>
<p>假如说，现在有一个 Person.java 类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想为这个类，添加一个 ‘public int age’ 的属性该怎么添加呢？我们会面对两个问题：</p>
<ol>
<li>该调用 ASM 的哪个 API 添加属性呢？</li>
<li>在何时写添加属性的代码？</li>
</ol>
<p>接下来，我们就一一解决上面的两个问题？</p>
<h5 id="3-2-1-添加属性的-API"><a href="#3-2-1-添加属性的-API" class="headerlink" title="3.2.1 添加属性的 API"></a>3.2.1 添加属性的 API</h5><p>按照我们分析的上述的 2.6 操作流程叙述，需要以下三个步骤：</p>
<ol>
<li>需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中</li>
<li>然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写</li>
<li>需要创建一个事件过滤器 ClassVisitor。事件过滤器中的某些方法可以产生一个新的XXXVisitor对象，当我们需要修改对应的内容时只要实现自己的XXXVisitor并返回就可以了</li>
</ol>
<p>在上面三个步骤中，可以操作的就是 ClassVisitor 了。ClassVisitor 接口提供了和类结构同名的一些方法，这些方法可以对相应的类结构进行操作。</p>
<p>在使用 ClassVisitor 添加类属性的时候，只需要添加一句话就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classVisitor.visitField(Opcodes.ACC_PUBLIC, <span class="string">&quot;age&quot;</span>, Type.getDescriptor(<span class="type">int</span>.class), <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/4179925-8c703df0b005aae7.webp" alt="img"></p>
<p>visitField.png</p>
<h5 id="3-2-2-添加属性的时机"><a href="#3-2-2-添加属性的时机" class="headerlink" title="3.2.2 添加属性的时机"></a>3.2.2 添加属性的时机</h5><p>我们先暂且在 ClassVisitor 的 visitEnd() 方法中写入上面的代码，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transform</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Transform</span><span class="params">(ClassVisitor cv)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(cv);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span> &#123;  </span><br><span class="line">        cv.visitField(Opcodes.ACC_PUBLIC, <span class="string">&quot;age&quot;</span>, Type.getDescriptor(<span class="type">int</span>.class), <span class="literal">null</span>, <span class="literal">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们写如下的测试类，测试一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldPractice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        addAgeField();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addAgeField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lijiankun/Desktop/Person.class&quot;</span>);</span><br><span class="line">            <span class="type">ClassReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(inputStream);</span><br><span class="line"></span><br><span class="line">            <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line"></span><br><span class="line">            <span class="type">ClassVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transform</span>(writer);</span><br><span class="line">            reader.accept(visitor, ClassReader.SKIP_DEBUG);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] classFile = writer.toByteArray();</span><br><span class="line">            <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.defineClass(<span class="string">&quot;Person&quot;</span>, classFile);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>).get(obj)); <span class="comment">//----(1)</span></span><br><span class="line">            System.out.println(clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>).get(obj));  <span class="comment">//----(2)</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出入下所示：</p>
<p><img src="/images/4179925-a718d240e05a2198.webp" alt="img"></p>
<p>visitFieldResult.png</p>
<p>那如果我们尝试在 ClassVisitor#visitField() 方法中添加属性可以吗？我们可以修改 Transform 测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transform</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    Transform(ClassVisitor classVisitor) &#123;</span><br><span class="line">        <span class="built_in">super</span>(Opcodes.ASM5, classVisitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FieldVisitor <span class="title function_">visitField</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, Object value)</span> &#123;</span><br><span class="line">        cv.visitField(Opcodes.ACC_PUBLIC, <span class="string">&quot;age&quot;</span>, Type.getDescriptor(<span class="type">int</span>.class), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visitField(access, name, desc, signature, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是使用上面的测试代码测试一下，会有如下的测试结果</p>
<p><img src="/images/4179925-e2e730e41623be28.webp" alt="img"></p>
<p>visitFieldError.png</p>
<p>在 Person 类中有重复的属性，为什么会报这个错误呢？</p>
<p>分析 ClassVisitor#visitField() 方法可得知，只要访问类中的一个属性，visitField() 方法就会被调用一次，在 Person 类中有两个属性，所以 visitField() 方法就会被调用两次，也就添加了两次 ‘public int age’ 属性，就报了上述的错误，而 visitEnd() 方法只有在最后才会被调用且只调用一次，所以在 visitEnd() 方法中是添加属性的最佳时机</p>
<h4 id="3-3-ASMifier"><a href="#3-3-ASMifier" class="headerlink" title="3.3 ASMifier"></a>3.3 ASMifier</h4><p>可能有人会问，我刚开始学，上面例子中那些 ASM 的代码我还不会写，怎么办呢？ASM 官方为我们提供了 <a target="_blank" rel="noopener" href="https://asm.ow2.io/#Q10">ASMifier</a>，可以帮助我们生成这些晦涩难懂的 ASM 代码。</p>
<p>比如，我想通过 ASM 实现统计一个方法的执行时间，该怎么做呢？一般会有如下的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.lijiankun24.classpractice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">costTime</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="built_in">long</span> duration = System.currentTimeMillis() - startTime;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;The cost time of this method is &quot;</span> + duration + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那上面这段代码对应的 ASM 代码是什么呢？我们可以通过以下两个步骤，使用 ASMifier 自动生成：</p>
<ol>
<li>通过 <code>javac</code> 编译该 <code>Demo.java</code> 文件生成对应的 <code>Demo.class</code> 文件，如下所示</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Demo<span class="selector-class">.java</span></span><br></pre></td></tr></table></figure>

<ol>
<li>通过 ASMifier 自动生成对应的 ASM 代码。首先需要在<a target="_blank" rel="noopener" href="https://asm.ow2.io/#Q10">ASM官网</a> 下载 <code>asm-all.jar</code> 库，我下载的是最新的 <code>asm-all-5.2.jar</code>，然后使用如下命令，即可生成</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath asm-all-<span class="number">5.2</span>.jar org.objectweb.asm.util.ASMifier Demo.class</span><br></pre></td></tr></table></figure>

<p>截图如下：</p>
<p><img src="/images/4179925-0cc8712718f08ea0.webp" alt="img"></p>
<p>DemoDump.png</p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/ta8210/blog/163550">深入字节码 – 玩转 ASM-Bytecode 原 荐</a><br> <a target="_blank" rel="noopener" href="http://www.easemob.com/news/729">美团热更方案ASM实践</a></p>
<p>43人点赞</p>
<p><a href="">Java 相关</a></p>
<p>作者：lijiankun24<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/905be2a9a700">https://www.jianshu.com/p/905be2a9a700</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-11-23</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 3199 words, 10 min 39 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/11/03/2022-09-17-LeakCanary%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">LeakCanary原理分析</a></h3></div><div class="post-content"><div class="card"><p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="comment">// debugImplementation because LeakCanary should only run in debug builds.</span></span><br><span class="line">  debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.5&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要这样简单配置，就能接入LeakCanary内存泄漏分析，到底是怎样做到的？</p>
<p>我们将这个问题分成两个问题：</p>
<ol>
<li>如何<strong>自动</strong>进行初始化的；</li>
<li>如何检测到内存泄漏的。</li>
</ol>
<h2 id="如何自动进行初始化的"><a href="#如何自动进行初始化的" class="headerlink" title="如何自动进行初始化的"></a>如何自动进行初始化的</h2><p>这部分，我们可以分成两部分去理解——<strong>自动</strong>和<strong>初始化</strong>。</p>
<h3 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h3><p>这一切还要从<code>ActivityThread</code>说起。<code>ActivityThread</code>中，执行了一些应用启动的初始化工作，在<code>ActivityThread</code>源码中，我们可以看到其内部类<code>class H extends Handler</code>的<code>handleMessage</code>方法中，有很多与应用相关的一些基本操作，比如<strong>BIND_APPLICATION</strong>, <strong>EXIT_APPLICATION</strong>, <strong>CREATE_SERVICE</strong>, <strong>BIND_SERVICE</strong>等，其中需要我们关注的是<strong>BIND_APPLICATION</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">                    <span class="type">AppBindData</span> <span class="variable">data</span> <span class="operator">=</span> (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ....</span><br><span class="line">            &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，其中调用了<code>handleBindApplication</code>方法。进入这个方法查看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindApplication</span><span class="params">(AppBindData data)</span> &#123;</span><br><span class="line">  ....</span><br><span class="line">  Application app;</span><br><span class="line">  <span class="keyword">final</span> StrictMode.<span class="type">ThreadPolicy</span> <span class="variable">savedPolicy</span> <span class="operator">=</span> StrictMode.allowThreadDiskWrites();</span><br><span class="line">  <span class="keyword">final</span> StrictMode.<span class="type">ThreadPolicy</span> <span class="variable">writesAllowedPolicy</span> <span class="operator">=</span> StrictMode.getThreadPolicy();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class="line">    <span class="comment">// a restricted environment with the base application class.</span></span><br><span class="line">    app = data.info.makeApplication(data.restrictedBackupMode, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// Propagate autofill compat state</span></span><br><span class="line">    app.setAutofillOptions(data.autofillOptions);</span><br><span class="line">    <span class="comment">// Propagate Content Capture options</span></span><br><span class="line">    app.setContentCaptureOptions(data.contentCaptureOptions);</span><br><span class="line">    mInitialApplication = app;</span><br><span class="line">    <span class="comment">// don&#x27;t bring up providers in restricted mode; they may depend on the</span></span><br><span class="line">    <span class="comment">// app&#x27;s custom Application class</span></span><br><span class="line">    <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">        installContentProviders(app, data.providers);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class="line">    <span class="comment">// test thread at this point, and we don&#x27;t want that racing.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">        <span class="string">&quot;Exception thrown in onCreate() of &quot;</span></span><br><span class="line">        + data.instrumentationName + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">          <span class="string">&quot;Unable to create application &quot;</span> + app.getClass().getName()</span><br><span class="line">          + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// If the app targets &lt; O-MR1, or doesn&#x27;t change the thread policy</span></span><br><span class="line">    <span class="comment">// during startup, clobber the policy to maintain behavior of b/36951662</span></span><br><span class="line">    <span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class="line">        || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class="line">      StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个方法中，我们可以找到这样一段代码，需要重点关注的是，<code>ContentProvider</code>的初始化是先于<code>Application.onCreate</code>的，且是被<code>ActivityThread</code><strong>自动</strong>执行的。</p>
<p>接下来再看LeakCanary源码。找到<a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt"><strong>AppWatcherInstaller.kt</strong></a>这个类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Content providers are loaded before the application class is created. [AppWatcherInstaller] is</span></span><br><span class="line"><span class="comment"> * used to install [leakcanary.AppWatcher] on application start.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">AppWatcherInstaller</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">MainProcess</span> : <span class="type">AppWatcherInstaller</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span></span><br><span class="line"><span class="comment">   * [LeakCanaryProcess] automatically sets up the LeakCanary code</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LeakCanaryProcess</span> : <span class="type">AppWatcherInstaller</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    AppWatcher.manualInstall(application)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">query</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    uri: <span class="type">Uri</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    strings: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?,</span></span></span><br><span class="line"><span class="params"><span class="function">    s: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    strings1: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?,</span></span></span><br><span class="line"><span class="params"><span class="function">    s1: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: Cursor? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(uri: <span class="type">Uri</span>)</span></span>: String? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    uri: <span class="type">Uri</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentValues: <span class="type">ContentValues</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: Uri? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    uri: <span class="type">Uri</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    s: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    strings: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    uri: <span class="type">Uri</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentValues: <span class="type">ContentValues</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    s: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    strings: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;?</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这个类是一个<code>ContentProvider</code>的子类，其query, insert等方法根本没有实际作用，有实际作用的只有<code>onCreate</code>方法，在这个方法中，执行了<code>AppWatcher</code>的install工作。</p>
<p>这里我们就可以看出来，LeakCanary就是利用<code>ContentProvider</code>的<code>onCreate</code>方法自动执行的特性，来自动“安装”这个类库的。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>通过追踪<code>AppWatcher.manualInstall(application)</code>这句代码，我们可以追踪到<a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/blob/main/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt"><strong>InternalLeakCanary.kt</strong></a>的<code>install</code>方法，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">  checkMainThread()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>::application.isInitialized) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  InternalAppWatcher.application = application</span><br><span class="line">  <span class="keyword">if</span> (isDebuggableBuild) &#123;</span><br><span class="line">    SharkLog.logger = DefaultCanaryLog()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> configProvider = &#123; AppWatcher.config &#125;</span><br><span class="line">  ActivityDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">  FragmentDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">  onAppWatcherInstalled(application)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，先后执行了<code>ActivityDestroyWatcher.install</code>,<code>FragmentDestroyWatcher.install</code>和<code>onAppWatcherInstalled(application)</code>方法。</p>
<p>其中在<code>onAppWatcherInstalled</code>创建了LeakCanary图标的快捷方式，用于方便查看内存泄漏的路径信息。最终实现的具体过程可以查看<a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/blob/main/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt"><strong>InternalLeakCanary.kt</strong></a>的<code>addDynamicShortcut</code>方法。</p>
<p>其他的两段代码——<code>ActivityDestroyWatcher.install</code>和<code>FragmentDestroyWatcher.install</code>，分别对应着两个类——<code>ActivityDestroyWatcher</code>和<code>FragmentDestroyWatcher</code>。这两个类相对来说比较简单，主要工作就是执行了<code>application.registerActivityLifecycleCallbacks</code>这段代码，目的是为了监听每个Activity的onDestroy事件。这也是判断该Activity是否泄漏的开端。</p>
<p>以<code>ActivityDestroyWatcher</code>为例，其ActivityLifecycleCallback中代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (configProvider().watchActivities) &#123;</span><br><span class="line">          objectWatcher.watch(</span><br><span class="line">              activity, <span class="string">&quot;<span class="subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这其中，最终是<code>objectWatcher</code>来进行内存泄漏监控的。</p>
<h2 id="如何检测到内存泄漏的"><a href="#如何检测到内存泄漏的" class="headerlink" title="如何检测到内存泄漏的"></a>如何检测到内存泄漏的</h2><p>这里涉及到两个关键的类：**<a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt"><code>ObjectWatcher</code></a><strong>和</strong><a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt"><code>KeyedWeakReference</code></a>**。</p>
<p><code>KeyedWeakReference</code>是<code>WeakReference</code>的子类，添加了额外的属性，代码十分简单，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KeyedWeakReference</span>(</span><br><span class="line">  referent: Any,</span><br><span class="line">  <span class="keyword">val</span> key: String,</span><br><span class="line">  <span class="keyword">val</span> description: String,</span><br><span class="line">  <span class="keyword">val</span> watchUptimeMillis: <span class="built_in">Long</span>,</span><br><span class="line">  referenceQueue: ReferenceQueue&lt;Any&gt;</span><br><span class="line">) : WeakReference&lt;Any&gt;(</span><br><span class="line">    referent, referenceQueue</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn&#x27;t</span></span><br><span class="line"><span class="comment">   * been yet.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Volatile</span></span><br><span class="line">  <span class="keyword">var</span> retainedUptimeMillis = -<span class="number">1L</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="meta">@JvmStatic</span> <span class="keyword">var</span> heapDumpUptimeMillis = <span class="number">0L</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看<code>ObjectWatcher</code>中的<code>watchObject</code>方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Watches the provided [watchedObject].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> description Describes why the object is watched.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Synchronized</span> <span class="function"><span class="keyword">fun</span> <span class="title">watch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  watchedObject: <span class="type">Any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  description: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> key = UUID.randomUUID()</span><br><span class="line">      .toString()</span><br><span class="line">  <span class="keyword">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class="line">  <span class="keyword">val</span> reference =</span><br><span class="line">    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">  SharkLog.d &#123;</span><br><span class="line">    <span class="string">&quot;Watching &quot;</span> +</span><br><span class="line">        (<span class="keyword">if</span> (watchedObject <span class="keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="keyword">else</span> <span class="string">&quot;instance of <span class="subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +</span><br><span class="line">        (<span class="keyword">if</span> (description.isNotEmpty()) <span class="string">&quot; (<span class="variable">$description</span>)&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span>) +</span><br><span class="line">        <span class="string">&quot; with key <span class="variable">$key</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  watchedObjects[key] = reference</span><br><span class="line">  checkRetainedExecutor.execute &#123;</span><br><span class="line">    moveToRetained(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分为三步：</p>
<ol>
<li>执行<code>removeWeaklyReachableObjects()</code>方法，这个方法之后讲到；</li>
<li>生成一个<code>KeyedWeakReference</code>对象，并将这个对象添加到<code>watchedObjects</code>去；</li>
<li>定时执行<code>moveToRetained</code>方法。</li>
</ol>
<ul>
<li><p>我们先看第二步，生成<code>KeyedWeakReference</code>对象时候，传入了一个一个<code>ReferenceQueue</code>对象，这是检测对象是否被回收的关键。假如一个对象O，被弱引用WR持有的时候，同时这个弱引用WR在构造时候传入了一个<code>ReferenceQueue</code>对象Q，则这个对象O被回收时候，WR将会被添加到Q中去，这样，通过检测Q中有没有值，便可以知道O有没有被回收掉。这也就是第一步做的事。</p>
</li>
<li><p>接下来我们查看<code>removeWeaklyReachableObjects</code>方法中做了什么。</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeWeaklyReachableObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">  <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">  <span class="keyword">var</span> ref: KeyedWeakReference?</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ref = queue.poll() <span class="keyword">as</span> KeyedWeakReference?</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">      watchedObjects.remove(ref.key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，从queue中取值，取出来ref，则说明被ref修饰的对象已经被回收了，则将这个弱引用ref从<code>watchedObjects</code>清除掉。</p>
<ul>
<li>接下来到了第三步，这一步实际上是一个定时5秒(LeakCanary默认)去将watchedObjects中残留的引用，移入到<code>retainedObjects</code>中去。我们来看其中代码：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">  <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123;</span><br><span class="line">    retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class="line">    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这个任务的Executor实际实现在<a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt"><strong>InternalAppWatcher.kt</strong></a>中，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> checkRetainedExecutor = Executor &#123;</span><br><span class="line">  mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，在<code>moveToRetained</code>中，还是先执行了<code>removeWeaklyReachableObjects</code>这一方法。目的是再次清除已经被回收的对象。如果经过这一步，仍然有引用留在watchedObjects中，则可以认为，这些对象泄漏了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the objects that are currently considered retained. Useful for logging purposes.</span></span><br><span class="line"><span class="comment">   * Be careful with those objects and release them ASAP as you may creating longer lived leaks</span></span><br><span class="line"><span class="comment">   * then the one that are already there.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">val</span> retainedObjects: List&lt;Any&gt;</span><br><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> instances = mutableListOf&lt;Any&gt;()</span><br><span class="line">  <span class="keyword">for</span> (weakReference <span class="keyword">in</span> watchedObjects.values) &#123;</span><br><span class="line">    <span class="keyword">if</span> (weakReference.retainedUptimeMillis != -<span class="number">1L</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> instance = weakReference.<span class="keyword">get</span>()</span><br><span class="line">      <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">        instances.add(instance)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instances</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不要在发行版本中使用LeakCanary，因为一系列初始化动作，可能会导致应用启动较慢。如果要用，请使用LeakCanary-Object-Watcher，或者直接使用Buggly这样的成熟框架。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-11-03</span><a class="tag" href="/categories/源码分析/" title="源码分析">源码分析 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 1933 words, 6 min 26 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/10/26/2022-09-19-Intent.FLAG_ACTIVITY_***%E5%88%B0%E5%BA%95%E8%83%BD%E5%B9%B2%E5%95%A5/">Intent.FLAG_ACTIVITY_***解密</a></h3></div><div class="post-content"><div class="card"><p><p>最好先看这一篇[Launch Mode](&#x2F;android&#x2F;LaunchMode.html)。</p>
<p>我们将重点针对<strong>FLAG_ACTIVITY_NEW_TASK</strong>、<strong>FLAG_ACTIVITY_CLEAR_TASK</strong>、<strong>FLAG_ACTIVITY_CLEAR_TOP</strong>、<strong>FLAG_ACTIVITY_SINGLE_TOP</strong>四个flag进行讲解。</p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_NEW_TASK"><strong>FLAG_ACTIVITY_NEW_TASK</strong></a>：</p>
<ol>
<li>通过非Activity的Context启动一个Activity时候，要使用此flag，比如：ApplicationContext、Service等；</li>
<li>用于Launcher类应用启动其他应用的时候；</li>
<li>当试图通过这个flag启动一个activity的时候，如果后台已经有一个任务栈中有运行的一个此类activity实例，将不会创建一个新的activity，而是将整个栈置于前台，并保持上次的状态。比如从另一个应用启动这种场景，或者Notification中。</li>
<li>如果你想使用startActivityForResult，则<strong>千万不要</strong>在启动的intent添加这个flag。因为onActivityResult回调方法，不会在目标activity执行finish后调用，而是在启动目标activity的时候直接调用，并且收r到resultCode &#x3D; <code>RESULT_CANCELED</code>。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TOP"><strong>FLAG_ACTIVITY_CLEAR_TOP</strong></a>：</p>
<ol>
<li><p>如果在当前任务栈中已经有了目标类型activity，则再次通过添加了此flag的intent去启动此类型activity，会有两种情况。</p>
<p>比如有如下图示结构的任务栈:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">subgraph Task;</span><br><span class="line">D;</span><br><span class="line">C;</span><br><span class="line">B;</span><br><span class="line">A;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p>此时D通过一个添加了<code>FLAG_ACTIVITY_CLEAR_TOP</code>的intent去启动了B类型Activity，则C、D执行onDestroy出栈（不会执行finish，触发onDestroy），现在B在栈顶，有如下图示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">subgraph Task;</span><br><span class="line">B;</span><br><span class="line">A;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p>接下来就有两种情况了。</p>
<p>情况一：intent中<strong>没有</strong>同时设置<code>FLAG_ACTIVITY_SINGLE_TOP</code>，并且B的launchMode是默认值。</p>
<p>B会finish掉再re-create一个新的B’放在B的位置上。</p>
<p>情况二：intent中设置了<code>FLAG_ACTIVITY_SINGLE_TOP</code>或者是其他类型的launchMode。</p>
<p>B不会finish（调用finish方法，onDestroy会被触发）掉，而是直接调用其onNewIntent()方法。</p>
<blockquote>
<p>或许你认为情况二这与launchMode中的singleTop或者singleTask类似，实则不然，其一，singleTop没有清空压在它上边activity的能力；其二，singleTask收到taskAffinity影响。</p>
</blockquote>
</li>
<li><p>与<code>FLAG_ACTIVITY_NEW_TASK</code>配合使用。如果想启动一个任务栈的root位置的activity，也就是栈低activity，同时设置这两个值，它会将整个任务栈放置于前台，并且清空其他activit，适用于从Notification启动Activity。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TASK"><strong>FLAG_ACTIVITY_CLEAR_TASK</strong></a>：这个flag很特殊，只能于<code>FLAG_ACTIVITY_NEW_TASK</code>配合使用。要启动的目标activity的任务栈如果已经存在并且不为空，则将所有activity出栈（不会调用finish方法，onDestroy会被触发），然后创建一个目标类型activity作为这个栈的root。</p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_SINGLE_TOP"><strong>FLAG_ACTIVITY_SINGLE_TOP</strong></a>：这个flag与launchMode中的singleTop几乎一样，当要启动一个activity时候，如果栈顶就是目标类型activity，则不会创建一个新的activity，而是直接调用栈顶的这个activity的onNewIntent()方法。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-10-26</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 800 words, 2 min 40 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/10/25/2022-09-19-LaunchMode/">LaunchMode</a></h3></div><div class="post-content"><div class="card"><p><p>此文是阅读<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/265946165">《Android 面试黑洞——当我按下 Home 键再切回来，会发生什么？》</a>一文后的总结，视频地址<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1CA41177Se/">Bilibili</a>、<a href="https://link.zhihu.com/?target=https://youtu.be/r4T9zkhpmII">Youtube</a>。</p>
<p>演示代码：</p>
<p>在正式讲解launchMode前，先要理解三个概念：<strong>ActivityStack</strong>, <strong>TaskRecord</strong>, <strong>ActivityRecord</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">style TaskRecord-A fill:#aaddff;</span><br><span class="line">style TaskRecord-B fill:#aaddff;</span><br><span class="line">subgraph ActivityStack</span><br><span class="line">subgraph TaskRecord-A</span><br><span class="line">A[ActivityRecord-1]</span><br><span class="line">B[ActivityRecord-2]</span><br><span class="line">end</span><br><span class="line">subgraph TaskRecord-B</span><br><span class="line">C[ActivityRecord-3]</span><br><span class="line">D[ActivityRecord-4]</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>他们的一般结构是这样的。</p>
<p>通过adb命令可以查看当前的ActivityStack、TaskRecord和ActivityRecord的结构。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity</span><br></pre></td></tr></table></figure>

<p>结果如下(搜索<code>ACTIVITY MANAGER STARTER (dumpsys activity containers)</code>)：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">ACTIVITY MANAGER STARTER (dumpsys activity containers)</span><br><span class="line">com.android.server.am.ActivityStackSupervisor@<span class="number">299</span>f1c5 <span class="built_in">type</span>=undefined mode=fullscreen</span><br><span class="line">  <span class="comment">#0 ActivityDisplay=&#123;0 numStacks=2&#125; type=undefined mode=fullscreen</span></span><br><span class="line">   <span class="comment">#1 ActivityStack&#123;694271a stackId=0 type=home mode=fullscreen visible=true translucent=false, 1 tasks&#125; type=home mode=fullscreen</span></span><br><span class="line">    <span class="comment">#0 TaskRecord&#123;e42980e #2 I=com.android.launcher3/.Launcher U=0 StackId=0 sz=1&#125; type=home mode=fullscreen</span></span><br><span class="line">     <span class="comment">#0 ActivityRecord&#123;5efeaf4 u0 com.android.launcher3/.Launcher t2&#125; type=home mode=fullscreen</span></span><br><span class="line">   <span class="comment">#0 ActivityStack&#123;91ac24b stackId=1 type=standard mode=fullscreen visible=false translucent=true, 1 tasks&#125; type=standard mode=fullscreen</span></span><br><span class="line">    <span class="comment">#0 TaskRecord&#123;583322f #72 A=com.github.boybeak.hellolaunchmode U=0 StackId=1 sz=1&#125; type=standard mode=fullscreen</span></span><br><span class="line">     <span class="comment">#0 ActivityRecord&#123;a126ec8 u0 com.github.boybeak.hellolaunchmode/.MainActivity t72&#125; type=standard mode=fullscreen</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们可以看到，此时有两个ActivityStack，索引为0的ActivityStack中，有一个TaskRecord，这个TaskRecord里有一个ActivityRecord，就是我们实验App的MainActivity；索引为1的ActivityStack为我们的Home界面。</p>
<h2 id="四种launchMode的一般行为"><a href="#四种launchMode的一般行为" class="headerlink" title="四种launchMode的一般行为"></a>四种launchMode的一般行为</h2><p>LaunchMode共有4个值可以选择：<strong>Standard</strong>、<strong>SingleTop</strong>、<strong>SingleTask</strong>、<strong>SingleInstance</strong>。接下来将分开讲这4个值的作用，实际上，由于Activity的跳转会涉及到两个Activity，比如ActivityA -&gt; ActivityB，ActivityB的跳转行为模式，不止受到自己launchMode的影响，还会受到ActivityA的launchMode的影响。除此以外，还会有其他属性的影响，比如<code>taskAffinity</code>、<code>allowTaskReparenting</code>、<a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/manifest/activity-element#dlmode"><code>documentLaunchMode</code></a>等。</p>
<p><strong>Standard</strong></p>
<p>这是launchMode的值。它的默认行为是：在当前TaskRecord下创建新Activity。</p>
<p><strong>SingleTop</strong></p>
<p>SingleTop的行为是：如果有一个同类型的Activity在当前TaskRecord的栈顶，那么就直接使用这个栈顶的Activity并调用其<code>onNewIntent()</code>方法；如果栈顶没有同类型的Activity，则在栈顶创建一个对应的Activity。</p>
<p><strong>SingleTask</strong></p>
<p>SingleTask的行为是：在对应<code>taskAffinity</code>的TaskRecord中，如果已经有了对应类型的Activity，则直接使用该Activity，并调用<code>onNewIntent()</code>方法，如果有其他Activity压在该Activity上，则这些Activity都将出栈，该Activity重回栈顶；如果对应<code>taskAffinity</code>的TaskRecord中没有对应类型的Activity，则创建对应类型的Activity并压入栈顶。</p>
<blockquote>
<p>这里需要注意的是<code>taskAffinity</code>对该属性的影响，如果没有为<code>android:launchMode=&quot;singleTask&quot;</code>的Activity指定<code>taskAffinity</code>，则默认值为Application的<code>taskAffinity</code>，而Application的默认<code>taskAffinity</code>为包名。</p>
</blockquote>
<p><strong>SingleInstance</strong></p>
<p>SingleInstance的行为是：1，只允许有一个栈中有此Activity，并且这个栈只允许有这一个Activity；2，如果已经有一个栈中有对应的Activity，则直接使用该Activity，并调用<code>onNewIntent()</code>方法。</p>
<h2 id="SingleInstance对其他三种launchMode的影响"><a href="#SingleInstance对其他三种launchMode的影响" class="headerlink" title="SingleInstance对其他三种launchMode的影响"></a>SingleInstance对其他三种launchMode的影响</h2><p>由于SingleInstance是如此的霸道，导致从一个SingleInstance的Activity启动其他类型Activity的话，会改变其他三种模式的一般行为。</p>
<p><strong>SingleInstanceA -&gt; StandardB</strong></p>
<p>StandardActivityB将无法在当前栈中创建，会回到默认栈中创建。</p>
<p><strong>SingleInstanceA -&gt; SingleTopB</strong></p>
<p>这个行为就很复杂了，可以按照SingleTopB有无<code>taskAffinity</code>属性分为两种情况：</p>
<ul>
<li>无<code>taskAffinity</code>：则直接在默认的栈中，创建新的SingleTopB或者使用已经存在的SingleTopB。</li>
<li>有<code>taskAffinity</code>：则在指定<code>taskAffinity</code>的栈中创建创建新的SingleTopB或者使用已经存在的SingleTopB。</li>
</ul>
<blockquote>
<p>这里实际上存在一个更为复杂的行为模式：<strong>StandardA -&gt; SingleTopB -&gt; SingleInstanceC -&gt; SingleTopB</strong>。</p>
<p>如果SingleTop有<code>taskAffinity</code>属性的话，情况就可以分为两个部分：</p>
<p><strong>StandardA -&gt; SingleTopB</strong>：在StandardA相同TaskRecord中创建SingleTopB的实例singleTopB1。</p>
<p><strong>SingleInstanceC -&gt; SingleTopB</strong>：在指定<code>taskAffinity</code>的TaskRecord中，创建SingleTopB的实例singleTopB2。</p>
<p>也就是说，此时有两个SingleTopB对象——singleTopB1和singleTopB2，分别在两个TaskRecord中。</p>
</blockquote>
<p><strong>SingleInstanceA -&gt; SingleTaskB</strong></p>
<p>比照<strong>SingleInstanceA -&gt; SingleTopB</strong>的例子，同样可以可以按照SingleTaskB有无<code>taskAffinity</code>属性分为两种情况：</p>
<ul>
<li>无<code>taskAffinity</code>：则直接在默认的栈中，创建新的SingleTaskB或者使用已经存在的SingleTaskB。</li>
<li>有<code>taskAffinity</code>：则在指定<code>taskAffinity</code>的栈中创建创建新的SingleTaskB或者使用已经存在的SingleTaskB。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大体了解了不同launchMode的行为逻辑，他们的用途可以简单粗暴的归结如下规律：</p>
<ul>
<li>standard和singleTop：多用于App内部；</li>
<li>singleInstance：多用于开放给外部App来共享使用；</li>
<li>singleTask：内部交互和外部调用都会用得上。</li>
</ul>
<p>当然，不能一概而论，还是要看具体需求。</p>
<p>看起来似乎很复杂，其实只要掌握了<code>adb shell dumpsys activity</code>这个命令工具，就能清晰的看到当前Activity的分布情况，就能分析出，你的Activity应该用什么<code>launchMode</code>，要不要设置<code>taskAffinity</code>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/94816e52cd77">ActivityRecord、TaskRecord、ActivityStack以及Activity启动模式详解</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-10-25</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 1307 words, 4 min 21 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/">Previous</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/3/">Next</a></li></ul></div></div></div></div><script src="/js/darkLightToggle.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>