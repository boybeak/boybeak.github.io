<!DOCTYPE html><html lang="zh-CN" id="theme-dark-mode"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Yourname"><title>Hexo</title><meta name="description" content="A simple and beautiful blog"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Hexo</a></h3><div class="description"><p>A simple and beautiful blog</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/Lhcfl"><i class="fa fa-github"></i></a></li><li><a href="mailto:yourname@example.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/people/jin-xin-4-68"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Yourname</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-19-ASM/">ASM库介绍与使用</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/905be2a9a700">原文</a></p>
</blockquote>
<p>前面几篇文章介绍了 .class 文件的结构、JVM 如何加载 .class 文件、JVM 中如何执行方法的调用和访问者模式，其实前面几篇文章都是为这篇文章做铺垫的，如果不知道 .class 文件结构、也不知道在 JVM 中 .class 文件中的方法是如何被执行的，这篇文章中的有些部分可能会看不懂，所以推荐先看下前面几篇文章。<br> 这篇文章主要介绍 ASM 库的结构、主要的 API，并且通过两个示例说明如何通过 ASM 修改 .class 文件中的方法和属性。</p>
<p>![img](&#x2F;assets&#x2F;images&#x2F;ezgif-6-73b502b11e16.jpg)</p>
<p>catalog.png</p>
<h3 id="一-ASM-的结构"><a href="#一-ASM-的结构" class="headerlink" title="一. ASM 的结构"></a>一. ASM 的结构</h3><p>ASM 库是一款基于 Java 字节码层面的代码分析和修改工具。ASM 可以直接生产二进制的 class 文件，也可以在类被加载入 JVM 之前动态修改类行为。<br> ASM 库的结构如下所示：</p>
<p>![img](&#x2F;assets&#x2F;images&#x2F;4179925-d4f950ec94a12cde.webp)</p>
<p>asm_arch.png</p>
<ul>
<li>Core：为其他包提供基础的读、写、转化Java字节码和定义的API，并且可以生成Java字节码和实现大部分字节码的转换，在 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4b8cb0b3204">访问者模式和 ASM</a> 中介绍的几个重要的类就在 Core API 中：ClassReader、ClassVisitor 和 ClassWriter 类.</li>
<li>Tree：提供了 Java 字节码在内存中的表现</li>
<li>Commons：提供了一些常用的简化字节码生成、转换的类和适配器</li>
<li>Util：包含一些帮助类和简单的字节码修改类，有利于在开发或者测试中使用</li>
<li>XML：提供一个适配器将XML和SAX-comliant转化成字节码结构，可以允许使用XSLT去定义字节码转化</li>
</ul>
<h3 id="二-Core-API-介绍"><a href="#二-Core-API-介绍" class="headerlink" title="二. Core API 介绍"></a>二. Core API 介绍</h3><h4 id="2-1-ClassVisitor-抽象类"><a href="#2-1-ClassVisitor-抽象类" class="headerlink" title="2.1 ClassVisitor 抽象类"></a>2.1 ClassVisitor 抽象类</h4><p>如下所示，在 ClassVisitor 中提供了和类结构同名的一些方法，这些方法会对类中相应的部分进行操作，而且是有顺序的：visit [ visitSource ] [ visitOuterClass ] ( visitAnnotation | visitAttribute )* (visitInnerClass | visitField | visitMethod )* visitEnd</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature, String superName, String[] interfaces)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitSource</span><span class="params">(String source, String debug)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitOuterClass</span><span class="params">(String owner, String name, String desc)</span>;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class="params">(String desc, <span class="type">boolean</span> visible)</span>;</span><br><span class="line">    <span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitTypeAnnotation</span><span class="params">(<span class="type">int</span> typeRef, TypePath typePath, String desc, <span class="type">boolean</span> visible)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitAttribute</span><span class="params">(Attribute attr)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInnerClass</span><span class="params">(String name, String outerName, String innerName, <span class="type">int</span> access)</span>;</span><br><span class="line">    <span class="keyword">public</span> FieldVisitor <span class="title function_">visitField</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, Object value)</span>;</span><br><span class="line">    <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, String[] exceptions)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>void visit(int version, int access, String name, String signature, String superName, String[] interfaces)<br> 该方法是当扫描类时第一个调用的方法，主要用于类声明使用。下面是对方法中各个参数的示意：visit( 类版本 , 修饰符 , 类名 , 泛型信息 , 继承的父类 , 实现的接口)</li>
<li>AnnotationVisitor visitAnnotation(String desc, boolean visible)<br> 该方法是当扫描器扫描到类注解声明时进行调用。下面是对方法中各个参数的示意：visitAnnotation(注解类型 , 注解是否可以在 JVM 中可见)。</li>
<li>FieldVisitor visitField(int access, String name, String desc, String signature, Object value)<br> 该方法是当扫描器扫描到类中字段时进行调用。下面是对方法中各个参数的示意：visitField(修饰符 , 字段名 , 字段类型 , 泛型描述 , 默认值)</li>
<li>MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions)<br> 该方法是当扫描器扫描到类的方法时进行调用。下面是对方法中各个参数的示意：visitMethod(修饰符 , 方法名 , 方法签名 , 泛型信息 , 抛出的异常)</li>
<li>void visitEnd()<br> 该方法是当扫描器完成类扫描时才会调用，如果想在类中追加某些方法</li>
</ol>
<h4 id="2-2-ClassReader-类"><a href="#2-2-ClassReader-类" class="headerlink" title="2.2 ClassReader 类"></a>2.2 ClassReader 类</h4><p>这个类会将 .class 文件读入到 ClassReader 中的字节数组中，它的 accept 方法接受一个 ClassVisitor 实现类，并按照顺序调用 ClassVisitor 中的方法</p>
<h4 id="2-3-ClassWriter-类"><a href="#2-3-ClassWriter-类" class="headerlink" title="2.3 ClassWriter 类"></a>2.3 ClassWriter 类</h4><p>ClassWriter 是一个 ClassVisitor 的子类，是和 ClassReader 对应的类，ClassReader 是将 .class 文件读入到一个字节数组中，ClassWriter 是将修改后的类的字节码内容以字节数组的形式输出。</p>
<h4 id="2-4-MethodVisitor-amp-AdviceAdapter"><a href="#2-4-MethodVisitor-amp-AdviceAdapter" class="headerlink" title="2.4 MethodVisitor &amp; AdviceAdapter"></a>2.4 MethodVisitor &amp; AdviceAdapter</h4><p>MethodVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Method 时就转入 MethodVisitor 接口处理。<br> AdviceAdapter 是 MethodVisitor 的子类，使用 AdviceAdapter 可以更方便的修改方法的字节码。<br> AdviceAdapter 的方法如下所示：</p>
<p>![img](&#x2F;assets&#x2F;images&#x2F;4179925-f5a428b729962860.webp)</p>
<p>AdviceAdapter.png</p>
<p>其中比较重要的几个方法如下：</p>
<ol>
<li>void visitCode()：表示 ASM 开始扫描这个方法</li>
<li>void onMethodEnter()：进入这个方法</li>
<li>void onMethodExit()：即将从这个方法出去</li>
<li>void onVisitEnd()：表示方法扫码完毕</li>
</ol>
<h4 id="2-5-FieldVisitor-抽象类"><a href="#2-5-FieldVisitor-抽象类" class="headerlink" title="2.5 FieldVisitor 抽象类"></a>2.5 FieldVisitor 抽象类</h4><p>FieldVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Field 时就转入 FieldVisitor 接口处理。和分析 MethodVisitor 的方法一样，也可以查看源码注释进行学习，这里不再详细介绍</p>
<h4 id="2-6-操作流程"><a href="#2-6-操作流程" class="headerlink" title="2.6 操作流程"></a>2.6 操作流程</h4><ol>
<li>需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中</li>
<li>然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写</li>
<li>需要事件过滤器 ClassVisitor。在调用 ClassVisitor 的某些方法时会产生一个新的 XXXVisitor 对象，当我们需要修改对应的内容时只要实现自己的 XXXVisitor 并返回就可以了</li>
</ol>
<h3 id="三-示例"><a href="#三-示例" class="headerlink" title="三. 示例"></a>三. 示例</h3><h4 id="3-1-修改类中方法的字节码"><a href="#3-1-修改类中方法的字节码" class="headerlink" title="3.1 修改类中方法的字节码"></a>3.1 修改类中方法的字节码</h4><p>假如现在我们有一个 HelloWorld 类，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lijiankun24.asmpractice.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>javac HelloWorld.java</code> 和 <code>javap -verbose HelloWorld.class</code> 可以查看到 sayName() 方法的字节码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: ldc2_w        #<span class="number">2</span>                  <span class="comment">// long 2000l</span></span><br><span class="line">       <span class="number">3</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method java/lang/Thread.sleep:(J)V</span></span><br><span class="line">       <span class="number">6</span>: <span class="keyword">goto</span>          <span class="number">14</span></span><br><span class="line">       <span class="number">9</span>: astore_1</span><br><span class="line">      <span class="number">10</span>: aload_1</span><br><span class="line">      <span class="number">11</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/InterruptedException.printStackTrace:()V</span></span><br><span class="line">      <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">6</span>     <span class="number">9</span>   Class java/lang/InterruptedException</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">8</span>: <span class="number">6</span></span><br><span class="line">      line <span class="number">6</span>: <span class="number">9</span></span><br><span class="line">      line <span class="number">7</span>: <span class="number">10</span></span><br><span class="line">      line <span class="number">9</span>: <span class="number">14</span></span><br><span class="line">    StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">      frame_type = <span class="number">73</span> <span class="comment">/* same_locals_1_stack_item */</span></span><br><span class="line">        stack = [ <span class="keyword">class</span> java/lang/InterruptedException ]</span><br><span class="line">      frame_type = <span class="number">4</span> <span class="comment">/* same */</span></span><br></pre></td></tr></table></figure>

<p>我们通过 ASM 修改 HelloWorld.class 字节码文件，实现统计方法执行时间的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CostTime</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        redefinePersonClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">redefinePersonClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.lijiankun24.asmpractice.demo.HelloWorld&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lijiankun/Desktop/HelloWorld.class&quot;</span>);</span><br><span class="line">            <span class="type">ClassReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(inputStream);                               <span class="comment">// 1. 创建 ClassReader 读入 .class 文件到内存中</span></span><br><span class="line">            <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(reader, ClassWriter.COMPUTE_MAXS);                 <span class="comment">// 2. 创建 ClassWriter 对象，将操作之后的字节码的字节数组回写</span></span><br><span class="line">            <span class="type">ClassVisitor</span> <span class="variable">change</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeVisitor</span>(writer);                                        <span class="comment">// 3. 创建自定义的 ClassVisitor 对象</span></span><br><span class="line">            reader.accept(change, ClassReader.EXPAND_FRAMES);                                       <span class="comment">// 4. 将 ClassVisitor 对象传入 ClassReader 中</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>().defineClass(className, writer.toByteArray());</span><br><span class="line">            <span class="type">Object</span> <span class="variable">personObj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">nameMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">            nameMethod.invoke(personObj, <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] code = writer.toByteArray();                                                               <span class="comment">// 获取修改后的 class 文件对应的字节数组</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/lijiankun/Desktop/HelloWorld2.class&quot;</span>);    <span class="comment">// 将二进制流写到本地磁盘上</span></span><br><span class="line">                fos.write(code);</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;Failure!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChangeVisitor</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">        ChangeVisitor(ClassVisitor classVisitor) &#123;</span><br><span class="line">            <span class="built_in">super</span>(Opcodes.ASM5, classVisitor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;</span><br><span class="line">            <span class="type">MethodVisitor</span> <span class="variable">methodVisitor</span> <span class="operator">=</span> <span class="built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> methodVisitor;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChangeAdapter</span>(Opcodes.ASM4, methodVisitor, access, name, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChangeAdapter</span> <span class="keyword">extends</span> <span class="title class_">AdviceAdapter</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">startTimeId</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        ChangeAdapter(<span class="type">int</span> api, MethodVisitor mv, <span class="type">int</span> access, String name, String desc) &#123;</span><br><span class="line">            <span class="built_in">super</span>(api, mv, access, name, desc);</span><br><span class="line">            methodName = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMethodEnter</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onMethodEnter();</span><br><span class="line">            startTimeId = newLocal(Type.LONG_TYPE);</span><br><span class="line">            mv.visitMethodInsn(INVOKESTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;currentTimeMillis&quot;</span>, <span class="string">&quot;()J&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitIntInsn(LSTORE, startTimeId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMethodExit</span><span class="params">(<span class="type">int</span> opcode)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onMethodExit(opcode);</span><br><span class="line">            <span class="type">int</span> <span class="variable">durationId</span> <span class="operator">=</span> newLocal(Type.LONG_TYPE);</span><br><span class="line">            mv.visitMethodInsn(INVOKESTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;currentTimeMillis&quot;</span>, <span class="string">&quot;()J&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitVarInsn(LLOAD, startTimeId);</span><br><span class="line">            mv.visitInsn(LSUB);</span><br><span class="line">            mv.visitVarInsn(LSTORE, durationId);</span><br><span class="line">            mv.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class="line">            mv.visitTypeInsn(NEW, <span class="string">&quot;java/lang/StringBuilder&quot;</span>);</span><br><span class="line">            mv.visitInsn(DUP);</span><br><span class="line">            mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitLdcInsn(<span class="string">&quot;The cost time of &quot;</span> + methodName + <span class="string">&quot; is &quot;</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitVarInsn(LLOAD, durationId);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(J)Ljava/lang/StringBuilder;&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下图所示</p>
<p>![img](&#x2F;assets&#x2F;images&#x2F;4179925-32ee7bd0974a4679.webp)</p>
<p>Class.png</p>
<p>反编译 HelloWorld2.class 文件的内容如下所示</p>
<p>![img](&#x2F;assets&#x2F;images&#x2F;4179925-af582100631d7eec.webp)</p>
<p>Class1.png</p>
<h4 id="3-2-修改类中属性的字节码"><a href="#3-2-修改类中属性的字节码" class="headerlink" title="3.2 修改类中属性的字节码"></a>3.2 修改类中属性的字节码</h4><p>这一节中我们将展示一下如何使用 Core API 对类中的属性进行操作。</p>
<p>假如说，现在有一个 Person.java 类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想为这个类，添加一个 ‘public int age’ 的属性该怎么添加呢？我们会面对两个问题：</p>
<ol>
<li>该调用 ASM 的哪个 API 添加属性呢？</li>
<li>在何时写添加属性的代码？</li>
</ol>
<p>接下来，我们就一一解决上面的两个问题？</p>
<h5 id="3-2-1-添加属性的-API"><a href="#3-2-1-添加属性的-API" class="headerlink" title="3.2.1 添加属性的 API"></a>3.2.1 添加属性的 API</h5><p>按照我们分析的上述的 2.6 操作流程叙述，需要以下三个步骤：</p>
<ol>
<li>需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中</li>
<li>然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写</li>
<li>需要创建一个事件过滤器 ClassVisitor。事件过滤器中的某些方法可以产生一个新的XXXVisitor对象，当我们需要修改对应的内容时只要实现自己的XXXVisitor并返回就可以了</li>
</ol>
<p>在上面三个步骤中，可以操作的就是 ClassVisitor 了。ClassVisitor 接口提供了和类结构同名的一些方法，这些方法可以对相应的类结构进行操作。</p>
<p>在使用 ClassVisitor 添加类属性的时候，只需要添加一句话就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classVisitor.visitField(Opcodes.ACC_PUBLIC, <span class="string">&quot;age&quot;</span>, Type.getDescriptor(<span class="type">int</span>.class), <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>![img](&#x2F;assets&#x2F;images&#x2F;4179925-8c703df0b005aae7.webp)</p>
<p>visitField.png</p>
<h5 id="3-2-2-添加属性的时机"><a href="#3-2-2-添加属性的时机" class="headerlink" title="3.2.2 添加属性的时机"></a>3.2.2 添加属性的时机</h5><p>我们先暂且在 ClassVisitor 的 visitEnd() 方法中写入上面的代码，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transform</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Transform</span><span class="params">(ClassVisitor cv)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(cv);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span> &#123;  </span><br><span class="line">        cv.visitField(Opcodes.ACC_PUBLIC, <span class="string">&quot;age&quot;</span>, Type.getDescriptor(<span class="type">int</span>.class), <span class="literal">null</span>, <span class="literal">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们写如下的测试类，测试一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldPractice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        addAgeField();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addAgeField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lijiankun/Desktop/Person.class&quot;</span>);</span><br><span class="line">            <span class="type">ClassReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(inputStream);</span><br><span class="line"></span><br><span class="line">            <span class="type">ClassWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class="line"></span><br><span class="line">            <span class="type">ClassVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transform</span>(writer);</span><br><span class="line">            reader.accept(visitor, ClassReader.SKIP_DEBUG);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] classFile = writer.toByteArray();</span><br><span class="line">            <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.defineClass(<span class="string">&quot;Person&quot;</span>, classFile);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>).get(obj)); <span class="comment">//----(1)</span></span><br><span class="line">            System.out.println(clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>).get(obj));  <span class="comment">//----(2)</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出入下所示：</p>
<p>![img](&#x2F;assets&#x2F;images&#x2F;4179925-a718d240e05a2198.webp)</p>
<p>visitFieldResult.png</p>
<p>那如果我们尝试在 ClassVisitor#visitField() 方法中添加属性可以吗？我们可以修改 Transform 测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transform</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    Transform(ClassVisitor classVisitor) &#123;</span><br><span class="line">        <span class="built_in">super</span>(Opcodes.ASM5, classVisitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FieldVisitor <span class="title function_">visitField</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, Object value)</span> &#123;</span><br><span class="line">        cv.visitField(Opcodes.ACC_PUBLIC, <span class="string">&quot;age&quot;</span>, Type.getDescriptor(<span class="type">int</span>.class), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visitField(access, name, desc, signature, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是使用上面的测试代码测试一下，会有如下的测试结果</p>
<p>![img](&#x2F;assets&#x2F;images&#x2F;4179925-e2e730e41623be28.webp)</p>
<p>visitFieldError.png</p>
<p>在 Person 类中有重复的属性，为什么会报这个错误呢？</p>
<p>分析 ClassVisitor#visitField() 方法可得知，只要访问类中的一个属性，visitField() 方法就会被调用一次，在 Person 类中有两个属性，所以 visitField() 方法就会被调用两次，也就添加了两次 ‘public int age’ 属性，就报了上述的错误，而 visitEnd() 方法只有在最后才会被调用且只调用一次，所以在 visitEnd() 方法中是添加属性的最佳时机</p>
<h4 id="3-3-ASMifier"><a href="#3-3-ASMifier" class="headerlink" title="3.3 ASMifier"></a>3.3 ASMifier</h4><p>可能有人会问，我刚开始学，上面例子中那些 ASM 的代码我还不会写，怎么办呢？ASM 官方为我们提供了 <a target="_blank" rel="noopener" href="https://asm.ow2.io/#Q10">ASMifier</a>，可以帮助我们生成这些晦涩难懂的 ASM 代码。</p>
<p>比如，我想通过 ASM 实现统计一个方法的执行时间，该怎么做呢？一般会有如下的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.lijiankun24.classpractice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">costTime</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="built_in">long</span> duration = System.currentTimeMillis() - startTime;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;The cost time of this method is &quot;</span> + duration + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那上面这段代码对应的 ASM 代码是什么呢？我们可以通过以下两个步骤，使用 ASMifier 自动生成：</p>
<ol>
<li>通过 <code>javac</code> 编译该 <code>Demo.java</code> 文件生成对应的 <code>Demo.class</code> 文件，如下所示</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Demo<span class="selector-class">.java</span></span><br></pre></td></tr></table></figure>

<ol>
<li>通过 ASMifier 自动生成对应的 ASM 代码。首先需要在<a target="_blank" rel="noopener" href="https://asm.ow2.io/#Q10">ASM官网</a> 下载 <code>asm-all.jar</code> 库，我下载的是最新的 <code>asm-all-5.2.jar</code>，然后使用如下命令，即可生成</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath asm-all-<span class="number">5.2</span>.jar org.objectweb.asm.util.ASMifier Demo.class</span><br></pre></td></tr></table></figure>

<p>截图如下：</p>
<p>![img](&#x2F;assets&#x2F;images&#x2F;4179925-0cc8712718f08ea0.webp)</p>
<p>DemoDump.png</p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/ta8210/blog/163550">深入字节码 – 玩转 ASM-Bytecode 原 荐</a><br> <a target="_blank" rel="noopener" href="http://www.easemob.com/news/729">美团热更方案ASM实践</a></p>
<p>43人点赞</p>
<p><a href="">Java 相关</a></p>
<p>作者：lijiankun24<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/905be2a9a700">https://www.jianshu.com/p/905be2a9a700</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 3322 words, 11 min 4 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-19-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">Activity启动流程</a></h3></div><div class="post-content"><div class="card"><p><p>原文参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/150283395">Activity 启动流程分析(Android10)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">A(启动Activity) --&gt; B[通过Binder调用AMS的startActivity方法] --&gt; C[通过Intent获取到目标Activity] --&gt; D&#123;目标Activity是否启动&#125; --&gt; |是|E[通过Instrumentation创建Activity] --&gt; F[回调Activity#attach] --&gt; G[回调Activity#onCreate] --&gt; H[准备显示Activity] --&gt; I[Activity#onResume];</span><br><span class="line">D --&gt; |否|J[通过Zygote进程fork一个App进程]:::zygote --&gt; K[创建Application并回调Application#onCreate]:::zygote --&gt; L[启动ActivityThread主线程消息队列]:::zygote --&gt; E;</span><br><span class="line">F --&gt; M[创建Window对象并设置Window.Callback接收事件]:::wms;</span><br><span class="line">G --&gt; N[Activity#setContentView] --&gt; O[Window#setContentView]:::wms;</span><br><span class="line">H --&gt; P[Window#addView]:::wms;</span><br><span class="line">classDef wms fill:#aaffff</span><br><span class="line">classDef zygote fill:#ffaa99</span><br></pre></td></tr></table></figure>

<p>途中浅蓝色部分为WMS关联部分，橙色部分为目标App未启动情况下的流程。</p>
<h2 id="Intent-解析到-Activity"><a href="#Intent-解析到-Activity" class="headerlink" title="Intent 解析到 Activity"></a>Intent 解析到 Activity</h2><p>调用 startActivity 之后，经过几步辗转最终会调用到 <strong>AMS</strong> 中，而 AMS 又会调用 ActivityStarter 来启动 Activity。<br>解析 Intent 的任务将由<code>PackageManagerService#resolveIntent</code>方法来处理。<br>Intent 匹配规则太负责了，我本意是想学习启动流程，所以就没深入进去看代码，就这样吧。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 291 words, 58 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-19-Apk%E7%98%A6%E8%BA%AB%E6%9C%AF/">Apk瘦身术</a></h3></div><div class="post-content"><div class="card"><p><p>Apk瘦身主要从三方面入手：资源文件、源代码和第三方类库。</p>
<h2 id="一、资源文件"><a href="#一、资源文件" class="headerlink" title="一、资源文件"></a>一、资源文件</h2><h3 id="1-1-删除无用资源文件"><a href="#1-1-删除无用资源文件" class="headerlink" title="1.1 删除无用资源文件"></a>1.1 删除无用资源文件</h3><h4 id="1-1-1-Lint工具"><a href="#1-1-1-Lint工具" class="headerlink" title="1.1.1 Lint工具"></a>1.1.1 Lint工具</h4><p>菜单 -&gt; Analyze -&gt; Run Inspection by Name，然后输入Unused resources便可以执行查找无用资源文件。自己根据需要进行删除。</p>
<h4 id="1-1-2-shrinkResources"><a href="#1-1-2-shrinkResources" class="headerlink" title="1.1.2 shrinkResources"></a>1.1.2 shrinkResources</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">  release &#123;</span><br><span class="line">    <span class="comment">// 不显示Log</span></span><br><span class="line">    buildConfigField <span class="string">&quot;boolean&quot;</span>, <span class="string">&quot;LOG_DEBUG&quot;</span>, <span class="string">&quot;false&quot;</span></span><br><span class="line">    <span class="comment">//混淆</span></span><br><span class="line">    minifyEnabled <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 移除无用的resource文件</span></span><br><span class="line">    shrinkResources <span class="literal">true</span></span><br><span class="line">    proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">    signingConfig signingConfigs.release</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用shrinkResources的前提是，打开混淆minifyEnabled，建议只在release版本开启，不然会使得编译速度变慢。</p>
<h3 id="1-2-图标类资源图片矢量化"><a href="#1-2-图标类资源图片矢量化" class="headerlink" title="1.2 图标类资源图片矢量化"></a>1.2 图标类资源图片矢量化</h3><p>对于图标类资源，可以选择用vector-drawable来代替，通过AndroidStudio自带的转换工具可以将svg文件转换为vector-drawable文件。</p>
<blockquote>
<p>具体操作为，在drawable相关文件夹上右键 -&gt; New -&gt; Vector Assert。</p>
</blockquote>
<p>你也可以进行批量转换：<a target="_blank" rel="noopener" href="https://github.com/vdmeer/svg2vector">工具地址</a></p>
<h3 id="1-3-非图标类资源图片适当压缩与格式选择"><a href="#1-3-非图标类资源图片适当压缩与格式选择" class="headerlink" title="1.3 非图标类资源图片适当压缩与格式选择"></a>1.3 非图标类资源图片适当压缩与格式选择</h3><h4 id="1-3-1-使用tinypng有损压缩png图片"><a href="#1-3-1-使用tinypng有损压缩png图片" class="headerlink" title="1.3.1 使用tinypng有损压缩png图片"></a>1.3.1 使用tinypng有损压缩png图片</h4><p>通过<a target="_blank" rel="noopener" href="http://tinypng.com/">Tinypng</a>官网上传压缩再下载，在保持alpha通道的情况下对png图片的压缩可达到1&#x2F;3以内，且肉眼基本看不出差别。</p>
<h4 id="1-3-2-使用jpg格式"><a href="#1-3-2-使用jpg格式" class="headerlink" title="1.3.2 使用jpg格式"></a>1.3.2 使用jpg格式</h4><p>对于非透明的大图，jpg会比png的大小和内存都更有优势，虽然不是绝对的，但是通常会减少到一半不止。</p>
<h4 id="1-3-3-使用webp格式"><a href="#1-3-3-使用webp格式" class="headerlink" title="1.3.3 使用webp格式"></a>1.3.3 使用webp格式</h4><p>webp格式支持透明度，压缩比比jpg高，但是显示效果却不输于jpg。缺点是在Android端的原生支持不好，从Android4.0+开始原生支持，但是不支持透明度，从Android4.3+开始支持带有透明度的webp。如果不需要兼容到这个版本，可以直接使用。</p>
<p>在Android studio中，在图片资源上右键可以转换为webp。详细参见<a target="_blank" rel="noopener" href="https://developer.android.com/studio/write/convert-webp">创建 WebP 图片</a>。</p>
<h4 id="1-3-4-适当的压缩和尺寸"><a href="#1-3-4-适当的压缩和尺寸" class="headerlink" title="1.3.4 适当的压缩和尺寸"></a>1.3.4 适当的压缩和尺寸</h4><p>无论以上哪种格式图片，都可以通过选择合适的尺寸和适当的提高压缩率的方式，来进一步减少文件大小，进而减小apk文件的体积。</p>
<h4 id="1-3-5-帧动画尽可能使用lottie"><a href="#1-3-5-帧动画尽可能使用lottie" class="headerlink" title="1.3.5 帧动画尽可能使用lottie"></a>1.3.5 帧动画尽可能使用lottie</h4><p><a target="_blank" rel="noopener" href="https://github.com/airbnb/lottie-android">Lottie</a>是Aribnb开源的动画库，通过json文件来进行展示动画，动画文件可以通过Adobe AE来制作。</p>
<h3 id="1-4-有限国际化"><a href="#1-4-有限国际化" class="headerlink" title="1.4 有限国际化"></a>1.4 有限国际化</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    resConfigs <span class="string">&quot;zh&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-第三方库中大尺寸的无用资源同名替换"><a href="#1-5-第三方库中大尺寸的无用资源同名替换" class="headerlink" title="1.5 第三方库中大尺寸的无用资源同名替换"></a>1.5 第三方库中大尺寸的无用资源同名替换</h3><p>如果在第三方类库中，存在用不到的图片资源文件，可以通过1x1像素的同名图片进行替换。</p>
<h3 id="1-6-使用AndResGuard"><a href="#1-6-使用AndResGuard" class="headerlink" title="1.6 使用AndResGuard"></a>1.6 使用AndResGuard</h3><p><a target="_blank" rel="noopener" href="https://github.com/shwenzhang/AndResGuard">AndResGuard</a>，在gradle文件中就可以直接使用，非常方便。</p>
<h2 id="二、源代码"><a href="#二、源代码" class="headerlink" title="二、源代码"></a>二、源代码</h2><h3 id="2-1-开启混淆"><a href="#2-1-开启混淆" class="headerlink" title="2.1 开启混淆"></a>2.1 开启混淆</h3><p>这是基本操作了，无需多言。</p>
<h3 id="2-2-手动修改开源代码"><a href="#2-2-手动修改开源代码" class="headerlink" title="2.2 手动修改开源代码"></a>2.2 手动修改开源代码</h3><p>将开源代码中我们不需要的类或者方法等删除掉，但是这需要对开源代码非常了解，而且确保版本兼容性，将来开源库升级或者随着我们产品需求变更对开源库的要求也改变了，都会影响对开源库的修改，不建议使用。</p>
<h2 id="三、第三方类库"><a href="#三、第三方类库" class="headerlink" title="三、第三方类库"></a>三、第三方类库</h2><h3 id="3-1-动态库"><a href="#3-1-动态库" class="headerlink" title="3.1 动态库"></a>3.1 动态库</h3><h4 id="3-1-1-删除非必要平台so库"><a href="#3-1-1-删除非必要平台so库" class="headerlink" title="3.1.1 删除非必要平台so库"></a>3.1.1 删除非必要平台so库</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ndk &#123;</span><br><span class="line">  <span class="comment">//设置支持的so库架构</span></span><br><span class="line">  abiFilters <span class="string">&quot;armeabi-v7a&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上，对于手机来说，支持armeabi-v7a就足够了。</p>
<h4 id="3-1-2-动态加载so库"><a href="#3-1-2-动态加载so库" class="headerlink" title="3.1.2 动态加载so库"></a>3.1.2 动态加载so库</h4><p>如果不是一启动应用就需要初始化的so库，完全可以在需要的时候再下载这个so文件，再通过以下代码进行加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  System.loadLibrary(<span class="string">&quot;path/to/lib.so&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h3><p>将不需要在启动就加载的功能模块，通过插件化，在用户使用的时候再从服务器加载。</p>
<h3 id="删除class文件的debug-items"><a href="#删除class文件的debug-items" class="headerlink" title="删除class文件的debug items"></a>删除class文件的debug items</h3><p>不建议使用，这种做法，事倍功半。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 1029 words, 3 min 25 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-19-App%E4%BF%9D%E6%B4%BB%E6%9C%AF/">App保活术</a></h3></div><div class="post-content"><div class="card"><p><p><strong>为什么要保活？</strong></p>
<p>因为Android的Low memory killer机制，在系统内存不足的情况下，系统开始根据自身的一套进程回收机制结束一些进程，以便腾出内存给需要的进程。</p>
<p><strong>如何判断内存不足？</strong></p>
<p>判断的阈值在不同手机上是不一样的，一旦低于该阈值，系统就会杀死对应优先级的进程。</p>
<p>在adb shell下，通过如下命令来查看阈值：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/module/lowmemorykiller/parameters/minfree</span><br></pre></td></tr></table></figure>

<p><em>注意: 这可能需要root手机。</em></p>
<p>返回的结果如下示例：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18432</span>, <span class="number">23040</span>, <span class="number">27648</span>, <span class="number">32256</span>, <span class="number">55296</span>, <span class="number">80640</span></span><br></pre></td></tr></table></figure>

<p>其单位为4kb，也就是内存1页大小。</p>
<p>该值表示的是剩余内存大小，优先级为从高到低，比如当内存小于18432*4kb时，杀死对应的优先级的进程。</p>
<p>![oom_adj](&#x2F;assets&#x2F;images&#x2F;process_priority.jpg)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">style 关键优先级 fill:#5befb9</span><br><span class="line">style 高级优先级 fill:#6998c6</span><br><span class="line">style 低优先级 fill:#d38a49</span><br><span class="line">subgraph 关键优先级</span><br><span class="line">A(前台进程)</span><br><span class="line">end</span><br><span class="line">A(前台进程) --&gt; B(可见进程);</span><br><span class="line">subgraph 高级优先级</span><br><span class="line">B --&gt; C(服务进程);</span><br><span class="line">end</span><br><span class="line">C --&gt; D(后台进程);</span><br><span class="line">subgraph 低优先级</span><br><span class="line">D --&gt; E(空进程);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>优先级从高到低依次是，<code>前台进程</code>、<code>可见进程</code>、<code>服务进程</code>、<code>后台进程</code>、<code>空进程</code>。</p>
<p><strong>阈值有6个数，而进程有5种优先级，是如何对应呢？</strong></p>
<p>实际上，第5个数是ContentProvider的阈值，其他的5个数与线程优先级对应。</p>
<p><strong>如何判断线程的优先级？</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/&lt;pid&gt;/oom_adj</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中的<pid>应替换为对应的<strong>进程ID</strong>，从logcat中可以查看对应的pid。</p>
</blockquote>
<p>![oom_adj](&#x2F;assets&#x2F;images&#x2F;oom_adj.png)</p>
<p>取值范围绿色代表比较安全，红色代表比较容易被杀死，白色代表为系统进程。</p>
<h2 id="1像素保活"><a href="#1像素保活" class="headerlink" title="1像素保活"></a>1像素保活</h2><p>监听锁屏广播，当屏幕关闭，偷偷创建一个1像素的activity，当屏幕开启，关闭掉这个1像素activity。</p>
<p>关键代码如下:</p>
<p><code>ScreenObserverService.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建后台service，监听屏幕事件。</span></span><br><span class="line"><span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(Intent.ACTION_SCREEN_ON);</span><br><span class="line">filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">registerReceiver(theReceiver, filter);</span><br><span class="line"><span class="comment">//别忘了在service结束时候，注销掉这个receiver。</span></span><br></pre></td></tr></table></figure>

<p><code>OnePixelActivity.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> getWindow();</span><br><span class="line">window.setGravity(Gravity.START | Gravity.TOP);</span><br><span class="line">WindowManager.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> window.getAttributes();</span><br><span class="line">params.width = <span class="number">1</span>;</span><br><span class="line">params.height = <span class="number">1</span>;</span><br><span class="line">params.x = <span class="number">0</span>;</span><br><span class="line">params.y = <span class="number">0</span>;</span><br><span class="line">window.setAttributes(params);</span><br></pre></td></tr></table></figure>

<p>别忘了在Manifest文件中，为这个activity设置一个透明主题。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.onepixel.OnePixelActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:excludeFromRecents</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:taskAffinity</span>=<span class="string">&quot;com.github.boybeak.livestock.onepixel&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/OnePixelTheme&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>android:excludeFromRecents&#x3D;”true” &#x2F;&#x2F;不会出现在任务管理器中</p>
<p>android:taskAffinity&#x3D;”xxxx”				&#x2F;&#x2F;在新的任务栈中创建，不会将其他界面带到前台，配合启动OnePixelActivity时候的Intent.FLAG_ACTIVITY_NEW_TASK使用.</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：经过实验，这个方案在真机上已经大概率失效了。</p>
<ol>
<li>收到锁屏广播会有1~3秒延迟；</li>
<li>当OnePixelActivity设置了<code>excludeFromRecents=&quot;true&quot;</code>后，在锁屏下是启动不起来的；</li>
<li>屏幕重新点亮的广播会有十几秒延迟。</li>
</ol>
<p>我在一架5T上实验的，其他机型不保证。</p>
</blockquote>
<h2 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h2><p>这一方案就是利用一个前台服务，配合Notification，来达到保活。弊端就是，当你的应用没有Notification需求的时候，对于一些敏感用户来说，这就容易引起方案。如下图。</p>
<p>![forground_service](&#x2F;assets&#x2F;images&#x2F;forground_service.png)</p>
<p>所以当你的应用是音乐类播放器，可以将这个通知作为音乐播放控制来使用，但是如果你的应用没有这样的需求，就会引起敏感用户注意，反而有可能被手动杀死甚至卸载。在Android8.0以前，可以通过如下方案消除这个无意义的敏感通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    startForground(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Notification</span>());</span><br><span class="line">    startService(<span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, InnerService.class));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">      startForground(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Notification</span>());</span><br><span class="line">      stopSelf();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是利用系统漏洞来消除的这个通知，但是在Android8.0以后，同一个ID下，不允许重复创建前台服务，所以使用该方法需要判断版本。</p>
<h2 id="系统广播拉活"><a href="#系统广播拉活" class="headerlink" title="系统广播拉活"></a>系统广播拉活</h2><p><strong>系统拉活</strong></p>
<p>比如开机广播，电量变化，信号变化，网络变化等。但是在Android7.0后增加了限制，在Android8.0后限制更加严格。所以，这类保活方案已经不可靠了。</p>
<blockquote>
<p>Oreo: <a target="_blank" rel="noopener" href="https://developer.android.google.cn/about/versions/oreo/background.html#Broadcasts">https://developer.android.google.cn/about/versions/oreo/background.html#Broadcasts</a></p>
<p>Pie: <a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/components/broadcast-exceptions.html">https://developer.android.google.cn/guide/components/broadcast-exceptions.html</a></p>
</blockquote>
<p><strong>用户拉活</strong></p>
<p>大厂的多个APP之间可以互相之间拉活。 </p>
<h2 id="Service系统机制拉活"><a href="#Service系统机制拉活" class="headerlink" title="Service系统机制拉活"></a>Service系统机制拉活</h2><p>根据Service的onStartCommand方法的返回值，系统会执行不同的拉活方案。一般按照默认返回<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/app/Service#START_STICKY">START_STICKY</a>就可以。</p>
<p>优点是使用成本低，缺点是不稳定。</p>
<h2 id="账户同步拉活"><a href="#账户同步拉活" class="headerlink" title="账户同步拉活"></a>账户同步拉活</h2><p>优点：非常稳定。</p>
<h2 id="JobScheduler拉活"><a href="#JobScheduler拉活" class="headerlink" title="JobScheduler拉活"></a>JobScheduler拉活</h2><h2 id="双进程守护"><a href="#双进程守护" class="headerlink" title="双进程守护"></a>双进程守护</h2><h2 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h2><h2 id="厂商推送"><a href="#厂商推送" class="headerlink" title="厂商推送"></a>厂商推送</h2><h2 id="播放无声音乐"><a href="#播放无声音乐" class="headerlink" title="播放无声音乐"></a>播放无声音乐</h2><h2 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h2><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p><a target="_blank" rel="noopener" href="https://github.com/boybeak/Livestock">示例代码Livestock</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="http://gityuan.com/2018/05/19/android-process-adj/">解读Android进程优先级ADJ算法</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/training/id-auth/custom_auth">创建自定义账号类型</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 1345 words, 4 min 29 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-19-Binder%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/">Binder机制分析</a></h3></div><div class="post-content"><div class="card"><p><p>参考文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35519585">写给 Android 应用工程师的 Binder 原理剖析</a></p>
<p>实验代码：<a target="_blank" rel="noopener" href="https://github.com/boybeak/TheBinder">TheBinder</a></p>
<p>Binder机制可以说是Android的核心。提到Binder，可能会让你想到，通过bindService与<code>Service</code>进行通信(也可能是跨进程的通信)，实际上，Android中Binder的使用可以说是无处不在的，包括Activity跳转，详情可以参考<a target="_blank" rel="noopener" href="https://boybeak.github.io/android/AMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html">AMS启动流程</a>。</p>
<h2 id="为什么要用Binder"><a href="#为什么要用Binder" class="headerlink" title="为什么要用Binder?"></a>为什么要用Binder?</h2><p>在Linux系统中，跨进程通信(IPC)方式有很多种，包括Socket、管道、共享内存等。可以Android为何最后选择Binder作为核心的跨进程通信的手段呢？</p>
<p>这需要从两方面去分析——<strong>性能</strong>和<strong>安全性</strong>。</p>
<h3 id="1-性能"><a href="#1-性能" class="headerlink" title="1. 性能"></a>1. 性能</h3><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</p>
<h3 id="2-安全性"><a href="#2-安全性" class="headerlink" title="2. 安全性"></a>2. 安全性</h3><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID&#x2F;进程ID（UID&#x2F;PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID&#x2F;PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<p>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。</p>
<p>用一张表格来总结与对比各种IPC方式。</p>
<table>
<thead>
<tr>
<th>IPC方式</th>
<th>性能(内存拷贝次数)</th>
<th>安全性</th>
</tr>
</thead>
<tbody><tr>
<td>Binder</td>
<td>1</td>
<td>通过UID&#x2F;PID来保证</td>
</tr>
<tr>
<td>共享内存</td>
<td>0</td>
<td>操作非常复杂，难以保证</td>
</tr>
<tr>
<td>Socket&#x2F;管道&#x2F;消息队列</td>
<td>2</td>
<td>依靠上层协议做身份识别，非常不可靠</td>
</tr>
</tbody></table>
<h2 id="传统IPC是什么样的？"><a href="#传统IPC是什么样的？" class="headerlink" title="传统IPC是什么样的？"></a>传统IPC是什么样的？</h2><p>先要了解一些基本概念——<strong>进程隔离</strong>、<strong>用户空间</strong>、<strong>内核空间</strong>、<strong>用户态</strong>、<strong>内核态</strong>。</p>
<p>![IPC](&#x2F;assets&#x2F;images&#x2F;traditional_ipc.jpg)</p>
<p>上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：</p>
<ul>
<li>进程隔离</li>
<li>进程空间划分：用户空间(User Space)&#x2F;内核空间(Kernel Space)</li>
<li>系统调用：用户态&#x2F;内核态</li>
</ul>
<h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><p>顾名思义，就是进程之间内存是不共享的。进程间要进行数据交换，就得采用**进程间通信(IPC)**机制。</p>
<h3 id="进程空间划分：用户空间-User-Space-x2F-内核空间-Kernel-Space"><a href="#进程空间划分：用户空间-User-Space-x2F-内核空间-Kernel-Space" class="headerlink" title="进程空间划分：用户空间(User Space)&#x2F;内核空间(Kernel Space)"></a>进程空间划分：用户空间(User Space)&#x2F;内核空间(Kernel Space)</h3><p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
<blockquote>
<p>简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。</p>
</blockquote>
<p>![linux memory](&#x2F;assets&#x2F;images&#x2F;linux_memory.png)</p>
<h3 id="系统调用：用户态-x2F-内核态"><a href="#系统调用：用户态-x2F-内核态" class="headerlink" title="系统调用：用户态&#x2F;内核态"></a>系统调用：用户态&#x2F;内核态</h3><p>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助<strong>系统调用</strong>来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于<strong>内核运行态（内核态）</strong>。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>
<p>当进程在执行用户自己的代码的时候，我们称其处于<strong>用户运行态（用户态）</strong>。此时处理器在特权级最低的（3级）用户代码中运行。</p>
<p>系统调用主要通过如下两个函数来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user() //将数据从用户空间拷贝到内核空间</span><br><span class="line">copy_to_user() //将数据从内核空间拷贝到用户空间</span><br></pre></td></tr></table></figure>



<h3 id="Linux下传统IPC通信"><a href="#Linux下传统IPC通信" class="headerlink" title="Linux下传统IPC通信"></a>Linux下传统IPC通信</h3><p>![linux ipc](&#x2F;assets&#x2F;images&#x2F;linux_ipc.jpg)</p>
<p><strong>数据发送进程</strong>：开辟用户空间缓存区 -&gt; 系统调用，进入内核态 -&gt; 开辟内核空间缓存区 -&gt;通过<code>copy_from_user()</code>将数据拷贝到内核空间缓存区。</p>
<p><strong>数据接收进程</strong>：开辟用户空间缓存区 -&gt; 调用<code>copytouser()</code>将数据从内核缓存区拷贝到用户空间缓存区。</p>
<p>这样，两个进程就完成了依次进程间通信。</p>
<p>这种传统的 IPC 通信方式有两个问题：</p>
<ol>
<li>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>
</ol>
<h2 id="Binder跨进程通信原理"><a href="#Binder跨进程通信原理" class="headerlink" title="Binder跨进程通信原理"></a>Binder跨进程通信原理</h2><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的<strong>动态内核可加载模块</strong>（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<blockquote>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 <strong>Binder 驱动</strong>（Binder Dirver）。</p>
</blockquote>
<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。</p>
<p>这就不得不通道 Linux 下的另一个概念：<strong>内存映射</strong>。</p>
<p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<h3 id="Binder-IPC实现原理"><a href="#Binder-IPC实现原理" class="headerlink" title="Binder IPC实现原理"></a>Binder IPC实现原理</h3><p>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</p>
<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I&#x2F;O读写，提高文件读取效率。</p>
<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。</p>
<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>
<li>发送方进程通过系统调用 copy<em>from</em>user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ol>
<p>如下图：</p>
<p>![binder](&#x2F;assets&#x2F;images&#x2F;binder.jpg)</p>
<p>注意图中两个红色虚线。我们从图中可以看到，内核空间开辟了两个缓存区——<strong>内核缓存区</strong>和<strong>数据接收缓存区</strong>，这两个缓存区之间存在内存映射，然后<strong>数据接收缓存区</strong>与<strong>数据接收进程的用户空间缓存区</strong>同样有内存映射。当数据发送进程通过<code>copy_from_user()</code>将数据拷贝到<strong>内核缓存区</strong>的时候，存在映射关系的数据接收进程用户空间缓存区也就收到了数据。</p>
<h2 id="Binder通信模型"><a href="#Binder通信模型" class="headerlink" title="Binder通信模型"></a>Binder通信模型</h2><p>跨进程通讯至少包含两个进程，我们将数据发送进程称为<strong>Client</strong>，把数据接收方称为<strong>Server</strong>。</p>
<h3 id="Client-x2F-Server-x2F-ServiceManager-x2F-驱动"><a href="#Client-x2F-Server-x2F-ServiceManager-x2F-驱动" class="headerlink" title="Client&#x2F;Server&#x2F;ServiceManager&#x2F;驱动"></a>Client&#x2F;Server&#x2F;ServiceManager&#x2F;驱动</h3><p>前面我们介绍过，Binder 是基于 C&#x2F;S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 &#x2F;dev&#x2F;binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p>![img](&#x2F;assets&#x2F;images&#x2F;android_binder.jpg)</p>
<p><a href="https://link.zhihu.com/?target=http://blog.csdn.net/universus/article/details/6211589">Android Binder 设计与实现</a><em>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</em></p>
<blockquote>
<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p>
<p><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p>
<p>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p>
<p><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>
</blockquote>
<h3 id="Binder通信过程"><a href="#Binder通信过程" class="headerlink" title="Binder通信过程"></a>Binder通信过程</h3><p>至此，我们大致能总结出 Binder 通信过程：</p>
<ol>
<li>首先，一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ol>
<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>
<p>![img](&#x2F;assets&#x2F;images&#x2F;client_server_service_manager.jpg)</p>
<h3 id="Binder-通信中的代理模式"><a href="#Binder-通信中的代理模式" class="headerlink" title="Binder 通信中的代理模式"></a>Binder 通信中的代理模式</h3><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。</p>
<p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
<p>![img](&#x2F;assets&#x2F;images&#x2F;binder_data_trans.jpg)</p>
<h3 id="Binder的完整定义"><a href="#Binder的完整定义" class="headerlink" title="Binder的完整定义"></a>Binder的完整定义</h3><p>现在我们可以对 Binder 做个更加全面的定义了：</p>
<ul>
<li>从进程间通信的角度看，Binder 是一种进程间通信的机制；</li>
<li>从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；</li>
<li>从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理</li>
<li>从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。</li>
</ul>
<h2 id="实现Binder跨进程通信"><a href="#实现Binder跨进程通信" class="headerlink" title="实现Binder跨进程通信"></a>实现Binder跨进程通信</h2><p>一般Android上，使用**AIDL(Android Interface Definition Language)**来实现跨进程通信协议。AIDL主要是对接口进行描述的，包括定义Server为Client提供那些操作服务。通过AIDL文件，Android Studio在编译时候，会自动产生接口类以及代理类。</p>
<p>除了通过AIDL的方式，我们还可以自己手动编写接口类和代理类。</p>
<p>代码请参考<a target="_blank" rel="noopener" href="https://github.com/boybeak/TheBinder">TheBinder</a>，这里展示了两种方式实现Binder IPC。</p>
<p>代码中涉及到了一些Java类。</p>
<ul>
<li><strong>IBinder</strong> : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输。</li>
<li><strong>IInterface</strong> : IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）</li>
<li><strong>Binder</strong> : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。</li>
<li><strong>Stub</strong> : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。</li>
</ul>
<h2 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h2><p>代码请参考<a target="_blank" rel="noopener" href="https://github.com/boybeak/TheBinder">TheBinder</a></p>
<p>代码中有两个module: <strong>withAIDL</strong>和<strong>noAIDL</strong>，分别演示了使用AIDL的方式和不使用ADIL的方式进行Binder IPC。</p>
<p><strong>NoAIDL</strong>相比<strong>WithAIDL</strong>有一个优点，就是可以在对应的<code>IInterface</code>文件中，添加一些自定义的代码，比如添加log代码；由于AIDL的方式是自动生成的代码，所以这些自定义代码是没法添加到对应的<code>IInterface</code>文件中。</p>
<p>我们重点关注<strong>noAIDL</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//INoAIDL.kt</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">INoAIDL</span> : <span class="type">IInterface</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">sayHi</span><span class="params">(name: <span class="type">String</span>)</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">showObjN</span><span class="params">(objN: <span class="type">ObjN</span>)</span></span>: ObjN?</span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = INoAIDL::<span class="keyword">class</span>.java.simpleName</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> DESCRIPTOR = INoAIDL::<span class="keyword">class</span>.java.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> : <span class="type">Binder</span>(), INoAIDL &#123;...&#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Proxy</span>(<span class="keyword">private</span> <span class="keyword">val</span> remote: IBinder) : INoAIDL &#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>INoAIDL.kt</code>文件的大体结构如上代码，我们可以看到，在这个<code>IInterface</code>类中：</p>
<ul>
<li>定义两个Server端承诺的服务——<code>sayHi</code>和<code>showObjN</code>；</li>
<li>两个静态类——一个Stub类和一个Proxy类。</li>
</ul>
<p><strong>Stub类</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> : <span class="type">Binder</span>(), INoAIDL &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> TRANSACTION_sayHi = IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> TRANSACTION_showObjN = IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asInterface</span><span class="params">(binder: <span class="type">IBinder</span>?)</span></span>: INoAIDL? &#123;</span><br><span class="line">      <span class="keyword">if</span> (binder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> iin = binder.queryLocalInterface(DESCRIPTOR)</span><br><span class="line">      <span class="keyword">if</span> (iin != <span class="literal">null</span> &amp;&amp; iin <span class="keyword">is</span> INoAIDL) &#123;</span><br><span class="line">        Log.v(TAG, <span class="string">&quot;Client and Server in the same Process&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> iin</span><br><span class="line">      &#125;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;Client and Server in different Processes&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> Proxy(binder)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span> &#123;</span><br><span class="line">    attachInterface(<span class="keyword">this</span>, DESCRIPTOR)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">attachInterface</span><span class="params">(owner: <span class="type">IInterface</span>?, descriptor: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.attachInterface(owner, descriptor)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTransact</span><span class="params">(code: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Parcel</span>, reply: <span class="type">Parcel</span>?, flags: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> descriptor = DESCRIPTOR</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span>(code) &#123;</span><br><span class="line">      INTERFACE_TRANSACTION -&gt; &#123;</span><br><span class="line">        reply?.writeString(descriptor)</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      TRANSACTION_sayHi -&gt; &#123;</span><br><span class="line">        <span class="keyword">data</span>.enforceInterface(descriptor)</span><br><span class="line">        <span class="keyword">val</span> name = <span class="keyword">data</span>.readString() ?: <span class="string">&quot;&quot;</span></span><br><span class="line">        sayHi(name)</span><br><span class="line">        reply?.writeNoException()</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      TRANSACTION_showObjN -&gt; &#123;</span><br><span class="line">        <span class="keyword">data</span>.enforceInterface(descriptor)</span><br><span class="line">        <span class="keyword">var</span> objN: ObjN? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != <span class="keyword">data</span>.readInt()) &#123;</span><br><span class="line">          objN = ObjN.CREATOR.createFromParcel(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> _result = showObjN(objN!!)</span><br><span class="line">        reply?.writeNoException()</span><br><span class="line">        <span class="keyword">if</span> (_result != <span class="literal">null</span>) &#123;</span><br><span class="line">          reply?.writeInt(<span class="number">1</span>)</span><br><span class="line">          _result.writeToParcel(reply, Parcelable.PARCELABLE_WRITE_RETURN_VALUE)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reply?.writeInt(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        <span class="keyword">super</span>.onTransact(code, <span class="keyword">data</span>, reply, flags)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">asBinder</span><span class="params">()</span></span>: IBinder &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Manifest文件中我们定义对应Service</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">&quot;.NoAIDLService&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--android:process=&quot;:noAIDL&quot;--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--把上述属性设置到service中，则是在不同进程中运行--&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们重点关注<code>asInterface</code>方法，在这个方法中，有一个代码片段：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> iin = binder.queryLocalInterface(DESCRIPTOR)</span><br><span class="line"><span class="keyword">if</span> (iin != <span class="literal">null</span> &amp;&amp; iin <span class="keyword">is</span> INoAIDL) &#123;</span><br><span class="line">	Log.v(TAG, <span class="string">&quot;Client and Server in the same Process&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> iin</span><br><span class="line">&#125;</span><br><span class="line">Log.v(TAG, <span class="string">&quot;Client and Server in different Processes&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> Proxy(binder)</span><br></pre></td></tr></table></figure>

<p>通过这样的代码来进行Client和Server是否在不同进程的判断。</p>
<ul>
<li>相同进程：返回<code>queryLocalInterface</code>出来的对象，这个对象是在<code>Stub</code>构造方法中通过<code>attachInterface</code>方法传入的。</li>
<li>不同进程：构造一个<code>Proxy</code>类返回。</li>
</ul>
<p>MainActivity去bind一个Service，Service返回一个Binder。我们打印一下日志。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoAIDLService</span> : <span class="type">Service</span>() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">    <span class="keyword">return</span> binder.also &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;onBind=<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> noAIDL: INoAIDL? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> noConnection = <span class="keyword">object</span> : ServiceConnection &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">    service ?: <span class="keyword">return</span></span><br><span class="line">    Log.v(TAG, <span class="string">&quot;onServiceConnected service=<span class="variable">$service</span>&quot;</span>)</span><br><span class="line">    noAIDL = INoAIDL.Companion.Stub.asInterface(service)</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, <span class="string">&quot;connected to NoAIDLService&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    Log.v(TAG, <span class="string">&quot;onServiceConnected noAIDL=<span class="subst">$&#123;noAIDL&#125;</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当Client与Server在相同进程，有如下日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// NoAIDLService</span><br><span class="line">onBind=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc</span><br><span class="line"></span><br><span class="line">// MainActivity</span><br><span class="line">onServiceConnected service=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc</span><br><span class="line">noAIDL=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc</span><br></pre></td></tr></table></figure>

<p>当Client与Server在不同进程，有如下日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// NoAIDLService</span><br><span class="line">onBind=com.github.boybeak.noaidl.NoAIDLService$binder$1@2d32060</span><br><span class="line"></span><br><span class="line">// MainActivity</span><br><span class="line">onServiceConnected service=android.os.BinderProxy@99b42f6</span><br><span class="line">noAIDL=com.github.boybeak.noaidl.INoAIDL$Companion$Proxy@67e8964</span><br></pre></td></tr></table></figure>

<p>我们看到，当Client与Server在相同进程时候，Service的<code>onBind</code>方法返回的是什么，MainActivity接收到的就是什么；而当Client与Server在不同进程的时候，则返回的是Binder驱动传递给我们的对象，通过这个对象，我们创造一个 Proxy代理对象。</p>
<p>我们接下来重点关注<code>showObjN</code>方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> binder = <span class="keyword">object</span> : INoAIDL.Companion.Stub() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">showObjN</span><span class="params">(objN: <span class="type">ObjN</span>)</span></span>: ObjN? &#123;</span><br><span class="line">    Log.v(TAG, <span class="string">&quot;showObjN objN=<span class="variable">$objN</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> objN</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中，直接返回传入的参数。</p>
<p>调用的地方这样来写：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showObjN</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (noAIDL == <span class="literal">null</span>) &#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;Click NOAIDL button first&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> objN = ObjN()</span><br><span class="line">  Log.v(TAG, <span class="string">&quot;showObjN objN=<span class="variable">$objN</span>&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> returnObjN = noAIDL?.showObjN(objN)</span><br><span class="line">  Log.v(TAG, <span class="string">&quot;showObjN returnObjW=<span class="variable">$returnObjN</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看打印的<code>objN</code>日志。</p>
<p><strong>相同进程情况下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Client进程</span><br><span class="line">com.github.boybeak.binder V/MainActivity: showObjN objN=com.github.boybeak.noaidl.ObjN@4c7d499</span><br><span class="line">com.github.boybeak.binder V/MainActivity: showObjN returnObjW=com.github.boybeak.noaidl.ObjN@4c7d499</span><br><span class="line"></span><br><span class="line">// Server进程</span><br><span class="line">com.github.boybeak.binder V/NoAIDLService: showObjN objN=com.github.boybeak.noaidl.ObjN@4c7d499</span><br></pre></td></tr></table></figure>



<p><strong>不同进程情况下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Client进程</span><br><span class="line">com.github.boybeak.binder V/MainActivity: showObjN objN=com.github.boybeak.noaidl.ObjN@5ab3a61</span><br><span class="line">com.github.boybeak.binder V/MainActivity: showObjN returnObjW=com.github.boybeak.noaidl.ObjN@db79986</span><br><span class="line"></span><br><span class="line">// Server进程</span><br><span class="line">com.github.boybeak.binder V/NoAIDLService: showObjN objN=com.github.boybeak.noaidl.ObjN@1c5381d</span><br></pre></td></tr></table></figure>



<p>我们可以看到，在相同进程情况下，就是普通的函数调用；在不同进程情况下，Client传入的参数，Server接收到的参数，Client接收到的返回结果，全是不同的对象，这是因为，通过Proxy对象，在跨进程通信时候，将Parcelable对象进行了序列化和反序列化。</p>
<p>本文是在阅读<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35519585"><strong>写给 Android 应用工程师的 Binder 原理剖析</strong></a>一文后，加上自己的理解与实验完成，其中部分段落直接复制了原文，因为我觉得，那部分原文已经足够容易理解且没有冗余的文字，感谢原作者<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/BaronZ88"><strong>张磊</strong></a>，同时附上原文参考资料：</p>
<ul>
<li><a href="https://link.zhihu.com/?target=http://blog.csdn.net/universus/article/details/6211589">Android Binder 设计与实现 - 设计篇</a></li>
<li><a href="https://link.zhihu.com/?target=http://blog.csdn.net/luoshengyang/article/details/6618363">Android 进程间通信（IPC）机制 Binder 简要介绍和学习计划</a>、<a href="https://link.zhihu.com/?target=http://item.jd.com/12248208.html">《Android 系统源代码情景分析》</a></li>
<li><a href="https://link.zhihu.com/?target=http://weishu.me/2016/01/12/binder-index-for-newer/">Binder 学习指南</a></li>
<li><a href="https://link.zhihu.com/?target=http://gityuan.com/2015/10/31/binder-prepare/">Binder 系列文章</a></li>
<li><a href="https://link.zhihu.com/?target=https://blog.csdn.net/carson_ho/article/details/73560642">Android 图文详解 Binder 跨进程通信原理</a></li>
<li><a href="https://link.zhihu.com/?target=http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html">Android 深入浅出之 Binder 机制</a></li>
<li><a href="https://link.zhihu.com/?target=http://www.cnblogs.com/Anker/p/3269106.html">用户空间与内核空间</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/huxiao-tee/p/4660352.html">认真分析 mmap ：是什么 为什么 怎么用</a></li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 7189 words, 23 min 57 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-19-Intent.FLAG_ACTIVITY_***%E5%88%B0%E5%BA%95%E8%83%BD%E5%B9%B2%E5%95%A5/">Intent.FLAG_ACTIVITY_***解密</a></h3></div><div class="post-content"><div class="card"><p><p>最好先看这一篇[Launch Mode](&#x2F;android&#x2F;LaunchMode.html)。</p>
<p>我们将重点针对<strong>FLAG_ACTIVITY_NEW_TASK</strong>、<strong>FLAG_ACTIVITY_CLEAR_TASK</strong>、<strong>FLAG_ACTIVITY_CLEAR_TOP</strong>、<strong>FLAG_ACTIVITY_SINGLE_TOP</strong>四个flag进行讲解。</p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_NEW_TASK"><strong>FLAG_ACTIVITY_NEW_TASK</strong></a>：</p>
<ol>
<li>通过非Activity的Context启动一个Activity时候，要使用此flag，比如：ApplicationContext、Service等；</li>
<li>用于Launcher类应用启动其他应用的时候；</li>
<li>当试图通过这个flag启动一个activity的时候，如果后台已经有一个任务栈中有运行的一个此类activity实例，将不会创建一个新的activity，而是将整个栈置于前台，并保持上次的状态。比如从另一个应用启动这种场景，或者Notification中。</li>
<li>如果你想使用startActivityForResult，则<strong>千万不要</strong>在启动的intent添加这个flag。因为onActivityResult回调方法，不会在目标activity执行finish后调用，而是在启动目标activity的时候直接调用，并且收r到resultCode &#x3D; <code>RESULT_CANCELED</code>。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TOP"><strong>FLAG_ACTIVITY_CLEAR_TOP</strong></a>：</p>
<ol>
<li><p>如果在当前任务栈中已经有了目标类型activity，则再次通过添加了此flag的intent去启动此类型activity，会有两种情况。</p>
<p>比如有如下图示结构的任务栈:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">subgraph Task;</span><br><span class="line">D;</span><br><span class="line">C;</span><br><span class="line">B;</span><br><span class="line">A;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p>此时D通过一个添加了<code>FLAG_ACTIVITY_CLEAR_TOP</code>的intent去启动了B类型Activity，则C、D执行onDestroy出栈（不会执行finish，触发onDestroy），现在B在栈顶，有如下图示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">subgraph Task;</span><br><span class="line">B;</span><br><span class="line">A;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p>接下来就有两种情况了。</p>
<p>情况一：intent中<strong>没有</strong>同时设置<code>FLAG_ACTIVITY_SINGLE_TOP</code>，并且B的launchMode是默认值。</p>
<p>B会finish掉再re-create一个新的B’放在B的位置上。</p>
<p>情况二：intent中设置了<code>FLAG_ACTIVITY_SINGLE_TOP</code>或者是其他类型的launchMode。</p>
<p>B不会finish（调用finish方法，onDestroy会被触发）掉，而是直接调用其onNewIntent()方法。</p>
<blockquote>
<p>或许你认为情况二这与launchMode中的singleTop或者singleTask类似，实则不然，其一，singleTop没有清空压在它上边activity的能力；其二，singleTask收到taskAffinity影响。</p>
</blockquote>
</li>
<li><p>与<code>FLAG_ACTIVITY_NEW_TASK</code>配合使用。如果想启动一个任务栈的root位置的activity，也就是栈低activity，同时设置这两个值，它会将整个任务栈放置于前台，并且清空其他activit，适用于从Notification启动Activity。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TASK"><strong>FLAG_ACTIVITY_CLEAR_TASK</strong></a>：这个flag很特殊，只能于<code>FLAG_ACTIVITY_NEW_TASK</code>配合使用。要启动的目标activity的任务栈如果已经存在并且不为空，则将所有activity出栈（不会调用finish方法，onDestroy会被触发），然后创建一个目标类型activity作为这个栈的root。</p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_SINGLE_TOP"><strong>FLAG_ACTIVITY_SINGLE_TOP</strong></a>：这个flag与launchMode中的singleTop几乎一样，当要启动一个activity时候，如果栈顶就是目标类型activity，则不会创建一个新的activity，而是直接调用栈顶的这个activity的onNewIntent()方法。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 800 words, 2 min 40 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-19-LaunchMode/">LaunchMode</a></h3></div><div class="post-content"><div class="card"><p><p>此文是阅读<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/265946165">《Android 面试黑洞——当我按下 Home 键再切回来，会发生什么？》</a>一文后的总结，视频地址<a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1CA41177Se/">Bilibili</a>、<a href="https://link.zhihu.com/?target=https://youtu.be/r4T9zkhpmII">Youtube</a>。</p>
<p>演示代码：</p>
<p>在正式讲解launchMode前，先要理解三个概念：<strong>ActivityStack</strong>, <strong>TaskRecord</strong>, <strong>ActivityRecord</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">style TaskRecord-A fill:#aaddff;</span><br><span class="line">style TaskRecord-B fill:#aaddff;</span><br><span class="line">subgraph ActivityStack</span><br><span class="line">subgraph TaskRecord-A</span><br><span class="line">A[ActivityRecord-1]</span><br><span class="line">B[ActivityRecord-2]</span><br><span class="line">end</span><br><span class="line">subgraph TaskRecord-B</span><br><span class="line">C[ActivityRecord-3]</span><br><span class="line">D[ActivityRecord-4]</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>他们的一般结构是这样的。</p>
<p>通过adb命令可以查看当前的ActivityStack、TaskRecord和ActivityRecord的结构。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity</span><br></pre></td></tr></table></figure>

<p>结果如下(搜索<code>ACTIVITY MANAGER STARTER (dumpsys activity containers)</code>)：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">ACTIVITY MANAGER STARTER (dumpsys activity containers)</span><br><span class="line">com.android.server.am.ActivityStackSupervisor@<span class="number">299</span>f1c5 <span class="built_in">type</span>=undefined mode=fullscreen</span><br><span class="line">  <span class="comment">#0 ActivityDisplay=&#123;0 numStacks=2&#125; type=undefined mode=fullscreen</span></span><br><span class="line">   <span class="comment">#1 ActivityStack&#123;694271a stackId=0 type=home mode=fullscreen visible=true translucent=false, 1 tasks&#125; type=home mode=fullscreen</span></span><br><span class="line">    <span class="comment">#0 TaskRecord&#123;e42980e #2 I=com.android.launcher3/.Launcher U=0 StackId=0 sz=1&#125; type=home mode=fullscreen</span></span><br><span class="line">     <span class="comment">#0 ActivityRecord&#123;5efeaf4 u0 com.android.launcher3/.Launcher t2&#125; type=home mode=fullscreen</span></span><br><span class="line">   <span class="comment">#0 ActivityStack&#123;91ac24b stackId=1 type=standard mode=fullscreen visible=false translucent=true, 1 tasks&#125; type=standard mode=fullscreen</span></span><br><span class="line">    <span class="comment">#0 TaskRecord&#123;583322f #72 A=com.github.boybeak.hellolaunchmode U=0 StackId=1 sz=1&#125; type=standard mode=fullscreen</span></span><br><span class="line">     <span class="comment">#0 ActivityRecord&#123;a126ec8 u0 com.github.boybeak.hellolaunchmode/.MainActivity t72&#125; type=standard mode=fullscreen</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们可以看到，此时有两个ActivityStack，索引为0的ActivityStack中，有一个TaskRecord，这个TaskRecord里有一个ActivityRecord，就是我们实验App的MainActivity；索引为1的ActivityStack为我们的Home界面。</p>
<h2 id="四种launchMode的一般行为"><a href="#四种launchMode的一般行为" class="headerlink" title="四种launchMode的一般行为"></a>四种launchMode的一般行为</h2><p>LaunchMode共有4个值可以选择：<strong>Standard</strong>、<strong>SingleTop</strong>、<strong>SingleTask</strong>、<strong>SingleInstance</strong>。接下来将分开讲这4个值的作用，实际上，由于Activity的跳转会涉及到两个Activity，比如ActivityA -&gt; ActivityB，ActivityB的跳转行为模式，不止受到自己launchMode的影响，还会受到ActivityA的launchMode的影响。除此以外，还会有其他属性的影响，比如<code>taskAffinity</code>、<code>allowTaskReparenting</code>、<a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/manifest/activity-element#dlmode"><code>documentLaunchMode</code></a>等。</p>
<p><strong>Standard</strong></p>
<p>这是launchMode的值。它的默认行为是：在当前TaskRecord下创建新Activity。</p>
<p><strong>SingleTop</strong></p>
<p>SingleTop的行为是：如果有一个同类型的Activity在当前TaskRecord的栈顶，那么就直接使用这个栈顶的Activity并调用其<code>onNewIntent()</code>方法；如果栈顶没有同类型的Activity，则在栈顶创建一个对应的Activity。</p>
<p><strong>SingleTask</strong></p>
<p>SingleTask的行为是：在对应<code>taskAffinity</code>的TaskRecord中，如果已经有了对应类型的Activity，则直接使用该Activity，并调用<code>onNewIntent()</code>方法，如果有其他Activity压在该Activity上，则这些Activity都将出栈，该Activity重回栈顶；如果对应<code>taskAffinity</code>的TaskRecord中没有对应类型的Activity，则创建对应类型的Activity并压入栈顶。</p>
<blockquote>
<p>这里需要注意的是<code>taskAffinity</code>对该属性的影响，如果没有为<code>android:launchMode=&quot;singleTask&quot;</code>的Activity指定<code>taskAffinity</code>，则默认值为Application的<code>taskAffinity</code>，而Application的默认<code>taskAffinity</code>为包名。</p>
</blockquote>
<p><strong>SingleInstance</strong></p>
<p>SingleInstance的行为是：1，只允许有一个栈中有此Activity，并且这个栈只允许有这一个Activity；2，如果已经有一个栈中有对应的Activity，则直接使用该Activity，并调用<code>onNewIntent()</code>方法。</p>
<h2 id="SingleInstance对其他三种launchMode的影响"><a href="#SingleInstance对其他三种launchMode的影响" class="headerlink" title="SingleInstance对其他三种launchMode的影响"></a>SingleInstance对其他三种launchMode的影响</h2><p>由于SingleInstance是如此的霸道，导致从一个SingleInstance的Activity启动其他类型Activity的话，会改变其他三种模式的一般行为。</p>
<p><strong>SingleInstanceA -&gt; StandardB</strong></p>
<p>StandardActivityB将无法在当前栈中创建，会回到默认栈中创建。</p>
<p><strong>SingleInstanceA -&gt; SingleTopB</strong></p>
<p>这个行为就很复杂了，可以按照SingleTopB有无<code>taskAffinity</code>属性分为两种情况：</p>
<ul>
<li>无<code>taskAffinity</code>：则直接在默认的栈中，创建新的SingleTopB或者使用已经存在的SingleTopB。</li>
<li>有<code>taskAffinity</code>：则在指定<code>taskAffinity</code>的栈中创建创建新的SingleTopB或者使用已经存在的SingleTopB。</li>
</ul>
<blockquote>
<p>这里实际上存在一个更为复杂的行为模式：<strong>StandardA -&gt; SingleTopB -&gt; SingleInstanceC -&gt; SingleTopB</strong>。</p>
<p>如果SingleTop有<code>taskAffinity</code>属性的话，情况就可以分为两个部分：</p>
<p><strong>StandardA -&gt; SingleTopB</strong>：在StandardA相同TaskRecord中创建SingleTopB的实例singleTopB1。</p>
<p><strong>SingleInstanceC -&gt; SingleTopB</strong>：在指定<code>taskAffinity</code>的TaskRecord中，创建SingleTopB的实例singleTopB2。</p>
<p>也就是说，此时有两个SingleTopB对象——singleTopB1和singleTopB2，分别在两个TaskRecord中。</p>
</blockquote>
<p><strong>SingleInstanceA -&gt; SingleTaskB</strong></p>
<p>比照<strong>SingleInstanceA -&gt; SingleTopB</strong>的例子，同样可以可以按照SingleTaskB有无<code>taskAffinity</code>属性分为两种情况：</p>
<ul>
<li>无<code>taskAffinity</code>：则直接在默认的栈中，创建新的SingleTaskB或者使用已经存在的SingleTaskB。</li>
<li>有<code>taskAffinity</code>：则在指定<code>taskAffinity</code>的栈中创建创建新的SingleTaskB或者使用已经存在的SingleTaskB。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大体了解了不同launchMode的行为逻辑，他们的用途可以简单粗暴的归结如下规律：</p>
<ul>
<li>standard和singleTop：多用于App内部；</li>
<li>singleInstance：多用于开放给外部App来共享使用；</li>
<li>singleTask：内部交互和外部调用都会用得上。</li>
</ul>
<p>当然，不能一概而论，还是要看具体需求。</p>
<p>看起来似乎很复杂，其实只要掌握了<code>adb shell dumpsys activity</code>这个命令工具，就能清晰的看到当前Activity的分布情况，就能分析出，你的Activity应该用什么<code>launchMode</code>，要不要设置<code>taskAffinity</code>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/94816e52cd77">ActivityRecord、TaskRecord、ActivityStack以及Activity启动模式详解</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 1307 words, 4 min 21 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-19-Mavencentral/">发布Android库到MavenCentral教程</a></h3></div><div class="post-content"><div class="card"><p><p>JCenter已经宣布，即将在2020年5月1日，停止新的库的提交，在2022年2月21号以前，连库的解析服务也停止，所以，把以前的库或者未来的新库替换到MavenCentral是当务之急了。</p>
<p>我参考的教程来自以下两篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://proandroiddev.com/publishing-your-first-android-library-to-mavencentral-be2c51330b88">Publishing your first Android library to MavenCentral</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaozhuanlan.com/topic/6174835029">Android库发布到Maven Central全攻略</a></p>
<p>Demo项目地址：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/boybeak/EasyPack">EasyPack</a></p>
<p>建议英文能力强的直接第一篇，我是在第二篇遇到问题时候，找到了第一篇文章解决了问题，因为第二篇里用的windows环境，我用的mac环境。</p>
<h2 id="一、-Sonatype-Jira相关设置"><a href="#一、-Sonatype-Jira相关设置" class="headerlink" title="一、 Sonatype Jira相关设置"></a>一、 <a target="_blank" rel="noopener" href="https://issues.sonatype.org/">Sonatype Jira</a>相关设置</h2><p>首先，先去<a target="_blank" rel="noopener" href="https://issues.sonatype.org/">Sonatype Jira</a>这个地址注册一个SonatypeJira的账号；</p>
<p>其次，账号创建后，登录，然后在这个页面<a target="_blank" rel="noopener" href="https://issues.sonatype.org/projects">https://issues.sonatype.org/projects</a> 点击Create创建一个issue，如下图：</p>
<p>![create](&#x2F;assets&#x2F;images&#x2F;mc_create.jpg)</p>
<blockquote>
<p>这里group id最好使用你的github地址，这样比较容易验证，如果你想用自己单独的域名，需要做更多的操作。很繁琐，不建议这样做。</p>
</blockquote>
<p>创建以后，会有管理员处理你的这个issue，等待管理员回复你的issue，他会告诉你，要在你的github创建一个repo，repo的名字是这个issue的id，比如我的是<strong>OSSRH-66052</strong>。管理员回复我的如下图：</p>
<p>![](&#x2F;assets&#x2F;images&#x2F;mc_replay.jpg)</p>
<p>你创建好repo后，回复管理员就好了，等待这个issue的状态变成<strong>RESOLVED</strong>状态。</p>
<p>![](&#x2F;assets&#x2F;images&#x2F;mc_resolved.jpg)</p>
<p>这样，你就创建好了一个issue，用来承接对应group id下所有的库。</p>
<h2 id="二、Gradle的准备"><a href="#二、Gradle的准备" class="headerlink" title="二、Gradle的准备"></a>二、Gradle的准备</h2><p>在你项目根目录下的build.gradle文件添加classpath。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        kotlin_version = <span class="string">&quot;1.4.31&quot;</span></span><br><span class="line">        appcompat = <span class="string">&quot;1.2.0&quot;</span></span><br><span class="line">        dokka_version = <span class="string">&#x27;1.4.10.2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&#x27;com.android.tools.build:gradle:4.1.3&#x27;</span></span><br><span class="line">        classpath <span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span></span><br><span class="line"></span><br><span class="line">        classpath <span class="string">&quot;org.jetbrains.dokka:dokka-gradle-plugin:$dokka_version&quot;</span> <span class="comment">//新添加的这一classpath</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在你要提交的module下的build.gradle文件中，尾部追加如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    PUBLISH_ARTIFACT_ID = <span class="string">&quot;你的artifact_id，一般是module的名字&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="attr">from:</span> <span class="string">&#x27;../publish.gradle&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在根目录下创建publish.gradle，如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven-publish&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;signing&#x27;</span></span><br><span class="line"></span><br><span class="line">task androidSourcesJar(<span class="attr">type:</span> Jar) &#123;</span><br><span class="line">    classifier = <span class="string">&#x27;sources&#x27;</span></span><br><span class="line">    from android.sourceSets.main.java.source</span><br><span class="line"></span><br><span class="line">    exclude <span class="string">&quot;**/R.class&quot;</span></span><br><span class="line">    exclude <span class="string">&quot;**/BuildConfig.class&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    PUBLISH_GROUP_ID = <span class="string">&#x27;你的group_id&#x27;</span></span><br><span class="line">    PUBLISH_VERSION = <span class="string">&#x27;你的版本号&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext[<span class="string">&quot;signing.keyId&quot;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">ext[<span class="string">&quot;signing.password&quot;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">ext[<span class="string">&quot;signing.secretKeyRingFile&quot;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">ext[<span class="string">&quot;ossrhUsername&quot;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">ext[<span class="string">&quot;ossrhPassword&quot;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">File secretPropsFile = project.rootProject.file(<span class="string">&#x27;local.properties&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (secretPropsFile.exists()) &#123;</span><br><span class="line">    println <span class="string">&quot;Found secret props file, loading props&quot;</span></span><br><span class="line">    Properties p = <span class="keyword">new</span> Properties()</span><br><span class="line">    p.load(<span class="keyword">new</span> FileInputStream(secretPropsFile))</span><br><span class="line">    p.each &#123; name, value -&gt;</span><br><span class="line">        ext[name] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println <span class="string">&quot;No props file, loading env vars&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">publishing &#123;</span><br><span class="line">    publications &#123;</span><br><span class="line">        release(MavenPublication) &#123;</span><br><span class="line">            <span class="comment">// The coordinates of the library, being set from variables that</span></span><br><span class="line">            <span class="comment">// we&#x27;ll set up in a moment</span></span><br><span class="line">            groupId PUBLISH_GROUP_ID</span><br><span class="line">            artifactId PUBLISH_ARTIFACT_ID</span><br><span class="line">            version PUBLISH_VERSION</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Two artifacts, the `aar` and the sources</span></span><br><span class="line">            artifact(<span class="string">&quot;$buildDir/outputs/aar/$&#123;project.getName()&#125;-release.aar&quot;</span>)</span><br><span class="line">            artifact androidSourcesJar</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Self-explanatory metadata for the most part</span></span><br><span class="line">            pom &#123;</span><br><span class="line">                name = PUBLISH_ARTIFACT_ID</span><br><span class="line">                description = <span class="string">&#x27;你的项目描述&#x27;</span></span><br><span class="line">                <span class="comment">// If your project has a dedicated site, use its URL here</span></span><br><span class="line">                url = <span class="string">&#x27;https://github.com/boybeak/EasyPack&#x27;</span></span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        <span class="comment">//协议类型，一般默认Apache License2.0的话不用改：</span></span><br><span class="line">                        name = <span class="string">&#x27;The Apache License, Version 2.0&#x27;</span></span><br><span class="line">                        url = <span class="string">&#x27;http://www.apache.org/licenses/LICENSE-2.0.txt&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                developers &#123;</span><br><span class="line">                    developer &#123;</span><br><span class="line">                        id = <span class="string">&#x27;你的sonatype用户名&#x27;</span></span><br><span class="line">                        name = <span class="string">&#x27;你的sonatype用户名&#x27;</span></span><br><span class="line">                        email = <span class="string">&#x27;你的sonatype注册邮箱&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Version control info, if you&#x27;re using GitHub, follow the format as seen here</span></span><br><span class="line">                scm &#123;</span><br><span class="line">                    <span class="comment">//修改成你的Git地址：</span></span><br><span class="line">                    connection = <span class="string">&#x27;scm:git:github.com/你的github账号/你的项目名称.git&#x27;</span></span><br><span class="line">                    developerConnection = <span class="string">&#x27;scm:git:ssh://github.com/你的github账号/你的项目名称.git&#x27;</span></span><br><span class="line">                    <span class="comment">//分支地址：</span></span><br><span class="line">                    url = <span class="string">&#x27;https://github.com/你的github账号/你的项目名称/tree/master&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// A slightly hacky fix so that your POM will include any transitive dependencies</span></span><br><span class="line">                <span class="comment">// that your library builds upon</span></span><br><span class="line">                withXml &#123;</span><br><span class="line">                    <span class="keyword">def</span> dependenciesNode = asNode().appendNode(<span class="string">&#x27;dependencies&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                    project.configurations.implementation.allDependencies.each &#123;</span><br><span class="line">                        <span class="keyword">def</span> dependencyNode = dependenciesNode.appendNode(<span class="string">&#x27;dependency&#x27;</span>)</span><br><span class="line">                        dependencyNode.appendNode(<span class="string">&#x27;groupId&#x27;</span>, it.group)</span><br><span class="line">                        dependencyNode.appendNode(<span class="string">&#x27;artifactId&#x27;</span>, it.name)</span><br><span class="line">                        dependencyNode.appendNode(<span class="string">&#x27;version&#x27;</span>, it.version)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        <span class="comment">// The repository to publish to, Sonatype/MavenCentral</span></span><br><span class="line">        maven &#123;</span><br><span class="line">            <span class="comment">// This is an arbitrary name, you may also use &quot;mavencentral&quot; or</span></span><br><span class="line">            <span class="comment">// any other name that&#x27;s descriptive for you</span></span><br><span class="line">            name = <span class="string">&quot;mavencentral&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> releasesRepoUrl = <span class="string">&quot;https://oss.sonatype.org/service/local/staging/deploy/maven2/&quot;</span></span><br><span class="line">            <span class="keyword">def</span> snapshotsRepoUrl = <span class="string">&quot;https://oss.sonatype.org/content/repositories/snapshots/&quot;</span></span><br><span class="line">            <span class="comment">// You only need this if you want to publish snapshots, otherwise just set the URL</span></span><br><span class="line">            <span class="comment">// to the release repo directly</span></span><br><span class="line">            url = version.endsWith(<span class="string">&#x27;SNAPSHOT&#x27;</span>) ? snapshotsRepoUrl : releasesRepoUrl</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The username and password we&#x27;ve fetched earlier</span></span><br><span class="line">            credentials &#123;</span><br><span class="line">                username ossrhUsername</span><br><span class="line">                password ossrhPassword</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signing &#123;</span><br><span class="line">    sign publishing.publications</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、创建GPG秘钥"><a href="#三、创建GPG秘钥" class="headerlink" title="三、创建GPG秘钥"></a>三、创建GPG秘钥</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://www.gnupg.org/download/%EF%BC%8C%E4%BB%8E%E8%BF%99%E9%87%8C%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85GPG%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%82">https://www.gnupg.org/download/，从这里下载并安装GPG客户端。</a></p>
</li>
<li><p>在命令行中执行命令<code>gpg --full-gen-key</code>，注意，一定要在命令行中执行命令，不能在客户端界面做。</p>
</li>
<li><p>加密方式选择<strong>RSA and RSA</strong>，长度输入<strong>4096</strong>，过期时间直接回车不用管，然后输入一个user ID并且提供一个邮箱，我直接用的我sonatype的用户名和邮箱。最后一步输入’O’，表示OK。</p>
</li>
<li><p>之后会弹出一个对话框，让输入密码。</p>
<p>![密码](&#x2F;assets&#x2F;images&#x2F;mc_pwd.png)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gpg: revocation certificate stored as &#x27;~/.gnupg/openpgp-revocs.d/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXE478F7CC.rev&#x27;</span><br><span class="line">public and secret key created and signed.</span><br><span class="line"></span><br><span class="line">pub   rsa4096 2021-03-22 [SC]</span><br><span class="line">      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXEE478F7CC</span><br><span class="line">uid                      boybeak &lt;boybeak@gmail.com&gt;</span><br><span class="line">sub   rsa4096 2021-03-22 [E]</span><br></pre></td></tr></table></figure>



<p>这会为你在<code>~/.gnupg/openpgp-revocs.d/</code>目录下创建一个.rev文件，记住pub的末尾8位。</p>
</li>
<li><p>接下来创建secring.gpg文件，命令行执行<code>gpg --export-secret-keys -o secring.gpg</code>，这会要求你输入在步骤4中设置的密码，在你用户根目录下会出现secring.gpg文件。</p>
</li>
<li><p>回到gpg客户端，选择我们刚生成的秘钥条目，右键，选择<code>Send Public Key to Key Server</code>。</p>
<p>![](&#x2F;assets&#x2F;images&#x2F;mc_cer_push.png)</p>
</li>
</ol>
<h2 id="四、设置local-properties"><a href="#四、设置local-properties" class="headerlink" title="四、设置local.properties"></a>四、设置local.properties</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">signing.keyId=刚才获取的秘钥后<span class="number">8</span>位</span><br><span class="line">signing.password=步骤<span class="number">4</span>中设置的密码</span><br><span class="line">signing.secretKeyRingFile=刚才生成的secring.gpg文件目录</span><br><span class="line">ossrhUsername=sonatype用户名</span><br><span class="line">ossrhPassword=sonatype密码</span><br></pre></td></tr></table></figure>



<h2 id="五、执行打包和上传"><a href="#五、执行打包和上传" class="headerlink" title="五、执行打包和上传"></a>五、执行打包和上传</h2><p>设置完这些后，在AndroidStudio右侧的gradle tasks中找到你想提交的module，先后执行以下两个任务。</p>
<p>![](&#x2F;assets&#x2F;images&#x2F;mc_build_push.jpg)</p>
<p>上传成功后，打开<a target="_blank" rel="noopener" href="https://oss.sonatype.org/">Nexus Repository Manager</a>，登录你的sonatype账号，在左侧<code>Staging Repositories</code>页面找到你的group id，选中，点击上边的close，等待几分钟十几分钟后刷新状态，等其状态变为closed后，再点击Release，则所有人都用使用你的库了。</p>
<p>![](&#x2F;assets&#x2F;images&#x2F;mc_publish.jpg)。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 1672 words, 5 min 34 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-22-%E9%9A%BE%E5%BF%98%E7%9A%84bug/">难忘的bug</a></h3></div><div class="post-content"><div class="card"><p><p>此贴是为了记录日常开发过程中，遇到的一些让人难忘的bug。</p>
<ul>
<li>MediaPlayer: surface has already been released</li>
<li>kotlin ?.的陷阱与缺陷</li>
</ul>
<h2 id="surface-has-already-been-released"><a href="#surface-has-already-been-released" class="headerlink" title="surface has already been released"></a>surface has already been released</h2><p><strong>场景</strong>：MediaPlayer做跨进程的视频播放发现的，由于有无画面的后台播放场景，所以，MediaPlayer的相关操作放在独立进程的Service中，通过跨进程的调度，进行相关媒体操作，包括设置用于展示画面的Surface，Surface是一个Parcable类，所以是可以通过跨进程传输的。<br><strong>归因</strong>：在播放进程中，用成员变量缓存了通过<code>setSurface</code>设置的surface变量，以便于从后台恢复前台播放时候，可以直接使用，而不需要再次传入surface参数。但是这样做是不可以的，会爆出<code>surface has already been released</code>的错误。<br>IPlayer.aidl如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IPlayer &#123;</span><br><span class="line">    void setSurface(inout Surface surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，此处surface的修饰符包括一个inout。这样设置，是为了适配IjkMediaPlayer切换全屏的场景。如果把这个修饰符改成<code>in</code>，则IjkMediaPlayer在通过<code>setSurface</code>多次修改surface时候，也会爆出<code>surface has already been released</code>这样的问题。</p>
<h2 id="kotlin-的陷阱与缺陷"><a href="#kotlin-的陷阱与缺陷" class="headerlink" title="kotlin ?.的陷阱与缺陷"></a>kotlin ?.的陷阱与缺陷</h2><p><code>?.</code>是kotlin的空安全语法。相比Java的if语句判断，这样做要简洁的多，但是这里边有一种“陷阱”，这并不是kotlin本身的问题，而是使用者容易疏忽的问题。<br>展示逻辑的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法A(回调) &#123;</span><br><span class="line">    结果1 = 动作1</span><br><span class="line">    结果2 = 动作2</span><br><span class="line">    回调(结果1, 结果2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释一下，一个<code>方法A</code>，带有一个Nullable的<code>回调</code>，需要执行<code>动作1</code>和<code>动作2</code>，分别返回了<code>结果1</code>和<code>结果2</code>，并且在<code>回调</code>中返回结果。<br>上述逻辑用kotlin实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案一</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">action1</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">action2</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodA</span><span class="params">(block: ((<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result1 = action1()</span><br><span class="line">    <span class="keyword">val</span> result2 = action2()</span><br><span class="line">    block?.invoke(result1, result2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案二</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">action1</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">action2</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodA</span><span class="params">(block: ((<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">    block?.invoke(action1(), action2())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你选择了方案二，那么你就掉入”陷阱”了。<br>因为方法内执行的逻辑，不应该收到回调的影响。如果在<code>methodA</code>中传入了null作为参数，或者直接调用<code>methodA()</code>，这样参数<code>block</code>就为null，那么<code>方案二</code>是不等价于<code>方案一</code>的，我只是不需要知道方法的执行结果，不是让你不执行方法。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/陷阱与缺陷/" title="陷阱与缺陷">陷阱与缺陷 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/陷阱与缺陷/" title="陷阱与缺陷">陷阱与缺陷 </a><span class="leancloud_visitors"></span><span>About 657 words, 2 min 11 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/02/05/2022-09-23-Kotlin%20Native/">Kotlin Native从初识到放弃</a></h3></div><div class="post-content"><div class="card"><p><p>此贴用于记录对Kotlin Native从初识到放弃的过程，因为还不清楚这一平台的开发能力上限多高，不排除用的好，会一直用下去。<br>以下Kotlin Native会用KN来代替。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先，下载IDEA，我这里用的是社区版，社区版已经足以应对大多数情况了。<br>然后，新建一个KN的项目。<br>![kotlin-native-start.jpg](&#x2F;assets&#x2F;images&#x2F;kotlin-native-starter.jpg)<br>IDE会自动生成hello world代码，直接点运行，如果工具栏的运行按钮没有可执行的配置，那就直接在Main.kt文件上右键运行。相比直接用Clion写**C&#x2F;C++*<em>代码的运行速度，KN项目运行要慢得多，因为要先执行gradle脚本。<br>即便是这样，你也很可能第一次运行不成功，在macOs上，要安装</em>XCode command line tools*工具，我这里直接安装了完整版的XCode。<br>然后继续尝试运行，你很可能会发现，依然执行不成功，报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The /usr/bin/xcrun command returned non-zero exit code: 72</span><br></pre></td></tr></table></figure>
<p>这时候，你需要打开XCode，执行一系列同意操作后，进入<strong>Preferences</strong> -&gt; <strong>Locations</strong>，选中一个版本。如下：<br>![xcode-select](&#x2F;assets&#x2F;images&#x2F;xcode-select.jpg)<br>如果你没有安装完整XCode，可以尝试<code>xcode select</code>这个命令，这里具体不做详述。<br>经过这个设置后，再次尝试运行，这次终于运行成功。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">21:41:11: Executing &#x27;runDebugExecutableNative&#x27;...</span><br><span class="line"></span><br><span class="line">Starting Gradle Daemon...</span><br><span class="line">Gradle Daemon started in 3 s 569 ms</span><br><span class="line"></span><br><span class="line">&gt; Configure project :</span><br><span class="line">Kotlin Multiplatform Projects are an Alpha feature. See: https://kotlinlang.org/docs/reference/evolution/components-stability.html. To hide this message, add &#x27;kotlin.mpp.stability.nowarn=true&#x27; to the Gradle properties.</span><br><span class="line"></span><br><span class="line">The property &#x27;kotlin.mpp.enableGranularSourceSetsMetadata=true&#x27; has no effect in this and future Kotlin versions, as Hierarchical Structures support is now enabled by default. It is safe to remove the property.</span><br><span class="line"></span><br><span class="line">The property &#x27;kotlin.native.enableDependencyPropagation=false&#x27; has no effect in this and future Kotlin versions, as Kotlin/Native dependency commonization is now enabled by default. It is safe to remove the property.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Task :wrapper</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 21s</span><br><span class="line">1 actionable task: 1 executed</span><br><span class="line"></span><br><span class="line">&gt; Configure project :</span><br><span class="line">Kotlin Multiplatform Projects are an Alpha feature. See: https://kotlinlang.org/docs/reference/evolution/components-stability.html. To hide this message, add &#x27;kotlin.mpp.stability.nowarn=true&#x27; to the Gradle properties.</span><br><span class="line"></span><br><span class="line">The property &#x27;kotlin.mpp.enableGranularSourceSetsMetadata=true&#x27; has no effect in this and future Kotlin versions, as Hierarchical Structures support is now enabled by default. It is safe to remove the property.</span><br><span class="line"></span><br><span class="line">The property &#x27;kotlin.native.enableDependencyPropagation=false&#x27; has no effect in this and future Kotlin versions, as Kotlin/Native dependency commonization is now enabled by default. It is safe to remove the property.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Task :compileKotlinNative UP-TO-DATE</span><br><span class="line">&gt; Task :linkDebugExecutableNative UP-TO-DATE</span><br><span class="line"></span><br><span class="line">&gt; Task :runDebugExecutableNative</span><br><span class="line">Hello, Kotlin/Native!</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 3s</span><br><span class="line">3 actionable tasks: 1 executed, 2 up-to-date</span><br><span class="line">21:41:44: Execution finished &#x27;runDebugExecutableNative&#x27;.</span><br></pre></td></tr></table></figure>
<p>请在上述输出日志中寻找<code>Hello, Kotlin/Native</code>字符串，很不起眼。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-02-05</span><a class="tag" href="/categories/Kotlin-Native/" title="Kotlin Native">Kotlin Native </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Kotlin/" title="Kotlin">Kotlin </a><span class="leancloud_visitors"></span><span>About 695 words, 2 min 19 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/">Previous</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/3/">Next</a></li></ul></div></div></div></div><script src="/js/darkLightToggle.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>