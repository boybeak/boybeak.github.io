{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/hexo-theme-anatolo/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/css/font-awesome.css","path":"css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/css/insight.css","path":"css/insight.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/css/blog_basic.styl","path":"css/blog_basic.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/images/favicon.webp","path":"images/favicon.webp","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/images/gongan.png","path":"images/gongan.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/images/logo.webp","path":"images/logo.webp","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/images/logo@2x.webp","path":"images/logo@2x.webp","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/js/baidu-tongji.js","path":"js/baidu-tongji.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/js/add-bookmark.js","path":"js/add-bookmark.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/js/darkLightToggle.js","path":"js/darkLightToggle.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/js/jquery-migrate-1.2.1.min.js","path":"js/jquery-migrate-1.2.1.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/js/jquery.appear.js","path":"js/jquery.appear.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/js/tagcanvas.js","path":"js/tagcanvas.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/js/tagcloud.js","path":"js/tagcloud.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/js/visitors.js","path":"js/visitors.js","modified":0,"renderable":1},{"_id":"source/images/4179925-32ee7bd0974a4679.webp","path":"images/4179925-32ee7bd0974a4679.webp","modified":0,"renderable":0},{"_id":"source/images/4179925-8c703df0b005aae7.webp","path":"images/4179925-8c703df0b005aae7.webp","modified":0,"renderable":0},{"_id":"source/images/4179925-a718d240e05a2198.webp","path":"images/4179925-a718d240e05a2198.webp","modified":0,"renderable":0},{"_id":"source/images/4179925-af582100631d7eec.webp","path":"images/4179925-af582100631d7eec.webp","modified":0,"renderable":0},{"_id":"source/images/4179925-d4f950ec94a12cde.webp","path":"images/4179925-d4f950ec94a12cde.webp","modified":0,"renderable":0},{"_id":"source/images/4179925-e2e730e41623be28.webp","path":"images/4179925-e2e730e41623be28.webp","modified":0,"renderable":0},{"_id":"source/images/4179925-f5a428b729962860.webp","path":"images/4179925-f5a428b729962860.webp","modified":0,"renderable":0},{"_id":"source/images/android_binder.jpg","path":"images/android_binder.jpg","modified":0,"renderable":0},{"_id":"source/images/apple-touch-icon-300x300.jpg","path":"images/apple-touch-icon-300x300.jpg","modified":0,"renderable":0},{"_id":"source/images/binder.jpg","path":"images/binder.jpg","modified":0,"renderable":0},{"_id":"source/images/binder_data_trans.jpg","path":"images/binder_data_trans.jpg","modified":0,"renderable":0},{"_id":"source/images/client_server_service_manager.jpg","path":"images/client_server_service_manager.jpg","modified":0,"renderable":0},{"_id":"source/images/ezgif-6-73b502b11e16.jpg","path":"images/ezgif-6-73b502b11e16.jpg","modified":0,"renderable":0},{"_id":"source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":0,"renderable":0},{"_id":"source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":0,"renderable":0},{"_id":"source/images/favicon-96x96.png","path":"images/favicon-96x96.png","modified":0,"renderable":0},{"_id":"source/images/favicon.svg","path":"images/favicon.svg","modified":0,"renderable":0},{"_id":"source/images/forground_service.png","path":"images/forground_service.png","modified":0,"renderable":0},{"_id":"source/images/gif.webp","path":"images/gif.webp","modified":0,"renderable":0},{"_id":"source/images/gif_after_optimization.png","path":"images/gif_after_optimization.png","modified":0,"renderable":0},{"_id":"source/images/gif_before_optimization.png","path":"images/gif_before_optimization.png","modified":0,"renderable":0},{"_id":"source/images/4179925-0cc8712718f08ea0.webp","path":"images/4179925-0cc8712718f08ea0.webp","modified":0,"renderable":0},{"_id":"source/images/kotlin-native-starter.jpg","path":"images/kotlin-native-starter.jpg","modified":0,"renderable":0},{"_id":"source/images/glide_struct.jpg","path":"images/glide_struct.jpg","modified":0,"renderable":0},{"_id":"source/images/linux_ipc.jpg","path":"images/linux_ipc.jpg","modified":0,"renderable":0},{"_id":"source/images/linux_memory.png","path":"images/linux_memory.png","modified":0,"renderable":0},{"_id":"source/images/mc_cer_push.png","path":"images/mc_cer_push.png","modified":0,"renderable":0},{"_id":"source/images/mc_build_push.jpg","path":"images/mc_build_push.jpg","modified":0,"renderable":0},{"_id":"source/images/mc_create.jpg","path":"images/mc_create.jpg","modified":0,"renderable":0},{"_id":"source/images/mc_publish.jpg","path":"images/mc_publish.jpg","modified":0,"renderable":0},{"_id":"source/images/mc_replay.jpg","path":"images/mc_replay.jpg","modified":0,"renderable":0},{"_id":"source/images/mc_pwd.png","path":"images/mc_pwd.png","modified":0,"renderable":0},{"_id":"source/images/mc_resolved.jpg","path":"images/mc_resolved.jpg","modified":0,"renderable":0},{"_id":"source/images/my_face.jpeg","path":"images/my_face.jpeg","modified":0,"renderable":0},{"_id":"source/images/oom_adj.png","path":"images/oom_adj.png","modified":0,"renderable":0},{"_id":"source/images/net_model.png","path":"images/net_model.png","modified":0,"renderable":0},{"_id":"source/images/playground.jpg","path":"images/playground.jpg","modified":0,"renderable":0},{"_id":"source/images/preview.jpg","path":"images/preview.jpg","modified":0,"renderable":0},{"_id":"source/images/process_priority.jpg","path":"images/process_priority.jpg","modified":0,"renderable":0},{"_id":"source/images/request_implementions.jpg","path":"images/request_implementions.jpg","modified":0,"renderable":0},{"_id":"source/images/search.svg","path":"images/search.svg","modified":0,"renderable":0},{"_id":"source/images/traditional_ipc.jpg","path":"images/traditional_ipc.jpg","modified":0,"renderable":0},{"_id":"source/images/xcode-select.jpg","path":"images/xcode-select.jpg","modified":0,"renderable":0},{"_id":"source/images/translator-logo-512.png","path":"images/translator-logo-512.png","modified":0,"renderable":0},{"_id":"source/images/jd_loader_manager.jpg","path":"images/jd_loader_manager.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-anatolo/source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/images/favicon-96x96.png","path":"images/favicon-96x96.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-anatolo/source/images/logo.jpg","path":"images/logo.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1675525694285},{"_id":"themes/hexo-theme-anatolo/.DS_Store","hash":"57ae7f1d06d5cb050a978e1d565adb17f3f82c3a","modified":1675572269289},{"_id":"themes/hexo-theme-anatolo/.gitignore","hash":"c039288d8cd6beb07aaaac062ab0b7c26667f5b2","modified":1675533069316},{"_id":"themes/hexo-theme-anatolo/package.json","hash":"da1cba3cf5d7e45eb731fed952ce1d0aaccc16bc","modified":1675526098063},{"_id":"themes/hexo-theme-anatolo/languages/pt-BR.yml","hash":"fa626fc47427c670bdab143c3b72536c273ea376","modified":1675526098052},{"_id":"themes/hexo-theme-anatolo/LICENSE","hash":"c6e73f74e331546c7bc59ed16025b1381145e389","modified":1675526098049},{"_id":"themes/hexo-theme-anatolo/_config.yml","hash":"2c67595a0685a6091dce881735e3ae9a7af07712","modified":1675572687747},{"_id":"themes/hexo-theme-anatolo/README.md","hash":"fa176d9b47f769935c44c6e6ae204e293d0142bf","modified":1675526098050},{"_id":"themes/hexo-theme-anatolo/languages/zh-cn.yml","hash":"8af686049de627e59676d25e13ad638f6f707315","modified":1675526098053},{"_id":"themes/hexo-theme-anatolo/layout/index.pug","hash":"57e3b4f9ff332de85c0726fc6f3e7a7882750eff","modified":1675526098054},{"_id":"themes/hexo-theme-anatolo/layout/category.pug","hash":"cf9c50a38f21a5a1f3223a06d3c731d211389d1c","modified":1675526098054},{"_id":"themes/hexo-theme-anatolo/languages/en.yml","hash":"16fc53de3c6d18be736ef69d315b0d387fed7ad3","modified":1675526098052},{"_id":"themes/hexo-theme-anatolo/layout/page.pug","hash":"570190249a84b551dc6ac3d4466c9e9deaff0711","modified":1675526098055},{"_id":"themes/hexo-theme-anatolo/layout/archive.pug","hash":"7c9c18beef56e713191da2f76a5320b1bfda86c5","modified":1675526098053},{"_id":"themes/hexo-theme-anatolo/layout/mixins.pug","hash":"c17a7d51fb25f2629fb3f8a1af89c1e946a900c1","modified":1675526098054},{"_id":"themes/hexo-theme-anatolo/includes/generators/insight.js","hash":"c4b981443927b87cc14a3a583029e13f819d6d71","modified":1675526098051},{"_id":"themes/hexo-theme-anatolo/includes/generators/tags.js","hash":"50d939b63fc00a19064c6fe59b6db0f8e140e39d","modified":1675526098051},{"_id":"themes/hexo-theme-anatolo/includes/tasks/welcome.js","hash":"56073b2019bb20b452a123b9dfcbb3678b40517c","modified":1675526098052},{"_id":"themes/hexo-theme-anatolo/layout/post.pug","hash":"757e8b4321870ad94040344ffb5405e7abe2625b","modified":1675526098062},{"_id":"themes/hexo-theme-anatolo/layout/tags.pug","hash":"41208b4d5ca33e171419769605089a012206ca35","modified":1675526098063},{"_id":"themes/hexo-theme-anatolo/layout/tag.pug","hash":"cc0b383e1313199e9e8537c610fc6c6023f22a1e","modified":1675526098062},{"_id":"themes/hexo-theme-anatolo/includes/helpers/site.js","hash":"221d84f5eca5b91dfd429705d0651067e6d9063a","modified":1675526098051},{"_id":"themes/hexo-theme-anatolo/scripts/index.js","hash":"116a35be4c2c89ee400bb5453943de2abb676840","modified":1675526098063},{"_id":"themes/hexo-theme-anatolo/layout/partial/footer.pug","hash":"4e3e47701211869b2097e6472278a024b912346d","modified":1675526098058},{"_id":"themes/hexo-theme-anatolo/layout/partial/comments.pug","hash":"18aa53273ea23a77def635a3b962fe71075f00f8","modified":1675526098056},{"_id":"themes/hexo-theme-anatolo/layout/partial/head.pug","hash":"8ec73cb945f60b27e9ce9928be31b13e98e18810","modified":1675526098059},{"_id":"themes/hexo-theme-anatolo/layout/partial/layout.pug","hash":"d1cadb1cf6d073649173d4475ebabd1ea78538ce","modified":1675526098060},{"_id":"themes/hexo-theme-anatolo/layout/partial/search.pug","hash":"342e0f1d5813d448051257c361fa676f45e3f49c","modified":1675526098061},{"_id":"themes/hexo-theme-anatolo/layout/partial/nav.pug","hash":"de72fabaa0d1464bcfa9f6b6d34739e170f09b8e","modified":1675526098060},{"_id":"themes/hexo-theme-anatolo/layout/partial/sidebar.pug","hash":"08a304b3a640c48fd4c58125d220d3f8dd1f1b08","modified":1675526098061},{"_id":"themes/hexo-theme-anatolo/layout/partial/social_links.pug","hash":"234218895422dd915a6d0115b012353d9b37fc62","modified":1675526098062},{"_id":"themes/hexo-theme-anatolo/layout/partial/toc.pug","hash":"2bbaab792d5346063d94d18ad1dd5e6dd7903711","modified":1675526098062},{"_id":"themes/hexo-theme-anatolo/source/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1675526098065},{"_id":"themes/hexo-theme-anatolo/source/css/insight.css","hash":"b468a47b30b47017b06ff6c431c49a316288a501","modified":1675526098065},{"_id":"themes/hexo-theme-anatolo/source/css/search.css","hash":"c1cb306e075386517ac15bf4ef37c647d37ec6b5","modified":1675526098066},{"_id":"themes/hexo-theme-anatolo/source/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1675526098064},{"_id":"themes/hexo-theme-anatolo/source/css/style.styl","hash":"3345e74ed0381227e9ac0d371aba4b4b12dba62f","modified":1675526098068},{"_id":"themes/hexo-theme-anatolo/source/images/favicon.webp","hash":"b2c2e853f326a171da7dce74aa45a363a750c359","modified":1675526098084},{"_id":"themes/hexo-theme-anatolo/source/css/blog_basic.styl","hash":"6036d6b6c44fd29a83732e6800aca163aac86008","modified":1675526098064},{"_id":"themes/hexo-theme-anatolo/source/images/logo.webp","hash":"9371dc18ac0528af787431109538cde4910da98d","modified":1675526098085},{"_id":"themes/hexo-theme-anatolo/source/images/logo@2x.webp","hash":"48e26e26b8e4a07d7e5c0a4b3654675cc870f3aa","modified":1675526098086},{"_id":"themes/hexo-theme-anatolo/source/js/add-bookmark.js","hash":"3cd1622f94f184ca7a542fcbcce75cf9130b9208","modified":1675526098086},{"_id":"themes/hexo-theme-anatolo/source/js/baidu-tongji.js","hash":"49d6d863bc54d843efcc1cd5a92b0e3d65c4bdd6","modified":1675526098087},{"_id":"themes/hexo-theme-anatolo/source/js/darkLightToggle.js","hash":"e965ae5a799d8e643f6d9b5eed2565258e2edf37","modified":1675526098087},{"_id":"themes/hexo-theme-anatolo/source/js/insight.js","hash":"16f64c50efc78abb3d94c079d3cda0b74e809f5e","modified":1675526098087},{"_id":"themes/hexo-theme-anatolo/source/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1675526098088},{"_id":"themes/hexo-theme-anatolo/source/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1675526098089},{"_id":"themes/hexo-theme-anatolo/source/js/tagcloud.js","hash":"cd02ffd8e5192cb25f50f6c5c920a3249ff1614f","modified":1675526098097},{"_id":"themes/hexo-theme-anatolo/source/js/visitors.js","hash":"717a2483ae4d7682d944e79c2a1efd959fa112bc","modified":1675526098097},{"_id":"themes/hexo-theme-anatolo/source/js/tagcanvas.js","hash":"db9a61a79350d1618a74a8f3448f06046c3d9a6c","modified":1675526098096},{"_id":"themes/hexo-theme-anatolo/source/images/gongan.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1675526098085},{"_id":"themes/hexo-theme-anatolo/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1675526098083},{"_id":"themes/hexo-theme-anatolo/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1675526098081},{"_id":"themes/hexo-theme-anatolo/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1675526098072},{"_id":"themes/hexo-theme-anatolo/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1675526098078},{"_id":"themes/hexo-theme-anatolo/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1675526098070},{"_id":"themes/hexo-theme-anatolo/source/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1675526098095},{"_id":"themes/hexo-theme-anatolo/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1675526098076},{"_id":"source/.DS_Store","hash":"7e37ae8ad43795b127922bf5cc278df150f06744","modified":1675570244223},{"_id":"source/_posts/2022-09-17-ARouter源码分析.md","hash":"100dee52925d0375e069036a40a0157ca2127b8a","modified":1675563567204},{"_id":"source/_posts/2022-09-17-Glide源码分析与自我实现1.md","hash":"80f3b641897312124208f494dda62cb685d63fb1","modified":1675570497295},{"_id":"source/_posts/2022-09-17-Glide源码分析与自我实现2.md","hash":"e465c09aae595e865050926f109b6f338485e8ee","modified":1663551259727},{"_id":"source/_posts/2022-09-17-Glide源码分析与自我实现3.md","hash":"b78db0780f14c3afdaae8b82643f364b1bc22457","modified":1675570564337},{"_id":"source/_posts/2022-09-17-Jetpack之Lifecycle源码分析.md","hash":"1d9c4b5fbd3f27feb72425235fd64592f7bd585e","modified":1663551264087},{"_id":"source/_posts/2022-09-17-LeakCanary原理分析.md","hash":"eca734e2796b4e15c2fa5f0069c71556d6b20f84","modified":1663551268388},{"_id":"source/_posts/2022-09-17-Jetpack之LiveData源码分析.md","hash":"a563879df5e873ef8822176e8dc4706c51ff58c6","modified":1663551266135},{"_id":"source/_posts/2022-09-17-LiveEventBus源码分析.md","hash":"2934da06644ef33ecb1b70dfb5dc4af39c068498","modified":1663551246246},{"_id":"source/_posts/2022-09-17-手撸一个路由框架IRouter.md","hash":"19c0efca627a76cd7888cf0bbf6e2aa71ea7acf7","modified":1675570576474},{"_id":"source/_posts/2022-09-19-AMS启动流程.md","hash":"f580f45418ef81b870d1f2fef87d5278b3079e85","modified":1663550886152},{"_id":"source/_posts/2022-09-19-ASM.md","hash":"cfbff115861cd3296246be96bda2e410b97c332e","modified":1675570716087},{"_id":"source/_posts/2022-09-19-Activity启动流程.md","hash":"49907b259c865ce2e462a602c93449640e12d63e","modified":1663551275313},{"_id":"source/_posts/2022-09-19-Apk瘦身术.md","hash":"1461f6fe43d3fecccda32685f6bc2af91edd7d49","modified":1663640087050},{"_id":"source/_posts/2022-09-19-Mavencentral.md","hash":"72d7c719967e4f8996e8caea7338bda8a9420147","modified":1675570707022},{"_id":"source/_posts/2022-09-19-Binder机制分析.md","hash":"20d8ae1386ce932130756ff728d9f0030b408e28","modified":1675570703479},{"_id":"source/_posts/2022-09-19-Intent.FLAG_ACTIVITY_***到底能干啥.md","hash":"201b2ce8ab5cb5389716cf52a984399e904d98d2","modified":1663550856141},{"_id":"source/_posts/2022-09-19-LaunchMode.md","hash":"1beed6c9c1bf14ab393a15fde61b1060da9329e3","modified":1663551253411},{"_id":"source/_posts/2022-09-19-App保活术.md","hash":"17fdb40703efb040ef1e0c113774664e072209b1","modified":1675570718597},{"_id":"source/_posts/2022-10-13-clipToXXX.md","hash":"63f36d2cab268e805f5b93bccb4c7bc39e865624","modified":1675570318206},{"_id":"source/_posts/2022-09-22-难忘的bug.md","hash":"a69e3fb01c717f97b1feb3e3763b2eedfe8a2c77","modified":1663927354640},{"_id":"source/_posts/2022-09-23-Kotlin Native.md","hash":"2ee828b91d498a0146a8c0c1d79e03d995562310","modified":1675570699758},{"_id":"source/assets/.DS_Store","hash":"2a98a0d8f231aef5b58e54eb973410448f9f52f7","modified":1675569045472},{"_id":"source/_posts/2023-02-05-Hello-2023.md","hash":"ccebd1149b85085a92e58d9eba5684b2d2dab30c","modified":1675534989744},{"_id":"source/_posts/2022-11-02-Translator.md","hash":"0afc6efd98cc159f5936c3fd751e5e652b0748f4","modified":1675571770481},{"_id":"source/assets/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1667488453092},{"_id":"source/assets/images/4179925-8c703df0b005aae7.webp","hash":"b415ef84a48ab432ce4e37a67d3c54fb6230bb86","modified":1602644782000},{"_id":"source/assets/images/4179925-32ee7bd0974a4679.webp","hash":"5fdfb0b5c499cac0475c92c80d8b5be23d869327","modified":1602644782000},{"_id":"source/assets/images/4179925-af582100631d7eec.webp","hash":"1d42ed4533a6066850ed1aad571442d235fa7277","modified":1602644782000},{"_id":"source/assets/images/4179925-a718d240e05a2198.webp","hash":"93fb0fbb7e80ed4ef018f92aee8acbe3d4744767","modified":1602644782000},{"_id":"source/assets/images/4179925-e2e730e41623be28.webp","hash":"26752200cf7a78b368f9a42391fc1e9309997099","modified":1602644782000},{"_id":"source/assets/images/4179925-d4f950ec94a12cde.webp","hash":"360f383a07df52841e903eb8be377849efe63b12","modified":1602644782000},{"_id":"source/assets/images/apple-touch-icon-300x300.jpg","hash":"b109526f061bb095ac80f4009848d71b6a5c1799","modified":1602646140000},{"_id":"source/assets/images/binder_data_trans.jpg","hash":"f8d277ca4d20af9c1a9691b9de8d02875752b68c","modified":1602840313000},{"_id":"source/assets/images/client_server_service_manager.jpg","hash":"2e6f8a81f85a0300770ba872db8c4149a9580726","modified":1602839103000},{"_id":"source/assets/images/ezgif-6-73b502b11e16.jpg","hash":"293f7545de3735a9c87977288084fe2791ae4b2e","modified":1602644782000},{"_id":"source/assets/images/favicon-16x16.png","hash":"618e521e7fcdee391904eb640a5afcee0e1827df","modified":1602645985000},{"_id":"source/assets/images/favicon-32x32.png","hash":"015aec45aa904c6e3abb5c1c88850b56d75e54d4","modified":1602646029000},{"_id":"source/assets/images/favicon-96x96.png","hash":"01a700c5ae676575307a49e447255c1b48c56911","modified":1602646019000},{"_id":"source/assets/images/favicon.svg","hash":"fd1617505a3aa939beaea9b9dce49b587ebf3d2d","modified":1602650740000},{"_id":"source/assets/images/gif_after_optimization.png","hash":"34702fa3776daca783e662e67ac913b27f0ea465","modified":1604599868000},{"_id":"source/assets/images/gif_before_optimization.png","hash":"1152538c1414ae1bfe24c12f676d58eea7586756","modified":1604599787000},{"_id":"source/assets/images/gif.webp","hash":"46111574995ed72ee8949e13fd5d4dd8dc5004ac","modified":1605163181000},{"_id":"source/assets/images/linux_memory.png","hash":"45c233172da59f1386edd3bb7567a1fa37721428","modified":1602835652000},{"_id":"source/assets/images/my_face.jpeg","hash":"48ba48ce5373c648492340c2e02cba366f741f0c","modified":1602644782000},{"_id":"source/assets/images/preview.jpg","hash":"0ca7f124f18d5d4ab78d4f741c5ce6221b83e861","modified":1667406898723},{"_id":"source/assets/images/oom_adj.png","hash":"dce29cb9f5d462a52f5e816c2f33d1dad2b5ce87","modified":1602644782000},{"_id":"source/assets/images/search.svg","hash":"74e01292f5ff20c9252c1b3b6f54cf3a18f91a59","modified":1602644782000},{"_id":"source/assets/images/playground.jpg","hash":"c36f5625c5a874c7537f60840bad8ad98335b061","modified":1666017078513},{"_id":"source/assets/images/translator-logo-512.png","hash":"126df804480c037d33275c383f38380534c42f4b","modified":1666877473791},{"_id":"source/assets/images/android_binder.jpg","hash":"37493760a630f10c998c9c208564a38bc39aaf22","modified":1602838541000},{"_id":"source/assets/images/4179925-f5a428b729962860.webp","hash":"e7f12b909fd9eaed28d0c32394569d3b7b6c1c50","modified":1602644782000},{"_id":"source/assets/images/binder.jpg","hash":"a573fd41bc104f928b3ca21b7435b00072ac29e3","modified":1602836604000},{"_id":"source/assets/images/glide_struct.jpg","hash":"f7882b9ad23e69abcede6bfb648550f4d2c3d9b6","modified":1604398052000},{"_id":"source/assets/images/linux_ipc.jpg","hash":"f06a3c6aa83daa173e3ad2f65310b1327f30c006","modified":1602836019000},{"_id":"source/assets/images/process_priority.jpg","hash":"aada1c63d4e8d0c48daa883d9b88039ba038a077","modified":1602644782000},{"_id":"source/assets/images/request_implementions.jpg","hash":"3435f6bb6261d9b4a96f4d2729b96f83ba3790d9","modified":1604072645000},{"_id":"source/assets/images/traditional_ipc.jpg","hash":"61969966ad978ba30f947177d6a637f5e89b6931","modified":1602834916000},{"_id":"source/assets/images/xcode-select.jpg","hash":"17c798c8a595d3ba244a89c120fefcb8ad4a70dd","modified":1663941031477},{"_id":"source/assets/images/4179925-0cc8712718f08ea0.webp","hash":"5dbbc103ee4bb410176301250240131b448c09f1","modified":1602644782000},{"_id":"source/assets/images/forground_service.png","hash":"f37e153d42f48afa0140c52d17afef7ece16c7e6","modified":1602644782000},{"_id":"source/assets/images/kotlin-native-starter.jpg","hash":"fad8a024ac6b003d9a087061837fb5478625f749","modified":1663939909643},{"_id":"source/assets/images/jd_loader_manager.jpg","hash":"6896c7533aab7508a4e9804eacbeb00280163b1f","modified":1614447281000},{"_id":"source/assets/images/mc_build_push.jpg","hash":"4188af5cae1d89336e6bb414540592417e40e0cf","modified":1616475855000},{"_id":"source/assets/images/net_model.png","hash":"2e150de90280ef4c660f355aef8af7a0f102894e","modified":1615477186000},{"_id":"source/assets/images/mc_resolved.jpg","hash":"b9558df7a4a2ba7bea0ebc156dd782fca3f1f943","modified":1616473425000},{"_id":"source/assets/images/mc_publish.jpg","hash":"fb0ae474f33b24693ae0c341bf1bda54e532375a","modified":1616476624000},{"_id":"source/assets/images/mc_pwd.png","hash":"b738d236271676ea6929bd9fd4d14ba8360bff49","modified":1616474553000},{"_id":"source/assets/images/mc_cer_push.png","hash":"69ee7895a0014ce62629191b2d4cf16fdc308cd4","modified":1616475487000},{"_id":"source/assets/images/mc_create.jpg","hash":"7d909da0bf201d3f045e0b04fb784c78508d95d3","modified":1616472896000},{"_id":"source/assets/images/mc_replay.jpg","hash":"3a927929c1e0cd4f536eb061c9517a86585b6664","modified":1616473284000},{"_id":"source/images/4179925-8c703df0b005aae7.webp","hash":"b415ef84a48ab432ce4e37a67d3c54fb6230bb86","modified":1602644782000},{"_id":"source/images/4179925-32ee7bd0974a4679.webp","hash":"5fdfb0b5c499cac0475c92c80d8b5be23d869327","modified":1602644782000},{"_id":"source/images/4179925-a718d240e05a2198.webp","hash":"93fb0fbb7e80ed4ef018f92aee8acbe3d4744767","modified":1602644782000},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1667488453092},{"_id":"source/images/4179925-d4f950ec94a12cde.webp","hash":"360f383a07df52841e903eb8be377849efe63b12","modified":1602644782000},{"_id":"source/images/4179925-e2e730e41623be28.webp","hash":"26752200cf7a78b368f9a42391fc1e9309997099","modified":1602644782000},{"_id":"source/images/apple-touch-icon-300x300.jpg","hash":"b109526f061bb095ac80f4009848d71b6a5c1799","modified":1602646140000},{"_id":"source/images/binder_data_trans.jpg","hash":"f8d277ca4d20af9c1a9691b9de8d02875752b68c","modified":1602840313000},{"_id":"source/images/favicon-96x96.png","hash":"01a700c5ae676575307a49e447255c1b48c56911","modified":1602646019000},{"_id":"source/images/favicon-16x16.png","hash":"618e521e7fcdee391904eb640a5afcee0e1827df","modified":1602645985000},{"_id":"source/images/ezgif-6-73b502b11e16.jpg","hash":"293f7545de3735a9c87977288084fe2791ae4b2e","modified":1602644782000},{"_id":"source/images/favicon-32x32.png","hash":"015aec45aa904c6e3abb5c1c88850b56d75e54d4","modified":1602646029000},{"_id":"source/images/client_server_service_manager.jpg","hash":"2e6f8a81f85a0300770ba872db8c4149a9580726","modified":1602839103000},{"_id":"source/images/favicon.svg","hash":"fd1617505a3aa939beaea9b9dce49b587ebf3d2d","modified":1602650740000},{"_id":"source/images/gif_after_optimization.png","hash":"34702fa3776daca783e662e67ac913b27f0ea465","modified":1604599868000},{"_id":"source/images/gif.webp","hash":"46111574995ed72ee8949e13fd5d4dd8dc5004ac","modified":1605163181000},{"_id":"source/images/gif_before_optimization.png","hash":"1152538c1414ae1bfe24c12f676d58eea7586756","modified":1604599787000},{"_id":"source/images/linux_memory.png","hash":"45c233172da59f1386edd3bb7567a1fa37721428","modified":1602835652000},{"_id":"source/images/4179925-af582100631d7eec.webp","hash":"1d42ed4533a6066850ed1aad571442d235fa7277","modified":1602644782000},{"_id":"source/images/oom_adj.png","hash":"dce29cb9f5d462a52f5e816c2f33d1dad2b5ce87","modified":1602644782000},{"_id":"source/images/playground.jpg","hash":"c36f5625c5a874c7537f60840bad8ad98335b061","modified":1666017078513},{"_id":"source/images/preview.jpg","hash":"0ca7f124f18d5d4ab78d4f741c5ce6221b83e861","modified":1667406898723},{"_id":"source/images/search.svg","hash":"74e01292f5ff20c9252c1b3b6f54cf3a18f91a59","modified":1602644782000},{"_id":"source/images/translator-logo-512.png","hash":"126df804480c037d33275c383f38380534c42f4b","modified":1666877473791},{"_id":"source/images/my_face.jpeg","hash":"48ba48ce5373c648492340c2e02cba366f741f0c","modified":1602644782000},{"_id":"source/images/android_binder.jpg","hash":"37493760a630f10c998c9c208564a38bc39aaf22","modified":1602838541000},{"_id":"source/images/4179925-f5a428b729962860.webp","hash":"e7f12b909fd9eaed28d0c32394569d3b7b6c1c50","modified":1602644782000},{"_id":"source/images/binder.jpg","hash":"a573fd41bc104f928b3ca21b7435b00072ac29e3","modified":1602836604000},{"_id":"source/images/glide_struct.jpg","hash":"f7882b9ad23e69abcede6bfb648550f4d2c3d9b6","modified":1604398052000},{"_id":"source/images/linux_ipc.jpg","hash":"f06a3c6aa83daa173e3ad2f65310b1327f30c006","modified":1602836019000},{"_id":"source/images/process_priority.jpg","hash":"aada1c63d4e8d0c48daa883d9b88039ba038a077","modified":1602644782000},{"_id":"source/images/request_implementions.jpg","hash":"3435f6bb6261d9b4a96f4d2729b96f83ba3790d9","modified":1604072645000},{"_id":"source/images/xcode-select.jpg","hash":"17c798c8a595d3ba244a89c120fefcb8ad4a70dd","modified":1663941031477},{"_id":"source/images/traditional_ipc.jpg","hash":"61969966ad978ba30f947177d6a637f5e89b6931","modified":1602834916000},{"_id":"source/images/4179925-0cc8712718f08ea0.webp","hash":"5dbbc103ee4bb410176301250240131b448c09f1","modified":1602644782000},{"_id":"source/images/kotlin-native-starter.jpg","hash":"fad8a024ac6b003d9a087061837fb5478625f749","modified":1663939909643},{"_id":"source/images/forground_service.png","hash":"f37e153d42f48afa0140c52d17afef7ece16c7e6","modified":1602644782000},{"_id":"source/images/mc_resolved.jpg","hash":"b9558df7a4a2ba7bea0ebc156dd782fca3f1f943","modified":1616473425000},{"_id":"source/images/mc_publish.jpg","hash":"fb0ae474f33b24693ae0c341bf1bda54e532375a","modified":1616476624000},{"_id":"source/images/mc_build_push.jpg","hash":"4188af5cae1d89336e6bb414540592417e40e0cf","modified":1616475855000},{"_id":"source/images/mc_pwd.png","hash":"b738d236271676ea6929bd9fd4d14ba8360bff49","modified":1616474553000},{"_id":"source/images/net_model.png","hash":"2e150de90280ef4c660f355aef8af7a0f102894e","modified":1615477186000},{"_id":"source/images/jd_loader_manager.jpg","hash":"6896c7533aab7508a4e9804eacbeb00280163b1f","modified":1614447281000},{"_id":"source/images/mc_cer_push.png","hash":"69ee7895a0014ce62629191b2d4cf16fdc308cd4","modified":1616475487000},{"_id":"source/images/mc_create.jpg","hash":"7d909da0bf201d3f045e0b04fb784c78508d95d3","modified":1616472896000},{"_id":"source/images/mc_replay.jpg","hash":"3a927929c1e0cd4f536eb061c9517a86585b6664","modified":1616473284000},{"_id":"themes/hexo-theme-anatolo/source/.DS_Store","hash":"b19a69b879d53e76b9bda94a288d0c0e468f6994","modified":1675572650750},{"_id":"themes/hexo-theme-anatolo/source/images/favicon-96x96.png","hash":"01a700c5ae676575307a49e447255c1b48c56911","modified":1602646019000},{"_id":"themes/hexo-theme-anatolo/source/images/favicon-32x32.png","hash":"015aec45aa904c6e3abb5c1c88850b56d75e54d4","modified":1602646029000},{"_id":"themes/hexo-theme-anatolo/source/images/favicon-16x16.png","hash":"618e521e7fcdee391904eb640a5afcee0e1827df","modified":1602645985000},{"_id":"themes/hexo-theme-anatolo/source/images/logo.jpg","hash":"820d62c34a58b104b9545442660502be25c26ac3","modified":1652460235000}],"Category":[{"name":"源码分析","_id":"cldqukh7v0002pcjg073e6yai"},{"name":"Android技巧","_id":"cldqukh8w000spcjgfnhk5vu6"},{"name":"陷阱与缺陷","_id":"cldqukh9m001mpcjg10qy39tx"},{"name":"Kotlin Native","_id":"cldqukh9r001wpcjg4h8t648u"},{"name":"Translator","_id":"cldqukh9t0023pcjg9ko5f73g"}],"Data":[],"Page":[],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2023-02-04T15:48:14.285Z","updated":"2023-02-04T15:48:14.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldq5il060000wsjg0momh7wx","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"layout":"post","title":"ARouter源码分析","author":"boybeak","_content":"\n\n在阅读源码前，请先下载源码：[ARouter](https://github.com/alibaba/ARouter)\n\n最近阅读ARouter源码，发现这真的是一个非常优秀的框架。激发出兴趣来读一下他的源码，实际上，这个框架的结构非常简单。这个框架可以分为**主流程**和**辅助流程**来拆开分析。\n\n主流程包含**编译时**和**运行时**两个部分，其中编译时主要做的是路由路径表的构建，运行时主要做的是路由路径表的加载；\n\n辅助流程主要就是做**启动优化**。\n\n## 主流程\n\n### 1. 编译时\n\n这部分主要涉及到的是路由路径表的构建，其实现原理是**APT**，即**注解处理器**。\n\n使用ARouter时候，需要在目标类上，通过**@Route**注解进行标记，注解处理器处理的就是这个注解。打开源码路径下的*arouter-compiler*这个module，找到**RouteProcessor**，这个类就是用来处理**@Route**注解的类。这里需要了解的知识，除了APT，还有java-poet，请自行了解这些。\n\nProcessor类的入口方法是*process*方法，这个方法返回true，则这个处理器已经完成了自己的任务，不会被重复调用。其他比较重要的方法有*getSupportedSourceVersion*，*getSupportedAnnotationTypes*等。\n\n```java\nSet<? extends Element> routeElements = roundEnv.getElementsAnnotatedWith(Route.class);\n```\n\n通过这个方法，获取所有被**@Route**标记的元素。\n\n获取到*routeElements*后，在*parseRoutes*方法进行处理。我们以最常用的Activity为例，进行分析。\n\n```java\nrootMap.clear();\t//用来分类存储标记元素\n\n// 用来检测元素是否为对应的类型，通过Types.isSubtype()方法来检测。\nTypeMirror type_Activity = elementUtils.getTypeElement(ACTIVITY).asType();\nTypeMirror type_Service = elementUtils.getTypeElement(SERVICE).asType();\nTypeMirror fragmentTm = elementUtils.getTypeElement(FRAGMENT).asType();\nTypeMirror fragmentTmV4 = elementUtils.getTypeElement(Consts.FRAGMENT_V4).asType();\n```\n\n最后将分类号的元素信息，存储在成员变量groupMap中去。\n\n```java\nprivate Map<String, Set<RouteMeta>> groupMap = new HashMap<>();\n```\n\n然后再通过这个groupMap，借助java-poet，来生成真实的类。如下：\n\n```java\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    atlas.put(\"/test/activity1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/activity1\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"ser\", 9); put(\"ch\", 5); put(\"fl\", 6); put(\"dou\", 7); put(\"boy\", 0); put(\"url\", 8); put(\"pac\", 10); put(\"obj\", 11); put(\"name\", 8); put(\"objList\", 11); put(\"map\", 11); put(\"age\", 3); put(\"height\", 3); }}, -1, -2147483648));\n    atlas.put(\"/test/activity2\", RouteMeta.build(RouteType.ACTIVITY, Test2Activity.class, \"/test/activity2\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"key1\", 8); }}, -1, -2147483648));\n    atlas.put(\"/test/activity3\", RouteMeta.build(RouteType.ACTIVITY, Test3Activity.class, \"/test/activity3\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"name\", 8); put(\"boy\", 0); put(\"age\", 3); }}, -1, -2147483648));\n    atlas.put(\"/test/activity4\", RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, \"/test/activity4\", \"test\", null, -1, -2147483648));\n    atlas.put(\"/test/fragment\", RouteMeta.build(RouteType.FRAGMENT, BlankFragment.class, \"/test/fragment\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"obj\", 11); put(\"name\", 8); }}, -1, -2147483648));\n    atlas.put(\"/test/webview\", RouteMeta.build(RouteType.ACTIVITY, TestWebview.class, \"/test/webview\", \"test\", null, -1, -2147483648));\n  }\n}\n```\n\n\n\n### 2. 运行时\n\n这部分主要做的是，在*ARouter.init()*时候，将上过程生成的路径表加载到内存中。\n\n> 如果你以官方demo程序验证这一步，需要将app/build.gradle中的`apply plugin: 'com.alibaba.arouter'`这一行代码注释掉。\n\n我们以*ARouter.init*方法为入口，实际上最终实现init流程的是LogisticsCenter类的*init*方法。\n\n```java\npublic synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n  ...\n  if (registerByPlugin) {\n    //这是在辅助流程需要去讲的\n  \tlogger.info(TAG, \"Load router map by arouter-auto-register plugin.\");\n  } else {\n    Set<String> routerMap;\n\n    // It will rebuild router map every times when debuggable.\n    if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) {\n      logger.info(TAG, \"Run with debug mode or new install, rebuild router map.\");\n      // These class was generated by arouter-compiler.\n      routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n      if (!routerMap.isEmpty()) {\n        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();\n      }\n\n      PackageUtils.updateVersion(context);    // Save new version name when router map update finishes.\n    } else {\n      logger.info(TAG, \"Load router map from cache.\");\n      routerMap = new HashSet<>(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, new HashSet<String>()));\n    }\n  }\n}\n```\n\n这里需要着重看的是这一句：\n\n```java\nrouterMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n```\n\n我们查看这个方法:\n\n```java\npublic static Set<String> getFileNameByPackageName(Context context, final String packageName) throws PackageManager.NameNotFoundException, IOException, InterruptedException {\n  final Set<String> classNames = new HashSet<>();\n\n  List<String> paths = getSourcePaths(context);\n  final CountDownLatch parserCtl = new CountDownLatch(paths.size());\n\n  for (final String path : paths) {\n    Log.v(TAG, \"getFileNameByPackageName path=\" + path);\n    DefaultPoolExecutor.getInstance().execute(new Runnable() {\n      @Override\n      public void run() {\n        DexFile dexfile = null;\n\n        try {\n          if (path.endsWith(EXTRACTED_SUFFIX)) {\n            //NOT use new DexFile(path), because it will throw \"permission error in /data/dalvik-cache\"\n            dexfile = DexFile.loadDex(path, path + \".tmp\", 0);\n          } else {\n            dexfile = new DexFile(path);\n          }\n\n          Enumeration<String> dexEntries = dexfile.entries();\n          while (dexEntries.hasMoreElements()) {\n            String className = dexEntries.nextElement();\n            if (className.startsWith(packageName)) {\n              Log.v(TAG, \"find CLASS NAME \" + className);\n              classNames.add(className);\n            }\n          }\n        } catch (Throwable ignore) {\n          Log.e(\"ARouter\", \"Scan map file in dex files made error.\", ignore);\n        } finally {\n          if (null != dexfile) {\n            try {\n              dexfile.close();\n            } catch (Throwable ignore) {\n            }\n          }\n\n          parserCtl.countDown();\n        }\n      }\n    });\n  }\n\n  parserCtl.await();\n\n  Log.d(Consts.TAG, \"Filter \" + classNames.size() + \" classes by packageName <\" + packageName + \">\");\n  return classNames;\n}\n```\n\n注意其中的*getSourcePaths*方法，这是从代码目录，来获取所有代码目录，然后在\n\n*getFileNameByPackageName*找出以`com.alibaba.android.arouter.routes`为开头包名的类，这些就是我们在步骤1中生成的辅助类。\n\n这个方法结束后，回到*LogisticsCenter#init*方法，接下来要做的就是，把加载到的辅助类，通过反射生成对象，再调用其*loadTo*方法，将路由路径表加载到Warehouse类中去，方便以后的查询。\n\n\n\n## 辅助流程\n\n在以上的流程中，有一个严重的问题，那就是执行*ARouter#init*方法的时间过长，以源码的demo为例，在InstantRun的情况下，OnePlus5T需要100多毫秒才能初始化完，这对于程序启动优化来说，是一个不可忽视的时间了。那么如何解决这个问题呢？\n\n```shell\nMainActivity: init cost 134\n```\n\n这就是在上一步中，要求你注释掉的代码起作用了，将`apply plugin: 'com.alibaba.arouter'`解除注释，让其发挥作用。\n\n这里需要关注的module是`arouter-gradle-plugin`。\n\n先来看一下，使用了`apply plugin: 'com.alibaba.arouter'`的神奇效果。\n\n```shell\nMainActivity: init cost 19\n```\n\n通过优化，让*ARouter#init*消耗时间直接降低了一个数量级，那么`arouter-gradle-plugin`是怎么做到的呢？\n\n这需要你先了解一下[ASM]({{site.base_url}}/android/ASM.md)。简单来说，这是一种字节码编程技术，通过修改编译后的字节码的方式，来对原始逻辑增强。\n\n我们再来看*ARouter#init*的最终实现类和方法*LogisticsCenter#init*：\n\n```java\npublic synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n  ....\n  try {\n    long startInit = System.currentTimeMillis();\n    //billy.qi modified at 2017-12-06\n    //load by plugin first\n    loadRouterMap();\n    if (registerByPlugin) {\n      logger.info(TAG, \"Load router map by arouter-auto-register plugin.\");\n    } else {\n      ....\n    }\n    .....\n  } catch (Exception e) {\n    throw new HandlerException(TAG + \"ARouter init logistics center exception! [\" + e.getMessage() + \"]\");\n  }\n}\n```\n\n我们可以看到，当`registerByPlugin`为true的时候，则只是打印了一句日志，我们再看loadRouterMap()这个方法：\n\n```java\nprivate static void loadRouterMap() {\n  registerByPlugin = false;\n  //auto generate register code by gradle plugin: arouter-auto-register\n  // looks like below:\n  // registerRouteRoot(new ARouter..Root..modulejava());\n  // registerRouteRoot(new ARouter..Root..modulekotlin());\n}\n```\n\n这里的逻辑非常简单，到底在哪里去加载的路由路径表呢？我们看这个方法的注释，发现，这个方法是被`arouter-auto-register`自动生成的。\n\n我们打开`arouter-gradle-plugin/resources/META-INF/gradle-plugins`这个目录，可以看到，有一个*com.alibaba.arouter.properties*文件，查看其内容：\n\n```properties\nimplementation-class=com.alibaba.android.arouter.register.launch.PluginLaunch\n```\n\n这个*PluginLaunch*便是此gradle plugin的入口类。查看此类：\n\n```groovy\npublic class PluginLaunch implements Plugin<Project> {\n\n  @Override\n  public void apply(Project project) {\n    def isApp = project.plugins.hasPlugin(AppPlugin)\n    //only application module needs this plugin to generate register code\n    if (isApp) {\n      Logger.make(project)\n\n      Logger.i('Project enable arouter-register plugin')\n\n      def android = project.extensions.getByType(AppExtension)\n      def transformImpl = new RegisterTransform(project)\n\n      //init arouter-auto-register settings\n      ArrayList<ScanSetting> list = new ArrayList<>(3)\n      list.add(new ScanSetting('IRouteRoot'))\n      list.add(new ScanSetting('IInterceptorGroup'))\n      list.add(new ScanSetting('IProviderGroup'))\n      RegisterTransform.registerList = list\n      //register this plugin\n      android.registerTransform(transformImpl)\n    }\n  }\n\n}\n```\n\n我们查看其代码，可以发现，这里一共做了三件事：\n\n1. 判断是否为app module，如果不是，则不做任何事，在app module下做2和3两步；\n2. 生成了一个RegisterTransform，并为其静态变量registerList赋值，**注意此处赋值的registerList中包含的三个对象**；\n3. 注册此RegisterTransform。\n\n接下来，就轮到*RegisterTransform*来执行了。\n\nTransform类，简单来说，就是可以在编译时，扫描所有的jar和class，包括引用类库中的。在扫描过程中，就可以借助**ASM**技术对目标类进行更改。\n\n我们看其入口方法*transform*：\n\n```groovy\n@Override\nvoid transform(Context context, Collection<TransformInput> inputs, Collection<TransformInput> referencedInputs, TransformOutputProvider outputProvider, boolean isIncremental) throws IOException, TransformException, InterruptedException {\n  inputs.each { TransformInput input ->\n    // scan all jars\n    input.jarInputs.each { JarInput jarInput ->\n      ...\n      if (ScanUtil.shouldProcessPreDexJar(src.absolutePath)) {\n        ScanUtil.scanJar(src, dest)\n      }\n      ...\n    }\n  }\n  input.directoryInputs.each { DirectoryInput directoryInput ->\n    ...\n    directoryInput.file.eachFileRecurse { File file ->\n      ...\n      if(file.isFile() && ScanUtil.shouldProcessClass(path)){\n        ScanUtil.scanClass(file)\n      }\n    }\n    ...\n  }\n}\n```\n\n省去了一些细节，只保留了主线逻辑，我们可以看到，其扫描到的jar和class都经过了ScanUtils的方法来处理，我们继续跟踪下去，会发现，*scanJar*也是循环调用的*scanClass*，这样我们直接看*scanClass*方法：\n\n```groovy\nstatic void scanClass(InputStream inputStream) {\n  ClassReader cr = new ClassReader(inputStream)\n  ClassWriter cw = new ClassWriter(cr, 0)\n  ScanClassVisitor cv = new ScanClassVisitor(Opcodes.ASM5, cw)\n  cr.accept(cv, ClassReader.EXPAND_FRAMES)\n  inputStream.close()\n}\n\nstatic class ScanClassVisitor extends ClassVisitor {\n\n  ScanClassVisitor(int api, ClassVisitor cv) {\n    super(api, cv)\n  }\n\n  void visit(int version, int access, String name, String signature,\n             String superName, String[] interfaces) {\n    super.visit(version, access, name, signature, superName, interfaces)\n    RegisterTransform.registerList.each { ext ->\n      if (ext.interfaceName && interfaces != null) {\n        interfaces.each { itName ->\n          if (itName == ext.interfaceName) {\n            //fix repeated inject init code when Multi-channel packaging\n            if (!ext.classList.contains(name)) {\n              ext.classList.add(name)\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n这里就又涉及到了ASM的知识，ScanClassVisitor是访问某个类的内部结构。\n\n>version：类的版本；\n>\n>access：表示类的访问权限，public，private，protected等；\n>\n>name：类的名字；\n>\n>signature：有无泛型；\n>\n>superName：其父类；\n>\n>interfaces：其实现的接口；\n\n在*ScanClassVisitor*中，并没有对类做修改，只是从遍历过的类中，把我们关心的类挑出来。那么，我们关心哪些类呢？\n\n在*PluginLaunch*类中，我们注册了三个*ScanSettings*类，分别是**IRouteRoot**、**IInterceptorGroup**和**IProviderGroup**，也就是说，我们把实现了这三个接口的类，挑出来，加入到各自对应的ScanSettings类中记录起来。这三个接口是不是很熟悉？就是通过APT生成的用来记录路由路径表的类。\n\n等收集好了这些记录的路径表信息后，就可以对*LogisticsCenter*通过ASM进行修改了。我们接着看*RegisterTransform#transform*方法中剩下的逻辑。\n\n```groovy\nif (fileContainsInitClass) {\n  registerList.each { ext ->\n    Logger.i('Insert register code to file ' + fileContainsInitClass.absolutePath)\n\n    if (ext.classList.isEmpty()) {\n      Logger.e(\"No class implements found for interface:\" + ext.interfaceName)\n    } else {\n      ext.classList.each {\n        Logger.i(it)\n      }\n      RegisterCodeGenerator.insertInitCodeTo(ext)\n    }\n  }\n}\n```\n\n注意此处的insertInitCodeTo方法，这就是ASM修改的入口了。这里不对修改过程进行详细解释了。我们直接对比看*LogisticsCenter*修改前后关键代码的对比。\n\n在*app/build*目录下，找到生成的apk文件，通过AndroidStudio来查看其中的class，找到关键*LogisticsCenter*关键方法*loadRouterMap*。\n\n> 具体过程如下：\n>\n> app/build/outputs/apk/debug/app-debug.apk -> classes.dex(双击) -> 找到*LogisticsCenter#loadRouterMap*方法 -> 右键: show Bytecode。\n\n```java\n// 不使用apply plugin: 'com.alibaba.arouter'\n.method private static loadRouterMap()V\n    .registers 1\n\n    .line 64\n    const/4 v0, 0x0\n\n    sput-boolean v0, Lcom/alibaba/android/arouter/core/LogisticsCenter;->registerByPlugin:Z\n\n    .line 69\n    return-void\n.end method\n```\n\n```java\n// 使用apply plugin: 'com.alibaba.arouter'\n.method private static loadRouterMap()V\n    .registers 1\n\n    .line 64\n    const/4 v0, 0x0\n\n    sput-boolean v0, Lcom/alibaba/android/arouter/core/LogisticsCenter;->registerByPlugin:Z\n\n    .line 69\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Root$$modulejava\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Root$$modulekotlin\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Root$$arouterapi\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Root$$app\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Interceptors$$modulejava\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Interceptors$$app\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Providers$$modulejava\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Providers$$modulekotlin\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Providers$$arouterapi\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Providers$$app\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    return-void\n.end method\n```\n\n对比发现，使用`apply plugin: 'com.alibaba.arouter'`后，这个方法增加了很多代码，基本上就是在加载路由路径表。使用这个gradle插件的基本思想就是，将查找路由路径表的过程，从**运行时**提前到了**编译时**，这算是一种AOT(Ahead of time)思想。\n\n将最耗时的查找过程提前，也就解决了ARouter初始化时间过长的问题。","source":"_posts/2022-09-17-ARouter源码分析.md","raw":"---\nlayout: post\ntitle: ARouter源码分析\nauthor: boybeak\ncategory: 源码分析\ntags: Android\n---\n\n\n在阅读源码前，请先下载源码：[ARouter](https://github.com/alibaba/ARouter)\n\n最近阅读ARouter源码，发现这真的是一个非常优秀的框架。激发出兴趣来读一下他的源码，实际上，这个框架的结构非常简单。这个框架可以分为**主流程**和**辅助流程**来拆开分析。\n\n主流程包含**编译时**和**运行时**两个部分，其中编译时主要做的是路由路径表的构建，运行时主要做的是路由路径表的加载；\n\n辅助流程主要就是做**启动优化**。\n\n## 主流程\n\n### 1. 编译时\n\n这部分主要涉及到的是路由路径表的构建，其实现原理是**APT**，即**注解处理器**。\n\n使用ARouter时候，需要在目标类上，通过**@Route**注解进行标记，注解处理器处理的就是这个注解。打开源码路径下的*arouter-compiler*这个module，找到**RouteProcessor**，这个类就是用来处理**@Route**注解的类。这里需要了解的知识，除了APT，还有java-poet，请自行了解这些。\n\nProcessor类的入口方法是*process*方法，这个方法返回true，则这个处理器已经完成了自己的任务，不会被重复调用。其他比较重要的方法有*getSupportedSourceVersion*，*getSupportedAnnotationTypes*等。\n\n```java\nSet<? extends Element> routeElements = roundEnv.getElementsAnnotatedWith(Route.class);\n```\n\n通过这个方法，获取所有被**@Route**标记的元素。\n\n获取到*routeElements*后，在*parseRoutes*方法进行处理。我们以最常用的Activity为例，进行分析。\n\n```java\nrootMap.clear();\t//用来分类存储标记元素\n\n// 用来检测元素是否为对应的类型，通过Types.isSubtype()方法来检测。\nTypeMirror type_Activity = elementUtils.getTypeElement(ACTIVITY).asType();\nTypeMirror type_Service = elementUtils.getTypeElement(SERVICE).asType();\nTypeMirror fragmentTm = elementUtils.getTypeElement(FRAGMENT).asType();\nTypeMirror fragmentTmV4 = elementUtils.getTypeElement(Consts.FRAGMENT_V4).asType();\n```\n\n最后将分类号的元素信息，存储在成员变量groupMap中去。\n\n```java\nprivate Map<String, Set<RouteMeta>> groupMap = new HashMap<>();\n```\n\n然后再通过这个groupMap，借助java-poet，来生成真实的类。如下：\n\n```java\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    atlas.put(\"/test/activity1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/activity1\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"ser\", 9); put(\"ch\", 5); put(\"fl\", 6); put(\"dou\", 7); put(\"boy\", 0); put(\"url\", 8); put(\"pac\", 10); put(\"obj\", 11); put(\"name\", 8); put(\"objList\", 11); put(\"map\", 11); put(\"age\", 3); put(\"height\", 3); }}, -1, -2147483648));\n    atlas.put(\"/test/activity2\", RouteMeta.build(RouteType.ACTIVITY, Test2Activity.class, \"/test/activity2\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"key1\", 8); }}, -1, -2147483648));\n    atlas.put(\"/test/activity3\", RouteMeta.build(RouteType.ACTIVITY, Test3Activity.class, \"/test/activity3\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"name\", 8); put(\"boy\", 0); put(\"age\", 3); }}, -1, -2147483648));\n    atlas.put(\"/test/activity4\", RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, \"/test/activity4\", \"test\", null, -1, -2147483648));\n    atlas.put(\"/test/fragment\", RouteMeta.build(RouteType.FRAGMENT, BlankFragment.class, \"/test/fragment\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"obj\", 11); put(\"name\", 8); }}, -1, -2147483648));\n    atlas.put(\"/test/webview\", RouteMeta.build(RouteType.ACTIVITY, TestWebview.class, \"/test/webview\", \"test\", null, -1, -2147483648));\n  }\n}\n```\n\n\n\n### 2. 运行时\n\n这部分主要做的是，在*ARouter.init()*时候，将上过程生成的路径表加载到内存中。\n\n> 如果你以官方demo程序验证这一步，需要将app/build.gradle中的`apply plugin: 'com.alibaba.arouter'`这一行代码注释掉。\n\n我们以*ARouter.init*方法为入口，实际上最终实现init流程的是LogisticsCenter类的*init*方法。\n\n```java\npublic synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n  ...\n  if (registerByPlugin) {\n    //这是在辅助流程需要去讲的\n  \tlogger.info(TAG, \"Load router map by arouter-auto-register plugin.\");\n  } else {\n    Set<String> routerMap;\n\n    // It will rebuild router map every times when debuggable.\n    if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) {\n      logger.info(TAG, \"Run with debug mode or new install, rebuild router map.\");\n      // These class was generated by arouter-compiler.\n      routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n      if (!routerMap.isEmpty()) {\n        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();\n      }\n\n      PackageUtils.updateVersion(context);    // Save new version name when router map update finishes.\n    } else {\n      logger.info(TAG, \"Load router map from cache.\");\n      routerMap = new HashSet<>(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, new HashSet<String>()));\n    }\n  }\n}\n```\n\n这里需要着重看的是这一句：\n\n```java\nrouterMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n```\n\n我们查看这个方法:\n\n```java\npublic static Set<String> getFileNameByPackageName(Context context, final String packageName) throws PackageManager.NameNotFoundException, IOException, InterruptedException {\n  final Set<String> classNames = new HashSet<>();\n\n  List<String> paths = getSourcePaths(context);\n  final CountDownLatch parserCtl = new CountDownLatch(paths.size());\n\n  for (final String path : paths) {\n    Log.v(TAG, \"getFileNameByPackageName path=\" + path);\n    DefaultPoolExecutor.getInstance().execute(new Runnable() {\n      @Override\n      public void run() {\n        DexFile dexfile = null;\n\n        try {\n          if (path.endsWith(EXTRACTED_SUFFIX)) {\n            //NOT use new DexFile(path), because it will throw \"permission error in /data/dalvik-cache\"\n            dexfile = DexFile.loadDex(path, path + \".tmp\", 0);\n          } else {\n            dexfile = new DexFile(path);\n          }\n\n          Enumeration<String> dexEntries = dexfile.entries();\n          while (dexEntries.hasMoreElements()) {\n            String className = dexEntries.nextElement();\n            if (className.startsWith(packageName)) {\n              Log.v(TAG, \"find CLASS NAME \" + className);\n              classNames.add(className);\n            }\n          }\n        } catch (Throwable ignore) {\n          Log.e(\"ARouter\", \"Scan map file in dex files made error.\", ignore);\n        } finally {\n          if (null != dexfile) {\n            try {\n              dexfile.close();\n            } catch (Throwable ignore) {\n            }\n          }\n\n          parserCtl.countDown();\n        }\n      }\n    });\n  }\n\n  parserCtl.await();\n\n  Log.d(Consts.TAG, \"Filter \" + classNames.size() + \" classes by packageName <\" + packageName + \">\");\n  return classNames;\n}\n```\n\n注意其中的*getSourcePaths*方法，这是从代码目录，来获取所有代码目录，然后在\n\n*getFileNameByPackageName*找出以`com.alibaba.android.arouter.routes`为开头包名的类，这些就是我们在步骤1中生成的辅助类。\n\n这个方法结束后，回到*LogisticsCenter#init*方法，接下来要做的就是，把加载到的辅助类，通过反射生成对象，再调用其*loadTo*方法，将路由路径表加载到Warehouse类中去，方便以后的查询。\n\n\n\n## 辅助流程\n\n在以上的流程中，有一个严重的问题，那就是执行*ARouter#init*方法的时间过长，以源码的demo为例，在InstantRun的情况下，OnePlus5T需要100多毫秒才能初始化完，这对于程序启动优化来说，是一个不可忽视的时间了。那么如何解决这个问题呢？\n\n```shell\nMainActivity: init cost 134\n```\n\n这就是在上一步中，要求你注释掉的代码起作用了，将`apply plugin: 'com.alibaba.arouter'`解除注释，让其发挥作用。\n\n这里需要关注的module是`arouter-gradle-plugin`。\n\n先来看一下，使用了`apply plugin: 'com.alibaba.arouter'`的神奇效果。\n\n```shell\nMainActivity: init cost 19\n```\n\n通过优化，让*ARouter#init*消耗时间直接降低了一个数量级，那么`arouter-gradle-plugin`是怎么做到的呢？\n\n这需要你先了解一下[ASM]({{site.base_url}}/android/ASM.md)。简单来说，这是一种字节码编程技术，通过修改编译后的字节码的方式，来对原始逻辑增强。\n\n我们再来看*ARouter#init*的最终实现类和方法*LogisticsCenter#init*：\n\n```java\npublic synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n  ....\n  try {\n    long startInit = System.currentTimeMillis();\n    //billy.qi modified at 2017-12-06\n    //load by plugin first\n    loadRouterMap();\n    if (registerByPlugin) {\n      logger.info(TAG, \"Load router map by arouter-auto-register plugin.\");\n    } else {\n      ....\n    }\n    .....\n  } catch (Exception e) {\n    throw new HandlerException(TAG + \"ARouter init logistics center exception! [\" + e.getMessage() + \"]\");\n  }\n}\n```\n\n我们可以看到，当`registerByPlugin`为true的时候，则只是打印了一句日志，我们再看loadRouterMap()这个方法：\n\n```java\nprivate static void loadRouterMap() {\n  registerByPlugin = false;\n  //auto generate register code by gradle plugin: arouter-auto-register\n  // looks like below:\n  // registerRouteRoot(new ARouter..Root..modulejava());\n  // registerRouteRoot(new ARouter..Root..modulekotlin());\n}\n```\n\n这里的逻辑非常简单，到底在哪里去加载的路由路径表呢？我们看这个方法的注释，发现，这个方法是被`arouter-auto-register`自动生成的。\n\n我们打开`arouter-gradle-plugin/resources/META-INF/gradle-plugins`这个目录，可以看到，有一个*com.alibaba.arouter.properties*文件，查看其内容：\n\n```properties\nimplementation-class=com.alibaba.android.arouter.register.launch.PluginLaunch\n```\n\n这个*PluginLaunch*便是此gradle plugin的入口类。查看此类：\n\n```groovy\npublic class PluginLaunch implements Plugin<Project> {\n\n  @Override\n  public void apply(Project project) {\n    def isApp = project.plugins.hasPlugin(AppPlugin)\n    //only application module needs this plugin to generate register code\n    if (isApp) {\n      Logger.make(project)\n\n      Logger.i('Project enable arouter-register plugin')\n\n      def android = project.extensions.getByType(AppExtension)\n      def transformImpl = new RegisterTransform(project)\n\n      //init arouter-auto-register settings\n      ArrayList<ScanSetting> list = new ArrayList<>(3)\n      list.add(new ScanSetting('IRouteRoot'))\n      list.add(new ScanSetting('IInterceptorGroup'))\n      list.add(new ScanSetting('IProviderGroup'))\n      RegisterTransform.registerList = list\n      //register this plugin\n      android.registerTransform(transformImpl)\n    }\n  }\n\n}\n```\n\n我们查看其代码，可以发现，这里一共做了三件事：\n\n1. 判断是否为app module，如果不是，则不做任何事，在app module下做2和3两步；\n2. 生成了一个RegisterTransform，并为其静态变量registerList赋值，**注意此处赋值的registerList中包含的三个对象**；\n3. 注册此RegisterTransform。\n\n接下来，就轮到*RegisterTransform*来执行了。\n\nTransform类，简单来说，就是可以在编译时，扫描所有的jar和class，包括引用类库中的。在扫描过程中，就可以借助**ASM**技术对目标类进行更改。\n\n我们看其入口方法*transform*：\n\n```groovy\n@Override\nvoid transform(Context context, Collection<TransformInput> inputs, Collection<TransformInput> referencedInputs, TransformOutputProvider outputProvider, boolean isIncremental) throws IOException, TransformException, InterruptedException {\n  inputs.each { TransformInput input ->\n    // scan all jars\n    input.jarInputs.each { JarInput jarInput ->\n      ...\n      if (ScanUtil.shouldProcessPreDexJar(src.absolutePath)) {\n        ScanUtil.scanJar(src, dest)\n      }\n      ...\n    }\n  }\n  input.directoryInputs.each { DirectoryInput directoryInput ->\n    ...\n    directoryInput.file.eachFileRecurse { File file ->\n      ...\n      if(file.isFile() && ScanUtil.shouldProcessClass(path)){\n        ScanUtil.scanClass(file)\n      }\n    }\n    ...\n  }\n}\n```\n\n省去了一些细节，只保留了主线逻辑，我们可以看到，其扫描到的jar和class都经过了ScanUtils的方法来处理，我们继续跟踪下去，会发现，*scanJar*也是循环调用的*scanClass*，这样我们直接看*scanClass*方法：\n\n```groovy\nstatic void scanClass(InputStream inputStream) {\n  ClassReader cr = new ClassReader(inputStream)\n  ClassWriter cw = new ClassWriter(cr, 0)\n  ScanClassVisitor cv = new ScanClassVisitor(Opcodes.ASM5, cw)\n  cr.accept(cv, ClassReader.EXPAND_FRAMES)\n  inputStream.close()\n}\n\nstatic class ScanClassVisitor extends ClassVisitor {\n\n  ScanClassVisitor(int api, ClassVisitor cv) {\n    super(api, cv)\n  }\n\n  void visit(int version, int access, String name, String signature,\n             String superName, String[] interfaces) {\n    super.visit(version, access, name, signature, superName, interfaces)\n    RegisterTransform.registerList.each { ext ->\n      if (ext.interfaceName && interfaces != null) {\n        interfaces.each { itName ->\n          if (itName == ext.interfaceName) {\n            //fix repeated inject init code when Multi-channel packaging\n            if (!ext.classList.contains(name)) {\n              ext.classList.add(name)\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n这里就又涉及到了ASM的知识，ScanClassVisitor是访问某个类的内部结构。\n\n>version：类的版本；\n>\n>access：表示类的访问权限，public，private，protected等；\n>\n>name：类的名字；\n>\n>signature：有无泛型；\n>\n>superName：其父类；\n>\n>interfaces：其实现的接口；\n\n在*ScanClassVisitor*中，并没有对类做修改，只是从遍历过的类中，把我们关心的类挑出来。那么，我们关心哪些类呢？\n\n在*PluginLaunch*类中，我们注册了三个*ScanSettings*类，分别是**IRouteRoot**、**IInterceptorGroup**和**IProviderGroup**，也就是说，我们把实现了这三个接口的类，挑出来，加入到各自对应的ScanSettings类中记录起来。这三个接口是不是很熟悉？就是通过APT生成的用来记录路由路径表的类。\n\n等收集好了这些记录的路径表信息后，就可以对*LogisticsCenter*通过ASM进行修改了。我们接着看*RegisterTransform#transform*方法中剩下的逻辑。\n\n```groovy\nif (fileContainsInitClass) {\n  registerList.each { ext ->\n    Logger.i('Insert register code to file ' + fileContainsInitClass.absolutePath)\n\n    if (ext.classList.isEmpty()) {\n      Logger.e(\"No class implements found for interface:\" + ext.interfaceName)\n    } else {\n      ext.classList.each {\n        Logger.i(it)\n      }\n      RegisterCodeGenerator.insertInitCodeTo(ext)\n    }\n  }\n}\n```\n\n注意此处的insertInitCodeTo方法，这就是ASM修改的入口了。这里不对修改过程进行详细解释了。我们直接对比看*LogisticsCenter*修改前后关键代码的对比。\n\n在*app/build*目录下，找到生成的apk文件，通过AndroidStudio来查看其中的class，找到关键*LogisticsCenter*关键方法*loadRouterMap*。\n\n> 具体过程如下：\n>\n> app/build/outputs/apk/debug/app-debug.apk -> classes.dex(双击) -> 找到*LogisticsCenter#loadRouterMap*方法 -> 右键: show Bytecode。\n\n```java\n// 不使用apply plugin: 'com.alibaba.arouter'\n.method private static loadRouterMap()V\n    .registers 1\n\n    .line 64\n    const/4 v0, 0x0\n\n    sput-boolean v0, Lcom/alibaba/android/arouter/core/LogisticsCenter;->registerByPlugin:Z\n\n    .line 69\n    return-void\n.end method\n```\n\n```java\n// 使用apply plugin: 'com.alibaba.arouter'\n.method private static loadRouterMap()V\n    .registers 1\n\n    .line 64\n    const/4 v0, 0x0\n\n    sput-boolean v0, Lcom/alibaba/android/arouter/core/LogisticsCenter;->registerByPlugin:Z\n\n    .line 69\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Root$$modulejava\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Root$$modulekotlin\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Root$$arouterapi\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Root$$app\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Interceptors$$modulejava\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Interceptors$$app\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Providers$$modulejava\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Providers$$modulekotlin\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Providers$$arouterapi\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    const-string v0, \"com.alibaba.android.arouter.routes.ARouter$$Providers$$app\"\n\n    invoke-static {v0}, Lcom/alibaba/android/arouter/core/LogisticsCenter;->register(Ljava/lang/String;)V\n\n    return-void\n.end method\n```\n\n对比发现，使用`apply plugin: 'com.alibaba.arouter'`后，这个方法增加了很多代码，基本上就是在加载路由路径表。使用这个gradle插件的基本思想就是，将查找路由路径表的过程，从**运行时**提前到了**编译时**，这算是一种AOT(Ahead of time)思想。\n\n将最耗时的查找过程提前，也就解决了ARouter初始化时间过长的问题。","slug":"2022-09-17-ARouter源码分析","published":1,"date":"2020-11-28T05:37:46.000Z","updated":"2023-02-05T02:19:27.204Z","comments":1,"photos":[],"link":"","_id":"cldqukh7g0000pcjg9h9tbnsd","content":"<p>在阅读源码前，请先下载源码：<a href=\"https://github.com/alibaba/ARouter\">ARouter</a></p>\n<p>最近阅读ARouter源码，发现这真的是一个非常优秀的框架。激发出兴趣来读一下他的源码，实际上，这个框架的结构非常简单。这个框架可以分为<strong>主流程</strong>和<strong>辅助流程</strong>来拆开分析。</p>\n<p>主流程包含<strong>编译时</strong>和<strong>运行时</strong>两个部分，其中编译时主要做的是路由路径表的构建，运行时主要做的是路由路径表的加载；</p>\n<p>辅助流程主要就是做<strong>启动优化</strong>。</p>\n<h2 id=\"主流程\"><a href=\"#主流程\" class=\"headerlink\" title=\"主流程\"></a>主流程</h2><h3 id=\"1-编译时\"><a href=\"#1-编译时\" class=\"headerlink\" title=\"1. 编译时\"></a>1. 编译时</h3><p>这部分主要涉及到的是路由路径表的构建，其实现原理是<strong>APT</strong>，即<strong>注解处理器</strong>。</p>\n<p>使用ARouter时候，需要在目标类上，通过**@Route<strong>注解进行标记，注解处理器处理的就是这个注解。打开源码路径下的<em>arouter-compiler</em>这个module，找到</strong>RouteProcessor<strong>，这个类就是用来处理</strong>@Route**注解的类。这里需要了解的知识，除了APT，还有java-poet，请自行了解这些。</p>\n<p>Processor类的入口方法是<em>process</em>方法，这个方法返回true，则这个处理器已经完成了自己的任务，不会被重复调用。其他比较重要的方法有<em>getSupportedSourceVersion</em>，<em>getSupportedAnnotationTypes</em>等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span>&gt; routeElements = roundEnv.getElementsAnnotatedWith(Route.class);</span><br></pre></td></tr></table></figure>\n\n<p>通过这个方法，获取所有被**@Route**标记的元素。</p>\n<p>获取到<em>routeElements</em>后，在<em>parseRoutes</em>方法进行处理。我们以最常用的Activity为例，进行分析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootMap.clear();\t<span class=\"comment\">//用来分类存储标记元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用来检测元素是否为对应的类型，通过Types.isSubtype()方法来检测。</span></span><br><span class=\"line\"><span class=\"type\">TypeMirror</span> <span class=\"variable\">type_Activity</span> <span class=\"operator\">=</span> elementUtils.getTypeElement(ACTIVITY).asType();</span><br><span class=\"line\"><span class=\"type\">TypeMirror</span> <span class=\"variable\">type_Service</span> <span class=\"operator\">=</span> elementUtils.getTypeElement(SERVICE).asType();</span><br><span class=\"line\"><span class=\"type\">TypeMirror</span> <span class=\"variable\">fragmentTm</span> <span class=\"operator\">=</span> elementUtils.getTypeElement(FRAGMENT).asType();</span><br><span class=\"line\"><span class=\"type\">TypeMirror</span> <span class=\"variable\">fragmentTmV4</span> <span class=\"operator\">=</span> elementUtils.getTypeElement(Consts.FRAGMENT_V4).asType();</span><br></pre></td></tr></table></figure>\n\n<p>最后将分类号的元素信息，存储在成员变量groupMap中去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Set&lt;RouteMeta&gt;&gt; groupMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>然后再通过这个groupMap，借助java-poet，来生成真实的类。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ARouter$$Group$$test</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRouteGroup</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadInto</span><span class=\"params\">(Map&lt;String, RouteMeta&gt; atlas)</span> &#123;</span><br><span class=\"line\">    atlas.put(<span class=\"string\">&quot;/test/activity1&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, <span class=\"string\">&quot;/test/activity1&quot;</span>, <span class=\"string\">&quot;test&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class=\"string\">&quot;ser&quot;</span>, <span class=\"number\">9</span>); put(<span class=\"string\">&quot;ch&quot;</span>, <span class=\"number\">5</span>); put(<span class=\"string\">&quot;fl&quot;</span>, <span class=\"number\">6</span>); put(<span class=\"string\">&quot;dou&quot;</span>, <span class=\"number\">7</span>); put(<span class=\"string\">&quot;boy&quot;</span>, <span class=\"number\">0</span>); put(<span class=\"string\">&quot;url&quot;</span>, <span class=\"number\">8</span>); put(<span class=\"string\">&quot;pac&quot;</span>, <span class=\"number\">10</span>); put(<span class=\"string\">&quot;obj&quot;</span>, <span class=\"number\">11</span>); put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"number\">8</span>); put(<span class=\"string\">&quot;objList&quot;</span>, <span class=\"number\">11</span>); put(<span class=\"string\">&quot;map&quot;</span>, <span class=\"number\">11</span>); put(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">3</span>); put(<span class=\"string\">&quot;height&quot;</span>, <span class=\"number\">3</span>); &#125;&#125;, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    atlas.put(<span class=\"string\">&quot;/test/activity2&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test2Activity.class, <span class=\"string\">&quot;/test/activity2&quot;</span>, <span class=\"string\">&quot;test&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"number\">8</span>); &#125;&#125;, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    atlas.put(<span class=\"string\">&quot;/test/activity3&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test3Activity.class, <span class=\"string\">&quot;/test/activity3&quot;</span>, <span class=\"string\">&quot;test&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"number\">8</span>); put(<span class=\"string\">&quot;boy&quot;</span>, <span class=\"number\">0</span>); put(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">3</span>); &#125;&#125;, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    atlas.put(<span class=\"string\">&quot;/test/activity4&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, <span class=\"string\">&quot;/test/activity4&quot;</span>, <span class=\"string\">&quot;test&quot;</span>, <span class=\"literal\">null</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    atlas.put(<span class=\"string\">&quot;/test/fragment&quot;</span>, RouteMeta.build(RouteType.FRAGMENT, BlankFragment.class, <span class=\"string\">&quot;/test/fragment&quot;</span>, <span class=\"string\">&quot;test&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class=\"string\">&quot;obj&quot;</span>, <span class=\"number\">11</span>); put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"number\">8</span>); &#125;&#125;, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    atlas.put(<span class=\"string\">&quot;/test/webview&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, TestWebview.class, <span class=\"string\">&quot;/test/webview&quot;</span>, <span class=\"string\">&quot;test&quot;</span>, <span class=\"literal\">null</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-运行时\"><a href=\"#2-运行时\" class=\"headerlink\" title=\"2. 运行时\"></a>2. 运行时</h3><p>这部分主要做的是，在*ARouter.init()*时候，将上过程生成的路径表加载到内存中。</p>\n<blockquote>\n<p>如果你以官方demo程序验证这一步，需要将app&#x2F;build.gradle中的<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>这一行代码注释掉。</p>\n</blockquote>\n<p>我们以<em>ARouter.init</em>方法为入口，实际上最终实现init流程的是LogisticsCenter类的<em>init</em>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(Context context, ThreadPoolExecutor tpe)</span> <span class=\"keyword\">throws</span> HandlerException &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (registerByPlugin) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//这是在辅助流程需要去讲的</span></span><br><span class=\"line\">  \tlogger.info(TAG, <span class=\"string\">&quot;Load router map by arouter-auto-register plugin.&quot;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    Set&lt;String&gt; routerMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// It will rebuild router map every times when debuggable.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class=\"line\">      logger.info(TAG, <span class=\"string\">&quot;Run with debug mode or new install, rebuild router map.&quot;</span>);</span><br><span class=\"line\">      <span class=\"comment\">// These class was generated by arouter-compiler.</span></span><br><span class=\"line\">      routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class=\"line\">        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      PackageUtils.updateVersion(context);    <span class=\"comment\">// Save new version name when router map update finishes.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      logger.info(TAG, <span class=\"string\">&quot;Load router map from cache.&quot;</span>);</span><br><span class=\"line\">      routerMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;String&gt;()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要着重看的是这一句：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br></pre></td></tr></table></figure>\n\n<p>我们查看这个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Set&lt;String&gt; <span class=\"title function_\">getFileNameByPackageName</span><span class=\"params\">(Context context, <span class=\"keyword\">final</span> String packageName)</span> <span class=\"keyword\">throws</span> PackageManager.NameNotFoundException, IOException, InterruptedException &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Set&lt;String&gt; classNames = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  List&lt;String&gt; paths = getSourcePaths(context);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"type\">CountDownLatch</span> <span class=\"variable\">parserCtl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(paths.size());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> String path : paths) &#123;</span><br><span class=\"line\">    Log.v(TAG, <span class=\"string\">&quot;getFileNameByPackageName path=&quot;</span> + path);</span><br><span class=\"line\">    DefaultPoolExecutor.getInstance().execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">DexFile</span> <span class=\"variable\">dexfile</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (path.endsWith(EXTRACTED_SUFFIX)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//NOT use new DexFile(path), because it will throw &quot;permission error in /data/dalvik-cache&quot;</span></span><br><span class=\"line\">            dexfile = DexFile.loadDex(path, path + <span class=\"string\">&quot;.tmp&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            dexfile = <span class=\"keyword\">new</span> <span class=\"title class_\">DexFile</span>(path);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          Enumeration&lt;String&gt; dexEntries = dexfile.entries();</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (dexEntries.hasMoreElements()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">className</span> <span class=\"operator\">=</span> dexEntries.nextElement();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (className.startsWith(packageName)) &#123;</span><br><span class=\"line\">              Log.v(TAG, <span class=\"string\">&quot;find CLASS NAME &quot;</span> + className);</span><br><span class=\"line\">              classNames.add(className);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ignore) &#123;</span><br><span class=\"line\">          Log.e(<span class=\"string\">&quot;ARouter&quot;</span>, <span class=\"string\">&quot;Scan map file in dex files made error.&quot;</span>, ignore);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != dexfile) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              dexfile.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ignore) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          parserCtl.countDown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  parserCtl.await();</span><br><span class=\"line\"></span><br><span class=\"line\">  Log.d(Consts.TAG, <span class=\"string\">&quot;Filter &quot;</span> + classNames.size() + <span class=\"string\">&quot; classes by packageName &lt;&quot;</span> + packageName + <span class=\"string\">&quot;&gt;&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> classNames;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意其中的<em>getSourcePaths</em>方法，这是从代码目录，来获取所有代码目录，然后在</p>\n<p><em>getFileNameByPackageName</em>找出以<code>com.alibaba.android.arouter.routes</code>为开头包名的类，这些就是我们在步骤1中生成的辅助类。</p>\n<p>这个方法结束后，回到<em>LogisticsCenter#init</em>方法，接下来要做的就是，把加载到的辅助类，通过反射生成对象，再调用其<em>loadTo</em>方法，将路由路径表加载到Warehouse类中去，方便以后的查询。</p>\n<h2 id=\"辅助流程\"><a href=\"#辅助流程\" class=\"headerlink\" title=\"辅助流程\"></a>辅助流程</h2><p>在以上的流程中，有一个严重的问题，那就是执行<em>ARouter#init</em>方法的时间过长，以源码的demo为例，在InstantRun的情况下，OnePlus5T需要100多毫秒才能初始化完，这对于程序启动优化来说，是一个不可忽视的时间了。那么如何解决这个问题呢？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MainActivity: init cost 134</span><br></pre></td></tr></table></figure>\n\n<p>这就是在上一步中，要求你注释掉的代码起作用了，将<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>解除注释，让其发挥作用。</p>\n<p>这里需要关注的module是<code>arouter-gradle-plugin</code>。</p>\n<p>先来看一下，使用了<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>的神奇效果。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MainActivity: init cost 19</span><br></pre></td></tr></table></figure>\n\n<p>通过优化，让<em>ARouter#init</em>消耗时间直接降低了一个数量级，那么<code>arouter-gradle-plugin</code>是怎么做到的呢？</p>\n<p>这需要你先了解一下[ASM](&#x2F;android&#x2F;ASM.md)。简单来说，这是一种字节码编程技术，通过修改编译后的字节码的方式，来对原始逻辑增强。</p>\n<p>我们再来看<em>ARouter#init</em>的最终实现类和方法<em>LogisticsCenter#init</em>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(Context context, ThreadPoolExecutor tpe)</span> <span class=\"keyword\">throws</span> HandlerException &#123;</span><br><span class=\"line\">  ....</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startInit</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"comment\">//billy.qi modified at 2017-12-06</span></span><br><span class=\"line\">    <span class=\"comment\">//load by plugin first</span></span><br><span class=\"line\">    loadRouterMap();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (registerByPlugin) &#123;</span><br><span class=\"line\">      logger.info(TAG, <span class=\"string\">&quot;Load router map by arouter-auto-register plugin.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HandlerException</span>(TAG + <span class=\"string\">&quot;ARouter init logistics center exception! [&quot;</span> + e.getMessage() + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，当<code>registerByPlugin</code>为true的时候，则只是打印了一句日志，我们再看loadRouterMap()这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadRouterMap</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  registerByPlugin = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">//auto generate register code by gradle plugin: arouter-auto-register</span></span><br><span class=\"line\">  <span class=\"comment\">// looks like below:</span></span><br><span class=\"line\">  <span class=\"comment\">// registerRouteRoot(new ARouter..Root..modulejava());</span></span><br><span class=\"line\">  <span class=\"comment\">// registerRouteRoot(new ARouter..Root..modulekotlin());</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的逻辑非常简单，到底在哪里去加载的路由路径表呢？我们看这个方法的注释，发现，这个方法是被<code>arouter-auto-register</code>自动生成的。</p>\n<p>我们打开<code>arouter-gradle-plugin/resources/META-INF/gradle-plugins</code>这个目录，可以看到，有一个<em>com.alibaba.arouter.properties</em>文件，查看其内容：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">implementation-class</span>=<span class=\"string\">com.alibaba.android.arouter.register.launch.PluginLaunch</span></span><br></pre></td></tr></table></figure>\n\n<p>这个<em>PluginLaunch</em>便是此gradle plugin的入口类。查看此类：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PluginLaunch</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Plugin</span>&lt;Project&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">def</span> isApp = project.plugins.hasPlugin(AppPlugin)</span><br><span class=\"line\">    <span class=\"comment\">//only application module needs this plugin to generate register code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isApp) &#123;</span><br><span class=\"line\">      Logger.make(project)</span><br><span class=\"line\"></span><br><span class=\"line\">      Logger.i(<span class=\"string\">&#x27;Project enable arouter-register plugin&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">def</span> android = project.extensions.getByType(AppExtension)</span><br><span class=\"line\">      <span class=\"keyword\">def</span> transformImpl = <span class=\"keyword\">new</span> RegisterTransform(project)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//init arouter-auto-register settings</span></span><br><span class=\"line\">      ArrayList&lt;ScanSetting&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">3</span>)</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> ScanSetting(<span class=\"string\">&#x27;IRouteRoot&#x27;</span>))</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> ScanSetting(<span class=\"string\">&#x27;IInterceptorGroup&#x27;</span>))</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> ScanSetting(<span class=\"string\">&#x27;IProviderGroup&#x27;</span>))</span><br><span class=\"line\">      RegisterTransform.registerList = list</span><br><span class=\"line\">      <span class=\"comment\">//register this plugin</span></span><br><span class=\"line\">      android.registerTransform(transformImpl)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们查看其代码，可以发现，这里一共做了三件事：</p>\n<ol>\n<li>判断是否为app module，如果不是，则不做任何事，在app module下做2和3两步；</li>\n<li>生成了一个RegisterTransform，并为其静态变量registerList赋值，<strong>注意此处赋值的registerList中包含的三个对象</strong>；</li>\n<li>注册此RegisterTransform。</li>\n</ol>\n<p>接下来，就轮到<em>RegisterTransform</em>来执行了。</p>\n<p>Transform类，简单来说，就是可以在编译时，扫描所有的jar和class，包括引用类库中的。在扫描过程中，就可以借助<strong>ASM</strong>技术对目标类进行更改。</p>\n<p>我们看其入口方法<em>transform</em>：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"type\">void</span> transform(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, <span class=\"type\">boolean</span> isIncremental) <span class=\"keyword\">throws</span> IOException, TransformException, InterruptedException &#123;</span><br><span class=\"line\">  inputs.each &#123; TransformInput input -&gt;</span><br><span class=\"line\">    <span class=\"comment\">// scan all jars</span></span><br><span class=\"line\">    input.jarInputs.each &#123; JarInput jarInput -&gt;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ScanUtil.shouldProcessPreDexJar(src.absolutePath)) &#123;</span><br><span class=\"line\">        ScanUtil.scanJar(src, dest)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    directoryInput.file.eachFileRecurse &#123; File file -&gt;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(file.isFile() &amp;&amp; ScanUtil.shouldProcessClass(path))&#123;</span><br><span class=\"line\">        ScanUtil.scanClass(file)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>省去了一些细节，只保留了主线逻辑，我们可以看到，其扫描到的jar和class都经过了ScanUtils的方法来处理，我们继续跟踪下去，会发现，<em>scanJar</em>也是循环调用的<em>scanClass</em>，这样我们直接看<em>scanClass</em>方法：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">void</span> scanClass(InputStream inputStream) &#123;</span><br><span class=\"line\">  ClassReader cr = <span class=\"keyword\">new</span> ClassReader(inputStream)</span><br><span class=\"line\">  ClassWriter cw = <span class=\"keyword\">new</span> ClassWriter(cr, <span class=\"number\">0</span>)</span><br><span class=\"line\">  ScanClassVisitor cv = <span class=\"keyword\">new</span> ScanClassVisitor(Opcodes.ASM5, cw)</span><br><span class=\"line\">  cr.accept(cv, ClassReader.EXPAND_FRAMES)</span><br><span class=\"line\">  inputStream.close()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ScanClassVisitor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassVisitor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  ScanClassVisitor(<span class=\"type\">int</span> api, ClassVisitor cv) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(api, cv)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">void</span> visit(<span class=\"type\">int</span> version, <span class=\"type\">int</span> access, String name, String signature,</span><br><span class=\"line\">             String superName, String[] interfaces) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>.visit(version, access, name, signature, superName, interfaces)</span><br><span class=\"line\">    RegisterTransform.registerList.each &#123; ext -&gt;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ext.interfaceName &amp;&amp; interfaces != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        interfaces.each &#123; itName -&gt;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (itName == ext.interfaceName) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//fix repeated inject init code when Multi-channel packaging</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!ext.classList.contains(name)) &#123;</span><br><span class=\"line\">              ext.classList.add(name)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就又涉及到了ASM的知识，ScanClassVisitor是访问某个类的内部结构。</p>\n<blockquote>\n<p>version：类的版本；</p>\n<p>access：表示类的访问权限，public，private，protected等；</p>\n<p>name：类的名字；</p>\n<p>signature：有无泛型；</p>\n<p>superName：其父类；</p>\n<p>interfaces：其实现的接口；</p>\n</blockquote>\n<p>在<em>ScanClassVisitor</em>中，并没有对类做修改，只是从遍历过的类中，把我们关心的类挑出来。那么，我们关心哪些类呢？</p>\n<p>在<em>PluginLaunch</em>类中，我们注册了三个<em>ScanSettings</em>类，分别是<strong>IRouteRoot</strong>、<strong>IInterceptorGroup</strong>和<strong>IProviderGroup</strong>，也就是说，我们把实现了这三个接口的类，挑出来，加入到各自对应的ScanSettings类中记录起来。这三个接口是不是很熟悉？就是通过APT生成的用来记录路由路径表的类。</p>\n<p>等收集好了这些记录的路径表信息后，就可以对<em>LogisticsCenter</em>通过ASM进行修改了。我们接着看<em>RegisterTransform#transform</em>方法中剩下的逻辑。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (fileContainsInitClass) &#123;</span><br><span class=\"line\">  registerList.each &#123; ext -&gt;</span><br><span class=\"line\">    Logger.i(<span class=\"string\">&#x27;Insert register code to file &#x27;</span> + fileContainsInitClass.absolutePath)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ext.classList.isEmpty()) &#123;</span><br><span class=\"line\">      Logger.e(<span class=\"string\">&quot;No class implements found for interface:&quot;</span> + ext.interfaceName)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ext.classList.each &#123;</span><br><span class=\"line\">        Logger.i(it)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      RegisterCodeGenerator.insertInitCodeTo(ext)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意此处的insertInitCodeTo方法，这就是ASM修改的入口了。这里不对修改过程进行详细解释了。我们直接对比看<em>LogisticsCenter</em>修改前后关键代码的对比。</p>\n<p>在<em>app&#x2F;build</em>目录下，找到生成的apk文件，通过AndroidStudio来查看其中的class，找到关键<em>LogisticsCenter</em>关键方法<em>loadRouterMap</em>。</p>\n<blockquote>\n<p>具体过程如下：</p>\n<p>app&#x2F;build&#x2F;outputs&#x2F;apk&#x2F;debug&#x2F;app-debug.apk -&gt; classes.dex(双击) -&gt; 找到<em>LogisticsCenter#loadRouterMap</em>方法 -&gt; 右键: show Bytecode。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不使用apply plugin: &#x27;com.alibaba.arouter&#x27;</span></span><br><span class=\"line\">.method <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"title function_\">loadRouterMap</span><span class=\"params\">()</span>V</span><br><span class=\"line\">    .registers <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    .line <span class=\"number\">64</span></span><br><span class=\"line\">    const/<span class=\"number\">4</span> v0, <span class=\"number\">0x0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sput-<span class=\"type\">boolean</span> v0, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;registerByPlugin:Z</span><br><span class=\"line\"></span><br><span class=\"line\">    .line <span class=\"number\">69</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>-<span class=\"keyword\">void</span></span><br><span class=\"line\">.end method</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用apply plugin: &#x27;com.alibaba.arouter&#x27;</span></span><br><span class=\"line\">.method <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"title function_\">loadRouterMap</span><span class=\"params\">()</span>V</span><br><span class=\"line\">    .registers <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    .line <span class=\"number\">64</span></span><br><span class=\"line\">    const/<span class=\"number\">4</span> v0, <span class=\"number\">0x0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sput-<span class=\"type\">boolean</span> v0, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;registerByPlugin:Z</span><br><span class=\"line\"></span><br><span class=\"line\">    .line <span class=\"number\">69</span></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$modulejava&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$modulekotlin&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$arouterapi&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$app&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Interceptors$$modulejava&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Interceptors$$app&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$modulejava&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$modulekotlin&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$arouterapi&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$app&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>-<span class=\"keyword\">void</span></span><br><span class=\"line\">.end method</span><br></pre></td></tr></table></figure>\n\n<p>对比发现，使用<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>后，这个方法增加了很多代码，基本上就是在加载路由路径表。使用这个gradle插件的基本思想就是，将查找路由路径表的过程，从<strong>运行时</strong>提前到了<strong>编译时</strong>，这算是一种AOT(Ahead of time)思想。</p>\n<p>将最耗时的查找过程提前，也就解决了ARouter初始化时间过长的问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在阅读源码前，请先下载源码：<a href=\"https://github.com/alibaba/ARouter\">ARouter</a></p>\n<p>最近阅读ARouter源码，发现这真的是一个非常优秀的框架。激发出兴趣来读一下他的源码，实际上，这个框架的结构非常简单。这个框架可以分为<strong>主流程</strong>和<strong>辅助流程</strong>来拆开分析。</p>\n<p>主流程包含<strong>编译时</strong>和<strong>运行时</strong>两个部分，其中编译时主要做的是路由路径表的构建，运行时主要做的是路由路径表的加载；</p>\n<p>辅助流程主要就是做<strong>启动优化</strong>。</p>\n<h2 id=\"主流程\"><a href=\"#主流程\" class=\"headerlink\" title=\"主流程\"></a>主流程</h2><h3 id=\"1-编译时\"><a href=\"#1-编译时\" class=\"headerlink\" title=\"1. 编译时\"></a>1. 编译时</h3><p>这部分主要涉及到的是路由路径表的构建，其实现原理是<strong>APT</strong>，即<strong>注解处理器</strong>。</p>\n<p>使用ARouter时候，需要在目标类上，通过**@Route<strong>注解进行标记，注解处理器处理的就是这个注解。打开源码路径下的<em>arouter-compiler</em>这个module，找到</strong>RouteProcessor<strong>，这个类就是用来处理</strong>@Route**注解的类。这里需要了解的知识，除了APT，还有java-poet，请自行了解这些。</p>\n<p>Processor类的入口方法是<em>process</em>方法，这个方法返回true，则这个处理器已经完成了自己的任务，不会被重复调用。其他比较重要的方法有<em>getSupportedSourceVersion</em>，<em>getSupportedAnnotationTypes</em>等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span>&gt; routeElements = roundEnv.getElementsAnnotatedWith(Route.class);</span><br></pre></td></tr></table></figure>\n\n<p>通过这个方法，获取所有被**@Route**标记的元素。</p>\n<p>获取到<em>routeElements</em>后，在<em>parseRoutes</em>方法进行处理。我们以最常用的Activity为例，进行分析。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rootMap.clear();\t<span class=\"comment\">//用来分类存储标记元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用来检测元素是否为对应的类型，通过Types.isSubtype()方法来检测。</span></span><br><span class=\"line\"><span class=\"type\">TypeMirror</span> <span class=\"variable\">type_Activity</span> <span class=\"operator\">=</span> elementUtils.getTypeElement(ACTIVITY).asType();</span><br><span class=\"line\"><span class=\"type\">TypeMirror</span> <span class=\"variable\">type_Service</span> <span class=\"operator\">=</span> elementUtils.getTypeElement(SERVICE).asType();</span><br><span class=\"line\"><span class=\"type\">TypeMirror</span> <span class=\"variable\">fragmentTm</span> <span class=\"operator\">=</span> elementUtils.getTypeElement(FRAGMENT).asType();</span><br><span class=\"line\"><span class=\"type\">TypeMirror</span> <span class=\"variable\">fragmentTmV4</span> <span class=\"operator\">=</span> elementUtils.getTypeElement(Consts.FRAGMENT_V4).asType();</span><br></pre></td></tr></table></figure>\n\n<p>最后将分类号的元素信息，存储在成员变量groupMap中去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Set&lt;RouteMeta&gt;&gt; groupMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>然后再通过这个groupMap，借助java-poet，来生成真实的类。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ARouter$$Group$$test</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRouteGroup</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadInto</span><span class=\"params\">(Map&lt;String, RouteMeta&gt; atlas)</span> &#123;</span><br><span class=\"line\">    atlas.put(<span class=\"string\">&quot;/test/activity1&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, <span class=\"string\">&quot;/test/activity1&quot;</span>, <span class=\"string\">&quot;test&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class=\"string\">&quot;ser&quot;</span>, <span class=\"number\">9</span>); put(<span class=\"string\">&quot;ch&quot;</span>, <span class=\"number\">5</span>); put(<span class=\"string\">&quot;fl&quot;</span>, <span class=\"number\">6</span>); put(<span class=\"string\">&quot;dou&quot;</span>, <span class=\"number\">7</span>); put(<span class=\"string\">&quot;boy&quot;</span>, <span class=\"number\">0</span>); put(<span class=\"string\">&quot;url&quot;</span>, <span class=\"number\">8</span>); put(<span class=\"string\">&quot;pac&quot;</span>, <span class=\"number\">10</span>); put(<span class=\"string\">&quot;obj&quot;</span>, <span class=\"number\">11</span>); put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"number\">8</span>); put(<span class=\"string\">&quot;objList&quot;</span>, <span class=\"number\">11</span>); put(<span class=\"string\">&quot;map&quot;</span>, <span class=\"number\">11</span>); put(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">3</span>); put(<span class=\"string\">&quot;height&quot;</span>, <span class=\"number\">3</span>); &#125;&#125;, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    atlas.put(<span class=\"string\">&quot;/test/activity2&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test2Activity.class, <span class=\"string\">&quot;/test/activity2&quot;</span>, <span class=\"string\">&quot;test&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class=\"string\">&quot;key1&quot;</span>, <span class=\"number\">8</span>); &#125;&#125;, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    atlas.put(<span class=\"string\">&quot;/test/activity3&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test3Activity.class, <span class=\"string\">&quot;/test/activity3&quot;</span>, <span class=\"string\">&quot;test&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"number\">8</span>); put(<span class=\"string\">&quot;boy&quot;</span>, <span class=\"number\">0</span>); put(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">3</span>); &#125;&#125;, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    atlas.put(<span class=\"string\">&quot;/test/activity4&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, <span class=\"string\">&quot;/test/activity4&quot;</span>, <span class=\"string\">&quot;test&quot;</span>, <span class=\"literal\">null</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    atlas.put(<span class=\"string\">&quot;/test/fragment&quot;</span>, RouteMeta.build(RouteType.FRAGMENT, BlankFragment.class, <span class=\"string\">&quot;/test/fragment&quot;</span>, <span class=\"string\">&quot;test&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class=\"string\">&quot;obj&quot;</span>, <span class=\"number\">11</span>); put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"number\">8</span>); &#125;&#125;, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">    atlas.put(<span class=\"string\">&quot;/test/webview&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, TestWebview.class, <span class=\"string\">&quot;/test/webview&quot;</span>, <span class=\"string\">&quot;test&quot;</span>, <span class=\"literal\">null</span>, -<span class=\"number\">1</span>, -<span class=\"number\">2147483648</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-运行时\"><a href=\"#2-运行时\" class=\"headerlink\" title=\"2. 运行时\"></a>2. 运行时</h3><p>这部分主要做的是，在*ARouter.init()*时候，将上过程生成的路径表加载到内存中。</p>\n<blockquote>\n<p>如果你以官方demo程序验证这一步，需要将app&#x2F;build.gradle中的<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>这一行代码注释掉。</p>\n</blockquote>\n<p>我们以<em>ARouter.init</em>方法为入口，实际上最终实现init流程的是LogisticsCenter类的<em>init</em>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(Context context, ThreadPoolExecutor tpe)</span> <span class=\"keyword\">throws</span> HandlerException &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (registerByPlugin) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//这是在辅助流程需要去讲的</span></span><br><span class=\"line\">  \tlogger.info(TAG, <span class=\"string\">&quot;Load router map by arouter-auto-register plugin.&quot;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    Set&lt;String&gt; routerMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// It will rebuild router map every times when debuggable.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class=\"line\">      logger.info(TAG, <span class=\"string\">&quot;Run with debug mode or new install, rebuild router map.&quot;</span>);</span><br><span class=\"line\">      <span class=\"comment\">// These class was generated by arouter-compiler.</span></span><br><span class=\"line\">      routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class=\"line\">        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      PackageUtils.updateVersion(context);    <span class=\"comment\">// Save new version name when router map update finishes.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      logger.info(TAG, <span class=\"string\">&quot;Load router map from cache.&quot;</span>);</span><br><span class=\"line\">      routerMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;String&gt;()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要着重看的是这一句：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br></pre></td></tr></table></figure>\n\n<p>我们查看这个方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Set&lt;String&gt; <span class=\"title function_\">getFileNameByPackageName</span><span class=\"params\">(Context context, <span class=\"keyword\">final</span> String packageName)</span> <span class=\"keyword\">throws</span> PackageManager.NameNotFoundException, IOException, InterruptedException &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Set&lt;String&gt; classNames = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  List&lt;String&gt; paths = getSourcePaths(context);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"type\">CountDownLatch</span> <span class=\"variable\">parserCtl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(paths.size());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> String path : paths) &#123;</span><br><span class=\"line\">    Log.v(TAG, <span class=\"string\">&quot;getFileNameByPackageName path=&quot;</span> + path);</span><br><span class=\"line\">    DefaultPoolExecutor.getInstance().execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">DexFile</span> <span class=\"variable\">dexfile</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (path.endsWith(EXTRACTED_SUFFIX)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//NOT use new DexFile(path), because it will throw &quot;permission error in /data/dalvik-cache&quot;</span></span><br><span class=\"line\">            dexfile = DexFile.loadDex(path, path + <span class=\"string\">&quot;.tmp&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            dexfile = <span class=\"keyword\">new</span> <span class=\"title class_\">DexFile</span>(path);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          Enumeration&lt;String&gt; dexEntries = dexfile.entries();</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (dexEntries.hasMoreElements()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">className</span> <span class=\"operator\">=</span> dexEntries.nextElement();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (className.startsWith(packageName)) &#123;</span><br><span class=\"line\">              Log.v(TAG, <span class=\"string\">&quot;find CLASS NAME &quot;</span> + className);</span><br><span class=\"line\">              classNames.add(className);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ignore) &#123;</span><br><span class=\"line\">          Log.e(<span class=\"string\">&quot;ARouter&quot;</span>, <span class=\"string\">&quot;Scan map file in dex files made error.&quot;</span>, ignore);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != dexfile) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              dexfile.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ignore) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          parserCtl.countDown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  parserCtl.await();</span><br><span class=\"line\"></span><br><span class=\"line\">  Log.d(Consts.TAG, <span class=\"string\">&quot;Filter &quot;</span> + classNames.size() + <span class=\"string\">&quot; classes by packageName &lt;&quot;</span> + packageName + <span class=\"string\">&quot;&gt;&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> classNames;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意其中的<em>getSourcePaths</em>方法，这是从代码目录，来获取所有代码目录，然后在</p>\n<p><em>getFileNameByPackageName</em>找出以<code>com.alibaba.android.arouter.routes</code>为开头包名的类，这些就是我们在步骤1中生成的辅助类。</p>\n<p>这个方法结束后，回到<em>LogisticsCenter#init</em>方法，接下来要做的就是，把加载到的辅助类，通过反射生成对象，再调用其<em>loadTo</em>方法，将路由路径表加载到Warehouse类中去，方便以后的查询。</p>\n<h2 id=\"辅助流程\"><a href=\"#辅助流程\" class=\"headerlink\" title=\"辅助流程\"></a>辅助流程</h2><p>在以上的流程中，有一个严重的问题，那就是执行<em>ARouter#init</em>方法的时间过长，以源码的demo为例，在InstantRun的情况下，OnePlus5T需要100多毫秒才能初始化完，这对于程序启动优化来说，是一个不可忽视的时间了。那么如何解决这个问题呢？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MainActivity: init cost 134</span><br></pre></td></tr></table></figure>\n\n<p>这就是在上一步中，要求你注释掉的代码起作用了，将<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>解除注释，让其发挥作用。</p>\n<p>这里需要关注的module是<code>arouter-gradle-plugin</code>。</p>\n<p>先来看一下，使用了<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>的神奇效果。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MainActivity: init cost 19</span><br></pre></td></tr></table></figure>\n\n<p>通过优化，让<em>ARouter#init</em>消耗时间直接降低了一个数量级，那么<code>arouter-gradle-plugin</code>是怎么做到的呢？</p>\n<p>这需要你先了解一下[ASM](&#x2F;android&#x2F;ASM.md)。简单来说，这是一种字节码编程技术，通过修改编译后的字节码的方式，来对原始逻辑增强。</p>\n<p>我们再来看<em>ARouter#init</em>的最终实现类和方法<em>LogisticsCenter#init</em>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(Context context, ThreadPoolExecutor tpe)</span> <span class=\"keyword\">throws</span> HandlerException &#123;</span><br><span class=\"line\">  ....</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startInit</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"comment\">//billy.qi modified at 2017-12-06</span></span><br><span class=\"line\">    <span class=\"comment\">//load by plugin first</span></span><br><span class=\"line\">    loadRouterMap();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (registerByPlugin) &#123;</span><br><span class=\"line\">      logger.info(TAG, <span class=\"string\">&quot;Load router map by arouter-auto-register plugin.&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HandlerException</span>(TAG + <span class=\"string\">&quot;ARouter init logistics center exception! [&quot;</span> + e.getMessage() + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，当<code>registerByPlugin</code>为true的时候，则只是打印了一句日志，我们再看loadRouterMap()这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadRouterMap</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  registerByPlugin = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">//auto generate register code by gradle plugin: arouter-auto-register</span></span><br><span class=\"line\">  <span class=\"comment\">// looks like below:</span></span><br><span class=\"line\">  <span class=\"comment\">// registerRouteRoot(new ARouter..Root..modulejava());</span></span><br><span class=\"line\">  <span class=\"comment\">// registerRouteRoot(new ARouter..Root..modulekotlin());</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的逻辑非常简单，到底在哪里去加载的路由路径表呢？我们看这个方法的注释，发现，这个方法是被<code>arouter-auto-register</code>自动生成的。</p>\n<p>我们打开<code>arouter-gradle-plugin/resources/META-INF/gradle-plugins</code>这个目录，可以看到，有一个<em>com.alibaba.arouter.properties</em>文件，查看其内容：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">implementation-class</span>=<span class=\"string\">com.alibaba.android.arouter.register.launch.PluginLaunch</span></span><br></pre></td></tr></table></figure>\n\n<p>这个<em>PluginLaunch</em>便是此gradle plugin的入口类。查看此类：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PluginLaunch</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Plugin</span>&lt;Project&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">def</span> isApp = project.plugins.hasPlugin(AppPlugin)</span><br><span class=\"line\">    <span class=\"comment\">//only application module needs this plugin to generate register code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isApp) &#123;</span><br><span class=\"line\">      Logger.make(project)</span><br><span class=\"line\"></span><br><span class=\"line\">      Logger.i(<span class=\"string\">&#x27;Project enable arouter-register plugin&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">def</span> android = project.extensions.getByType(AppExtension)</span><br><span class=\"line\">      <span class=\"keyword\">def</span> transformImpl = <span class=\"keyword\">new</span> RegisterTransform(project)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//init arouter-auto-register settings</span></span><br><span class=\"line\">      ArrayList&lt;ScanSetting&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">3</span>)</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> ScanSetting(<span class=\"string\">&#x27;IRouteRoot&#x27;</span>))</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> ScanSetting(<span class=\"string\">&#x27;IInterceptorGroup&#x27;</span>))</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> ScanSetting(<span class=\"string\">&#x27;IProviderGroup&#x27;</span>))</span><br><span class=\"line\">      RegisterTransform.registerList = list</span><br><span class=\"line\">      <span class=\"comment\">//register this plugin</span></span><br><span class=\"line\">      android.registerTransform(transformImpl)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们查看其代码，可以发现，这里一共做了三件事：</p>\n<ol>\n<li>判断是否为app module，如果不是，则不做任何事，在app module下做2和3两步；</li>\n<li>生成了一个RegisterTransform，并为其静态变量registerList赋值，<strong>注意此处赋值的registerList中包含的三个对象</strong>；</li>\n<li>注册此RegisterTransform。</li>\n</ol>\n<p>接下来，就轮到<em>RegisterTransform</em>来执行了。</p>\n<p>Transform类，简单来说，就是可以在编译时，扫描所有的jar和class，包括引用类库中的。在扫描过程中，就可以借助<strong>ASM</strong>技术对目标类进行更改。</p>\n<p>我们看其入口方法<em>transform</em>：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"type\">void</span> transform(Context context, Collection&lt;TransformInput&gt; inputs, Collection&lt;TransformInput&gt; referencedInputs, TransformOutputProvider outputProvider, <span class=\"type\">boolean</span> isIncremental) <span class=\"keyword\">throws</span> IOException, TransformException, InterruptedException &#123;</span><br><span class=\"line\">  inputs.each &#123; TransformInput input -&gt;</span><br><span class=\"line\">    <span class=\"comment\">// scan all jars</span></span><br><span class=\"line\">    input.jarInputs.each &#123; JarInput jarInput -&gt;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ScanUtil.shouldProcessPreDexJar(src.absolutePath)) &#123;</span><br><span class=\"line\">        ScanUtil.scanJar(src, dest)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    directoryInput.file.eachFileRecurse &#123; File file -&gt;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(file.isFile() &amp;&amp; ScanUtil.shouldProcessClass(path))&#123;</span><br><span class=\"line\">        ScanUtil.scanClass(file)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>省去了一些细节，只保留了主线逻辑，我们可以看到，其扫描到的jar和class都经过了ScanUtils的方法来处理，我们继续跟踪下去，会发现，<em>scanJar</em>也是循环调用的<em>scanClass</em>，这样我们直接看<em>scanClass</em>方法：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">void</span> scanClass(InputStream inputStream) &#123;</span><br><span class=\"line\">  ClassReader cr = <span class=\"keyword\">new</span> ClassReader(inputStream)</span><br><span class=\"line\">  ClassWriter cw = <span class=\"keyword\">new</span> ClassWriter(cr, <span class=\"number\">0</span>)</span><br><span class=\"line\">  ScanClassVisitor cv = <span class=\"keyword\">new</span> ScanClassVisitor(Opcodes.ASM5, cw)</span><br><span class=\"line\">  cr.accept(cv, ClassReader.EXPAND_FRAMES)</span><br><span class=\"line\">  inputStream.close()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ScanClassVisitor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassVisitor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  ScanClassVisitor(<span class=\"type\">int</span> api, ClassVisitor cv) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(api, cv)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">void</span> visit(<span class=\"type\">int</span> version, <span class=\"type\">int</span> access, String name, String signature,</span><br><span class=\"line\">             String superName, String[] interfaces) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>.visit(version, access, name, signature, superName, interfaces)</span><br><span class=\"line\">    RegisterTransform.registerList.each &#123; ext -&gt;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ext.interfaceName &amp;&amp; interfaces != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        interfaces.each &#123; itName -&gt;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (itName == ext.interfaceName) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//fix repeated inject init code when Multi-channel packaging</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!ext.classList.contains(name)) &#123;</span><br><span class=\"line\">              ext.classList.add(name)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就又涉及到了ASM的知识，ScanClassVisitor是访问某个类的内部结构。</p>\n<blockquote>\n<p>version：类的版本；</p>\n<p>access：表示类的访问权限，public，private，protected等；</p>\n<p>name：类的名字；</p>\n<p>signature：有无泛型；</p>\n<p>superName：其父类；</p>\n<p>interfaces：其实现的接口；</p>\n</blockquote>\n<p>在<em>ScanClassVisitor</em>中，并没有对类做修改，只是从遍历过的类中，把我们关心的类挑出来。那么，我们关心哪些类呢？</p>\n<p>在<em>PluginLaunch</em>类中，我们注册了三个<em>ScanSettings</em>类，分别是<strong>IRouteRoot</strong>、<strong>IInterceptorGroup</strong>和<strong>IProviderGroup</strong>，也就是说，我们把实现了这三个接口的类，挑出来，加入到各自对应的ScanSettings类中记录起来。这三个接口是不是很熟悉？就是通过APT生成的用来记录路由路径表的类。</p>\n<p>等收集好了这些记录的路径表信息后，就可以对<em>LogisticsCenter</em>通过ASM进行修改了。我们接着看<em>RegisterTransform#transform</em>方法中剩下的逻辑。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (fileContainsInitClass) &#123;</span><br><span class=\"line\">  registerList.each &#123; ext -&gt;</span><br><span class=\"line\">    Logger.i(<span class=\"string\">&#x27;Insert register code to file &#x27;</span> + fileContainsInitClass.absolutePath)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ext.classList.isEmpty()) &#123;</span><br><span class=\"line\">      Logger.e(<span class=\"string\">&quot;No class implements found for interface:&quot;</span> + ext.interfaceName)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ext.classList.each &#123;</span><br><span class=\"line\">        Logger.i(it)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      RegisterCodeGenerator.insertInitCodeTo(ext)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意此处的insertInitCodeTo方法，这就是ASM修改的入口了。这里不对修改过程进行详细解释了。我们直接对比看<em>LogisticsCenter</em>修改前后关键代码的对比。</p>\n<p>在<em>app&#x2F;build</em>目录下，找到生成的apk文件，通过AndroidStudio来查看其中的class，找到关键<em>LogisticsCenter</em>关键方法<em>loadRouterMap</em>。</p>\n<blockquote>\n<p>具体过程如下：</p>\n<p>app&#x2F;build&#x2F;outputs&#x2F;apk&#x2F;debug&#x2F;app-debug.apk -&gt; classes.dex(双击) -&gt; 找到<em>LogisticsCenter#loadRouterMap</em>方法 -&gt; 右键: show Bytecode。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不使用apply plugin: &#x27;com.alibaba.arouter&#x27;</span></span><br><span class=\"line\">.method <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"title function_\">loadRouterMap</span><span class=\"params\">()</span>V</span><br><span class=\"line\">    .registers <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    .line <span class=\"number\">64</span></span><br><span class=\"line\">    const/<span class=\"number\">4</span> v0, <span class=\"number\">0x0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sput-<span class=\"type\">boolean</span> v0, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;registerByPlugin:Z</span><br><span class=\"line\"></span><br><span class=\"line\">    .line <span class=\"number\">69</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>-<span class=\"keyword\">void</span></span><br><span class=\"line\">.end method</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用apply plugin: &#x27;com.alibaba.arouter&#x27;</span></span><br><span class=\"line\">.method <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"title function_\">loadRouterMap</span><span class=\"params\">()</span>V</span><br><span class=\"line\">    .registers <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    .line <span class=\"number\">64</span></span><br><span class=\"line\">    const/<span class=\"number\">4</span> v0, <span class=\"number\">0x0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sput-<span class=\"type\">boolean</span> v0, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;registerByPlugin:Z</span><br><span class=\"line\"></span><br><span class=\"line\">    .line <span class=\"number\">69</span></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$modulejava&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$modulekotlin&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$arouterapi&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$app&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Interceptors$$modulejava&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Interceptors$$app&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$modulejava&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$modulekotlin&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$arouterapi&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    const-string v0, <span class=\"string\">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$app&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    invoke-<span class=\"keyword\">static</span> &#123;v0&#125;, Lcom/alibaba/android/arouter/core/LogisticsCenter;-&gt;register(Ljava/lang/String;)V</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>-<span class=\"keyword\">void</span></span><br><span class=\"line\">.end method</span><br></pre></td></tr></table></figure>\n\n<p>对比发现，使用<code>apply plugin: &#39;com.alibaba.arouter&#39;</code>后，这个方法增加了很多代码，基本上就是在加载路由路径表。使用这个gradle插件的基本思想就是，将查找路由路径表的过程，从<strong>运行时</strong>提前到了<strong>编译时</strong>，这算是一种AOT(Ahead of time)思想。</p>\n<p>将最耗时的查找过程提前，也就解决了ARouter初始化时间过长的问题。</p>\n"},{"layout":"post","title":"Glide源码分析与自我实现(一)——数据加载主流程","author":"boybeak","_content":"\n> 本文基于Glide 4.11.0\n\n阅读前请参考[Glide 源码分析解读-基于最新版Glide 4.9.0](https://zhuanlan.zhihu.com/p/60425157)一文，该文章中，将Glide中各个部分的作用分析的非常好了。\n\nGlide几乎是现在做Android图片加载的最佳选择了。如此优秀的一个框架是如何实现的呢？如果让我们自己来实现该怎么做呢？我们就通过自己实现一个低配版Glide的方式，来探究Glide中是如何实现的。\n\n我们就称我们自己低配版Glide为**Slide**。那么Slide要实现哪些功能呢？简单来说，就是**获取图片**+**界面显示**。我们通过先构架大体框架，再分步丰富其中细节的方式，来构建Slide的整体结构。\n\n```mermaid\nflowchart LR;\nA[获取图片] --> C[Slide] --> B[界面显示];\n```\n\n```java\nGlide.with(xxx).load(url).into(iv);\n```\n\n这是Glide一个典型的最为简单的调用过程。那么在这个过程中发生了哪些事情呢？\n\n我们可以通过这个链式调用的返回值发现，有如下过程：\n\n```mermaid\ngraph LR;\nstyle A fill:#aaffcc\nstyle D fill:#ffaa99\nA(Glide) -->|\"with(xxx)\"| B(RequestManager) -->|\"load(xxx)\"| C(RequestBuilder) -->|\"into(iv)\"| D(Target);\n```\n\n## Glide.with(xxx)发生了什么事？\n\n阅读源码发现，`Glide.with(xxx)`的最终实现类是*RequestManagerRetriever.java*类。继续跟踪，我们在这个类中，看到这样一个方法。\n\n```java\n@NonNull\nprivate RequestManager supportFragmentGet(\n  @NonNull Context context,\n  @NonNull FragmentManager fm,\n  @Nullable Fragment parentHint,\n  boolean isParentVisible) {\n  SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);\n  RequestManager requestManager = current.getRequestManager();\n\n  .....\n\n    return requestManager;\n}\n```\n\n重点关注这个getSupportRequestManagerFragment方法。\n\n```java\n//getSupportRequestManagerFragment\n@NonNull\nprivate SupportRequestManagerFragment getSupportRequestManagerFragment(\n  @NonNull final FragmentManager fm, @Nullable Fragment parentHint) {\n  SupportRequestManagerFragment current =\n    (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n  if (current == null) {\n    current = pendingSupportRequestManagerFragments.get(fm);\n    if (current == null) {\n      current = new SupportRequestManagerFragment();\n      current.setParentFragmentHint(parentHint);\n      pendingSupportRequestManagerFragments.put(fm, current);\n      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n      handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();\n    }\n  }\n  return current;\n}\n```\n\n其实，这里是一个Glide检测到界面生命周期的关键了。**Glide就是通过像当前Activity添加一个一个无UI的Fragment来探测生命周期的**。\n\n> **注意：**在执行了添加fragment的语句`fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss()`后，又马上通过handler发送了一个一个message，这里需要熟悉Handler机制才能理解，简单来说，就是添加fragment操作，实际上也是通过handler执行的，这是一个异步的过程，如何检测到fragment已经添加完成了呢？就是在`commitAllowingStateLoss`后，马上去发送一条指定的消息，利用handler处理message的顺序性，来获知fragment已经添加完成。\n\n经过添加*SupportRequestManagerFragment*后，我们获得了探测当前界面生命周期的能力。\n\n继续阅读`supportFragmentGet`方法代码，**RequestManager**是从**SupportRequestManagerFragment**拿到的，如果拿到的是空，则创建一个，设置到该fragment当中去。\n\n\n\n## RequestManager.load(xxx)发生了什么？\n\n我们以`load(url)`为例，来探究这部分代码。\n\n这个方法，返回的是*RequestBuilder*这个类，看名字就知道，这是一个构建者模式中的Builder类，主要是在添加各种配置项，比如RequestOptions、RequestListener等。\n\n\n\n## RequestBuilder.into(iv)发生了什么？\n\n其实，这里才是真正开始触发发起请求的地方。\n\n### RequestBuilder\n\n我们把`into(ImageView)`方法作为入口，一路跟踪，可以发现最终的实现是如下方法。\n\n```java\nprivate <Y extends Target<TranscodeType>> Y into(\n  @NonNull Y target,\n  @Nullable RequestListener<TranscodeType> targetListener,\n  BaseRequestOptions<?> options,\n  Executor callbackExecutor) {\n  Preconditions.checkNotNull(target);\n  if (!isModelSet) {\n    throw new IllegalArgumentException(\"You must call #load() before calling #into()\");\n  }\n\n  Request request = buildRequest(target, targetListener, options, callbackExecutor);\n\n  Request previous = target.getRequest();\n  if (request.isEquivalentTo(previous)\n      && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {\n    // If the request is completed, beginning again will ensure the result is re-delivered,\n    // triggering RequestListeners and Targets. If the request is failed, beginning again will\n    // restart the request, giving it another chance to complete. If the request is already\n    // running, we can let it continue running without interruption.\n    if (!Preconditions.checkNotNull(previous).isRunning()) {\n      // Use the previous request rather than the new one to allow for optimizations like skipping\n      // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions\n      // that are done in the individual Request.\n      previous.begin();\n    }\n    return target;\n  }\n\n  requestManager.clear(target);\n  target.setRequest(request);\n  requestManager.track(target, request);\n\n  return target;\n}\n```\n\n这个方法主要是做了以下事情：\n\n1. 是否已经有一个request在处理相同的请求，如果有，则判断是否正在运行，没有正在运行则开始运行；\n2. 如果没有一个request在处理此请求，则对target做一些清理操作，与之前的请求解绑，为当前target设置新的请求，然后requestManager开始追踪这个请求。\n\n接下来我们就按照`requestManager.track(target, request)`这段代码继续追踪。来到RequestManager的track方法。\n\n### RequestManager\n\n```java\nsynchronized void track(@NonNull Target<?> target, @NonNull Request request) {\n  targetTracker.track(target);\n  requestTracker.runRequest(request);\n}\n```\n\n这个方法很简单，只有两个方法。\n\n#### TargetTracker\n\n```java\nprivate final Set<Target<?>> targets =\n      Collections.newSetFromMap(new WeakHashMap<Target<?>, Boolean>());\n\npublic void track(@NonNull Target<?> target) {\n  targets.add(target);\n}\n```\n\n这里把一个target存放在WeakHashMap中，因为target是与生命周期有关的东西，比如ImageView对应的**ImageViewTarget**，所以这么做是为了防止内存泄漏。\n\n#### RequestTracker\n\n```java\n/** Starts tracking the given request. */\npublic void runRequest(@NonNull Request request) {\n  requests.add(request);\n  if (!isPaused) {\n    request.begin();\n  } else {\n    request.clear();\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      Log.v(TAG, \"Paused, delaying request\");\n    }\n    pendingRequests.add(request);\n  }\n}\n```\n\n这里是将暂停的request加入到pendingRequests中去，如果不是暂停的request，则调用其begin方法。\n\n我们查看*Request*类的子类，可以看到下图。\n\n![request_implementions](/images/request_implementions.jpg)\n\n可以看到一共有4个类实现了*Request*类，其中*FakeRequest*类是用于测试的，不去考虑。其他三个类的作用如下：\n\n1. **ThumbnailRequestCoordinator:** 用来加载thumbnail；\n2. **ErrorRequestCoordinator:** 用来加载错误时候，展示错误状态； \n3. **SingleRequest:** 这才是用来加载目标图片的request。\n\n我们重点去看SingleRequest的begin方法。\n\n### SingleRequest\n\n```java\npublic void begin() {\n  synchronized (requestLock) {\n    assertNotCallingCallbacks();\n    stateVerifier.throwIfRecycled();\n    startTime = LogTime.getLogTime();\n    if (model == null) {\n      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n        width = overrideWidth;\n        height = overrideHeight;\n      }\n      // Only log at more verbose log levels if the user has set a fallback drawable, because\n      // fallback Drawables indicate the user expects null models occasionally.\n      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;\n      onLoadFailed(new GlideException(\"Received null model\"), logLevel);\n      return;\n    }\n\n    if (status == Status.RUNNING) {\n      throw new IllegalArgumentException(\"Cannot restart a running request\");\n    }\n\n    // If we're restarted after we're complete (usually via something like a notifyDataSetChanged\n    // that starts an identical request into the same Target or View), we can simply use the\n    // resource and size we retrieved the last time around and skip obtaining a new size, starting\n    // a new load etc. This does mean that users who want to restart a load because they expect\n    // that the view size has changed will need to explicitly clear the View or Target before\n    // starting the new load.\n    if (status == Status.COMPLETE) {\n      onResourceReady(\n        resource, DataSource.MEMORY_CACHE, /* isLoadedFromAlternateCacheKey= */ false);\n      return;\n    }\n\n    // Restarts for requests that are neither complete nor running can be treated as new requests\n    // and can run again from the beginning.\n\n    status = Status.WAITING_FOR_SIZE;\n    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n      onSizeReady(overrideWidth, overrideHeight);\n    } else {\n      target.getSize(this);\n    }\n\n    if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)\n        && canNotifyStatusChanged()) {\n      target.onLoadStarted(getPlaceholderDrawable());\n    }\n    if (IS_VERBOSE_LOGGABLE) {\n      logV(\"finished run method in \" + LogTime.getElapsedMillis(startTime));\n    }\n  }\n}\n```\n\n代码虽长，但是结构简单。主要做了以下事情：\n\n1. 检查model是否是空，model就是要加载的数据来源，比如url、resourceId、File等；\n2. 判断request状态，不能重新开始一个正在运行的请求；\n3. 判断request状态，如果是已经完成的请求，则说明资源已经存在，直接调用`onResourceReady`方法并返回；\n4. 接下来就来到判断target尺寸的过程了，如果target尺寸已经确定，比如view尺寸measure结束后，则调用`onSizeReady`方法，**注意：实际的网络请求就在这个onSizeReady方法中，因为只有target的尺寸确定了，才能进行请求并处理图片；**\n5. 如果尺寸未确定，则调用`target.getSize`方法去监听尺寸事件，具体可以参考`ViewTarget#getSize`方法，这是一个通过onPreDrawListener来监听尺寸的；\n6. 接下来回调`onLoadStarted`方法，并且显示加载过程状态。\n\n我们着重看网络请求那个分支，也就是`onSizeReady`方法。\n\n```java\n@Override\npublic void onSizeReady(int width, int height) {\n  ......\n\tloadStatus = engine.load(\n    glideContext,\n    model,\n    requestOptions.getSignature(),\n    this.width,\n    this.height,\n    requestOptions.getResourceClass(),\n    transcodeClass,\n    priority,\n    requestOptions.getDiskCacheStrategy(),\n    requestOptions.getTransformations(),\n    requestOptions.isTransformationRequired(),\n    requestOptions.isScaleOnlyOrNoTransform(),\n    requestOptions.getOptions(),\n    requestOptions.isMemoryCacheable(),\n    requestOptions.getUseUnlimitedSourceGeneratorsPool(),\n    requestOptions.getUseAnimationPool(),\n    requestOptions.getOnlyRetrieveFromCache(),\n    this,\n    callbackExecutor\n  );\n  ...\n}\n```\n\n关键代码来了！这个`engine`就是Glide的核心。这个engine是在Glide初始化时候生成的一个实例。\n\n### Engine\n\nEngine不只是用于加载图片，而是一个任务执行核心引擎，它要执行的不只是请求远程图片的任务，包括解码任务等，它执行的实际上是一个个的job。\n\n跟踪上一阶段中的`engine.load`方法，来到是这个方法的关键部分——调用`waitForExistingOrStartNewJob`。\n\n在这个方法中，主要做了以下事情：\n\n```mermaid\ngraph TD;\nA{{是否有一个job执行相同操作}} --> |有|B[为此job添加新的回调];\nA --> |无|C[添加并执行一个EngineJob];\n```\n\n#### EngineJob.start(decodeJob)\n\n```java\npublic synchronized void start(DecodeJob<R> decodeJob) {\n  this.decodeJob = decodeJob;\n  GlideExecutor executor =\n    decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();\n  executor.execute(decodeJob);\n}\n```\n\n这里执行的是decodeJob。\n\n> 这里需要着重关注一点，就是`executor.execute(decodeJob)`的时候，就已经通过*GlideExecutor*的sourceExecutor.Builder创建了一个**ThreadPoolExecutor**，也就是在这里实现线程池异步执行任务。**ThreadPoolExecutor**并不是Glide提供的实现，而是在java.util.concurrent包下。\n\n#### DecodeJob\n\nDecodeJob是一个*Runnable*类，所以，我们查看其run方法。\n\n接下来的调用路径参考下图。\n\n```mermaid\ngraph TD;\nsubgraph DecodeJob;\nA(run) --> B[runWrapped] --> C[runGenerators] --> D[getNextGenerator];\nend;\nsubgraph SourceGenerator\nD --> E[startNext] --> F[startNextLoad];\nend;\nsubgraph HttpUrlFetcher\nF --> G[loadData] --> H[loadDataWithRedirects];\nend;\n```\n\n经过这么长的调用链，我们终于来到了网络请求的部分，我们可以看到Glide原生使用的*HttpURLConnection*进行网络请求的。**获取到InputStream后，在SourceGenerator中的cacheData方法进行缓存处理。**\n\n#### 获取到数据后的处理\n\n通过`DataFetcherGenerator.FetcherReadyCallback`可以探知到数据获取成功或者失败，如果获取成功，则在`DecodeJob#onDataFetcherReady`中处理。关键代码如下：\n\n```java\npublic void onDataFetcherReady(\n      Key sourceKey, Object data, DataFetcher<?> fetcher, DataSource dataSource, Key attemptedKey) {\n  .....\n  if (Thread.currentThread() != currentThread) {\n    runReason = RunReason.DECODE_DATA;\n    callback.reschedule(this);\n  } else {\n    .....\n  }\n}\n```\n\n更改任务状态，重新执行此任务，则重新执行到`getNextGenerator`方法，此时则会返回**DataCacheGenerator**来处理从Disk缓存加载的任务。\n\n## 获取图片\n\n首先，图片来源有哪些？\n\n1. 资源图片：drawable, assets, raw, mipmap这些程序中自带的图片；\n2. 本地图片：本地存储设备上的图片；\n3. 远端图片：我们服务器或者来自第三方服务器的图片，通过URL来获取。这就需要**异步网络请求**，请求结束以后，要**缓存**图片，避免重复请求远端图片，造成时间、网络的浪费。\n\n```mermaid\ngraph LR;\nA[Slide];\nB([1. 资源图片]) --> A;\nC([2. 本地图片]) --> A;\nE{缓存是否存在} --> |是,交给Slide|A;\nE --> |否,网络请求|D([3. 远端图片]);\nD -.-> |获取到图片并缓存|E;\n\n```\n\n\n\n那么接下来，要丰富的细节，就来到了**网络请求**和**缓存**了。\n\n\n\n### 网络请求\n\n\n\n### 缓存\n\n","source":"_posts/2022-09-17-Glide源码分析与自我实现1.md","raw":"---\nlayout: post\ntitle: Glide源码分析与自我实现(一)——数据加载主流程\nauthor: boybeak\ncategory: 源码分析\ntags: Android\n---\n\n> 本文基于Glide 4.11.0\n\n阅读前请参考[Glide 源码分析解读-基于最新版Glide 4.9.0](https://zhuanlan.zhihu.com/p/60425157)一文，该文章中，将Glide中各个部分的作用分析的非常好了。\n\nGlide几乎是现在做Android图片加载的最佳选择了。如此优秀的一个框架是如何实现的呢？如果让我们自己来实现该怎么做呢？我们就通过自己实现一个低配版Glide的方式，来探究Glide中是如何实现的。\n\n我们就称我们自己低配版Glide为**Slide**。那么Slide要实现哪些功能呢？简单来说，就是**获取图片**+**界面显示**。我们通过先构架大体框架，再分步丰富其中细节的方式，来构建Slide的整体结构。\n\n```mermaid\nflowchart LR;\nA[获取图片] --> C[Slide] --> B[界面显示];\n```\n\n```java\nGlide.with(xxx).load(url).into(iv);\n```\n\n这是Glide一个典型的最为简单的调用过程。那么在这个过程中发生了哪些事情呢？\n\n我们可以通过这个链式调用的返回值发现，有如下过程：\n\n```mermaid\ngraph LR;\nstyle A fill:#aaffcc\nstyle D fill:#ffaa99\nA(Glide) -->|\"with(xxx)\"| B(RequestManager) -->|\"load(xxx)\"| C(RequestBuilder) -->|\"into(iv)\"| D(Target);\n```\n\n## Glide.with(xxx)发生了什么事？\n\n阅读源码发现，`Glide.with(xxx)`的最终实现类是*RequestManagerRetriever.java*类。继续跟踪，我们在这个类中，看到这样一个方法。\n\n```java\n@NonNull\nprivate RequestManager supportFragmentGet(\n  @NonNull Context context,\n  @NonNull FragmentManager fm,\n  @Nullable Fragment parentHint,\n  boolean isParentVisible) {\n  SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);\n  RequestManager requestManager = current.getRequestManager();\n\n  .....\n\n    return requestManager;\n}\n```\n\n重点关注这个getSupportRequestManagerFragment方法。\n\n```java\n//getSupportRequestManagerFragment\n@NonNull\nprivate SupportRequestManagerFragment getSupportRequestManagerFragment(\n  @NonNull final FragmentManager fm, @Nullable Fragment parentHint) {\n  SupportRequestManagerFragment current =\n    (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n  if (current == null) {\n    current = pendingSupportRequestManagerFragments.get(fm);\n    if (current == null) {\n      current = new SupportRequestManagerFragment();\n      current.setParentFragmentHint(parentHint);\n      pendingSupportRequestManagerFragments.put(fm, current);\n      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n      handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();\n    }\n  }\n  return current;\n}\n```\n\n其实，这里是一个Glide检测到界面生命周期的关键了。**Glide就是通过像当前Activity添加一个一个无UI的Fragment来探测生命周期的**。\n\n> **注意：**在执行了添加fragment的语句`fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss()`后，又马上通过handler发送了一个一个message，这里需要熟悉Handler机制才能理解，简单来说，就是添加fragment操作，实际上也是通过handler执行的，这是一个异步的过程，如何检测到fragment已经添加完成了呢？就是在`commitAllowingStateLoss`后，马上去发送一条指定的消息，利用handler处理message的顺序性，来获知fragment已经添加完成。\n\n经过添加*SupportRequestManagerFragment*后，我们获得了探测当前界面生命周期的能力。\n\n继续阅读`supportFragmentGet`方法代码，**RequestManager**是从**SupportRequestManagerFragment**拿到的，如果拿到的是空，则创建一个，设置到该fragment当中去。\n\n\n\n## RequestManager.load(xxx)发生了什么？\n\n我们以`load(url)`为例，来探究这部分代码。\n\n这个方法，返回的是*RequestBuilder*这个类，看名字就知道，这是一个构建者模式中的Builder类，主要是在添加各种配置项，比如RequestOptions、RequestListener等。\n\n\n\n## RequestBuilder.into(iv)发生了什么？\n\n其实，这里才是真正开始触发发起请求的地方。\n\n### RequestBuilder\n\n我们把`into(ImageView)`方法作为入口，一路跟踪，可以发现最终的实现是如下方法。\n\n```java\nprivate <Y extends Target<TranscodeType>> Y into(\n  @NonNull Y target,\n  @Nullable RequestListener<TranscodeType> targetListener,\n  BaseRequestOptions<?> options,\n  Executor callbackExecutor) {\n  Preconditions.checkNotNull(target);\n  if (!isModelSet) {\n    throw new IllegalArgumentException(\"You must call #load() before calling #into()\");\n  }\n\n  Request request = buildRequest(target, targetListener, options, callbackExecutor);\n\n  Request previous = target.getRequest();\n  if (request.isEquivalentTo(previous)\n      && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {\n    // If the request is completed, beginning again will ensure the result is re-delivered,\n    // triggering RequestListeners and Targets. If the request is failed, beginning again will\n    // restart the request, giving it another chance to complete. If the request is already\n    // running, we can let it continue running without interruption.\n    if (!Preconditions.checkNotNull(previous).isRunning()) {\n      // Use the previous request rather than the new one to allow for optimizations like skipping\n      // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions\n      // that are done in the individual Request.\n      previous.begin();\n    }\n    return target;\n  }\n\n  requestManager.clear(target);\n  target.setRequest(request);\n  requestManager.track(target, request);\n\n  return target;\n}\n```\n\n这个方法主要是做了以下事情：\n\n1. 是否已经有一个request在处理相同的请求，如果有，则判断是否正在运行，没有正在运行则开始运行；\n2. 如果没有一个request在处理此请求，则对target做一些清理操作，与之前的请求解绑，为当前target设置新的请求，然后requestManager开始追踪这个请求。\n\n接下来我们就按照`requestManager.track(target, request)`这段代码继续追踪。来到RequestManager的track方法。\n\n### RequestManager\n\n```java\nsynchronized void track(@NonNull Target<?> target, @NonNull Request request) {\n  targetTracker.track(target);\n  requestTracker.runRequest(request);\n}\n```\n\n这个方法很简单，只有两个方法。\n\n#### TargetTracker\n\n```java\nprivate final Set<Target<?>> targets =\n      Collections.newSetFromMap(new WeakHashMap<Target<?>, Boolean>());\n\npublic void track(@NonNull Target<?> target) {\n  targets.add(target);\n}\n```\n\n这里把一个target存放在WeakHashMap中，因为target是与生命周期有关的东西，比如ImageView对应的**ImageViewTarget**，所以这么做是为了防止内存泄漏。\n\n#### RequestTracker\n\n```java\n/** Starts tracking the given request. */\npublic void runRequest(@NonNull Request request) {\n  requests.add(request);\n  if (!isPaused) {\n    request.begin();\n  } else {\n    request.clear();\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      Log.v(TAG, \"Paused, delaying request\");\n    }\n    pendingRequests.add(request);\n  }\n}\n```\n\n这里是将暂停的request加入到pendingRequests中去，如果不是暂停的request，则调用其begin方法。\n\n我们查看*Request*类的子类，可以看到下图。\n\n![request_implementions](/images/request_implementions.jpg)\n\n可以看到一共有4个类实现了*Request*类，其中*FakeRequest*类是用于测试的，不去考虑。其他三个类的作用如下：\n\n1. **ThumbnailRequestCoordinator:** 用来加载thumbnail；\n2. **ErrorRequestCoordinator:** 用来加载错误时候，展示错误状态； \n3. **SingleRequest:** 这才是用来加载目标图片的request。\n\n我们重点去看SingleRequest的begin方法。\n\n### SingleRequest\n\n```java\npublic void begin() {\n  synchronized (requestLock) {\n    assertNotCallingCallbacks();\n    stateVerifier.throwIfRecycled();\n    startTime = LogTime.getLogTime();\n    if (model == null) {\n      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n        width = overrideWidth;\n        height = overrideHeight;\n      }\n      // Only log at more verbose log levels if the user has set a fallback drawable, because\n      // fallback Drawables indicate the user expects null models occasionally.\n      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;\n      onLoadFailed(new GlideException(\"Received null model\"), logLevel);\n      return;\n    }\n\n    if (status == Status.RUNNING) {\n      throw new IllegalArgumentException(\"Cannot restart a running request\");\n    }\n\n    // If we're restarted after we're complete (usually via something like a notifyDataSetChanged\n    // that starts an identical request into the same Target or View), we can simply use the\n    // resource and size we retrieved the last time around and skip obtaining a new size, starting\n    // a new load etc. This does mean that users who want to restart a load because they expect\n    // that the view size has changed will need to explicitly clear the View or Target before\n    // starting the new load.\n    if (status == Status.COMPLETE) {\n      onResourceReady(\n        resource, DataSource.MEMORY_CACHE, /* isLoadedFromAlternateCacheKey= */ false);\n      return;\n    }\n\n    // Restarts for requests that are neither complete nor running can be treated as new requests\n    // and can run again from the beginning.\n\n    status = Status.WAITING_FOR_SIZE;\n    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n      onSizeReady(overrideWidth, overrideHeight);\n    } else {\n      target.getSize(this);\n    }\n\n    if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)\n        && canNotifyStatusChanged()) {\n      target.onLoadStarted(getPlaceholderDrawable());\n    }\n    if (IS_VERBOSE_LOGGABLE) {\n      logV(\"finished run method in \" + LogTime.getElapsedMillis(startTime));\n    }\n  }\n}\n```\n\n代码虽长，但是结构简单。主要做了以下事情：\n\n1. 检查model是否是空，model就是要加载的数据来源，比如url、resourceId、File等；\n2. 判断request状态，不能重新开始一个正在运行的请求；\n3. 判断request状态，如果是已经完成的请求，则说明资源已经存在，直接调用`onResourceReady`方法并返回；\n4. 接下来就来到判断target尺寸的过程了，如果target尺寸已经确定，比如view尺寸measure结束后，则调用`onSizeReady`方法，**注意：实际的网络请求就在这个onSizeReady方法中，因为只有target的尺寸确定了，才能进行请求并处理图片；**\n5. 如果尺寸未确定，则调用`target.getSize`方法去监听尺寸事件，具体可以参考`ViewTarget#getSize`方法，这是一个通过onPreDrawListener来监听尺寸的；\n6. 接下来回调`onLoadStarted`方法，并且显示加载过程状态。\n\n我们着重看网络请求那个分支，也就是`onSizeReady`方法。\n\n```java\n@Override\npublic void onSizeReady(int width, int height) {\n  ......\n\tloadStatus = engine.load(\n    glideContext,\n    model,\n    requestOptions.getSignature(),\n    this.width,\n    this.height,\n    requestOptions.getResourceClass(),\n    transcodeClass,\n    priority,\n    requestOptions.getDiskCacheStrategy(),\n    requestOptions.getTransformations(),\n    requestOptions.isTransformationRequired(),\n    requestOptions.isScaleOnlyOrNoTransform(),\n    requestOptions.getOptions(),\n    requestOptions.isMemoryCacheable(),\n    requestOptions.getUseUnlimitedSourceGeneratorsPool(),\n    requestOptions.getUseAnimationPool(),\n    requestOptions.getOnlyRetrieveFromCache(),\n    this,\n    callbackExecutor\n  );\n  ...\n}\n```\n\n关键代码来了！这个`engine`就是Glide的核心。这个engine是在Glide初始化时候生成的一个实例。\n\n### Engine\n\nEngine不只是用于加载图片，而是一个任务执行核心引擎，它要执行的不只是请求远程图片的任务，包括解码任务等，它执行的实际上是一个个的job。\n\n跟踪上一阶段中的`engine.load`方法，来到是这个方法的关键部分——调用`waitForExistingOrStartNewJob`。\n\n在这个方法中，主要做了以下事情：\n\n```mermaid\ngraph TD;\nA{{是否有一个job执行相同操作}} --> |有|B[为此job添加新的回调];\nA --> |无|C[添加并执行一个EngineJob];\n```\n\n#### EngineJob.start(decodeJob)\n\n```java\npublic synchronized void start(DecodeJob<R> decodeJob) {\n  this.decodeJob = decodeJob;\n  GlideExecutor executor =\n    decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();\n  executor.execute(decodeJob);\n}\n```\n\n这里执行的是decodeJob。\n\n> 这里需要着重关注一点，就是`executor.execute(decodeJob)`的时候，就已经通过*GlideExecutor*的sourceExecutor.Builder创建了一个**ThreadPoolExecutor**，也就是在这里实现线程池异步执行任务。**ThreadPoolExecutor**并不是Glide提供的实现，而是在java.util.concurrent包下。\n\n#### DecodeJob\n\nDecodeJob是一个*Runnable*类，所以，我们查看其run方法。\n\n接下来的调用路径参考下图。\n\n```mermaid\ngraph TD;\nsubgraph DecodeJob;\nA(run) --> B[runWrapped] --> C[runGenerators] --> D[getNextGenerator];\nend;\nsubgraph SourceGenerator\nD --> E[startNext] --> F[startNextLoad];\nend;\nsubgraph HttpUrlFetcher\nF --> G[loadData] --> H[loadDataWithRedirects];\nend;\n```\n\n经过这么长的调用链，我们终于来到了网络请求的部分，我们可以看到Glide原生使用的*HttpURLConnection*进行网络请求的。**获取到InputStream后，在SourceGenerator中的cacheData方法进行缓存处理。**\n\n#### 获取到数据后的处理\n\n通过`DataFetcherGenerator.FetcherReadyCallback`可以探知到数据获取成功或者失败，如果获取成功，则在`DecodeJob#onDataFetcherReady`中处理。关键代码如下：\n\n```java\npublic void onDataFetcherReady(\n      Key sourceKey, Object data, DataFetcher<?> fetcher, DataSource dataSource, Key attemptedKey) {\n  .....\n  if (Thread.currentThread() != currentThread) {\n    runReason = RunReason.DECODE_DATA;\n    callback.reschedule(this);\n  } else {\n    .....\n  }\n}\n```\n\n更改任务状态，重新执行此任务，则重新执行到`getNextGenerator`方法，此时则会返回**DataCacheGenerator**来处理从Disk缓存加载的任务。\n\n## 获取图片\n\n首先，图片来源有哪些？\n\n1. 资源图片：drawable, assets, raw, mipmap这些程序中自带的图片；\n2. 本地图片：本地存储设备上的图片；\n3. 远端图片：我们服务器或者来自第三方服务器的图片，通过URL来获取。这就需要**异步网络请求**，请求结束以后，要**缓存**图片，避免重复请求远端图片，造成时间、网络的浪费。\n\n```mermaid\ngraph LR;\nA[Slide];\nB([1. 资源图片]) --> A;\nC([2. 本地图片]) --> A;\nE{缓存是否存在} --> |是,交给Slide|A;\nE --> |否,网络请求|D([3. 远端图片]);\nD -.-> |获取到图片并缓存|E;\n\n```\n\n\n\n那么接下来，要丰富的细节，就来到了**网络请求**和**缓存**了。\n\n\n\n### 网络请求\n\n\n\n### 缓存\n\n","slug":"2022-09-17-Glide源码分析与自我实现1","published":1,"date":"2020-12-16T04:05:52.000Z","updated":"2023-02-05T04:14:57.295Z","_id":"cldqukh7r0001pcjggk4gcmu5","comments":1,"photos":[],"link":"","content":"<blockquote>\n<p>本文基于Glide 4.11.0</p>\n</blockquote>\n<p>阅读前请参考<a href=\"https://zhuanlan.zhihu.com/p/60425157\">Glide 源码分析解读-基于最新版Glide 4.9.0</a>一文，该文章中，将Glide中各个部分的作用分析的非常好了。</p>\n<p>Glide几乎是现在做Android图片加载的最佳选择了。如此优秀的一个框架是如何实现的呢？如果让我们自己来实现该怎么做呢？我们就通过自己实现一个低配版Glide的方式，来探究Glide中是如何实现的。</p>\n<p>我们就称我们自己低配版Glide为<strong>Slide</strong>。那么Slide要实现哪些功能呢？简单来说，就是<strong>获取图片</strong>+<strong>界面显示</strong>。我们通过先构架大体框架，再分步丰富其中细节的方式，来构建Slide的整体结构。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flowchart LR;</span><br><span class=\"line\">A[获取图片] --&gt; C[Slide] --&gt; B[界面显示];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Glide.with(xxx).load(url).into(iv);</span><br></pre></td></tr></table></figure>\n\n<p>这是Glide一个典型的最为简单的调用过程。那么在这个过程中发生了哪些事情呢？</p>\n<p>我们可以通过这个链式调用的返回值发现，有如下过程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">style A fill:#aaffcc</span><br><span class=\"line\">style D fill:#ffaa99</span><br><span class=\"line\">A(Glide) --&gt;|&quot;with(xxx)&quot;| B(RequestManager) --&gt;|&quot;load(xxx)&quot;| C(RequestBuilder) --&gt;|&quot;into(iv)&quot;| D(Target);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Glide-with-xxx-发生了什么事？\"><a href=\"#Glide-with-xxx-发生了什么事？\" class=\"headerlink\" title=\"Glide.with(xxx)发生了什么事？\"></a>Glide.with(xxx)发生了什么事？</h2><p>阅读源码发现，<code>Glide.with(xxx)</code>的最终实现类是<em>RequestManagerRetriever.java</em>类。继续跟踪，我们在这个类中，看到这样一个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RequestManager <span class=\"title function_\">supportFragmentGet</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> Context context,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> FragmentManager fm,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@Nullable</span> Fragment parentHint,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">boolean</span> isParentVisible)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">SupportRequestManagerFragment</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> getSupportRequestManagerFragment(fm, parentHint);</span><br><span class=\"line\">  <span class=\"type\">RequestManager</span> <span class=\"variable\">requestManager</span> <span class=\"operator\">=</span> current.getRequestManager();</span><br><span class=\"line\"></span><br><span class=\"line\">  .....</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> requestManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重点关注这个getSupportRequestManagerFragment方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//getSupportRequestManagerFragment</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> SupportRequestManagerFragment <span class=\"title function_\">getSupportRequestManagerFragment</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> FragmentManager fm, <span class=\"meta\">@Nullable</span> Fragment parentHint)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">SupportRequestManagerFragment</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span></span><br><span class=\"line\">    (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (current == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      current = <span class=\"keyword\">new</span> <span class=\"title class_\">SupportRequestManagerFragment</span>();</span><br><span class=\"line\">      current.setParentFragmentHint(parentHint);</span><br><span class=\"line\">      pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class=\"line\">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class=\"line\">      handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实，这里是一个Glide检测到界面生命周期的关键了。<strong>Glide就是通过像当前Activity添加一个一个无UI的Fragment来探测生命周期的</strong>。</p>\n<blockquote>\n<p><strong>注意：</strong>在执行了添加fragment的语句<code>fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss()</code>后，又马上通过handler发送了一个一个message，这里需要熟悉Handler机制才能理解，简单来说，就是添加fragment操作，实际上也是通过handler执行的，这是一个异步的过程，如何检测到fragment已经添加完成了呢？就是在<code>commitAllowingStateLoss</code>后，马上去发送一条指定的消息，利用handler处理message的顺序性，来获知fragment已经添加完成。</p>\n</blockquote>\n<p>经过添加<em>SupportRequestManagerFragment</em>后，我们获得了探测当前界面生命周期的能力。</p>\n<p>继续阅读<code>supportFragmentGet</code>方法代码，<strong>RequestManager</strong>是从<strong>SupportRequestManagerFragment</strong>拿到的，如果拿到的是空，则创建一个，设置到该fragment当中去。</p>\n<h2 id=\"RequestManager-load-xxx-发生了什么？\"><a href=\"#RequestManager-load-xxx-发生了什么？\" class=\"headerlink\" title=\"RequestManager.load(xxx)发生了什么？\"></a>RequestManager.load(xxx)发生了什么？</h2><p>我们以<code>load(url)</code>为例，来探究这部分代码。</p>\n<p>这个方法，返回的是<em>RequestBuilder</em>这个类，看名字就知道，这是一个构建者模式中的Builder类，主要是在添加各种配置项，比如RequestOptions、RequestListener等。</p>\n<h2 id=\"RequestBuilder-into-iv-发生了什么？\"><a href=\"#RequestBuilder-into-iv-发生了什么？\" class=\"headerlink\" title=\"RequestBuilder.into(iv)发生了什么？\"></a>RequestBuilder.into(iv)发生了什么？</h2><p>其实，这里才是真正开始触发发起请求的地方。</p>\n<h3 id=\"RequestBuilder\"><a href=\"#RequestBuilder\" class=\"headerlink\" title=\"RequestBuilder\"></a>RequestBuilder</h3><p>我们把<code>into(ImageView)</code>方法作为入口，一路跟踪，可以发现最终的实现是如下方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;Y <span class=\"keyword\">extends</span> <span class=\"title class_\">Target</span>&lt;TranscodeType&gt;&gt; Y <span class=\"title function_\">into</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> Y target,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span><br><span class=\"line\"><span class=\"params\">  BaseRequestOptions&lt;?&gt; options,</span></span><br><span class=\"line\"><span class=\"params\">  Executor callbackExecutor)</span> &#123;</span><br><span class=\"line\">  Preconditions.checkNotNull(target);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isModelSet) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">Request</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">Request</span> <span class=\"variable\">previous</span> <span class=\"operator\">=</span> target.getRequest();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.isEquivalentTo(previous)</span><br><span class=\"line\">      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class=\"line\">    <span class=\"comment\">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class=\"line\">    <span class=\"comment\">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class=\"line\">    <span class=\"comment\">// running, we can let it continue running without interruption.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class=\"line\">      <span class=\"comment\">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class=\"line\">      <span class=\"comment\">// that are done in the individual Request.</span></span><br><span class=\"line\">      previous.begin();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  requestManager.clear(target);</span><br><span class=\"line\">  target.setRequest(request);</span><br><span class=\"line\">  requestManager.track(target, request);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法主要是做了以下事情：</p>\n<ol>\n<li>是否已经有一个request在处理相同的请求，如果有，则判断是否正在运行，没有正在运行则开始运行；</li>\n<li>如果没有一个request在处理此请求，则对target做一些清理操作，与之前的请求解绑，为当前target设置新的请求，然后requestManager开始追踪这个请求。</li>\n</ol>\n<p>接下来我们就按照<code>requestManager.track(target, request)</code>这段代码继续追踪。来到RequestManager的track方法。</p>\n<h3 id=\"RequestManager\"><a href=\"#RequestManager\" class=\"headerlink\" title=\"RequestManager\"></a>RequestManager</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">track</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Target&lt;?&gt; target, <span class=\"meta\">@NonNull</span> Request request)</span> &#123;</span><br><span class=\"line\">  targetTracker.track(target);</span><br><span class=\"line\">  requestTracker.runRequest(request);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法很简单，只有两个方法。</p>\n<h4 id=\"TargetTracker\"><a href=\"#TargetTracker\" class=\"headerlink\" title=\"TargetTracker\"></a>TargetTracker</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;Target&lt;?&gt;&gt; targets =</span><br><span class=\"line\">      Collections.newSetFromMap(<span class=\"keyword\">new</span> <span class=\"title class_\">WeakHashMap</span>&lt;Target&lt;?&gt;, Boolean&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">track</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Target&lt;?&gt; target)</span> &#123;</span><br><span class=\"line\">  targets.add(target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里把一个target存放在WeakHashMap中，因为target是与生命周期有关的东西，比如ImageView对应的<strong>ImageViewTarget</strong>，所以这么做是为了防止内存泄漏。</p>\n<h4 id=\"RequestTracker\"><a href=\"#RequestTracker\" class=\"headerlink\" title=\"RequestTracker\"></a>RequestTracker</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Starts tracking the given request. */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">runRequest</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Request request)</span> &#123;</span><br><span class=\"line\">  requests.add(request);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isPaused) &#123;</span><br><span class=\"line\">    request.begin();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    request.clear();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">      Log.v(TAG, <span class=\"string\">&quot;Paused, delaying request&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pendingRequests.add(request);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是将暂停的request加入到pendingRequests中去，如果不是暂停的request，则调用其begin方法。</p>\n<p>我们查看<em>Request</em>类的子类，可以看到下图。</p>\n<p><img src=\"/images/request_implementions.jpg\" alt=\"request_implementions\"></p>\n<p>可以看到一共有4个类实现了<em>Request</em>类，其中<em>FakeRequest</em>类是用于测试的，不去考虑。其他三个类的作用如下：</p>\n<ol>\n<li><strong>ThumbnailRequestCoordinator:</strong> 用来加载thumbnail；</li>\n<li><strong>ErrorRequestCoordinator:</strong> 用来加载错误时候，展示错误状态； </li>\n<li><strong>SingleRequest:</strong> 这才是用来加载目标图片的request。</li>\n</ol>\n<p>我们重点去看SingleRequest的begin方法。</p>\n<h3 id=\"SingleRequest\"><a href=\"#SingleRequest\" class=\"headerlink\" title=\"SingleRequest\"></a>SingleRequest</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">begin</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (requestLock) &#123;</span><br><span class=\"line\">    assertNotCallingCallbacks();</span><br><span class=\"line\">    stateVerifier.throwIfRecycled();</span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (model == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class=\"line\">        width = overrideWidth;</span><br><span class=\"line\">        height = overrideHeight;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// Only log at more verbose log levels if the user has set a fallback drawable, because</span></span><br><span class=\"line\">      <span class=\"comment\">// fallback Drawables indicate the user expects null models occasionally.</span></span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">logLevel</span> <span class=\"operator\">=</span> getFallbackDrawable() == <span class=\"literal\">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class=\"line\">      onLoadFailed(<span class=\"keyword\">new</span> <span class=\"title class_\">GlideException</span>(<span class=\"string\">&quot;Received null model&quot;</span>), logLevel);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == Status.RUNNING) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Cannot restart a running request&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we&#x27;re restarted after we&#x27;re complete (usually via something like a notifyDataSetChanged</span></span><br><span class=\"line\">    <span class=\"comment\">// that starts an identical request into the same Target or View), we can simply use the</span></span><br><span class=\"line\">    <span class=\"comment\">// resource and size we retrieved the last time around and skip obtaining a new size, starting</span></span><br><span class=\"line\">    <span class=\"comment\">// a new load etc. This does mean that users who want to restart a load because they expect</span></span><br><span class=\"line\">    <span class=\"comment\">// that the view size has changed will need to explicitly clear the View or Target before</span></span><br><span class=\"line\">    <span class=\"comment\">// starting the new load.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == Status.COMPLETE) &#123;</span><br><span class=\"line\">      onResourceReady(</span><br><span class=\"line\">        resource, DataSource.MEMORY_CACHE, <span class=\"comment\">/* isLoadedFromAlternateCacheKey= */</span> <span class=\"literal\">false</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Restarts for requests that are neither complete nor running can be treated as new requests</span></span><br><span class=\"line\">    <span class=\"comment\">// and can run again from the beginning.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    status = Status.WAITING_FOR_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class=\"line\">      onSizeReady(overrideWidth, overrideHeight);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      target.getSize(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class=\"line\">        &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class=\"line\">      target.onLoadStarted(getPlaceholderDrawable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class=\"line\">      logV(<span class=\"string\">&quot;finished run method in &quot;</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码虽长，但是结构简单。主要做了以下事情：</p>\n<ol>\n<li>检查model是否是空，model就是要加载的数据来源，比如url、resourceId、File等；</li>\n<li>判断request状态，不能重新开始一个正在运行的请求；</li>\n<li>判断request状态，如果是已经完成的请求，则说明资源已经存在，直接调用<code>onResourceReady</code>方法并返回；</li>\n<li>接下来就来到判断target尺寸的过程了，如果target尺寸已经确定，比如view尺寸measure结束后，则调用<code>onSizeReady</code>方法，<strong>注意：实际的网络请求就在这个onSizeReady方法中，因为只有target的尺寸确定了，才能进行请求并处理图片；</strong></li>\n<li>如果尺寸未确定，则调用<code>target.getSize</code>方法去监听尺寸事件，具体可以参考<code>ViewTarget#getSize</code>方法，这是一个通过onPreDrawListener来监听尺寸的；</li>\n<li>接下来回调<code>onLoadStarted</code>方法，并且显示加载过程状态。</li>\n</ol>\n<p>我们着重看网络请求那个分支，也就是<code>onSizeReady</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSizeReady</span><span class=\"params\">(<span class=\"type\">int</span> width, <span class=\"type\">int</span> height)</span> &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">\tloadStatus = engine.load(</span><br><span class=\"line\">    glideContext,</span><br><span class=\"line\">    model,</span><br><span class=\"line\">    requestOptions.getSignature(),</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.width,</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.height,</span><br><span class=\"line\">    requestOptions.getResourceClass(),</span><br><span class=\"line\">    transcodeClass,</span><br><span class=\"line\">    priority,</span><br><span class=\"line\">    requestOptions.getDiskCacheStrategy(),</span><br><span class=\"line\">    requestOptions.getTransformations(),</span><br><span class=\"line\">    requestOptions.isTransformationRequired(),</span><br><span class=\"line\">    requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class=\"line\">    requestOptions.getOptions(),</span><br><span class=\"line\">    requestOptions.isMemoryCacheable(),</span><br><span class=\"line\">    requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class=\"line\">    requestOptions.getUseAnimationPool(),</span><br><span class=\"line\">    requestOptions.getOnlyRetrieveFromCache(),</span><br><span class=\"line\">    <span class=\"built_in\">this</span>,</span><br><span class=\"line\">    callbackExecutor</span><br><span class=\"line\">  );</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码来了！这个<code>engine</code>就是Glide的核心。这个engine是在Glide初始化时候生成的一个实例。</p>\n<h3 id=\"Engine\"><a href=\"#Engine\" class=\"headerlink\" title=\"Engine\"></a>Engine</h3><p>Engine不只是用于加载图片，而是一个任务执行核心引擎，它要执行的不只是请求远程图片的任务，包括解码任务等，它执行的实际上是一个个的job。</p>\n<p>跟踪上一阶段中的<code>engine.load</code>方法，来到是这个方法的关键部分——调用<code>waitForExistingOrStartNewJob</code>。</p>\n<p>在这个方法中，主要做了以下事情：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">A&#123;&#123;是否有一个job执行相同操作&#125;&#125; --&gt; |有|B[为此job添加新的回调];</span><br><span class=\"line\">A --&gt; |无|C[添加并执行一个EngineJob];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"EngineJob-start-decodeJob\"><a href=\"#EngineJob-start-decodeJob\" class=\"headerlink\" title=\"EngineJob.start(decodeJob)\"></a>EngineJob.start(decodeJob)</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">(DecodeJob&lt;R&gt; decodeJob)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.decodeJob = decodeJob;</span><br><span class=\"line\">  <span class=\"type\">GlideExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span></span><br><span class=\"line\">    decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class=\"line\">  executor.execute(decodeJob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里执行的是decodeJob。</p>\n<blockquote>\n<p>这里需要着重关注一点，就是<code>executor.execute(decodeJob)</code>的时候，就已经通过<em>GlideExecutor</em>的sourceExecutor.Builder创建了一个<strong>ThreadPoolExecutor</strong>，也就是在这里实现线程池异步执行任务。<strong>ThreadPoolExecutor</strong>并不是Glide提供的实现，而是在java.util.concurrent包下。</p>\n</blockquote>\n<h4 id=\"DecodeJob\"><a href=\"#DecodeJob\" class=\"headerlink\" title=\"DecodeJob\"></a>DecodeJob</h4><p>DecodeJob是一个<em>Runnable</em>类，所以，我们查看其run方法。</p>\n<p>接下来的调用路径参考下图。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">subgraph DecodeJob;</span><br><span class=\"line\">A(run) --&gt; B[runWrapped] --&gt; C[runGenerators] --&gt; D[getNextGenerator];</span><br><span class=\"line\">end;</span><br><span class=\"line\">subgraph SourceGenerator</span><br><span class=\"line\">D --&gt; E[startNext] --&gt; F[startNextLoad];</span><br><span class=\"line\">end;</span><br><span class=\"line\">subgraph HttpUrlFetcher</span><br><span class=\"line\">F --&gt; G[loadData] --&gt; H[loadDataWithRedirects];</span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure>\n\n<p>经过这么长的调用链，我们终于来到了网络请求的部分，我们可以看到Glide原生使用的<em>HttpURLConnection</em>进行网络请求的。<strong>获取到InputStream后，在SourceGenerator中的cacheData方法进行缓存处理。</strong></p>\n<h4 id=\"获取到数据后的处理\"><a href=\"#获取到数据后的处理\" class=\"headerlink\" title=\"获取到数据后的处理\"></a>获取到数据后的处理</h4><p>通过<code>DataFetcherGenerator.FetcherReadyCallback</code>可以探知到数据获取成功或者失败，如果获取成功，则在<code>DecodeJob#onDataFetcherReady</code>中处理。关键代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onDataFetcherReady</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">      Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey)</span> &#123;</span><br><span class=\"line\">  .....</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class=\"line\">    runReason = RunReason.DECODE_DATA;</span><br><span class=\"line\">    callback.reschedule(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更改任务状态，重新执行此任务，则重新执行到<code>getNextGenerator</code>方法，此时则会返回<strong>DataCacheGenerator</strong>来处理从Disk缓存加载的任务。</p>\n<h2 id=\"获取图片\"><a href=\"#获取图片\" class=\"headerlink\" title=\"获取图片\"></a>获取图片</h2><p>首先，图片来源有哪些？</p>\n<ol>\n<li>资源图片：drawable, assets, raw, mipmap这些程序中自带的图片；</li>\n<li>本地图片：本地存储设备上的图片；</li>\n<li>远端图片：我们服务器或者来自第三方服务器的图片，通过URL来获取。这就需要<strong>异步网络请求</strong>，请求结束以后，要<strong>缓存</strong>图片，避免重复请求远端图片，造成时间、网络的浪费。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">A[Slide];</span><br><span class=\"line\">B([1. 资源图片]) --&gt; A;</span><br><span class=\"line\">C([2. 本地图片]) --&gt; A;</span><br><span class=\"line\">E&#123;缓存是否存在&#125; --&gt; |是,交给Slide|A;</span><br><span class=\"line\">E --&gt; |否,网络请求|D([3. 远端图片]);</span><br><span class=\"line\">D -.-&gt; |获取到图片并缓存|E;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>那么接下来，要丰富的细节，就来到了<strong>网络请求</strong>和<strong>缓存</strong>了。</p>\n<h3 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h3><h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文基于Glide 4.11.0</p>\n</blockquote>\n<p>阅读前请参考<a href=\"https://zhuanlan.zhihu.com/p/60425157\">Glide 源码分析解读-基于最新版Glide 4.9.0</a>一文，该文章中，将Glide中各个部分的作用分析的非常好了。</p>\n<p>Glide几乎是现在做Android图片加载的最佳选择了。如此优秀的一个框架是如何实现的呢？如果让我们自己来实现该怎么做呢？我们就通过自己实现一个低配版Glide的方式，来探究Glide中是如何实现的。</p>\n<p>我们就称我们自己低配版Glide为<strong>Slide</strong>。那么Slide要实现哪些功能呢？简单来说，就是<strong>获取图片</strong>+<strong>界面显示</strong>。我们通过先构架大体框架，再分步丰富其中细节的方式，来构建Slide的整体结构。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flowchart LR;</span><br><span class=\"line\">A[获取图片] --&gt; C[Slide] --&gt; B[界面显示];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Glide.with(xxx).load(url).into(iv);</span><br></pre></td></tr></table></figure>\n\n<p>这是Glide一个典型的最为简单的调用过程。那么在这个过程中发生了哪些事情呢？</p>\n<p>我们可以通过这个链式调用的返回值发现，有如下过程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">style A fill:#aaffcc</span><br><span class=\"line\">style D fill:#ffaa99</span><br><span class=\"line\">A(Glide) --&gt;|&quot;with(xxx)&quot;| B(RequestManager) --&gt;|&quot;load(xxx)&quot;| C(RequestBuilder) --&gt;|&quot;into(iv)&quot;| D(Target);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Glide-with-xxx-发生了什么事？\"><a href=\"#Glide-with-xxx-发生了什么事？\" class=\"headerlink\" title=\"Glide.with(xxx)发生了什么事？\"></a>Glide.with(xxx)发生了什么事？</h2><p>阅读源码发现，<code>Glide.with(xxx)</code>的最终实现类是<em>RequestManagerRetriever.java</em>类。继续跟踪，我们在这个类中，看到这样一个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RequestManager <span class=\"title function_\">supportFragmentGet</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> Context context,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> FragmentManager fm,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@Nullable</span> Fragment parentHint,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"type\">boolean</span> isParentVisible)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">SupportRequestManagerFragment</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> getSupportRequestManagerFragment(fm, parentHint);</span><br><span class=\"line\">  <span class=\"type\">RequestManager</span> <span class=\"variable\">requestManager</span> <span class=\"operator\">=</span> current.getRequestManager();</span><br><span class=\"line\"></span><br><span class=\"line\">  .....</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> requestManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重点关注这个getSupportRequestManagerFragment方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//getSupportRequestManagerFragment</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> SupportRequestManagerFragment <span class=\"title function_\">getSupportRequestManagerFragment</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> FragmentManager fm, <span class=\"meta\">@Nullable</span> Fragment parentHint)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">SupportRequestManagerFragment</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span></span><br><span class=\"line\">    (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (current == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      current = <span class=\"keyword\">new</span> <span class=\"title class_\">SupportRequestManagerFragment</span>();</span><br><span class=\"line\">      current.setParentFragmentHint(parentHint);</span><br><span class=\"line\">      pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class=\"line\">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class=\"line\">      handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实，这里是一个Glide检测到界面生命周期的关键了。<strong>Glide就是通过像当前Activity添加一个一个无UI的Fragment来探测生命周期的</strong>。</p>\n<blockquote>\n<p><strong>注意：</strong>在执行了添加fragment的语句<code>fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss()</code>后，又马上通过handler发送了一个一个message，这里需要熟悉Handler机制才能理解，简单来说，就是添加fragment操作，实际上也是通过handler执行的，这是一个异步的过程，如何检测到fragment已经添加完成了呢？就是在<code>commitAllowingStateLoss</code>后，马上去发送一条指定的消息，利用handler处理message的顺序性，来获知fragment已经添加完成。</p>\n</blockquote>\n<p>经过添加<em>SupportRequestManagerFragment</em>后，我们获得了探测当前界面生命周期的能力。</p>\n<p>继续阅读<code>supportFragmentGet</code>方法代码，<strong>RequestManager</strong>是从<strong>SupportRequestManagerFragment</strong>拿到的，如果拿到的是空，则创建一个，设置到该fragment当中去。</p>\n<h2 id=\"RequestManager-load-xxx-发生了什么？\"><a href=\"#RequestManager-load-xxx-发生了什么？\" class=\"headerlink\" title=\"RequestManager.load(xxx)发生了什么？\"></a>RequestManager.load(xxx)发生了什么？</h2><p>我们以<code>load(url)</code>为例，来探究这部分代码。</p>\n<p>这个方法，返回的是<em>RequestBuilder</em>这个类，看名字就知道，这是一个构建者模式中的Builder类，主要是在添加各种配置项，比如RequestOptions、RequestListener等。</p>\n<h2 id=\"RequestBuilder-into-iv-发生了什么？\"><a href=\"#RequestBuilder-into-iv-发生了什么？\" class=\"headerlink\" title=\"RequestBuilder.into(iv)发生了什么？\"></a>RequestBuilder.into(iv)发生了什么？</h2><p>其实，这里才是真正开始触发发起请求的地方。</p>\n<h3 id=\"RequestBuilder\"><a href=\"#RequestBuilder\" class=\"headerlink\" title=\"RequestBuilder\"></a>RequestBuilder</h3><p>我们把<code>into(ImageView)</code>方法作为入口，一路跟踪，可以发现最终的实现是如下方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;Y <span class=\"keyword\">extends</span> <span class=\"title class_\">Target</span>&lt;TranscodeType&gt;&gt; Y <span class=\"title function_\">into</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> Y target,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span><br><span class=\"line\"><span class=\"params\">  BaseRequestOptions&lt;?&gt; options,</span></span><br><span class=\"line\"><span class=\"params\">  Executor callbackExecutor)</span> &#123;</span><br><span class=\"line\">  Preconditions.checkNotNull(target);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isModelSet) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">Request</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">Request</span> <span class=\"variable\">previous</span> <span class=\"operator\">=</span> target.getRequest();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.isEquivalentTo(previous)</span><br><span class=\"line\">      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class=\"line\">    <span class=\"comment\">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class=\"line\">    <span class=\"comment\">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class=\"line\">    <span class=\"comment\">// running, we can let it continue running without interruption.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class=\"line\">      <span class=\"comment\">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class=\"line\">      <span class=\"comment\">// that are done in the individual Request.</span></span><br><span class=\"line\">      previous.begin();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  requestManager.clear(target);</span><br><span class=\"line\">  target.setRequest(request);</span><br><span class=\"line\">  requestManager.track(target, request);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法主要是做了以下事情：</p>\n<ol>\n<li>是否已经有一个request在处理相同的请求，如果有，则判断是否正在运行，没有正在运行则开始运行；</li>\n<li>如果没有一个request在处理此请求，则对target做一些清理操作，与之前的请求解绑，为当前target设置新的请求，然后requestManager开始追踪这个请求。</li>\n</ol>\n<p>接下来我们就按照<code>requestManager.track(target, request)</code>这段代码继续追踪。来到RequestManager的track方法。</p>\n<h3 id=\"RequestManager\"><a href=\"#RequestManager\" class=\"headerlink\" title=\"RequestManager\"></a>RequestManager</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">track</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Target&lt;?&gt; target, <span class=\"meta\">@NonNull</span> Request request)</span> &#123;</span><br><span class=\"line\">  targetTracker.track(target);</span><br><span class=\"line\">  requestTracker.runRequest(request);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法很简单，只有两个方法。</p>\n<h4 id=\"TargetTracker\"><a href=\"#TargetTracker\" class=\"headerlink\" title=\"TargetTracker\"></a>TargetTracker</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;Target&lt;?&gt;&gt; targets =</span><br><span class=\"line\">      Collections.newSetFromMap(<span class=\"keyword\">new</span> <span class=\"title class_\">WeakHashMap</span>&lt;Target&lt;?&gt;, Boolean&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">track</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Target&lt;?&gt; target)</span> &#123;</span><br><span class=\"line\">  targets.add(target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里把一个target存放在WeakHashMap中，因为target是与生命周期有关的东西，比如ImageView对应的<strong>ImageViewTarget</strong>，所以这么做是为了防止内存泄漏。</p>\n<h4 id=\"RequestTracker\"><a href=\"#RequestTracker\" class=\"headerlink\" title=\"RequestTracker\"></a>RequestTracker</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Starts tracking the given request. */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">runRequest</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Request request)</span> &#123;</span><br><span class=\"line\">  requests.add(request);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isPaused) &#123;</span><br><span class=\"line\">    request.begin();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    request.clear();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">      Log.v(TAG, <span class=\"string\">&quot;Paused, delaying request&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pendingRequests.add(request);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是将暂停的request加入到pendingRequests中去，如果不是暂停的request，则调用其begin方法。</p>\n<p>我们查看<em>Request</em>类的子类，可以看到下图。</p>\n<p><img src=\"/images/request_implementions.jpg\" alt=\"request_implementions\"></p>\n<p>可以看到一共有4个类实现了<em>Request</em>类，其中<em>FakeRequest</em>类是用于测试的，不去考虑。其他三个类的作用如下：</p>\n<ol>\n<li><strong>ThumbnailRequestCoordinator:</strong> 用来加载thumbnail；</li>\n<li><strong>ErrorRequestCoordinator:</strong> 用来加载错误时候，展示错误状态； </li>\n<li><strong>SingleRequest:</strong> 这才是用来加载目标图片的request。</li>\n</ol>\n<p>我们重点去看SingleRequest的begin方法。</p>\n<h3 id=\"SingleRequest\"><a href=\"#SingleRequest\" class=\"headerlink\" title=\"SingleRequest\"></a>SingleRequest</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">begin</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (requestLock) &#123;</span><br><span class=\"line\">    assertNotCallingCallbacks();</span><br><span class=\"line\">    stateVerifier.throwIfRecycled();</span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (model == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class=\"line\">        width = overrideWidth;</span><br><span class=\"line\">        height = overrideHeight;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// Only log at more verbose log levels if the user has set a fallback drawable, because</span></span><br><span class=\"line\">      <span class=\"comment\">// fallback Drawables indicate the user expects null models occasionally.</span></span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">logLevel</span> <span class=\"operator\">=</span> getFallbackDrawable() == <span class=\"literal\">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class=\"line\">      onLoadFailed(<span class=\"keyword\">new</span> <span class=\"title class_\">GlideException</span>(<span class=\"string\">&quot;Received null model&quot;</span>), logLevel);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == Status.RUNNING) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Cannot restart a running request&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we&#x27;re restarted after we&#x27;re complete (usually via something like a notifyDataSetChanged</span></span><br><span class=\"line\">    <span class=\"comment\">// that starts an identical request into the same Target or View), we can simply use the</span></span><br><span class=\"line\">    <span class=\"comment\">// resource and size we retrieved the last time around and skip obtaining a new size, starting</span></span><br><span class=\"line\">    <span class=\"comment\">// a new load etc. This does mean that users who want to restart a load because they expect</span></span><br><span class=\"line\">    <span class=\"comment\">// that the view size has changed will need to explicitly clear the View or Target before</span></span><br><span class=\"line\">    <span class=\"comment\">// starting the new load.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == Status.COMPLETE) &#123;</span><br><span class=\"line\">      onResourceReady(</span><br><span class=\"line\">        resource, DataSource.MEMORY_CACHE, <span class=\"comment\">/* isLoadedFromAlternateCacheKey= */</span> <span class=\"literal\">false</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Restarts for requests that are neither complete nor running can be treated as new requests</span></span><br><span class=\"line\">    <span class=\"comment\">// and can run again from the beginning.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    status = Status.WAITING_FOR_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class=\"line\">      onSizeReady(overrideWidth, overrideHeight);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      target.getSize(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class=\"line\">        &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class=\"line\">      target.onLoadStarted(getPlaceholderDrawable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class=\"line\">      logV(<span class=\"string\">&quot;finished run method in &quot;</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码虽长，但是结构简单。主要做了以下事情：</p>\n<ol>\n<li>检查model是否是空，model就是要加载的数据来源，比如url、resourceId、File等；</li>\n<li>判断request状态，不能重新开始一个正在运行的请求；</li>\n<li>判断request状态，如果是已经完成的请求，则说明资源已经存在，直接调用<code>onResourceReady</code>方法并返回；</li>\n<li>接下来就来到判断target尺寸的过程了，如果target尺寸已经确定，比如view尺寸measure结束后，则调用<code>onSizeReady</code>方法，<strong>注意：实际的网络请求就在这个onSizeReady方法中，因为只有target的尺寸确定了，才能进行请求并处理图片；</strong></li>\n<li>如果尺寸未确定，则调用<code>target.getSize</code>方法去监听尺寸事件，具体可以参考<code>ViewTarget#getSize</code>方法，这是一个通过onPreDrawListener来监听尺寸的；</li>\n<li>接下来回调<code>onLoadStarted</code>方法，并且显示加载过程状态。</li>\n</ol>\n<p>我们着重看网络请求那个分支，也就是<code>onSizeReady</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSizeReady</span><span class=\"params\">(<span class=\"type\">int</span> width, <span class=\"type\">int</span> height)</span> &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">\tloadStatus = engine.load(</span><br><span class=\"line\">    glideContext,</span><br><span class=\"line\">    model,</span><br><span class=\"line\">    requestOptions.getSignature(),</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.width,</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.height,</span><br><span class=\"line\">    requestOptions.getResourceClass(),</span><br><span class=\"line\">    transcodeClass,</span><br><span class=\"line\">    priority,</span><br><span class=\"line\">    requestOptions.getDiskCacheStrategy(),</span><br><span class=\"line\">    requestOptions.getTransformations(),</span><br><span class=\"line\">    requestOptions.isTransformationRequired(),</span><br><span class=\"line\">    requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class=\"line\">    requestOptions.getOptions(),</span><br><span class=\"line\">    requestOptions.isMemoryCacheable(),</span><br><span class=\"line\">    requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class=\"line\">    requestOptions.getUseAnimationPool(),</span><br><span class=\"line\">    requestOptions.getOnlyRetrieveFromCache(),</span><br><span class=\"line\">    <span class=\"built_in\">this</span>,</span><br><span class=\"line\">    callbackExecutor</span><br><span class=\"line\">  );</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码来了！这个<code>engine</code>就是Glide的核心。这个engine是在Glide初始化时候生成的一个实例。</p>\n<h3 id=\"Engine\"><a href=\"#Engine\" class=\"headerlink\" title=\"Engine\"></a>Engine</h3><p>Engine不只是用于加载图片，而是一个任务执行核心引擎，它要执行的不只是请求远程图片的任务，包括解码任务等，它执行的实际上是一个个的job。</p>\n<p>跟踪上一阶段中的<code>engine.load</code>方法，来到是这个方法的关键部分——调用<code>waitForExistingOrStartNewJob</code>。</p>\n<p>在这个方法中，主要做了以下事情：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">A&#123;&#123;是否有一个job执行相同操作&#125;&#125; --&gt; |有|B[为此job添加新的回调];</span><br><span class=\"line\">A --&gt; |无|C[添加并执行一个EngineJob];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"EngineJob-start-decodeJob\"><a href=\"#EngineJob-start-decodeJob\" class=\"headerlink\" title=\"EngineJob.start(decodeJob)\"></a>EngineJob.start(decodeJob)</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">(DecodeJob&lt;R&gt; decodeJob)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.decodeJob = decodeJob;</span><br><span class=\"line\">  <span class=\"type\">GlideExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span></span><br><span class=\"line\">    decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class=\"line\">  executor.execute(decodeJob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里执行的是decodeJob。</p>\n<blockquote>\n<p>这里需要着重关注一点，就是<code>executor.execute(decodeJob)</code>的时候，就已经通过<em>GlideExecutor</em>的sourceExecutor.Builder创建了一个<strong>ThreadPoolExecutor</strong>，也就是在这里实现线程池异步执行任务。<strong>ThreadPoolExecutor</strong>并不是Glide提供的实现，而是在java.util.concurrent包下。</p>\n</blockquote>\n<h4 id=\"DecodeJob\"><a href=\"#DecodeJob\" class=\"headerlink\" title=\"DecodeJob\"></a>DecodeJob</h4><p>DecodeJob是一个<em>Runnable</em>类，所以，我们查看其run方法。</p>\n<p>接下来的调用路径参考下图。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">subgraph DecodeJob;</span><br><span class=\"line\">A(run) --&gt; B[runWrapped] --&gt; C[runGenerators] --&gt; D[getNextGenerator];</span><br><span class=\"line\">end;</span><br><span class=\"line\">subgraph SourceGenerator</span><br><span class=\"line\">D --&gt; E[startNext] --&gt; F[startNextLoad];</span><br><span class=\"line\">end;</span><br><span class=\"line\">subgraph HttpUrlFetcher</span><br><span class=\"line\">F --&gt; G[loadData] --&gt; H[loadDataWithRedirects];</span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure>\n\n<p>经过这么长的调用链，我们终于来到了网络请求的部分，我们可以看到Glide原生使用的<em>HttpURLConnection</em>进行网络请求的。<strong>获取到InputStream后，在SourceGenerator中的cacheData方法进行缓存处理。</strong></p>\n<h4 id=\"获取到数据后的处理\"><a href=\"#获取到数据后的处理\" class=\"headerlink\" title=\"获取到数据后的处理\"></a>获取到数据后的处理</h4><p>通过<code>DataFetcherGenerator.FetcherReadyCallback</code>可以探知到数据获取成功或者失败，如果获取成功，则在<code>DecodeJob#onDataFetcherReady</code>中处理。关键代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onDataFetcherReady</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">      Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey)</span> &#123;</span><br><span class=\"line\">  .....</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class=\"line\">    runReason = RunReason.DECODE_DATA;</span><br><span class=\"line\">    callback.reschedule(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更改任务状态，重新执行此任务，则重新执行到<code>getNextGenerator</code>方法，此时则会返回<strong>DataCacheGenerator</strong>来处理从Disk缓存加载的任务。</p>\n<h2 id=\"获取图片\"><a href=\"#获取图片\" class=\"headerlink\" title=\"获取图片\"></a>获取图片</h2><p>首先，图片来源有哪些？</p>\n<ol>\n<li>资源图片：drawable, assets, raw, mipmap这些程序中自带的图片；</li>\n<li>本地图片：本地存储设备上的图片；</li>\n<li>远端图片：我们服务器或者来自第三方服务器的图片，通过URL来获取。这就需要<strong>异步网络请求</strong>，请求结束以后，要<strong>缓存</strong>图片，避免重复请求远端图片，造成时间、网络的浪费。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">A[Slide];</span><br><span class=\"line\">B([1. 资源图片]) --&gt; A;</span><br><span class=\"line\">C([2. 本地图片]) --&gt; A;</span><br><span class=\"line\">E&#123;缓存是否存在&#125; --&gt; |是,交给Slide|A;</span><br><span class=\"line\">E --&gt; |否,网络请求|D([3. 远端图片]);</span><br><span class=\"line\">D -.-&gt; |获取到图片并缓存|E;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>那么接下来，要丰富的细节，就来到了<strong>网络请求</strong>和<strong>缓存</strong>了。</p>\n<h3 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h3><h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3>"},{"layout":"post","title":"Glide源码分析与自我实现(二)——缓存与BitmapPool","author":"boybeak","_content":"\n\n> 本文基于Glide 4.11.0\n\n参考文章：[Glide 源码分析解读-缓存模块-基于最新版Glide 4.9.0](https://zhuanlan.zhihu.com/p/60426316)\n\n**注意：**由于版本差异问题，本文有些部分与参考文章有差异。\n\n缓存模块是Glide中非常重要的部分，Glide图片加载的高效性，几乎有一半功劳都在这里了。\n\n一般来说，Glide有三级缓存，就是**内存缓存**、**磁盘缓存**和**网络缓存**。\n\n先来看缓存流程图，如下：\n\n```mermaid\ngraph TD;\nstyle A fill:#99ccff\nstyle B1 fill:#aaffaa\nA(发起请求) --> B{1. 通过<br>ActiveResources<br>获取资源} --> |命中|B1([加载完成]);\nB --> |未命中|C{2. 通过<br>MemoryCache<br>获取资源} --> |命中|C1[缓存至<br>ActiveResources] --> B1;\nC --> |未命中|D{3. 通过<br>DiskCache<br>获取资源} --> |命中|D1[缓存至<br>MemoryCache] --> C1;\nD --> |未命中|E[\"4. 通过数据源(网络、文件等)<br>加载数据\"] --> E1[缓存至<br>DiskCache] --> D1;\n```\n\n## 内存缓存\n\n内存缓存主要靠三个部分组成：**ActiveResources**、**MemoryCache**和**BitmapPool**。\n\n### ActiveResources\n\nActiveResources表示当前正在活动中的资源。ActiveResources通过一个`Map<Key, ResourceWeakReference>`来保存活动中的资源，其中的ResourceWeakReference就是资源数据，在构建这个ResourceWeakReference的时候必须传入一个ReferenceQueue用来检测资源是否被回收。\n\n> **Q1：如何探知WeakReference中的值被回收了呢？**\n>\n> ```java\n> ReferenceQueue queue = ...;\n> WeakReference wr = new WeakReference(value, queue);\n> ```\n>\n> 当构建WeakReference的时候，如果传入了queue参数，则在value被回收的时候，wr会被加入到queue中去，这样，通过检测queue中是否有值，就可以探知value是否被回收了。\n\n那么，在何时去探知ReferenceQueue中的值呢？我们查看ActiveResources的关键代码：\n\n```java\n/*构造方法中，通过monitorClearedResourcesExecutor执行了cleanReferenceQueue()方法。\n*/\nActiveResources(boolean isActiveResourceRetentionAllowed) {\n  this(\n    isActiveResourceRetentionAllowed,\n    java.util.concurrent.Executors.newSingleThreadExecutor(\n      new ThreadFactory() {\n        @Override\n        public Thread newThread(@NonNull final Runnable r) {\n          return new Thread(\n            new Runnable() {\n              @Override\n              public void run() {\n                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                r.run();\n              }\n            },\n            \"glide-active-resources\");\n        }\n      }));\n}\n\n@VisibleForTesting\nActiveResources(\n  boolean isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) {\n  this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;\n  this.monitorClearedResourcesExecutor = monitorClearedResourcesExecutor;\n\n  monitorClearedResourcesExecutor.execute(\n    new Runnable() {\n      @Override\n      public void run() {\n        cleanReferenceQueue();\n      }\n    });\n}\n\n\nvoid cleanReferenceQueue() {\n  while (!isShutdown) {\n    try {\n      ResourceWeakReference ref = (ResourceWeakReference) resourceReferenceQueue.remove();\n      cleanupActiveReference(ref);\n\n      // This section for testing only.\n      DequeuedResourceCallback current = cb;\n      if (current != null) {\n        current.onResourceDequeued();\n      }\n      // End for testing only.\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n  }\n}\n```\n\n我们通过代码可以看出，`cleanReferenceQueue`是一个靠`isShutdown`变量控制的**死循环**方法，这个方法执行在一个优先级为`THREAD_PRIORITY_BACKGROUND`的线程上。\n\n> **Q2：那么，既然是死循环方法，会不会过多的占用CPU资源呢？**\n>\n> 其实不会的，因为ReferenceQueue#remove是一个阻塞式的方法，如果没有元素可以被remove，则等待至有元素可以remove的时候，等待期间释放CPU。\n\n> **注意：**此处与**参考文章**中的说法不同，这是因为版本差异。查看[Glide update log hsitory](https://github.com/bumptech/glide/commit/8f1ea5c07dff7ade8c49c324bcb5a7f40d0b4891#diff-c46e6c0760c04e74cb867c2bdf9cdee90ab279b119268478524c42cc743cb8a9)，可以看出**出于避免在主线程做清理的原因**，将清理任务放在了后台线程，而不是放在IdleHandler中。\n\n\n\n**那么被回收了的资源去哪里了呢？**\n\n我们查看`cleanupActiveReference`方法，得知，通过*ResourceListener#onResourceReleased*回调，交给了**Engine**来处理，我们查看Engine的onResourceReleased方法。\n\n```java\n@Override\npublic void onResourceReleased(Key cacheKey, EngineResource<?> resource) {\n  activeResources.deactivate(cacheKey);\n  if (resource.isMemoryCacheable()) {\n    cache.put(cacheKey, resource);\n  } else {\n    resourceRecycler.recycle(resource, /*forceNextFrame=*/ false);\n  }\n}\n```\n\n从这里我们发现，这里出现了两种情况：\n\n1. 如果资源是**MemoryCacheable**的，则缓存在MemoryCache；\n2. 如果资源不是**MemoryCacheable**的，则交给ResourceRecycler调用Resource的recycle()方法来回收，如果此Resource为BitmapResource，则会将Bitmap回收到BitmapPool中去。\n\n\n\n在开始MemoryCache和BitmapPool前，需要先了解一下**MemorySizeCalculator**这个类，这个类是用来计算 BitmapPool 、ArrayPool 以及 MemoryCache **大小**的。\n\n### MemoryCache\n\nMemoryCache的具体实现类是LruResourceCache，而实际的逻辑方法，都在其父类LruCache中，以put方法为例。\n\n```java\n@Nullable\npublic synchronized Y put(@NonNull T key, @Nullable Y item) {\n  final int itemSize = getSize(item);\n  if (itemSize >= maxSize) {\n    onItemEvicted(key, item);\n    return null;\n  }\n\n  if (item != null) {\n    currentSize += itemSize;\n  }\n  @Nullable Entry<Y> old = cache.put(key, item == null ? null : new Entry<>(item, itemSize));\n  if (old != null) {\n    currentSize -= old.size;\n\n    if (!old.value.equals(item)) {\n      onItemEvicted(key, old.value);\n    }\n  }\n  evict();\n\n  return old != null ? old.value : null;\n}\n```\n\n当有一个新的item被put进去以后，会替换出一个老的值old，如果old非为空，则需要将当前容量减去old的大小，如果old并非新的item，则需要通过onItemEvicted进行回调，通知有老值被**“驱逐”**了。最后还要执行一次evict方法，按照LRU算法，将超出maxSize的item**“驱逐”**出去，以确保在maxSize范围内。\n\n```java\nprotected synchronized void trimToSize(long size) {\n  Map.Entry<T, Entry<Y>> last;\n  Iterator<Map.Entry<T, Entry<Y>>> cacheIterator;\n  while (currentSize > size) {\n    cacheIterator = cache.entrySet().iterator();\n    last = cacheIterator.next();\n    final Entry<Y> toRemove = last.getValue();\n    currentSize -= toRemove.size;\n    final T key = last.getKey();\n    cacheIterator.remove();\n    onItemEvicted(key, toRemove.value);\n  }\n}\n\nprivate void evict() {\n  trimToSize(maxSize);\n}\n```\n\n被**\"驱逐\"**的值去哪里了呢？我们查看*MemoryCache*类的源码，可以知道是通过*ResourceRemovedListener*回调给了*Engine*，在*Engine*中我们查看*onResourceRemoved*方法。\n\n```java\n@Override\npublic void onResourceRemoved(@NonNull final Resource<?> resource) {\n  // Avoid deadlock with RequestManagers when recycling triggers recursive clear() calls.\n  // See b/145519760.\n  resourceRecycler.recycle(resource, /*forceNextFrame=*/ true);\n}\n```\n\n我们可以看到，这里同样是通过resourceRecycler进行了回收。在这里，则是交给resource自己的recycle()方法来处理，比如，*BitmapResource*是交给了*BitmapPool*进行处理。\n\n\n\n### BitmapPool\n\n这里是专门用来存放被回收的Bitmap的，其中**BitmapDrawableResource**、**BitmapResource**都持有一个**BitmapPool**变量，在执行recycle()方法时候，调用*BitmapPool#put()*方法。我们来看一下这个BitmapPool的默认实现类**LruBitmapPool**的方法实现。\n\n```java\n@Override\npublic synchronized void put(Bitmap bitmap) {\n  if (bitmap == null) {\n    throw new NullPointerException(\"Bitmap must not be null\");\n  }\n  if (bitmap.isRecycled()) {\n    throw new IllegalStateException(\"Cannot pool recycled bitmap\");\n  }\n  if (!bitmap.isMutable()\n      || strategy.getSize(bitmap) > maxSize\n      || !allowedConfigs.contains(bitmap.getConfig())) {\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      Log.v(\n        TAG,\n        \"Reject bitmap from pool\"\n        + \", bitmap: \"\n        + strategy.logBitmap(bitmap)\n        + \", is mutable: \"\n        + bitmap.isMutable()\n        + \", is allowed config: \"\n        + allowedConfigs.contains(bitmap.getConfig()));\n    }\n    bitmap.recycle();\n    return;\n  }\n\n  final int size = strategy.getSize(bitmap);\n  strategy.put(bitmap);\n  tracker.add(bitmap);\n\t...\n}\n```\n\n这里我们可以看出，当Bitmap在三种情况下是不会被BitmapPool缓存起来的：\n\n1. 这个bitmap是非mutable的，也就是说是不允许被复用的；\n2. 这一个bitmap的字节数大小已经超过了可以容纳的总大小；\n3. BitmapPool中不允许的Config类型。\n\n在这种情况，bitmap就被直接recycle掉，而不是放入缓存等待下次使用。\n\n如果不满足这三种情况，则会被strategy缓存起来，等待下次使用。\n\n我们再看LruBitmapPool#get()方法。\n\n```java\n@Override\n@NonNull\npublic Bitmap get(int width, int height, Bitmap.Config config) {\n  Bitmap result = getDirtyOrNull(width, height, config);\n  if (result != null) {\n    result.eraseColor(Color.TRANSPARENT);\n  } else {\n    result = createBitmap(width, height, config);\n  }\n  return result;\n}\n```\n\n我们可以看到，当能够查询到符合条件的Bitmap的时候，会先通过eraseColor方法，将其变成透明图片，然后再交给调用者来使用；如果查询不到，则创建一个新图交给调用者来使用。\n\n> LruBitmapPool的LruPoolStrategy变量，在KITKAT以及以上，是SizeConfigStrategy，在以下是AttributeStrategy，这是因为在KITKAT版本以下，Bitmap的复用需要尺寸的严格匹配，但是KITKAT及以上没有这个问题，只要被复用的图片尺寸比目标尺寸大就可以。\n\n\n\n### ArrayPool\n\nArrayPool主要用在**ThumbnailStreamOpener**和**ByteBufferGifDecoder**中，具体的实现类为**LruArrayPool**。\n\n在LruArrayPool中，通过groupedMap来缓存数据，而缓存数据的byte字节数是通过**ArrayAdapterInterface**来计算的，ArrayAdapterInterface是一个接口，实现类有两个：**IntegerArrayAdapter**和**ByteArrayAdapter**，分别对应缓存int[].class和byte[].class。\n\nStreamGifDecoder和StreamBitmapDecoder都有一个ArrayPool成员。解码过程中需要用到byte[]，但不是直接new byte[]，而是调用`ArrayPool.get()`从对象池中拿，用完了归还。\n\n\n\n\n\n## DiskCache\n\n在上一章[Glide源码分析与自我实现(一)——数据加载主流程]({{site.base_url}}/源码分析系列/Glide源码分析与自我实现2.md)中，提到过数据加载的主流程，其中一个非常重要的类是 **DecodeJob**，在这个类的`getNextGenerator`方法中，返回的**SourceGenerator**会用来加载远程数据，但是这个方法不止返回这一个**DataFetcherGenerator**类，这是一个通过条件判断，返回不同DataFetcherGenerator类的方法。\n\n```java\nprivate DataFetcherGenerator getNextGenerator() {\n  switch (stage) {\n    case RESOURCE_CACHE:\n      return new ResourceCacheGenerator(decodeHelper, this);\n    case DATA_CACHE:\n      return new DataCacheGenerator(decodeHelper, this);\n    case SOURCE:\n      return new SourceGenerator(decodeHelper, this);\n    case FINISHED:\n      return null;\n    default:\n      throw new IllegalStateException(\"Unrecognized stage: \" + stage);\n  }\n}\n```\n\n实际上，这是依次递进的**有限状态机**设计模式，当一个获取数据请求到来时候，此时是默认状态INITIALIZE，然后通过`getNextStage`方法判断下一个状态是什么，再按照新的状态获取DataFetcherGenerator，然后随着任务的执行，不断改变状态。\n\n```java\nprivate Stage getNextStage(Stage current) {\n  switch (current) {\n    case INITIALIZE:\n      return diskCacheStrategy.decodeCachedResource()\n        ? Stage.RESOURCE_CACHE\n        : getNextStage(Stage.RESOURCE_CACHE);\n    case RESOURCE_CACHE:\n      return diskCacheStrategy.decodeCachedData()\n        ? Stage.DATA_CACHE\n        : getNextStage(Stage.DATA_CACHE);\n    case DATA_CACHE:\n      // Skip loading from source if the user opted to only retrieve the resource from cache.\n      return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;\n    case SOURCE:\n    case FINISHED:\n      return Stage.FINISHED;\n    default:\n      throw new IllegalArgumentException(\"Unrecognized stage: \" + current);\n  }\n}\n```\n\n其状态变更顺序为INITIALIZE -> RESOURCE_CACHE -> DATA_CACHE -> SOURCE，代表着ResourceCacheGenerator、DataCacheGenerator和SourceGenerator，当从ResourceCahce中拿不到数据，则向DataCacheGenerator请求数据，如果还是拿不到，则通过SourceGenerator去请求数据了。\n\n在这个过程中，SourceGenerator向DiskCache中写入数据，ResourceCacheGenerator和DataCacheGenerator从DiskCache中读取数据。\n\n```java\nclass ResourceCacheGenerator implements DataFetcherGenerator,\n\n  @Override\n  public boolean startNext() {\n      ...\n      currentKey = new ResourceCacheKey(sourceId, helper.getSignature(), helper.getWidth(),\n          helper.getHeight(), transformation, resourceClass, helper.getOptions());\n      cacheFile = helper.getDiskCache().get(currentKey);\n      if (cacheFile != null) {\n        this.sourceKey = sourceId;\n        modelLoaders = helper.getModelLoaders(cacheFile);\n        modelLoaderIndex = 0;\n      }\n    }\n  }\n}\n\nclass DataCacheGenerator implements DataFetcherGenerator,\n\n  @Override\n  public boolean startNext() {\n    while (modelLoaders == null || !hasNextModelLoader()) {\n      ...\n      Key sourceId = cacheKeys.get(sourceIdIndex);\n      Key originalKey = new DataCacheKey(sourceId, helper.getSignature());\n      cacheFile = helper.getDiskCache().get(originalKey);\n      if (cacheFile != null) {\n        this.sourceKey = sourceId;\n        modelLoaders = helper.getModelLoaders(cacheFile);\n        modelLoaderIndex = 0;\n      }\n    }\n}\n\nclass SourceGenerator implements DataFetcherGenerator {\n\n  @Override\n  public boolean startNext() {\n    if (dataToCache != null) {\n      Object data = dataToCache;\n      dataToCache = null;\n      cacheData(data);\n    }\n    ...\n  }\n\n  private void cacheData(Object dataToCache) {\n    long startTime = LogTime.getLogTime();\n    try {\n      Encoder<Object> encoder = helper.getSourceEncoder(dataToCache);\n      DataCacheWriter<Object> writer =\n          new DataCacheWriter<>(encoder, dataToCache, helper.getOptions());\n      originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());\n      helper.getDiskCache().put(originalKey, writer);\n      ...\n    } finally {\n      loadData.fetcher.cleanup();\n    }\n\n    sourceCacheGenerator =\n        new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this);\n  }\n}\n```\n\nDiskCache的默认实现类是**DiskLruCacheWrapper**，其内部通过**DiskLruCache**来管理磁盘缓存。\n\n\n\n## 总结\n\n到现在，Glide主要部分已经分析的差不多了，实际上这个优秀的框架可挖的地方还有很多，比如通过[APT来实现很好的扩展]({{site.base_url}}/源码分析系列/Glide源码分析与自我实现3.md)，框架中涉及多种涉及模式等。\n\n> 其中涉及到的涉及模式，比如无处不在的**构建者模式**和**工厂模式**，DecodeJob中的**有限状态机模式**，还有BitmapPool和ArrayPool中的**享元模式**，DiskLruCacheWrapper中的**代理模式**等。\n\n## 参考文章\n\n[Glide缓存分析](https://www.sunmoonblog.com/2018/07/27/glide-cache/)","source":"_posts/2022-09-17-Glide源码分析与自我实现2.md","raw":"---\nlayout: post\ntitle: Glide源码分析与自我实现(二)——缓存与BitmapPool\nauthor: boybeak\ncategory: 源码分析\ntags: Android\n---\n\n\n> 本文基于Glide 4.11.0\n\n参考文章：[Glide 源码分析解读-缓存模块-基于最新版Glide 4.9.0](https://zhuanlan.zhihu.com/p/60426316)\n\n**注意：**由于版本差异问题，本文有些部分与参考文章有差异。\n\n缓存模块是Glide中非常重要的部分，Glide图片加载的高效性，几乎有一半功劳都在这里了。\n\n一般来说，Glide有三级缓存，就是**内存缓存**、**磁盘缓存**和**网络缓存**。\n\n先来看缓存流程图，如下：\n\n```mermaid\ngraph TD;\nstyle A fill:#99ccff\nstyle B1 fill:#aaffaa\nA(发起请求) --> B{1. 通过<br>ActiveResources<br>获取资源} --> |命中|B1([加载完成]);\nB --> |未命中|C{2. 通过<br>MemoryCache<br>获取资源} --> |命中|C1[缓存至<br>ActiveResources] --> B1;\nC --> |未命中|D{3. 通过<br>DiskCache<br>获取资源} --> |命中|D1[缓存至<br>MemoryCache] --> C1;\nD --> |未命中|E[\"4. 通过数据源(网络、文件等)<br>加载数据\"] --> E1[缓存至<br>DiskCache] --> D1;\n```\n\n## 内存缓存\n\n内存缓存主要靠三个部分组成：**ActiveResources**、**MemoryCache**和**BitmapPool**。\n\n### ActiveResources\n\nActiveResources表示当前正在活动中的资源。ActiveResources通过一个`Map<Key, ResourceWeakReference>`来保存活动中的资源，其中的ResourceWeakReference就是资源数据，在构建这个ResourceWeakReference的时候必须传入一个ReferenceQueue用来检测资源是否被回收。\n\n> **Q1：如何探知WeakReference中的值被回收了呢？**\n>\n> ```java\n> ReferenceQueue queue = ...;\n> WeakReference wr = new WeakReference(value, queue);\n> ```\n>\n> 当构建WeakReference的时候，如果传入了queue参数，则在value被回收的时候，wr会被加入到queue中去，这样，通过检测queue中是否有值，就可以探知value是否被回收了。\n\n那么，在何时去探知ReferenceQueue中的值呢？我们查看ActiveResources的关键代码：\n\n```java\n/*构造方法中，通过monitorClearedResourcesExecutor执行了cleanReferenceQueue()方法。\n*/\nActiveResources(boolean isActiveResourceRetentionAllowed) {\n  this(\n    isActiveResourceRetentionAllowed,\n    java.util.concurrent.Executors.newSingleThreadExecutor(\n      new ThreadFactory() {\n        @Override\n        public Thread newThread(@NonNull final Runnable r) {\n          return new Thread(\n            new Runnable() {\n              @Override\n              public void run() {\n                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                r.run();\n              }\n            },\n            \"glide-active-resources\");\n        }\n      }));\n}\n\n@VisibleForTesting\nActiveResources(\n  boolean isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) {\n  this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;\n  this.monitorClearedResourcesExecutor = monitorClearedResourcesExecutor;\n\n  monitorClearedResourcesExecutor.execute(\n    new Runnable() {\n      @Override\n      public void run() {\n        cleanReferenceQueue();\n      }\n    });\n}\n\n\nvoid cleanReferenceQueue() {\n  while (!isShutdown) {\n    try {\n      ResourceWeakReference ref = (ResourceWeakReference) resourceReferenceQueue.remove();\n      cleanupActiveReference(ref);\n\n      // This section for testing only.\n      DequeuedResourceCallback current = cb;\n      if (current != null) {\n        current.onResourceDequeued();\n      }\n      // End for testing only.\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n  }\n}\n```\n\n我们通过代码可以看出，`cleanReferenceQueue`是一个靠`isShutdown`变量控制的**死循环**方法，这个方法执行在一个优先级为`THREAD_PRIORITY_BACKGROUND`的线程上。\n\n> **Q2：那么，既然是死循环方法，会不会过多的占用CPU资源呢？**\n>\n> 其实不会的，因为ReferenceQueue#remove是一个阻塞式的方法，如果没有元素可以被remove，则等待至有元素可以remove的时候，等待期间释放CPU。\n\n> **注意：**此处与**参考文章**中的说法不同，这是因为版本差异。查看[Glide update log hsitory](https://github.com/bumptech/glide/commit/8f1ea5c07dff7ade8c49c324bcb5a7f40d0b4891#diff-c46e6c0760c04e74cb867c2bdf9cdee90ab279b119268478524c42cc743cb8a9)，可以看出**出于避免在主线程做清理的原因**，将清理任务放在了后台线程，而不是放在IdleHandler中。\n\n\n\n**那么被回收了的资源去哪里了呢？**\n\n我们查看`cleanupActiveReference`方法，得知，通过*ResourceListener#onResourceReleased*回调，交给了**Engine**来处理，我们查看Engine的onResourceReleased方法。\n\n```java\n@Override\npublic void onResourceReleased(Key cacheKey, EngineResource<?> resource) {\n  activeResources.deactivate(cacheKey);\n  if (resource.isMemoryCacheable()) {\n    cache.put(cacheKey, resource);\n  } else {\n    resourceRecycler.recycle(resource, /*forceNextFrame=*/ false);\n  }\n}\n```\n\n从这里我们发现，这里出现了两种情况：\n\n1. 如果资源是**MemoryCacheable**的，则缓存在MemoryCache；\n2. 如果资源不是**MemoryCacheable**的，则交给ResourceRecycler调用Resource的recycle()方法来回收，如果此Resource为BitmapResource，则会将Bitmap回收到BitmapPool中去。\n\n\n\n在开始MemoryCache和BitmapPool前，需要先了解一下**MemorySizeCalculator**这个类，这个类是用来计算 BitmapPool 、ArrayPool 以及 MemoryCache **大小**的。\n\n### MemoryCache\n\nMemoryCache的具体实现类是LruResourceCache，而实际的逻辑方法，都在其父类LruCache中，以put方法为例。\n\n```java\n@Nullable\npublic synchronized Y put(@NonNull T key, @Nullable Y item) {\n  final int itemSize = getSize(item);\n  if (itemSize >= maxSize) {\n    onItemEvicted(key, item);\n    return null;\n  }\n\n  if (item != null) {\n    currentSize += itemSize;\n  }\n  @Nullable Entry<Y> old = cache.put(key, item == null ? null : new Entry<>(item, itemSize));\n  if (old != null) {\n    currentSize -= old.size;\n\n    if (!old.value.equals(item)) {\n      onItemEvicted(key, old.value);\n    }\n  }\n  evict();\n\n  return old != null ? old.value : null;\n}\n```\n\n当有一个新的item被put进去以后，会替换出一个老的值old，如果old非为空，则需要将当前容量减去old的大小，如果old并非新的item，则需要通过onItemEvicted进行回调，通知有老值被**“驱逐”**了。最后还要执行一次evict方法，按照LRU算法，将超出maxSize的item**“驱逐”**出去，以确保在maxSize范围内。\n\n```java\nprotected synchronized void trimToSize(long size) {\n  Map.Entry<T, Entry<Y>> last;\n  Iterator<Map.Entry<T, Entry<Y>>> cacheIterator;\n  while (currentSize > size) {\n    cacheIterator = cache.entrySet().iterator();\n    last = cacheIterator.next();\n    final Entry<Y> toRemove = last.getValue();\n    currentSize -= toRemove.size;\n    final T key = last.getKey();\n    cacheIterator.remove();\n    onItemEvicted(key, toRemove.value);\n  }\n}\n\nprivate void evict() {\n  trimToSize(maxSize);\n}\n```\n\n被**\"驱逐\"**的值去哪里了呢？我们查看*MemoryCache*类的源码，可以知道是通过*ResourceRemovedListener*回调给了*Engine*，在*Engine*中我们查看*onResourceRemoved*方法。\n\n```java\n@Override\npublic void onResourceRemoved(@NonNull final Resource<?> resource) {\n  // Avoid deadlock with RequestManagers when recycling triggers recursive clear() calls.\n  // See b/145519760.\n  resourceRecycler.recycle(resource, /*forceNextFrame=*/ true);\n}\n```\n\n我们可以看到，这里同样是通过resourceRecycler进行了回收。在这里，则是交给resource自己的recycle()方法来处理，比如，*BitmapResource*是交给了*BitmapPool*进行处理。\n\n\n\n### BitmapPool\n\n这里是专门用来存放被回收的Bitmap的，其中**BitmapDrawableResource**、**BitmapResource**都持有一个**BitmapPool**变量，在执行recycle()方法时候，调用*BitmapPool#put()*方法。我们来看一下这个BitmapPool的默认实现类**LruBitmapPool**的方法实现。\n\n```java\n@Override\npublic synchronized void put(Bitmap bitmap) {\n  if (bitmap == null) {\n    throw new NullPointerException(\"Bitmap must not be null\");\n  }\n  if (bitmap.isRecycled()) {\n    throw new IllegalStateException(\"Cannot pool recycled bitmap\");\n  }\n  if (!bitmap.isMutable()\n      || strategy.getSize(bitmap) > maxSize\n      || !allowedConfigs.contains(bitmap.getConfig())) {\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      Log.v(\n        TAG,\n        \"Reject bitmap from pool\"\n        + \", bitmap: \"\n        + strategy.logBitmap(bitmap)\n        + \", is mutable: \"\n        + bitmap.isMutable()\n        + \", is allowed config: \"\n        + allowedConfigs.contains(bitmap.getConfig()));\n    }\n    bitmap.recycle();\n    return;\n  }\n\n  final int size = strategy.getSize(bitmap);\n  strategy.put(bitmap);\n  tracker.add(bitmap);\n\t...\n}\n```\n\n这里我们可以看出，当Bitmap在三种情况下是不会被BitmapPool缓存起来的：\n\n1. 这个bitmap是非mutable的，也就是说是不允许被复用的；\n2. 这一个bitmap的字节数大小已经超过了可以容纳的总大小；\n3. BitmapPool中不允许的Config类型。\n\n在这种情况，bitmap就被直接recycle掉，而不是放入缓存等待下次使用。\n\n如果不满足这三种情况，则会被strategy缓存起来，等待下次使用。\n\n我们再看LruBitmapPool#get()方法。\n\n```java\n@Override\n@NonNull\npublic Bitmap get(int width, int height, Bitmap.Config config) {\n  Bitmap result = getDirtyOrNull(width, height, config);\n  if (result != null) {\n    result.eraseColor(Color.TRANSPARENT);\n  } else {\n    result = createBitmap(width, height, config);\n  }\n  return result;\n}\n```\n\n我们可以看到，当能够查询到符合条件的Bitmap的时候，会先通过eraseColor方法，将其变成透明图片，然后再交给调用者来使用；如果查询不到，则创建一个新图交给调用者来使用。\n\n> LruBitmapPool的LruPoolStrategy变量，在KITKAT以及以上，是SizeConfigStrategy，在以下是AttributeStrategy，这是因为在KITKAT版本以下，Bitmap的复用需要尺寸的严格匹配，但是KITKAT及以上没有这个问题，只要被复用的图片尺寸比目标尺寸大就可以。\n\n\n\n### ArrayPool\n\nArrayPool主要用在**ThumbnailStreamOpener**和**ByteBufferGifDecoder**中，具体的实现类为**LruArrayPool**。\n\n在LruArrayPool中，通过groupedMap来缓存数据，而缓存数据的byte字节数是通过**ArrayAdapterInterface**来计算的，ArrayAdapterInterface是一个接口，实现类有两个：**IntegerArrayAdapter**和**ByteArrayAdapter**，分别对应缓存int[].class和byte[].class。\n\nStreamGifDecoder和StreamBitmapDecoder都有一个ArrayPool成员。解码过程中需要用到byte[]，但不是直接new byte[]，而是调用`ArrayPool.get()`从对象池中拿，用完了归还。\n\n\n\n\n\n## DiskCache\n\n在上一章[Glide源码分析与自我实现(一)——数据加载主流程]({{site.base_url}}/源码分析系列/Glide源码分析与自我实现2.md)中，提到过数据加载的主流程，其中一个非常重要的类是 **DecodeJob**，在这个类的`getNextGenerator`方法中，返回的**SourceGenerator**会用来加载远程数据，但是这个方法不止返回这一个**DataFetcherGenerator**类，这是一个通过条件判断，返回不同DataFetcherGenerator类的方法。\n\n```java\nprivate DataFetcherGenerator getNextGenerator() {\n  switch (stage) {\n    case RESOURCE_CACHE:\n      return new ResourceCacheGenerator(decodeHelper, this);\n    case DATA_CACHE:\n      return new DataCacheGenerator(decodeHelper, this);\n    case SOURCE:\n      return new SourceGenerator(decodeHelper, this);\n    case FINISHED:\n      return null;\n    default:\n      throw new IllegalStateException(\"Unrecognized stage: \" + stage);\n  }\n}\n```\n\n实际上，这是依次递进的**有限状态机**设计模式，当一个获取数据请求到来时候，此时是默认状态INITIALIZE，然后通过`getNextStage`方法判断下一个状态是什么，再按照新的状态获取DataFetcherGenerator，然后随着任务的执行，不断改变状态。\n\n```java\nprivate Stage getNextStage(Stage current) {\n  switch (current) {\n    case INITIALIZE:\n      return diskCacheStrategy.decodeCachedResource()\n        ? Stage.RESOURCE_CACHE\n        : getNextStage(Stage.RESOURCE_CACHE);\n    case RESOURCE_CACHE:\n      return diskCacheStrategy.decodeCachedData()\n        ? Stage.DATA_CACHE\n        : getNextStage(Stage.DATA_CACHE);\n    case DATA_CACHE:\n      // Skip loading from source if the user opted to only retrieve the resource from cache.\n      return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;\n    case SOURCE:\n    case FINISHED:\n      return Stage.FINISHED;\n    default:\n      throw new IllegalArgumentException(\"Unrecognized stage: \" + current);\n  }\n}\n```\n\n其状态变更顺序为INITIALIZE -> RESOURCE_CACHE -> DATA_CACHE -> SOURCE，代表着ResourceCacheGenerator、DataCacheGenerator和SourceGenerator，当从ResourceCahce中拿不到数据，则向DataCacheGenerator请求数据，如果还是拿不到，则通过SourceGenerator去请求数据了。\n\n在这个过程中，SourceGenerator向DiskCache中写入数据，ResourceCacheGenerator和DataCacheGenerator从DiskCache中读取数据。\n\n```java\nclass ResourceCacheGenerator implements DataFetcherGenerator,\n\n  @Override\n  public boolean startNext() {\n      ...\n      currentKey = new ResourceCacheKey(sourceId, helper.getSignature(), helper.getWidth(),\n          helper.getHeight(), transformation, resourceClass, helper.getOptions());\n      cacheFile = helper.getDiskCache().get(currentKey);\n      if (cacheFile != null) {\n        this.sourceKey = sourceId;\n        modelLoaders = helper.getModelLoaders(cacheFile);\n        modelLoaderIndex = 0;\n      }\n    }\n  }\n}\n\nclass DataCacheGenerator implements DataFetcherGenerator,\n\n  @Override\n  public boolean startNext() {\n    while (modelLoaders == null || !hasNextModelLoader()) {\n      ...\n      Key sourceId = cacheKeys.get(sourceIdIndex);\n      Key originalKey = new DataCacheKey(sourceId, helper.getSignature());\n      cacheFile = helper.getDiskCache().get(originalKey);\n      if (cacheFile != null) {\n        this.sourceKey = sourceId;\n        modelLoaders = helper.getModelLoaders(cacheFile);\n        modelLoaderIndex = 0;\n      }\n    }\n}\n\nclass SourceGenerator implements DataFetcherGenerator {\n\n  @Override\n  public boolean startNext() {\n    if (dataToCache != null) {\n      Object data = dataToCache;\n      dataToCache = null;\n      cacheData(data);\n    }\n    ...\n  }\n\n  private void cacheData(Object dataToCache) {\n    long startTime = LogTime.getLogTime();\n    try {\n      Encoder<Object> encoder = helper.getSourceEncoder(dataToCache);\n      DataCacheWriter<Object> writer =\n          new DataCacheWriter<>(encoder, dataToCache, helper.getOptions());\n      originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());\n      helper.getDiskCache().put(originalKey, writer);\n      ...\n    } finally {\n      loadData.fetcher.cleanup();\n    }\n\n    sourceCacheGenerator =\n        new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this);\n  }\n}\n```\n\nDiskCache的默认实现类是**DiskLruCacheWrapper**，其内部通过**DiskLruCache**来管理磁盘缓存。\n\n\n\n## 总结\n\n到现在，Glide主要部分已经分析的差不多了，实际上这个优秀的框架可挖的地方还有很多，比如通过[APT来实现很好的扩展]({{site.base_url}}/源码分析系列/Glide源码分析与自我实现3.md)，框架中涉及多种涉及模式等。\n\n> 其中涉及到的涉及模式，比如无处不在的**构建者模式**和**工厂模式**，DecodeJob中的**有限状态机模式**，还有BitmapPool和ArrayPool中的**享元模式**，DiskLruCacheWrapper中的**代理模式**等。\n\n## 参考文章\n\n[Glide缓存分析](https://www.sunmoonblog.com/2018/07/27/glide-cache/)","slug":"2022-09-17-Glide源码分析与自我实现2","published":1,"date":"2020-12-27T19:42:51.000Z","updated":"2022-09-19T01:34:19.727Z","comments":1,"photos":[],"link":"","_id":"cldqukh7y0004pcjgc9tkbuxw","content":"<blockquote>\n<p>本文基于Glide 4.11.0</p>\n</blockquote>\n<p>参考文章：<a href=\"https://zhuanlan.zhihu.com/p/60426316\">Glide 源码分析解读-缓存模块-基于最新版Glide 4.9.0</a></p>\n<p><strong>注意：</strong>由于版本差异问题，本文有些部分与参考文章有差异。</p>\n<p>缓存模块是Glide中非常重要的部分，Glide图片加载的高效性，几乎有一半功劳都在这里了。</p>\n<p>一般来说，Glide有三级缓存，就是<strong>内存缓存</strong>、<strong>磁盘缓存</strong>和<strong>网络缓存</strong>。</p>\n<p>先来看缓存流程图，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">style A fill:#99ccff</span><br><span class=\"line\">style B1 fill:#aaffaa</span><br><span class=\"line\">A(发起请求) --&gt; B&#123;1. 通过&lt;br&gt;ActiveResources&lt;br&gt;获取资源&#125; --&gt; |命中|B1([加载完成]);</span><br><span class=\"line\">B --&gt; |未命中|C&#123;2. 通过&lt;br&gt;MemoryCache&lt;br&gt;获取资源&#125; --&gt; |命中|C1[缓存至&lt;br&gt;ActiveResources] --&gt; B1;</span><br><span class=\"line\">C --&gt; |未命中|D&#123;3. 通过&lt;br&gt;DiskCache&lt;br&gt;获取资源&#125; --&gt; |命中|D1[缓存至&lt;br&gt;MemoryCache] --&gt; C1;</span><br><span class=\"line\">D --&gt; |未命中|E[&quot;4. 通过数据源(网络、文件等)&lt;br&gt;加载数据&quot;] --&gt; E1[缓存至&lt;br&gt;DiskCache] --&gt; D1;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h2><p>内存缓存主要靠三个部分组成：<strong>ActiveResources</strong>、<strong>MemoryCache</strong>和<strong>BitmapPool</strong>。</p>\n<h3 id=\"ActiveResources\"><a href=\"#ActiveResources\" class=\"headerlink\" title=\"ActiveResources\"></a>ActiveResources</h3><p>ActiveResources表示当前正在活动中的资源。ActiveResources通过一个<code>Map&lt;Key, ResourceWeakReference&gt;</code>来保存活动中的资源，其中的ResourceWeakReference就是资源数据，在构建这个ResourceWeakReference的时候必须传入一个ReferenceQueue用来检测资源是否被回收。</p>\n<blockquote>\n<p><strong>Q1：如何探知WeakReference中的值被回收了呢？</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ReferenceQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\"><span class=\"type\">WeakReference</span> <span class=\"variable\">wr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>(value, queue);</span><br></pre></td></tr></table></figure>\n\n<p>当构建WeakReference的时候，如果传入了queue参数，则在value被回收的时候，wr会被加入到queue中去，这样，通过检测queue中是否有值，就可以探知value是否被回收了。</p>\n</blockquote>\n<p>那么，在何时去探知ReferenceQueue中的值呢？我们查看ActiveResources的关键代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*构造方法中，通过monitorClearedResourcesExecutor执行了cleanReferenceQueue()方法。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">ActiveResources(<span class=\"type\">boolean</span> isActiveResourceRetentionAllowed) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>(</span><br><span class=\"line\">    isActiveResourceRetentionAllowed,</span><br><span class=\"line\">    java.util.concurrent.Executors.newSingleThreadExecutor(</span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadFactory</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Thread <span class=\"title function_\">newThread</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> Runnable r)</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class=\"line\">                r.run();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">&quot;glide-active-resources&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@VisibleForTesting</span></span><br><span class=\"line\">ActiveResources(</span><br><span class=\"line\">  <span class=\"type\">boolean</span> isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.monitorClearedResourcesExecutor = monitorClearedResourcesExecutor;</span><br><span class=\"line\"></span><br><span class=\"line\">  monitorClearedResourcesExecutor.execute(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        cleanReferenceQueue();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">cleanReferenceQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!isShutdown) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">ResourceWeakReference</span> <span class=\"variable\">ref</span> <span class=\"operator\">=</span> (ResourceWeakReference) resourceReferenceQueue.remove();</span><br><span class=\"line\">      cleanupActiveReference(ref);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// This section for testing only.</span></span><br><span class=\"line\">      <span class=\"type\">DequeuedResourceCallback</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> cb;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (current != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        current.onResourceDequeued();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// End for testing only.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      Thread.currentThread().interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们通过代码可以看出，<code>cleanReferenceQueue</code>是一个靠<code>isShutdown</code>变量控制的<strong>死循环</strong>方法，这个方法执行在一个优先级为<code>THREAD_PRIORITY_BACKGROUND</code>的线程上。</p>\n<blockquote>\n<p><strong>Q2：那么，既然是死循环方法，会不会过多的占用CPU资源呢？</strong></p>\n<p>其实不会的，因为ReferenceQueue#remove是一个阻塞式的方法，如果没有元素可以被remove，则等待至有元素可以remove的时候，等待期间释放CPU。</p>\n</blockquote>\n<blockquote>\n<p><strong>注意：</strong>此处与<strong>参考文章</strong>中的说法不同，这是因为版本差异。查看<a href=\"https://github.com/bumptech/glide/commit/8f1ea5c07dff7ade8c49c324bcb5a7f40d0b4891#diff-c46e6c0760c04e74cb867c2bdf9cdee90ab279b119268478524c42cc743cb8a9\">Glide update log hsitory</a>，可以看出<strong>出于避免在主线程做清理的原因</strong>，将清理任务放在了后台线程，而不是放在IdleHandler中。</p>\n</blockquote>\n<p><strong>那么被回收了的资源去哪里了呢？</strong></p>\n<p>我们查看<code>cleanupActiveReference</code>方法，得知，通过<em>ResourceListener#onResourceReleased</em>回调，交给了<strong>Engine</strong>来处理，我们查看Engine的onResourceReleased方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onResourceReleased</span><span class=\"params\">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> &#123;</span><br><span class=\"line\">  activeResources.deactivate(cacheKey);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (resource.isMemoryCacheable()) &#123;</span><br><span class=\"line\">    cache.put(cacheKey, resource);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    resourceRecycler.recycle(resource, <span class=\"comment\">/*forceNextFrame=*/</span> <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从这里我们发现，这里出现了两种情况：</p>\n<ol>\n<li>如果资源是<strong>MemoryCacheable</strong>的，则缓存在MemoryCache；</li>\n<li>如果资源不是<strong>MemoryCacheable</strong>的，则交给ResourceRecycler调用Resource的recycle()方法来回收，如果此Resource为BitmapResource，则会将Bitmap回收到BitmapPool中去。</li>\n</ol>\n<p>在开始MemoryCache和BitmapPool前，需要先了解一下<strong>MemorySizeCalculator</strong>这个类，这个类是用来计算 BitmapPool 、ArrayPool 以及 MemoryCache <strong>大小</strong>的。</p>\n<h3 id=\"MemoryCache\"><a href=\"#MemoryCache\" class=\"headerlink\" title=\"MemoryCache\"></a>MemoryCache</h3><p>MemoryCache的具体实现类是LruResourceCache，而实际的逻辑方法，都在其父类LruCache中，以put方法为例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Y <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> T key, <span class=\"meta\">@Nullable</span> Y item)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">itemSize</span> <span class=\"operator\">=</span> getSize(item);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (itemSize &gt;= maxSize) &#123;</span><br><span class=\"line\">    onItemEvicted(key, item);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (item != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    currentSize += itemSize;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span> Entry&lt;Y&gt; old = cache.put(key, item == <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>&lt;&gt;(item, itemSize));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (old != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    currentSize -= old.size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!old.value.equals(item)) &#123;</span><br><span class=\"line\">      onItemEvicted(key, old.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  evict();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> old != <span class=\"literal\">null</span> ? old.value : <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当有一个新的item被put进去以后，会替换出一个老的值old，如果old非为空，则需要将当前容量减去old的大小，如果old并非新的item，则需要通过onItemEvicted进行回调，通知有老值被<strong>“驱逐”</strong>了。最后还要执行一次evict方法，按照LRU算法，将超出maxSize的item<strong>“驱逐”</strong>出去，以确保在maxSize范围内。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">trimToSize</span><span class=\"params\">(<span class=\"type\">long</span> size)</span> &#123;</span><br><span class=\"line\">  Map.Entry&lt;T, Entry&lt;Y&gt;&gt; last;</span><br><span class=\"line\">  Iterator&lt;Map.Entry&lt;T, Entry&lt;Y&gt;&gt;&gt; cacheIterator;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (currentSize &gt; size) &#123;</span><br><span class=\"line\">    cacheIterator = cache.entrySet().iterator();</span><br><span class=\"line\">    last = cacheIterator.next();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Entry&lt;Y&gt; toRemove = last.getValue();</span><br><span class=\"line\">    currentSize -= toRemove.size;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">T</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> last.getKey();</span><br><span class=\"line\">    cacheIterator.remove();</span><br><span class=\"line\">    onItemEvicted(key, toRemove.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">evict</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  trimToSize(maxSize);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>被**”驱逐”*<em>的值去哪里了呢？我们查看</em>MemoryCache<em>类的源码，可以知道是通过</em>ResourceRemovedListener<em>回调给了</em>Engine<em>，在</em>Engine<em>中我们查看</em>onResourceRemoved*方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onResourceRemoved</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> Resource&lt;?&gt; resource)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Avoid deadlock with RequestManagers when recycling triggers recursive clear() calls.</span></span><br><span class=\"line\">  <span class=\"comment\">// See b/145519760.</span></span><br><span class=\"line\">  resourceRecycler.recycle(resource, <span class=\"comment\">/*forceNextFrame=*/</span> <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，这里同样是通过resourceRecycler进行了回收。在这里，则是交给resource自己的recycle()方法来处理，比如，<em>BitmapResource</em>是交给了<em>BitmapPool</em>进行处理。</p>\n<h3 id=\"BitmapPool\"><a href=\"#BitmapPool\" class=\"headerlink\" title=\"BitmapPool\"></a>BitmapPool</h3><p>这里是专门用来存放被回收的Bitmap的，其中<strong>BitmapDrawableResource</strong>、<strong>BitmapResource</strong>都持有一个<strong>BitmapPool</strong>变量，在执行recycle()方法时候，调用*BitmapPool#put()*方法。我们来看一下这个BitmapPool的默认实现类<strong>LruBitmapPool</strong>的方法实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(Bitmap bitmap)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (bitmap == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>(<span class=\"string\">&quot;Bitmap must not be null&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (bitmap.isRecycled()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Cannot pool recycled bitmap&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!bitmap.isMutable()</span><br><span class=\"line\">      || strategy.getSize(bitmap) &gt; maxSize</span><br><span class=\"line\">      || !allowedConfigs.contains(bitmap.getConfig())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">      Log.v(</span><br><span class=\"line\">        TAG,</span><br><span class=\"line\">        <span class=\"string\">&quot;Reject bitmap from pool&quot;</span></span><br><span class=\"line\">        + <span class=\"string\">&quot;, bitmap: &quot;</span></span><br><span class=\"line\">        + strategy.logBitmap(bitmap)</span><br><span class=\"line\">        + <span class=\"string\">&quot;, is mutable: &quot;</span></span><br><span class=\"line\">        + bitmap.isMutable()</span><br><span class=\"line\">        + <span class=\"string\">&quot;, is allowed config: &quot;</span></span><br><span class=\"line\">        + allowedConfigs.contains(bitmap.getConfig()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bitmap.recycle();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> strategy.getSize(bitmap);</span><br><span class=\"line\">  strategy.put(bitmap);</span><br><span class=\"line\">  tracker.add(bitmap);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们可以看出，当Bitmap在三种情况下是不会被BitmapPool缓存起来的：</p>\n<ol>\n<li>这个bitmap是非mutable的，也就是说是不允许被复用的；</li>\n<li>这一个bitmap的字节数大小已经超过了可以容纳的总大小；</li>\n<li>BitmapPool中不允许的Config类型。</li>\n</ol>\n<p>在这种情况，bitmap就被直接recycle掉，而不是放入缓存等待下次使用。</p>\n<p>如果不满足这三种情况，则会被strategy缓存起来，等待下次使用。</p>\n<p>我们再看LruBitmapPool#get()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Bitmap <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> width, <span class=\"type\">int</span> height, Bitmap.Config config)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">Bitmap</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> getDirtyOrNull(width, height, config);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    result.eraseColor(Color.TRANSPARENT);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    result = createBitmap(width, height, config);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，当能够查询到符合条件的Bitmap的时候，会先通过eraseColor方法，将其变成透明图片，然后再交给调用者来使用；如果查询不到，则创建一个新图交给调用者来使用。</p>\n<blockquote>\n<p>LruBitmapPool的LruPoolStrategy变量，在KITKAT以及以上，是SizeConfigStrategy，在以下是AttributeStrategy，这是因为在KITKAT版本以下，Bitmap的复用需要尺寸的严格匹配，但是KITKAT及以上没有这个问题，只要被复用的图片尺寸比目标尺寸大就可以。</p>\n</blockquote>\n<h3 id=\"ArrayPool\"><a href=\"#ArrayPool\" class=\"headerlink\" title=\"ArrayPool\"></a>ArrayPool</h3><p>ArrayPool主要用在<strong>ThumbnailStreamOpener</strong>和<strong>ByteBufferGifDecoder</strong>中，具体的实现类为<strong>LruArrayPool</strong>。</p>\n<p>在LruArrayPool中，通过groupedMap来缓存数据，而缓存数据的byte字节数是通过<strong>ArrayAdapterInterface</strong>来计算的，ArrayAdapterInterface是一个接口，实现类有两个：<strong>IntegerArrayAdapter</strong>和<strong>ByteArrayAdapter</strong>，分别对应缓存int[].class和byte[].class。</p>\n<p>StreamGifDecoder和StreamBitmapDecoder都有一个ArrayPool成员。解码过程中需要用到byte[]，但不是直接new byte[]，而是调用<code>ArrayPool.get()</code>从对象池中拿，用完了归还。</p>\n<h2 id=\"DiskCache\"><a href=\"#DiskCache\" class=\"headerlink\" title=\"DiskCache\"></a>DiskCache</h2><p>在上一章[Glide源码分析与自我实现(一)——数据加载主流程](&#x2F;源码分析系列&#x2F;Glide源码分析与自我实现2.md)中，提到过数据加载的主流程，其中一个非常重要的类是 <strong>DecodeJob</strong>，在这个类的<code>getNextGenerator</code>方法中，返回的<strong>SourceGenerator</strong>会用来加载远程数据，但是这个方法不止返回这一个<strong>DataFetcherGenerator</strong>类，这是一个通过条件判断，返回不同DataFetcherGenerator类的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> DataFetcherGenerator <span class=\"title function_\">getNextGenerator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (stage) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> RESOURCE_CACHE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourceCacheGenerator</span>(decodeHelper, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DATA_CACHE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataCacheGenerator</span>(decodeHelper, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SOURCE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SourceGenerator</span>(decodeHelper, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> FINISHED:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Unrecognized stage: &quot;</span> + stage);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，这是依次递进的<strong>有限状态机</strong>设计模式，当一个获取数据请求到来时候，此时是默认状态INITIALIZE，然后通过<code>getNextStage</code>方法判断下一个状态是什么，再按照新的状态获取DataFetcherGenerator，然后随着任务的执行，不断改变状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Stage <span class=\"title function_\">getNextStage</span><span class=\"params\">(Stage current)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (current) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> INITIALIZE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class=\"line\">        ? Stage.RESOURCE_CACHE</span><br><span class=\"line\">        : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> RESOURCE_CACHE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class=\"line\">        ? Stage.DATA_CACHE</span><br><span class=\"line\">        : getNextStage(Stage.DATA_CACHE);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DATA_CACHE:</span><br><span class=\"line\">      <span class=\"comment\">// Skip loading from source if the user opted to only retrieve the resource from cache.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SOURCE:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> FINISHED:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Stage.FINISHED;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Unrecognized stage: &quot;</span> + current);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其状态变更顺序为INITIALIZE -&gt; RESOURCE_CACHE -&gt; DATA_CACHE -&gt; SOURCE，代表着ResourceCacheGenerator、DataCacheGenerator和SourceGenerator，当从ResourceCahce中拿不到数据，则向DataCacheGenerator请求数据，如果还是拿不到，则通过SourceGenerator去请求数据了。</p>\n<p>在这个过程中，SourceGenerator向DiskCache中写入数据，ResourceCacheGenerator和DataCacheGenerator从DiskCache中读取数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ResourceCacheGenerator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DataFetcherGenerator</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">startNext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      currentKey = <span class=\"keyword\">new</span> <span class=\"title class_\">ResourceCacheKey</span>(sourceId, helper.getSignature(), helper.getWidth(),</span><br><span class=\"line\">          helper.getHeight(), transformation, resourceClass, helper.getOptions());</span><br><span class=\"line\">      cacheFile = helper.getDiskCache().get(currentKey);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cacheFile != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sourceKey = sourceId;</span><br><span class=\"line\">        modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class=\"line\">        modelLoaderIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataCacheGenerator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DataFetcherGenerator</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">startNext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (modelLoaders == <span class=\"literal\">null</span> || !hasNextModelLoader()) &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"type\">Key</span> <span class=\"variable\">sourceId</span> <span class=\"operator\">=</span> cacheKeys.get(sourceIdIndex);</span><br><span class=\"line\">      <span class=\"type\">Key</span> <span class=\"variable\">originalKey</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataCacheKey</span>(sourceId, helper.getSignature());</span><br><span class=\"line\">      cacheFile = helper.getDiskCache().get(originalKey);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cacheFile != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sourceKey = sourceId;</span><br><span class=\"line\">        modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class=\"line\">        modelLoaderIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SourceGenerator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DataFetcherGenerator</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">startNext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dataToCache != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"type\">Object</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> dataToCache;</span><br><span class=\"line\">      dataToCache = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      cacheData(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cacheData</span><span class=\"params\">(Object dataToCache)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</span><br><span class=\"line\">      DataCacheWriter&lt;Object&gt; writer =</span><br><span class=\"line\">          <span class=\"keyword\">new</span> <span class=\"title class_\">DataCacheWriter</span>&lt;&gt;(encoder, dataToCache, helper.getOptions());</span><br><span class=\"line\">      originalKey = <span class=\"keyword\">new</span> <span class=\"title class_\">DataCacheKey</span>(loadData.sourceKey, helper.getSignature());</span><br><span class=\"line\">      helper.getDiskCache().put(originalKey, writer);</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      loadData.fetcher.cleanup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sourceCacheGenerator =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">DataCacheGenerator</span>(Collections.singletonList(loadData.sourceKey), helper, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>DiskCache的默认实现类是<strong>DiskLruCacheWrapper</strong>，其内部通过<strong>DiskLruCache</strong>来管理磁盘缓存。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到现在，Glide主要部分已经分析的差不多了，实际上这个优秀的框架可挖的地方还有很多，比如通过[APT来实现很好的扩展](&#x2F;源码分析系列&#x2F;Glide源码分析与自我实现3.md)，框架中涉及多种涉及模式等。</p>\n<blockquote>\n<p>其中涉及到的涉及模式，比如无处不在的<strong>构建者模式</strong>和<strong>工厂模式</strong>，DecodeJob中的<strong>有限状态机模式</strong>，还有BitmapPool和ArrayPool中的<strong>享元模式</strong>，DiskLruCacheWrapper中的<strong>代理模式</strong>等。</p>\n</blockquote>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://www.sunmoonblog.com/2018/07/27/glide-cache/\">Glide缓存分析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文基于Glide 4.11.0</p>\n</blockquote>\n<p>参考文章：<a href=\"https://zhuanlan.zhihu.com/p/60426316\">Glide 源码分析解读-缓存模块-基于最新版Glide 4.9.0</a></p>\n<p><strong>注意：</strong>由于版本差异问题，本文有些部分与参考文章有差异。</p>\n<p>缓存模块是Glide中非常重要的部分，Glide图片加载的高效性，几乎有一半功劳都在这里了。</p>\n<p>一般来说，Glide有三级缓存，就是<strong>内存缓存</strong>、<strong>磁盘缓存</strong>和<strong>网络缓存</strong>。</p>\n<p>先来看缓存流程图，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">style A fill:#99ccff</span><br><span class=\"line\">style B1 fill:#aaffaa</span><br><span class=\"line\">A(发起请求) --&gt; B&#123;1. 通过&lt;br&gt;ActiveResources&lt;br&gt;获取资源&#125; --&gt; |命中|B1([加载完成]);</span><br><span class=\"line\">B --&gt; |未命中|C&#123;2. 通过&lt;br&gt;MemoryCache&lt;br&gt;获取资源&#125; --&gt; |命中|C1[缓存至&lt;br&gt;ActiveResources] --&gt; B1;</span><br><span class=\"line\">C --&gt; |未命中|D&#123;3. 通过&lt;br&gt;DiskCache&lt;br&gt;获取资源&#125; --&gt; |命中|D1[缓存至&lt;br&gt;MemoryCache] --&gt; C1;</span><br><span class=\"line\">D --&gt; |未命中|E[&quot;4. 通过数据源(网络、文件等)&lt;br&gt;加载数据&quot;] --&gt; E1[缓存至&lt;br&gt;DiskCache] --&gt; D1;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h2><p>内存缓存主要靠三个部分组成：<strong>ActiveResources</strong>、<strong>MemoryCache</strong>和<strong>BitmapPool</strong>。</p>\n<h3 id=\"ActiveResources\"><a href=\"#ActiveResources\" class=\"headerlink\" title=\"ActiveResources\"></a>ActiveResources</h3><p>ActiveResources表示当前正在活动中的资源。ActiveResources通过一个<code>Map&lt;Key, ResourceWeakReference&gt;</code>来保存活动中的资源，其中的ResourceWeakReference就是资源数据，在构建这个ResourceWeakReference的时候必须传入一个ReferenceQueue用来检测资源是否被回收。</p>\n<blockquote>\n<p><strong>Q1：如何探知WeakReference中的值被回收了呢？</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ReferenceQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\"><span class=\"type\">WeakReference</span> <span class=\"variable\">wr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>(value, queue);</span><br></pre></td></tr></table></figure>\n\n<p>当构建WeakReference的时候，如果传入了queue参数，则在value被回收的时候，wr会被加入到queue中去，这样，通过检测queue中是否有值，就可以探知value是否被回收了。</p>\n</blockquote>\n<p>那么，在何时去探知ReferenceQueue中的值呢？我们查看ActiveResources的关键代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*构造方法中，通过monitorClearedResourcesExecutor执行了cleanReferenceQueue()方法。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">ActiveResources(<span class=\"type\">boolean</span> isActiveResourceRetentionAllowed) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>(</span><br><span class=\"line\">    isActiveResourceRetentionAllowed,</span><br><span class=\"line\">    java.util.concurrent.Executors.newSingleThreadExecutor(</span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadFactory</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Thread <span class=\"title function_\">newThread</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> Runnable r)</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class=\"line\">                r.run();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">&quot;glide-active-resources&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@VisibleForTesting</span></span><br><span class=\"line\">ActiveResources(</span><br><span class=\"line\">  <span class=\"type\">boolean</span> isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.monitorClearedResourcesExecutor = monitorClearedResourcesExecutor;</span><br><span class=\"line\"></span><br><span class=\"line\">  monitorClearedResourcesExecutor.execute(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        cleanReferenceQueue();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">cleanReferenceQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!isShutdown) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">ResourceWeakReference</span> <span class=\"variable\">ref</span> <span class=\"operator\">=</span> (ResourceWeakReference) resourceReferenceQueue.remove();</span><br><span class=\"line\">      cleanupActiveReference(ref);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// This section for testing only.</span></span><br><span class=\"line\">      <span class=\"type\">DequeuedResourceCallback</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> cb;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (current != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        current.onResourceDequeued();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// End for testing only.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      Thread.currentThread().interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们通过代码可以看出，<code>cleanReferenceQueue</code>是一个靠<code>isShutdown</code>变量控制的<strong>死循环</strong>方法，这个方法执行在一个优先级为<code>THREAD_PRIORITY_BACKGROUND</code>的线程上。</p>\n<blockquote>\n<p><strong>Q2：那么，既然是死循环方法，会不会过多的占用CPU资源呢？</strong></p>\n<p>其实不会的，因为ReferenceQueue#remove是一个阻塞式的方法，如果没有元素可以被remove，则等待至有元素可以remove的时候，等待期间释放CPU。</p>\n</blockquote>\n<blockquote>\n<p><strong>注意：</strong>此处与<strong>参考文章</strong>中的说法不同，这是因为版本差异。查看<a href=\"https://github.com/bumptech/glide/commit/8f1ea5c07dff7ade8c49c324bcb5a7f40d0b4891#diff-c46e6c0760c04e74cb867c2bdf9cdee90ab279b119268478524c42cc743cb8a9\">Glide update log hsitory</a>，可以看出<strong>出于避免在主线程做清理的原因</strong>，将清理任务放在了后台线程，而不是放在IdleHandler中。</p>\n</blockquote>\n<p><strong>那么被回收了的资源去哪里了呢？</strong></p>\n<p>我们查看<code>cleanupActiveReference</code>方法，得知，通过<em>ResourceListener#onResourceReleased</em>回调，交给了<strong>Engine</strong>来处理，我们查看Engine的onResourceReleased方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onResourceReleased</span><span class=\"params\">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> &#123;</span><br><span class=\"line\">  activeResources.deactivate(cacheKey);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (resource.isMemoryCacheable()) &#123;</span><br><span class=\"line\">    cache.put(cacheKey, resource);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    resourceRecycler.recycle(resource, <span class=\"comment\">/*forceNextFrame=*/</span> <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从这里我们发现，这里出现了两种情况：</p>\n<ol>\n<li>如果资源是<strong>MemoryCacheable</strong>的，则缓存在MemoryCache；</li>\n<li>如果资源不是<strong>MemoryCacheable</strong>的，则交给ResourceRecycler调用Resource的recycle()方法来回收，如果此Resource为BitmapResource，则会将Bitmap回收到BitmapPool中去。</li>\n</ol>\n<p>在开始MemoryCache和BitmapPool前，需要先了解一下<strong>MemorySizeCalculator</strong>这个类，这个类是用来计算 BitmapPool 、ArrayPool 以及 MemoryCache <strong>大小</strong>的。</p>\n<h3 id=\"MemoryCache\"><a href=\"#MemoryCache\" class=\"headerlink\" title=\"MemoryCache\"></a>MemoryCache</h3><p>MemoryCache的具体实现类是LruResourceCache，而实际的逻辑方法，都在其父类LruCache中，以put方法为例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Y <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> T key, <span class=\"meta\">@Nullable</span> Y item)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">itemSize</span> <span class=\"operator\">=</span> getSize(item);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (itemSize &gt;= maxSize) &#123;</span><br><span class=\"line\">    onItemEvicted(key, item);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (item != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    currentSize += itemSize;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span> Entry&lt;Y&gt; old = cache.put(key, item == <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>&lt;&gt;(item, itemSize));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (old != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    currentSize -= old.size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!old.value.equals(item)) &#123;</span><br><span class=\"line\">      onItemEvicted(key, old.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  evict();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> old != <span class=\"literal\">null</span> ? old.value : <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当有一个新的item被put进去以后，会替换出一个老的值old，如果old非为空，则需要将当前容量减去old的大小，如果old并非新的item，则需要通过onItemEvicted进行回调，通知有老值被<strong>“驱逐”</strong>了。最后还要执行一次evict方法，按照LRU算法，将超出maxSize的item<strong>“驱逐”</strong>出去，以确保在maxSize范围内。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">trimToSize</span><span class=\"params\">(<span class=\"type\">long</span> size)</span> &#123;</span><br><span class=\"line\">  Map.Entry&lt;T, Entry&lt;Y&gt;&gt; last;</span><br><span class=\"line\">  Iterator&lt;Map.Entry&lt;T, Entry&lt;Y&gt;&gt;&gt; cacheIterator;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (currentSize &gt; size) &#123;</span><br><span class=\"line\">    cacheIterator = cache.entrySet().iterator();</span><br><span class=\"line\">    last = cacheIterator.next();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Entry&lt;Y&gt; toRemove = last.getValue();</span><br><span class=\"line\">    currentSize -= toRemove.size;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">T</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> last.getKey();</span><br><span class=\"line\">    cacheIterator.remove();</span><br><span class=\"line\">    onItemEvicted(key, toRemove.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">evict</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  trimToSize(maxSize);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>被**”驱逐”*<em>的值去哪里了呢？我们查看</em>MemoryCache<em>类的源码，可以知道是通过</em>ResourceRemovedListener<em>回调给了</em>Engine<em>，在</em>Engine<em>中我们查看</em>onResourceRemoved*方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onResourceRemoved</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> Resource&lt;?&gt; resource)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Avoid deadlock with RequestManagers when recycling triggers recursive clear() calls.</span></span><br><span class=\"line\">  <span class=\"comment\">// See b/145519760.</span></span><br><span class=\"line\">  resourceRecycler.recycle(resource, <span class=\"comment\">/*forceNextFrame=*/</span> <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，这里同样是通过resourceRecycler进行了回收。在这里，则是交给resource自己的recycle()方法来处理，比如，<em>BitmapResource</em>是交给了<em>BitmapPool</em>进行处理。</p>\n<h3 id=\"BitmapPool\"><a href=\"#BitmapPool\" class=\"headerlink\" title=\"BitmapPool\"></a>BitmapPool</h3><p>这里是专门用来存放被回收的Bitmap的，其中<strong>BitmapDrawableResource</strong>、<strong>BitmapResource</strong>都持有一个<strong>BitmapPool</strong>变量，在执行recycle()方法时候，调用*BitmapPool#put()*方法。我们来看一下这个BitmapPool的默认实现类<strong>LruBitmapPool</strong>的方法实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(Bitmap bitmap)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (bitmap == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>(<span class=\"string\">&quot;Bitmap must not be null&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (bitmap.isRecycled()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Cannot pool recycled bitmap&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!bitmap.isMutable()</span><br><span class=\"line\">      || strategy.getSize(bitmap) &gt; maxSize</span><br><span class=\"line\">      || !allowedConfigs.contains(bitmap.getConfig())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">      Log.v(</span><br><span class=\"line\">        TAG,</span><br><span class=\"line\">        <span class=\"string\">&quot;Reject bitmap from pool&quot;</span></span><br><span class=\"line\">        + <span class=\"string\">&quot;, bitmap: &quot;</span></span><br><span class=\"line\">        + strategy.logBitmap(bitmap)</span><br><span class=\"line\">        + <span class=\"string\">&quot;, is mutable: &quot;</span></span><br><span class=\"line\">        + bitmap.isMutable()</span><br><span class=\"line\">        + <span class=\"string\">&quot;, is allowed config: &quot;</span></span><br><span class=\"line\">        + allowedConfigs.contains(bitmap.getConfig()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bitmap.recycle();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> strategy.getSize(bitmap);</span><br><span class=\"line\">  strategy.put(bitmap);</span><br><span class=\"line\">  tracker.add(bitmap);</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们可以看出，当Bitmap在三种情况下是不会被BitmapPool缓存起来的：</p>\n<ol>\n<li>这个bitmap是非mutable的，也就是说是不允许被复用的；</li>\n<li>这一个bitmap的字节数大小已经超过了可以容纳的总大小；</li>\n<li>BitmapPool中不允许的Config类型。</li>\n</ol>\n<p>在这种情况，bitmap就被直接recycle掉，而不是放入缓存等待下次使用。</p>\n<p>如果不满足这三种情况，则会被strategy缓存起来，等待下次使用。</p>\n<p>我们再看LruBitmapPool#get()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Bitmap <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> width, <span class=\"type\">int</span> height, Bitmap.Config config)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">Bitmap</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> getDirtyOrNull(width, height, config);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    result.eraseColor(Color.TRANSPARENT);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    result = createBitmap(width, height, config);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，当能够查询到符合条件的Bitmap的时候，会先通过eraseColor方法，将其变成透明图片，然后再交给调用者来使用；如果查询不到，则创建一个新图交给调用者来使用。</p>\n<blockquote>\n<p>LruBitmapPool的LruPoolStrategy变量，在KITKAT以及以上，是SizeConfigStrategy，在以下是AttributeStrategy，这是因为在KITKAT版本以下，Bitmap的复用需要尺寸的严格匹配，但是KITKAT及以上没有这个问题，只要被复用的图片尺寸比目标尺寸大就可以。</p>\n</blockquote>\n<h3 id=\"ArrayPool\"><a href=\"#ArrayPool\" class=\"headerlink\" title=\"ArrayPool\"></a>ArrayPool</h3><p>ArrayPool主要用在<strong>ThumbnailStreamOpener</strong>和<strong>ByteBufferGifDecoder</strong>中，具体的实现类为<strong>LruArrayPool</strong>。</p>\n<p>在LruArrayPool中，通过groupedMap来缓存数据，而缓存数据的byte字节数是通过<strong>ArrayAdapterInterface</strong>来计算的，ArrayAdapterInterface是一个接口，实现类有两个：<strong>IntegerArrayAdapter</strong>和<strong>ByteArrayAdapter</strong>，分别对应缓存int[].class和byte[].class。</p>\n<p>StreamGifDecoder和StreamBitmapDecoder都有一个ArrayPool成员。解码过程中需要用到byte[]，但不是直接new byte[]，而是调用<code>ArrayPool.get()</code>从对象池中拿，用完了归还。</p>\n<h2 id=\"DiskCache\"><a href=\"#DiskCache\" class=\"headerlink\" title=\"DiskCache\"></a>DiskCache</h2><p>在上一章[Glide源码分析与自我实现(一)——数据加载主流程](&#x2F;源码分析系列&#x2F;Glide源码分析与自我实现2.md)中，提到过数据加载的主流程，其中一个非常重要的类是 <strong>DecodeJob</strong>，在这个类的<code>getNextGenerator</code>方法中，返回的<strong>SourceGenerator</strong>会用来加载远程数据，但是这个方法不止返回这一个<strong>DataFetcherGenerator</strong>类，这是一个通过条件判断，返回不同DataFetcherGenerator类的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> DataFetcherGenerator <span class=\"title function_\">getNextGenerator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (stage) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> RESOURCE_CACHE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResourceCacheGenerator</span>(decodeHelper, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DATA_CACHE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataCacheGenerator</span>(decodeHelper, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SOURCE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SourceGenerator</span>(decodeHelper, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> FINISHED:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Unrecognized stage: &quot;</span> + stage);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，这是依次递进的<strong>有限状态机</strong>设计模式，当一个获取数据请求到来时候，此时是默认状态INITIALIZE，然后通过<code>getNextStage</code>方法判断下一个状态是什么，再按照新的状态获取DataFetcherGenerator，然后随着任务的执行，不断改变状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Stage <span class=\"title function_\">getNextStage</span><span class=\"params\">(Stage current)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (current) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> INITIALIZE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class=\"line\">        ? Stage.RESOURCE_CACHE</span><br><span class=\"line\">        : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> RESOURCE_CACHE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class=\"line\">        ? Stage.DATA_CACHE</span><br><span class=\"line\">        : getNextStage(Stage.DATA_CACHE);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DATA_CACHE:</span><br><span class=\"line\">      <span class=\"comment\">// Skip loading from source if the user opted to only retrieve the resource from cache.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SOURCE:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> FINISHED:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Stage.FINISHED;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Unrecognized stage: &quot;</span> + current);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其状态变更顺序为INITIALIZE -&gt; RESOURCE_CACHE -&gt; DATA_CACHE -&gt; SOURCE，代表着ResourceCacheGenerator、DataCacheGenerator和SourceGenerator，当从ResourceCahce中拿不到数据，则向DataCacheGenerator请求数据，如果还是拿不到，则通过SourceGenerator去请求数据了。</p>\n<p>在这个过程中，SourceGenerator向DiskCache中写入数据，ResourceCacheGenerator和DataCacheGenerator从DiskCache中读取数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ResourceCacheGenerator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DataFetcherGenerator</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">startNext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      currentKey = <span class=\"keyword\">new</span> <span class=\"title class_\">ResourceCacheKey</span>(sourceId, helper.getSignature(), helper.getWidth(),</span><br><span class=\"line\">          helper.getHeight(), transformation, resourceClass, helper.getOptions());</span><br><span class=\"line\">      cacheFile = helper.getDiskCache().get(currentKey);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cacheFile != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sourceKey = sourceId;</span><br><span class=\"line\">        modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class=\"line\">        modelLoaderIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataCacheGenerator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DataFetcherGenerator</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">startNext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (modelLoaders == <span class=\"literal\">null</span> || !hasNextModelLoader()) &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"type\">Key</span> <span class=\"variable\">sourceId</span> <span class=\"operator\">=</span> cacheKeys.get(sourceIdIndex);</span><br><span class=\"line\">      <span class=\"type\">Key</span> <span class=\"variable\">originalKey</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataCacheKey</span>(sourceId, helper.getSignature());</span><br><span class=\"line\">      cacheFile = helper.getDiskCache().get(originalKey);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cacheFile != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sourceKey = sourceId;</span><br><span class=\"line\">        modelLoaders = helper.getModelLoaders(cacheFile);</span><br><span class=\"line\">        modelLoaderIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SourceGenerator</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DataFetcherGenerator</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">startNext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dataToCache != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"type\">Object</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> dataToCache;</span><br><span class=\"line\">      dataToCache = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      cacheData(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cacheData</span><span class=\"params\">(Object dataToCache)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</span><br><span class=\"line\">      DataCacheWriter&lt;Object&gt; writer =</span><br><span class=\"line\">          <span class=\"keyword\">new</span> <span class=\"title class_\">DataCacheWriter</span>&lt;&gt;(encoder, dataToCache, helper.getOptions());</span><br><span class=\"line\">      originalKey = <span class=\"keyword\">new</span> <span class=\"title class_\">DataCacheKey</span>(loadData.sourceKey, helper.getSignature());</span><br><span class=\"line\">      helper.getDiskCache().put(originalKey, writer);</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      loadData.fetcher.cleanup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sourceCacheGenerator =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">DataCacheGenerator</span>(Collections.singletonList(loadData.sourceKey), helper, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>DiskCache的默认实现类是<strong>DiskLruCacheWrapper</strong>，其内部通过<strong>DiskLruCache</strong>来管理磁盘缓存。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到现在，Glide主要部分已经分析的差不多了，实际上这个优秀的框架可挖的地方还有很多，比如通过[APT来实现很好的扩展](&#x2F;源码分析系列&#x2F;Glide源码分析与自我实现3.md)，框架中涉及多种涉及模式等。</p>\n<blockquote>\n<p>其中涉及到的涉及模式，比如无处不在的<strong>构建者模式</strong>和<strong>工厂模式</strong>，DecodeJob中的<strong>有限状态机模式</strong>，还有BitmapPool和ArrayPool中的<strong>享元模式</strong>，DiskLruCacheWrapper中的<strong>代理模式</strong>等。</p>\n</blockquote>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://www.sunmoonblog.com/2018/07/27/glide-cache/\">Glide缓存分析</a></p>\n"},{"layout":"post","title":"Glide源码分析与自我实现(三)——APT的使用与GIF的优化","author":"boybeak","_content":"\n\n项目Demo地址：[GifHelper](https://github.com/boybeak/GifHelper)\n\n**什么是APT？**\n\n**APT**是**Annotation Processing Tool**的简称，即**编译时注解处理器**。它是一个javac的工具，在编译时，通过注解，按照规则自动生成相关代码的工具。\n\n**APT与Glide什么关系？**\n\n我们通常通过在build.gradle加入这样一段代码来引入Glide库。\n\n```groovy\nrepositories {\n  google()\n  jcenter()\n}\n\ndependencies {\n  implementation 'com.github.bumptech.glide:glide:4.11.0'\n  annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'\n}\n```\n\n这里有一个`annotationProcessor`，这就是对Glide提供的APT进行引用。我们查看Glide的源码结构，可以看到一个名为*annotation*的文件夹，这里就是与APT有关的部分。\n\n![Glide Struct](/images/glide_struct.jpg)\n\n接下来我们先通过GIF优化，看一看Glide的APT能实现的神奇效果，在这之后，再来分析Glide是如何通过APT实现的。\n\n> **注意：**如果使用kotlin需要先加入`apply plugin: 'kotlin-kapt'`插件，并且将`annotationProcessor`改成`kapt`。\n\n## GIF优化\n\n**为什么要优化GIF？**\n\n有人可能会有疑问，Glide相比其他图片加载框架的优势之一，就是支持GIF，为什么还要做优化呢？\n\n先看两个截图来对比优化前后的CPU和内存使用情况。\n\n![优化前](/images/gif_before_optimization.png)\n\n![优化后](/images/gif_after_optimization.png)\n\n我们可以看出，优化后，CPU和内存状况都好了很多，那么我们是怎么做的呢？这就需要用到谷歌官方的两个库——[giflib](https://android.googlesource.com/platform/external/giflib/+/refs/heads/master)和[FrameSequence](https://android.googlesource.com/platform/frameworks/ex/+/refs/heads/master/framesequence/)，这两个库需要我们自己编译成.so文件，具体可以参考示例项目[GifHelper](https://github.com/boybeak/GifHelper)。\n\n我们查看GifHolder中的代码。\n\n```kotlin\nclass GifHolder(v: View) : AbsHolder<GifItem>(v) {\n\t...\n  private val gifIV = view<ImageView>(R.id.gifIV)\n  override fun onBind(item: GifItem, position: Int, absAdapter: AnyAdapter) {\n    if (item.useGifX) {\n      // 优化后的加载方式\n    \tGlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)\n    } else {\n      // 优化前的加载方式\n      Glide.with(itemView).asGif().load(item.source()).into(gifIV)\n    }\n    ....\n  }\n}\n```\n\n我们可以看到，加载后有这样一条语句：`GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)`，也许你会懵逼，哪里有GlideApp？哪里有asGifX()方法？我引入Glide后怎么没有看到这两个东西？这就涉及到了APT的内容了。想要看Glide官方文档的可以看[这里](http://bumptech.github.io/glide/doc/configuration.html#glidemodule)。\n\n一切的起因，要从**@GlideModule**这个注解说起，我们打开demo中的MyAppGlideModule类，可以看到这个类有一个@GlideModule注解。\n\n```kotlin\n@GlideModule\nclass MyAppGlideModule : AppGlideModule() {\n  override fun registerComponents(context: Context, glide: Glide, registry: Registry) {\n    super.registerComponents(context, glide, registry)\n    registry.append(Registry.BUCKET_GIF, InputStream::class.java,\n                    FrameSequenceDrawable::class.java, GifDecoder(glide.bitmapPool))\n  }\n}\n```\n\n我们再点开这个注解的源码，如下：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.CLASS)\npublic @interface GlideModule {\n  /**\n   * Returns the name of the class that will be used as a replacement for {@code\n   * com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.\n   */\n  String glideName() default \"GlideApp\";\n}\n```\n\n我们现在看到“GlideApp”了，是glideName这个注解属性的默认值。我们来逐条分析一下这个注解类的相关信息：\n\n- `@Target(ElementType.TYPE)`：指明这个注解的作用对象——只对类生效；\n- `@Retention(RetentionPolicy.CLASS)`：指明了这个注解的作用阶段——编译时记录在class文件中；\n- `public @interface GlideModule`：这是一个注解接口，接口名**GlideModule**；\n- `String glideName() default \"GlideApp\"`：这个注解接口需要一个名为*glideName*的属性，属性默认值为“GlideApp”。\n\n>RetentionPolicy：\n>\n>- **SOURCE**：这样的注解会被编译器擦除，只在编码阶段生效，目的是为了提示开发者，比如**@IntDef**、**@StringDef**、**@Visibility**、**@NonNull**；\n>- **CLASS**：记录在class文件中，编译时对编译器可见，运行时对VM不可见，这是RetentionPolicy的默认值，比如**@NotNull**;\n>- **RUNTIME**：记录在class文件中，在运行时需要反射获取其属性值，比如**@Column**。\n\n就是这个**@GlideModule**属性，为我们生成了GlideApp类，这其中的生成过程，我们稍后再说，先把Gif优化的流程说完。\n\n添加**@GlideModule**后，再次编译看，是否有了GlideApp这个类了。\n\n我们再来看*MyAppGlideModule*中的代码，`registry.append`方法，这是为Glide添加一种解析类型。\n\n```java\n/* \n* @param bucket 要添加的类型id.\n* @param dataClass 要从什么数据进行解析。 ({@link java.io.InputStream}, {@link\n*     java.io.FileDescriptor} etc).\n* @param resourceClass 要解析成什么数据。 ({@link android.graphics.Bitmap},\n*     {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).\n* @param decoder 用什么解码器进行解析 {@link ResourceDecoder}。\n*/\n@NonNull\npublic <Data, TResource> Registry append(\n  @NonNull String bucket,\n  @NonNull Class<Data> dataClass,\n  @NonNull Class<TResource> resourceClass,\n  @NonNull ResourceDecoder<Data, TResource> decoder) {\n  decoderRegistry.append(bucket, decoder, dataClass, resourceClass);\n  return this;\n}\n```\n\n\n\n接下来就要引入谷歌官方的两个类库了，[FrameSquence](https://android.googlesource.com/platform/frameworks/ex/+/android-9.0.0_r16/framesequence/)和[giflib](https://android.googlesource.com/platform/external/giflib/+/android-9.0.0_r16)。大家可以根据需要下载对应版本的库，不过这两个库的版本最好要对应。\n\n下载后需要编译，项目结构参考[GifHelper](https://github.com/boybeak/GifHelper)项目中的framesequence/src/main/jni文件夹。注意，需要将FrameSequence_gif.h中的include部分进行修改。\n\n```diff\n- #include \"config.h\"\n- #include \"gif_lib.h\"\n改成\n+ #include \"giflib/config.h\"\n+ #include \"giflib/gif_lib.h\"\n```\n\n然后执行ndk-build，则会在jni同级的目录下，生成一个libs文件夹，.so文件就在这里。\n\n接下来需要去自定义GifDecoder.java了，直接上代码：\n\n```kotlin\nclass GifDecoder(private val bmpPool: BitmapPool) : ResourceDecoder<InputStream, FrameSequenceDrawable> {\n\n    private val headerParser = DefaultImageHeaderParser()\n\n    override fun handles(source: InputStream, options: Options): Boolean {\n        return !(options.get(GifOptions.DISABLE_ANIMATION) ?: true)\n            && headerParser.getType(source) == ImageHeaderParser.ImageType.GIF\n    }\n\n    override fun decode(\n        source: InputStream,\n        width: Int,\n        height: Int,\n        options: Options\n    ): Resource<FrameSequenceDrawable>? {\n        val fs = FrameSequence.decodeStream(source)\n        val fsd = FrameSequenceDrawable(fs, object : FrameSequenceDrawable.BitmapProvider {\n            override fun acquireBitmap(minWidth: Int, minHeight: Int): Bitmap {\n                return bmpPool.get(minWidth, minHeight, Bitmap.Config.ARGB_8888)\n            }\n\n            override fun releaseBitmap(bitmap: Bitmap?) {\n                bmpPool.put(bitmap)\n            }\n        })\n        return GifResource(fsd)\n    }\n}\n```\n\n这个类里只需要实现两个方法：`handles`和`decode`：\n\n- handles：能否解析该输入源，能则返回true；\n- decode：如果handles返回true，则执行此方法，返回一个Resource对象包裹住目标类型对象。\n\n我们通过Glide自带的*ImageHeaderParser*来检测该输入流是否是gif图像的输入流，如果是且可以执行动画，则进行decode操作。\n\n我们着重看decode方法，这里需要重点看的是，在构建*FrameSequenceDrawable*时候，传入了一个*BitmapProvider*对象，这就是提高Gif效率的关键，在这个*BitmapProvider*里面，我们通过BitmapPool，去寻找可用尺寸的Bitmap，通过**池化**的方式，减小了内存开销，增加里Bitmap利用率。\n\n接下来看，如何添加`asGifX`方法。我们都知道，传统的Glide调用方式如下图：\n\n`Glide.with(itemView).asGif().load(item.source()).into(gifIV)`\n\n```mermaid\ngraph LR;\nA[Glide] -->|\"with(xxx)\"| B[RequestManager] -->|\"asGif\"| C[RequestBuilder];\n```\n\n而新的方式却不同，如下图：\n\n`GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)`\n\n```mermaid\ngraph LR;\nA[GlideApp] -->|\"with(xxx)\"| B[GlideRequests]  -->|asGifX| C[GlideRequest];\n```\n\n这其中的*GlideRequest*和*GlideRequest*，同样都是生成的类，其中GlideRequests继承自RequestManager，GlideRequest继承自RequestBuilder。\n\n这两个类的生成，同样是**@GlideModule**的作用，但是`asGifX`这个方法是什么时候定义的呢？我们去查看`asGifX`这个方法的代码：\n\n```java\n/**\n* @see GifExtension#asGifX(RequestBuilder)\n*/\n@NonNull\n@CheckResult\npublic GlideRequest<FrameSequenceDrawable> asGifX() {\n  return (GlideRequest<FrameSequenceDrawable>) GifExtension.asGifX(this.as(FrameSequenceDrawable.class));\n}\n```\n\n我们看到实际上这个类的具体实现，是依靠GifExtension类，我们去看这个类的代码：\n\n```java\n@GlideExtension\npublic class GifExtension {\n    @NonNull\n    @GlideType(FrameSequenceDrawable.class)\n    public static RequestBuilder<FrameSequenceDrawable> asGifX(RequestBuilder<FrameSequenceDrawable> requestBuilder) {\n        return requestBuilder.apply(RequestOptions\n                .decodeTypeOf(FrameSequenceDrawable.class)\n                .lock());\n    }\n    private GifExtension(){}\n}\n```\n\n这个类需要我们自己实现，并且需要标记**@GlideExtension**注解，又是注解的功劳。\n\n到此为止，Gif优化的主流程就全部讲完了，接下来就要看这两个注解——**@GlideModule**和**@GlideExtension**到底做了什么？\n\n\n\n## @GlideModule和@GlideExtension\n\n源码在Glide项目的annotation/compiler内，这种APT项目的入口文件标记在src/main/resources/META-INF/gradle内，这其中有一个incremental.annotation.processors文件，我们查看其内容：\n\n```\ncom.bumptech.glide.annotation.compiler.GlideAnnotationProcessor,aggregating\n```\n\n可以得知，程序入口在GlideAnnotationProcessor这个类，查看这个类的源码，我只提取了关键部分：\n\n```java\npublic final class GlideAnnotationProcessor extends AbstractProcessor {\n  ...\n  private LibraryModuleProcessor libraryModuleProcessor;\n  private AppModuleProcessor appModuleProcessor;\n  private boolean isGeneratedAppGlideModuleWritten;\n  private ExtensionProcessor extensionProcessor;\n  ...\n  @Override\n  public Set<String> getSupportedAnnotationTypes() {\n    Set<String> result = new HashSet<>();\n    result.addAll(libraryModuleProcessor.getSupportedAnnotationTypes());\n    result.addAll(extensionProcessor.getSupportedAnnotationTypes());\n    return result;\n  }\n  @Override\n  public boolean process(Set<? extends TypeElement> set, RoundEnvironment env) {\n    processorUtil.process();\n    boolean newModulesWritten = libraryModuleProcessor.processModules(env);\n    boolean newExtensionWritten = extensionProcessor.processExtensions(env);\n    appModuleProcessor.processModules(set, env);\n\n    if (newExtensionWritten || newModulesWritten) {\n      if (isGeneratedAppGlideModuleWritten) {\n        throw new IllegalStateException(\"Cannot process annotations after writing AppGlideModule\");\n      }\n      return false;\n    }\n\n    if (!isGeneratedAppGlideModuleWritten) {\n      isGeneratedAppGlideModuleWritten = appModuleProcessor.maybeWriteAppModule();\n    }\n    return false;\n  }\n}\n```\n\n- `getSupportedAnnotationTypes`方法中标记了，支持哪些注解的解析，其中`libraryModuleProcessor.getSupportedAnnotationTypes()`中返回了**@GlideModule**，`extensionProcessor.getSupportedAnnotationTypes()`中返回了**@GlideExtension**。\n- process方法中开始了对注解的处理。\n\n注解的处理，需要你对[**javapoet**](https://github.com/square/javapoet)有一点点了解，如果暂时不想去了解，你只需要知道，这个类库是通过字符串和占位符来生成Java代码的工具类库，因为接下来的生成代码工作，Glide就是通过这个类库来实现的。\n\n具体的生成过程不再赘述，从入口类*GlideAnnotationProcessor*追踪下去，就能看到。\n\n\n\n## 为什么优化能提高效率？\n\nGlide默认Gif加载方案，是通过GifDrawable来实现的，而GifDrawable是通过GifFrameLoader来加载帧数据的。具体代码分析可以看参考文章，我这里简单来说一下原因：\n\n- 默认方案是串行执行的，比如在加载显示第N帧，这一帧显示完毕，再去解析第N+1帧，当播放第N+1帧的时间窗口到了以后，如果已经解析完毕，则能正常显示，如果不能解析完毕，则会卡顿了；\n- GifFrameLoader内部是用了一个mainLooper的handler来进行流程控制，具体可以看GifFrameLoader里的代码，这种方式本身在时间上就不是准时的，与应用内其他各种系统共享mainLooper，如果其他事件执行占用时间较长，也会影响这里的效率了。\n\n我们再来说说优化方案，优化的原因也简单说一下：\n\n- 优化方案是**并行+双缓冲**执行的，在显示第N帧的BitmapA同时，会有一个后台线程在解析第N+1帧的BitmapB，当需要显示第N+1帧BitmapB的时候，两帧的Bitmap交换，BitmapA则进入后台线程去解析第N+2帧了；\n- 在native去解析数据，效率更高；\n- 通过BitmapPool提高了内存利用率。\n\n借用参考文章里的一张图\n\n![Gif](/images/gif.webp)\n\n## 参考文章\n\n[Glide加载Gif的卡顿优化思路分析](https://juejin.im/post/6854573219425288199)","source":"_posts/2022-09-17-Glide源码分析与自我实现3.md","raw":"---\nlayout: post\ntitle: Glide源码分析与自我实现(三)——APT的使用与GIF的优化\nauthor: boybeak\ncategory: 源码分析\ntags: Android\n---\n\n\n项目Demo地址：[GifHelper](https://github.com/boybeak/GifHelper)\n\n**什么是APT？**\n\n**APT**是**Annotation Processing Tool**的简称，即**编译时注解处理器**。它是一个javac的工具，在编译时，通过注解，按照规则自动生成相关代码的工具。\n\n**APT与Glide什么关系？**\n\n我们通常通过在build.gradle加入这样一段代码来引入Glide库。\n\n```groovy\nrepositories {\n  google()\n  jcenter()\n}\n\ndependencies {\n  implementation 'com.github.bumptech.glide:glide:4.11.0'\n  annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'\n}\n```\n\n这里有一个`annotationProcessor`，这就是对Glide提供的APT进行引用。我们查看Glide的源码结构，可以看到一个名为*annotation*的文件夹，这里就是与APT有关的部分。\n\n![Glide Struct](/images/glide_struct.jpg)\n\n接下来我们先通过GIF优化，看一看Glide的APT能实现的神奇效果，在这之后，再来分析Glide是如何通过APT实现的。\n\n> **注意：**如果使用kotlin需要先加入`apply plugin: 'kotlin-kapt'`插件，并且将`annotationProcessor`改成`kapt`。\n\n## GIF优化\n\n**为什么要优化GIF？**\n\n有人可能会有疑问，Glide相比其他图片加载框架的优势之一，就是支持GIF，为什么还要做优化呢？\n\n先看两个截图来对比优化前后的CPU和内存使用情况。\n\n![优化前](/images/gif_before_optimization.png)\n\n![优化后](/images/gif_after_optimization.png)\n\n我们可以看出，优化后，CPU和内存状况都好了很多，那么我们是怎么做的呢？这就需要用到谷歌官方的两个库——[giflib](https://android.googlesource.com/platform/external/giflib/+/refs/heads/master)和[FrameSequence](https://android.googlesource.com/platform/frameworks/ex/+/refs/heads/master/framesequence/)，这两个库需要我们自己编译成.so文件，具体可以参考示例项目[GifHelper](https://github.com/boybeak/GifHelper)。\n\n我们查看GifHolder中的代码。\n\n```kotlin\nclass GifHolder(v: View) : AbsHolder<GifItem>(v) {\n\t...\n  private val gifIV = view<ImageView>(R.id.gifIV)\n  override fun onBind(item: GifItem, position: Int, absAdapter: AnyAdapter) {\n    if (item.useGifX) {\n      // 优化后的加载方式\n    \tGlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)\n    } else {\n      // 优化前的加载方式\n      Glide.with(itemView).asGif().load(item.source()).into(gifIV)\n    }\n    ....\n  }\n}\n```\n\n我们可以看到，加载后有这样一条语句：`GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)`，也许你会懵逼，哪里有GlideApp？哪里有asGifX()方法？我引入Glide后怎么没有看到这两个东西？这就涉及到了APT的内容了。想要看Glide官方文档的可以看[这里](http://bumptech.github.io/glide/doc/configuration.html#glidemodule)。\n\n一切的起因，要从**@GlideModule**这个注解说起，我们打开demo中的MyAppGlideModule类，可以看到这个类有一个@GlideModule注解。\n\n```kotlin\n@GlideModule\nclass MyAppGlideModule : AppGlideModule() {\n  override fun registerComponents(context: Context, glide: Glide, registry: Registry) {\n    super.registerComponents(context, glide, registry)\n    registry.append(Registry.BUCKET_GIF, InputStream::class.java,\n                    FrameSequenceDrawable::class.java, GifDecoder(glide.bitmapPool))\n  }\n}\n```\n\n我们再点开这个注解的源码，如下：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.CLASS)\npublic @interface GlideModule {\n  /**\n   * Returns the name of the class that will be used as a replacement for {@code\n   * com.bumptech.glide.Glide} in Applications that depend on Glide's generated code.\n   */\n  String glideName() default \"GlideApp\";\n}\n```\n\n我们现在看到“GlideApp”了，是glideName这个注解属性的默认值。我们来逐条分析一下这个注解类的相关信息：\n\n- `@Target(ElementType.TYPE)`：指明这个注解的作用对象——只对类生效；\n- `@Retention(RetentionPolicy.CLASS)`：指明了这个注解的作用阶段——编译时记录在class文件中；\n- `public @interface GlideModule`：这是一个注解接口，接口名**GlideModule**；\n- `String glideName() default \"GlideApp\"`：这个注解接口需要一个名为*glideName*的属性，属性默认值为“GlideApp”。\n\n>RetentionPolicy：\n>\n>- **SOURCE**：这样的注解会被编译器擦除，只在编码阶段生效，目的是为了提示开发者，比如**@IntDef**、**@StringDef**、**@Visibility**、**@NonNull**；\n>- **CLASS**：记录在class文件中，编译时对编译器可见，运行时对VM不可见，这是RetentionPolicy的默认值，比如**@NotNull**;\n>- **RUNTIME**：记录在class文件中，在运行时需要反射获取其属性值，比如**@Column**。\n\n就是这个**@GlideModule**属性，为我们生成了GlideApp类，这其中的生成过程，我们稍后再说，先把Gif优化的流程说完。\n\n添加**@GlideModule**后，再次编译看，是否有了GlideApp这个类了。\n\n我们再来看*MyAppGlideModule*中的代码，`registry.append`方法，这是为Glide添加一种解析类型。\n\n```java\n/* \n* @param bucket 要添加的类型id.\n* @param dataClass 要从什么数据进行解析。 ({@link java.io.InputStream}, {@link\n*     java.io.FileDescriptor} etc).\n* @param resourceClass 要解析成什么数据。 ({@link android.graphics.Bitmap},\n*     {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).\n* @param decoder 用什么解码器进行解析 {@link ResourceDecoder}。\n*/\n@NonNull\npublic <Data, TResource> Registry append(\n  @NonNull String bucket,\n  @NonNull Class<Data> dataClass,\n  @NonNull Class<TResource> resourceClass,\n  @NonNull ResourceDecoder<Data, TResource> decoder) {\n  decoderRegistry.append(bucket, decoder, dataClass, resourceClass);\n  return this;\n}\n```\n\n\n\n接下来就要引入谷歌官方的两个类库了，[FrameSquence](https://android.googlesource.com/platform/frameworks/ex/+/android-9.0.0_r16/framesequence/)和[giflib](https://android.googlesource.com/platform/external/giflib/+/android-9.0.0_r16)。大家可以根据需要下载对应版本的库，不过这两个库的版本最好要对应。\n\n下载后需要编译，项目结构参考[GifHelper](https://github.com/boybeak/GifHelper)项目中的framesequence/src/main/jni文件夹。注意，需要将FrameSequence_gif.h中的include部分进行修改。\n\n```diff\n- #include \"config.h\"\n- #include \"gif_lib.h\"\n改成\n+ #include \"giflib/config.h\"\n+ #include \"giflib/gif_lib.h\"\n```\n\n然后执行ndk-build，则会在jni同级的目录下，生成一个libs文件夹，.so文件就在这里。\n\n接下来需要去自定义GifDecoder.java了，直接上代码：\n\n```kotlin\nclass GifDecoder(private val bmpPool: BitmapPool) : ResourceDecoder<InputStream, FrameSequenceDrawable> {\n\n    private val headerParser = DefaultImageHeaderParser()\n\n    override fun handles(source: InputStream, options: Options): Boolean {\n        return !(options.get(GifOptions.DISABLE_ANIMATION) ?: true)\n            && headerParser.getType(source) == ImageHeaderParser.ImageType.GIF\n    }\n\n    override fun decode(\n        source: InputStream,\n        width: Int,\n        height: Int,\n        options: Options\n    ): Resource<FrameSequenceDrawable>? {\n        val fs = FrameSequence.decodeStream(source)\n        val fsd = FrameSequenceDrawable(fs, object : FrameSequenceDrawable.BitmapProvider {\n            override fun acquireBitmap(minWidth: Int, minHeight: Int): Bitmap {\n                return bmpPool.get(minWidth, minHeight, Bitmap.Config.ARGB_8888)\n            }\n\n            override fun releaseBitmap(bitmap: Bitmap?) {\n                bmpPool.put(bitmap)\n            }\n        })\n        return GifResource(fsd)\n    }\n}\n```\n\n这个类里只需要实现两个方法：`handles`和`decode`：\n\n- handles：能否解析该输入源，能则返回true；\n- decode：如果handles返回true，则执行此方法，返回一个Resource对象包裹住目标类型对象。\n\n我们通过Glide自带的*ImageHeaderParser*来检测该输入流是否是gif图像的输入流，如果是且可以执行动画，则进行decode操作。\n\n我们着重看decode方法，这里需要重点看的是，在构建*FrameSequenceDrawable*时候，传入了一个*BitmapProvider*对象，这就是提高Gif效率的关键，在这个*BitmapProvider*里面，我们通过BitmapPool，去寻找可用尺寸的Bitmap，通过**池化**的方式，减小了内存开销，增加里Bitmap利用率。\n\n接下来看，如何添加`asGifX`方法。我们都知道，传统的Glide调用方式如下图：\n\n`Glide.with(itemView).asGif().load(item.source()).into(gifIV)`\n\n```mermaid\ngraph LR;\nA[Glide] -->|\"with(xxx)\"| B[RequestManager] -->|\"asGif\"| C[RequestBuilder];\n```\n\n而新的方式却不同，如下图：\n\n`GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)`\n\n```mermaid\ngraph LR;\nA[GlideApp] -->|\"with(xxx)\"| B[GlideRequests]  -->|asGifX| C[GlideRequest];\n```\n\n这其中的*GlideRequest*和*GlideRequest*，同样都是生成的类，其中GlideRequests继承自RequestManager，GlideRequest继承自RequestBuilder。\n\n这两个类的生成，同样是**@GlideModule**的作用，但是`asGifX`这个方法是什么时候定义的呢？我们去查看`asGifX`这个方法的代码：\n\n```java\n/**\n* @see GifExtension#asGifX(RequestBuilder)\n*/\n@NonNull\n@CheckResult\npublic GlideRequest<FrameSequenceDrawable> asGifX() {\n  return (GlideRequest<FrameSequenceDrawable>) GifExtension.asGifX(this.as(FrameSequenceDrawable.class));\n}\n```\n\n我们看到实际上这个类的具体实现，是依靠GifExtension类，我们去看这个类的代码：\n\n```java\n@GlideExtension\npublic class GifExtension {\n    @NonNull\n    @GlideType(FrameSequenceDrawable.class)\n    public static RequestBuilder<FrameSequenceDrawable> asGifX(RequestBuilder<FrameSequenceDrawable> requestBuilder) {\n        return requestBuilder.apply(RequestOptions\n                .decodeTypeOf(FrameSequenceDrawable.class)\n                .lock());\n    }\n    private GifExtension(){}\n}\n```\n\n这个类需要我们自己实现，并且需要标记**@GlideExtension**注解，又是注解的功劳。\n\n到此为止，Gif优化的主流程就全部讲完了，接下来就要看这两个注解——**@GlideModule**和**@GlideExtension**到底做了什么？\n\n\n\n## @GlideModule和@GlideExtension\n\n源码在Glide项目的annotation/compiler内，这种APT项目的入口文件标记在src/main/resources/META-INF/gradle内，这其中有一个incremental.annotation.processors文件，我们查看其内容：\n\n```\ncom.bumptech.glide.annotation.compiler.GlideAnnotationProcessor,aggregating\n```\n\n可以得知，程序入口在GlideAnnotationProcessor这个类，查看这个类的源码，我只提取了关键部分：\n\n```java\npublic final class GlideAnnotationProcessor extends AbstractProcessor {\n  ...\n  private LibraryModuleProcessor libraryModuleProcessor;\n  private AppModuleProcessor appModuleProcessor;\n  private boolean isGeneratedAppGlideModuleWritten;\n  private ExtensionProcessor extensionProcessor;\n  ...\n  @Override\n  public Set<String> getSupportedAnnotationTypes() {\n    Set<String> result = new HashSet<>();\n    result.addAll(libraryModuleProcessor.getSupportedAnnotationTypes());\n    result.addAll(extensionProcessor.getSupportedAnnotationTypes());\n    return result;\n  }\n  @Override\n  public boolean process(Set<? extends TypeElement> set, RoundEnvironment env) {\n    processorUtil.process();\n    boolean newModulesWritten = libraryModuleProcessor.processModules(env);\n    boolean newExtensionWritten = extensionProcessor.processExtensions(env);\n    appModuleProcessor.processModules(set, env);\n\n    if (newExtensionWritten || newModulesWritten) {\n      if (isGeneratedAppGlideModuleWritten) {\n        throw new IllegalStateException(\"Cannot process annotations after writing AppGlideModule\");\n      }\n      return false;\n    }\n\n    if (!isGeneratedAppGlideModuleWritten) {\n      isGeneratedAppGlideModuleWritten = appModuleProcessor.maybeWriteAppModule();\n    }\n    return false;\n  }\n}\n```\n\n- `getSupportedAnnotationTypes`方法中标记了，支持哪些注解的解析，其中`libraryModuleProcessor.getSupportedAnnotationTypes()`中返回了**@GlideModule**，`extensionProcessor.getSupportedAnnotationTypes()`中返回了**@GlideExtension**。\n- process方法中开始了对注解的处理。\n\n注解的处理，需要你对[**javapoet**](https://github.com/square/javapoet)有一点点了解，如果暂时不想去了解，你只需要知道，这个类库是通过字符串和占位符来生成Java代码的工具类库，因为接下来的生成代码工作，Glide就是通过这个类库来实现的。\n\n具体的生成过程不再赘述，从入口类*GlideAnnotationProcessor*追踪下去，就能看到。\n\n\n\n## 为什么优化能提高效率？\n\nGlide默认Gif加载方案，是通过GifDrawable来实现的，而GifDrawable是通过GifFrameLoader来加载帧数据的。具体代码分析可以看参考文章，我这里简单来说一下原因：\n\n- 默认方案是串行执行的，比如在加载显示第N帧，这一帧显示完毕，再去解析第N+1帧，当播放第N+1帧的时间窗口到了以后，如果已经解析完毕，则能正常显示，如果不能解析完毕，则会卡顿了；\n- GifFrameLoader内部是用了一个mainLooper的handler来进行流程控制，具体可以看GifFrameLoader里的代码，这种方式本身在时间上就不是准时的，与应用内其他各种系统共享mainLooper，如果其他事件执行占用时间较长，也会影响这里的效率了。\n\n我们再来说说优化方案，优化的原因也简单说一下：\n\n- 优化方案是**并行+双缓冲**执行的，在显示第N帧的BitmapA同时，会有一个后台线程在解析第N+1帧的BitmapB，当需要显示第N+1帧BitmapB的时候，两帧的Bitmap交换，BitmapA则进入后台线程去解析第N+2帧了；\n- 在native去解析数据，效率更高；\n- 通过BitmapPool提高了内存利用率。\n\n借用参考文章里的一张图\n\n![Gif](/images/gif.webp)\n\n## 参考文章\n\n[Glide加载Gif的卡顿优化思路分析](https://juejin.im/post/6854573219425288199)","slug":"2022-09-17-Glide源码分析与自我实现3","published":1,"date":"2020-12-27T15:19:52.000Z","updated":"2023-02-05T04:16:04.337Z","_id":"cldqukh830005pcjg58g70mq2","comments":1,"photos":[],"link":"","content":"<p>项目Demo地址：<a href=\"https://github.com/boybeak/GifHelper\">GifHelper</a></p>\n<p><strong>什么是APT？</strong></p>\n<p><strong>APT</strong>是<strong>Annotation Processing Tool</strong>的简称，即<strong>编译时注解处理器</strong>。它是一个javac的工具，在编译时，通过注解，按照规则自动生成相关代码的工具。</p>\n<p><strong>APT与Glide什么关系？</strong></p>\n<p>我们通常通过在build.gradle加入这样一段代码来引入Glide库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repositories &#123;</span><br><span class=\"line\">  google()</span><br><span class=\"line\">  jcenter()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  implementation <span class=\"string\">&#x27;com.github.bumptech.glide:glide:4.11.0&#x27;</span></span><br><span class=\"line\">  annotationProcessor <span class=\"string\">&#x27;com.github.bumptech.glide:compiler:4.11.0&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有一个<code>annotationProcessor</code>，这就是对Glide提供的APT进行引用。我们查看Glide的源码结构，可以看到一个名为<em>annotation</em>的文件夹，这里就是与APT有关的部分。</p>\n<p><img src=\"/images/glide_struct.jpg\" alt=\"Glide Struct\"></p>\n<p>接下来我们先通过GIF优化，看一看Glide的APT能实现的神奇效果，在这之后，再来分析Glide是如何通过APT实现的。</p>\n<blockquote>\n<p><strong>注意：</strong>如果使用kotlin需要先加入<code>apply plugin: &#39;kotlin-kapt&#39;</code>插件，并且将<code>annotationProcessor</code>改成<code>kapt</code>。</p>\n</blockquote>\n<h2 id=\"GIF优化\"><a href=\"#GIF优化\" class=\"headerlink\" title=\"GIF优化\"></a>GIF优化</h2><p><strong>为什么要优化GIF？</strong></p>\n<p>有人可能会有疑问，Glide相比其他图片加载框架的优势之一，就是支持GIF，为什么还要做优化呢？</p>\n<p>先看两个截图来对比优化前后的CPU和内存使用情况。</p>\n<p><img src=\"/images/gif_before_optimization.png\" alt=\"优化前\"></p>\n<p><img src=\"/images/gif_after_optimization.png\" alt=\"优化后\"></p>\n<p>我们可以看出，优化后，CPU和内存状况都好了很多，那么我们是怎么做的呢？这就需要用到谷歌官方的两个库——<a href=\"https://android.googlesource.com/platform/external/giflib/+/refs/heads/master\">giflib</a>和<a href=\"https://android.googlesource.com/platform/frameworks/ex/+/refs/heads/master/framesequence/\">FrameSequence</a>，这两个库需要我们自己编译成.so文件，具体可以参考示例项目<a href=\"https://github.com/boybeak/GifHelper\">GifHelper</a>。</p>\n<p>我们查看GifHolder中的代码。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GifHolder</span>(v: View) : AbsHolder&lt;GifItem&gt;(v) &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> gifIV = view&lt;ImageView&gt;(R.id.gifIV)</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onBind</span><span class=\"params\">(item: <span class=\"type\">GifItem</span>, position: <span class=\"type\">Int</span>, absAdapter: <span class=\"type\">AnyAdapter</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item.useGifX) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 优化后的加载方式</span></span><br><span class=\"line\">    \tGlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 优化前的加载方式</span></span><br><span class=\"line\">      Glide.with(itemView).asGif().load(item.source()).into(gifIV)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，加载后有这样一条语句：<code>GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</code>，也许你会懵逼，哪里有GlideApp？哪里有asGifX()方法？我引入Glide后怎么没有看到这两个东西？这就涉及到了APT的内容了。想要看Glide官方文档的可以看<a href=\"http://bumptech.github.io/glide/doc/configuration.html#glidemodule\">这里</a>。</p>\n<p>一切的起因，要从**@GlideModule**这个注解说起，我们打开demo中的MyAppGlideModule类，可以看到这个类有一个@GlideModule注解。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GlideModule</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyAppGlideModule</span> : <span class=\"type\">AppGlideModule</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">registerComponents</span><span class=\"params\">(context: <span class=\"type\">Context</span>, glide: <span class=\"type\">Glide</span>, registry: <span class=\"type\">Registry</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.registerComponents(context, glide, registry)</span><br><span class=\"line\">    registry.append(Registry.BUCKET_GIF, InputStream::<span class=\"keyword\">class</span>.java,</span><br><span class=\"line\">                    FrameSequenceDrawable::<span class=\"keyword\">class</span>.java, GifDecoder(glide.bitmapPool))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再点开这个注解的源码，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.CLASS)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> GlideModule &#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Returns the name of the class that will be used as a replacement for &#123;<span class=\"doctag\">@code</span></span></span><br><span class=\"line\"><span class=\"comment\">   * com.bumptech.glide.Glide&#125; in Applications that depend on Glide&#x27;s generated code.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  String <span class=\"title function_\">glideName</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;GlideApp&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们现在看到“GlideApp”了，是glideName这个注解属性的默认值。我们来逐条分析一下这个注解类的相关信息：</p>\n<ul>\n<li><code>@Target(ElementType.TYPE)</code>：指明这个注解的作用对象——只对类生效；</li>\n<li><code>@Retention(RetentionPolicy.CLASS)</code>：指明了这个注解的作用阶段——编译时记录在class文件中；</li>\n<li><code>public @interface GlideModule</code>：这是一个注解接口，接口名<strong>GlideModule</strong>；</li>\n<li><code>String glideName() default &quot;GlideApp&quot;</code>：这个注解接口需要一个名为<em>glideName</em>的属性，属性默认值为“GlideApp”。</li>\n</ul>\n<blockquote>\n<p>RetentionPolicy：</p>\n<ul>\n<li><strong>SOURCE</strong>：这样的注解会被编译器擦除，只在编码阶段生效，目的是为了提示开发者，比如**@IntDef<strong>、</strong>@StringDef<strong>、</strong>@Visibility<strong>、</strong>@NonNull**；</li>\n<li><strong>CLASS</strong>：记录在class文件中，编译时对编译器可见，运行时对VM不可见，这是RetentionPolicy的默认值，比如**@NotNull**;</li>\n<li><strong>RUNTIME</strong>：记录在class文件中，在运行时需要反射获取其属性值，比如**@Column**。</li>\n</ul>\n</blockquote>\n<p>就是这个**@GlideModule**属性，为我们生成了GlideApp类，这其中的生成过程，我们稍后再说，先把Gif优化的流程说完。</p>\n<p>添加**@GlideModule**后，再次编译看，是否有了GlideApp这个类了。</p>\n<p>我们再来看<em>MyAppGlideModule</em>中的代码，<code>registry.append</code>方法，这是为Glide添加一种解析类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">* @param bucket 要添加的类型id.</span></span><br><span class=\"line\"><span class=\"comment\">* @param dataClass 要从什么数据进行解析。 (&#123;@link java.io.InputStream&#125;, &#123;@link</span></span><br><span class=\"line\"><span class=\"comment\">*     java.io.FileDescriptor&#125; etc).</span></span><br><span class=\"line\"><span class=\"comment\">* @param resourceClass 要解析成什么数据。 (&#123;@link android.graphics.Bitmap&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">*     &#123;@link com.bumptech.glide.load.resource.gif.GifDrawable&#125; etc).</span></span><br><span class=\"line\"><span class=\"comment\">* @param decoder 用什么解码器进行解析 &#123;@link ResourceDecoder&#125;。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;Data, TResource&gt; Registry <span class=\"title function_\">append</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> String bucket,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> Class&lt;Data&gt; dataClass,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> Class&lt;TResource&gt; resourceClass,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> ResourceDecoder&lt;Data, TResource&gt; decoder)</span> &#123;</span><br><span class=\"line\">  decoderRegistry.append(bucket, decoder, dataClass, resourceClass);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来就要引入谷歌官方的两个类库了，<a href=\"https://android.googlesource.com/platform/frameworks/ex/+/android-9.0.0_r16/framesequence/\">FrameSquence</a>和<a href=\"https://android.googlesource.com/platform/external/giflib/+/android-9.0.0_r16\">giflib</a>。大家可以根据需要下载对应版本的库，不过这两个库的版本最好要对应。</p>\n<p>下载后需要编译，项目结构参考<a href=\"https://github.com/boybeak/GifHelper\">GifHelper</a>项目中的framesequence&#x2F;src&#x2F;main&#x2F;jni文件夹。注意，需要将FrameSequence_gif.h中的include部分进行修改。</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">- #include &quot;config.h&quot;</span></span><br><span class=\"line\"><span class=\"deletion\">- #include &quot;gif_lib.h&quot;</span></span><br><span class=\"line\">改成</span><br><span class=\"line\"><span class=\"addition\">+ #include &quot;giflib/config.h&quot;</span></span><br><span class=\"line\"><span class=\"addition\">+ #include &quot;giflib/gif_lib.h&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后执行ndk-build，则会在jni同级的目录下，生成一个libs文件夹，.so文件就在这里。</p>\n<p>接下来需要去自定义GifDecoder.java了，直接上代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GifDecoder</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> bmpPool: BitmapPool) : ResourceDecoder&lt;InputStream, FrameSequenceDrawable&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> headerParser = DefaultImageHeaderParser()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">handles</span><span class=\"params\">(source: <span class=\"type\">InputStream</span>, options: <span class=\"type\">Options</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !(options.<span class=\"keyword\">get</span>(GifOptions.DISABLE_ANIMATION) ?: <span class=\"literal\">true</span>)</span><br><span class=\"line\">            &amp;&amp; headerParser.getType(source) == ImageHeaderParser.ImageType.GIF</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">decode</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        source: <span class=\"type\">InputStream</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        width: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        height: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        options: <span class=\"type\">Options</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: Resource&lt;FrameSequenceDrawable&gt;? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> fs = FrameSequence.decodeStream(source)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> fsd = FrameSequenceDrawable(fs, <span class=\"keyword\">object</span> : FrameSequenceDrawable.BitmapProvider &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">acquireBitmap</span><span class=\"params\">(minWidth: <span class=\"type\">Int</span>, minHeight: <span class=\"type\">Int</span>)</span></span>: Bitmap &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> bmpPool.<span class=\"keyword\">get</span>(minWidth, minHeight, Bitmap.Config.ARGB_8888)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">releaseBitmap</span><span class=\"params\">(bitmap: <span class=\"type\">Bitmap</span>?)</span></span> &#123;</span><br><span class=\"line\">                bmpPool.put(bitmap)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> GifResource(fsd)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类里只需要实现两个方法：<code>handles</code>和<code>decode</code>：</p>\n<ul>\n<li>handles：能否解析该输入源，能则返回true；</li>\n<li>decode：如果handles返回true，则执行此方法，返回一个Resource对象包裹住目标类型对象。</li>\n</ul>\n<p>我们通过Glide自带的<em>ImageHeaderParser</em>来检测该输入流是否是gif图像的输入流，如果是且可以执行动画，则进行decode操作。</p>\n<p>我们着重看decode方法，这里需要重点看的是，在构建<em>FrameSequenceDrawable</em>时候，传入了一个<em>BitmapProvider</em>对象，这就是提高Gif效率的关键，在这个<em>BitmapProvider</em>里面，我们通过BitmapPool，去寻找可用尺寸的Bitmap，通过<strong>池化</strong>的方式，减小了内存开销，增加里Bitmap利用率。</p>\n<p>接下来看，如何添加<code>asGifX</code>方法。我们都知道，传统的Glide调用方式如下图：</p>\n<p><code>Glide.with(itemView).asGif().load(item.source()).into(gifIV)</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">A[Glide] --&gt;|&quot;with(xxx)&quot;| B[RequestManager] --&gt;|&quot;asGif&quot;| C[RequestBuilder];</span><br></pre></td></tr></table></figure>\n\n<p>而新的方式却不同，如下图：</p>\n<p><code>GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">A[GlideApp] --&gt;|&quot;with(xxx)&quot;| B[GlideRequests]  --&gt;|asGifX| C[GlideRequest];</span><br></pre></td></tr></table></figure>\n\n<p>这其中的<em>GlideRequest</em>和<em>GlideRequest</em>，同样都是生成的类，其中GlideRequests继承自RequestManager，GlideRequest继承自RequestBuilder。</p>\n<p>这两个类的生成，同样是**@GlideModule**的作用，但是<code>asGifX</code>这个方法是什么时候定义的呢？我们去查看<code>asGifX</code>这个方法的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@see</span> GifExtension#asGifX(RequestBuilder)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@CheckResult</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> GlideRequest&lt;FrameSequenceDrawable&gt; <span class=\"title function_\">asGifX</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (GlideRequest&lt;FrameSequenceDrawable&gt;) GifExtension.asGifX(<span class=\"built_in\">this</span>.as(FrameSequenceDrawable.class));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到实际上这个类的具体实现，是依靠GifExtension类，我们去看这个类的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GlideExtension</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GifExtension</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"meta\">@GlideType(FrameSequenceDrawable.class)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestBuilder&lt;FrameSequenceDrawable&gt; <span class=\"title function_\">asGifX</span><span class=\"params\">(RequestBuilder&lt;FrameSequenceDrawable&gt; requestBuilder)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> requestBuilder.apply(RequestOptions</span><br><span class=\"line\">                .decodeTypeOf(FrameSequenceDrawable.class)</span><br><span class=\"line\">                .lock());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">GifExtension</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类需要我们自己实现，并且需要标记**@GlideExtension**注解，又是注解的功劳。</p>\n<p>到此为止，Gif优化的主流程就全部讲完了，接下来就要看这两个注解——**@GlideModule<strong>和</strong>@GlideExtension**到底做了什么？</p>\n<h2 id=\"GlideModule和-GlideExtension\"><a href=\"#GlideModule和-GlideExtension\" class=\"headerlink\" title=\"@GlideModule和@GlideExtension\"></a>@GlideModule和@GlideExtension</h2><p>源码在Glide项目的annotation&#x2F;compiler内，这种APT项目的入口文件标记在src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;gradle内，这其中有一个incremental.annotation.processors文件，我们查看其内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor,aggregating</span><br></pre></td></tr></table></figure>\n\n<p>可以得知，程序入口在GlideAnnotationProcessor这个类，查看这个类的源码，我只提取了关键部分：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GlideAnnotationProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractProcessor</span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">private</span> LibraryModuleProcessor libraryModuleProcessor;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> AppModuleProcessor appModuleProcessor;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> isGeneratedAppGlideModuleWritten;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ExtensionProcessor extensionProcessor;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title function_\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Set&lt;String&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">    result.addAll(libraryModuleProcessor.getSupportedAnnotationTypes());</span><br><span class=\"line\">    result.addAll(extensionProcessor.getSupportedAnnotationTypes());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment env)</span> &#123;</span><br><span class=\"line\">    processorUtil.process();</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">newModulesWritten</span> <span class=\"operator\">=</span> libraryModuleProcessor.processModules(env);</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">newExtensionWritten</span> <span class=\"operator\">=</span> extensionProcessor.processExtensions(env);</span><br><span class=\"line\">    appModuleProcessor.processModules(set, env);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newExtensionWritten || newModulesWritten) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isGeneratedAppGlideModuleWritten) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Cannot process annotations after writing AppGlideModule&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isGeneratedAppGlideModuleWritten) &#123;</span><br><span class=\"line\">      isGeneratedAppGlideModuleWritten = appModuleProcessor.maybeWriteAppModule();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>getSupportedAnnotationTypes</code>方法中标记了，支持哪些注解的解析，其中<code>libraryModuleProcessor.getSupportedAnnotationTypes()</code>中返回了**@GlideModule<strong>，<code>extensionProcessor.getSupportedAnnotationTypes()</code>中返回了</strong>@GlideExtension**。</li>\n<li>process方法中开始了对注解的处理。</li>\n</ul>\n<p>注解的处理，需要你对<a href=\"https://github.com/square/javapoet\"><strong>javapoet</strong></a>有一点点了解，如果暂时不想去了解，你只需要知道，这个类库是通过字符串和占位符来生成Java代码的工具类库，因为接下来的生成代码工作，Glide就是通过这个类库来实现的。</p>\n<p>具体的生成过程不再赘述，从入口类<em>GlideAnnotationProcessor</em>追踪下去，就能看到。</p>\n<h2 id=\"为什么优化能提高效率？\"><a href=\"#为什么优化能提高效率？\" class=\"headerlink\" title=\"为什么优化能提高效率？\"></a>为什么优化能提高效率？</h2><p>Glide默认Gif加载方案，是通过GifDrawable来实现的，而GifDrawable是通过GifFrameLoader来加载帧数据的。具体代码分析可以看参考文章，我这里简单来说一下原因：</p>\n<ul>\n<li>默认方案是串行执行的，比如在加载显示第N帧，这一帧显示完毕，再去解析第N+1帧，当播放第N+1帧的时间窗口到了以后，如果已经解析完毕，则能正常显示，如果不能解析完毕，则会卡顿了；</li>\n<li>GifFrameLoader内部是用了一个mainLooper的handler来进行流程控制，具体可以看GifFrameLoader里的代码，这种方式本身在时间上就不是准时的，与应用内其他各种系统共享mainLooper，如果其他事件执行占用时间较长，也会影响这里的效率了。</li>\n</ul>\n<p>我们再来说说优化方案，优化的原因也简单说一下：</p>\n<ul>\n<li>优化方案是<strong>并行+双缓冲</strong>执行的，在显示第N帧的BitmapA同时，会有一个后台线程在解析第N+1帧的BitmapB，当需要显示第N+1帧BitmapB的时候，两帧的Bitmap交换，BitmapA则进入后台线程去解析第N+2帧了；</li>\n<li>在native去解析数据，效率更高；</li>\n<li>通过BitmapPool提高了内存利用率。</li>\n</ul>\n<p>借用参考文章里的一张图</p>\n<p><img src=\"/images/gif.webp\" alt=\"Gif\"></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://juejin.im/post/6854573219425288199\">Glide加载Gif的卡顿优化思路分析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>项目Demo地址：<a href=\"https://github.com/boybeak/GifHelper\">GifHelper</a></p>\n<p><strong>什么是APT？</strong></p>\n<p><strong>APT</strong>是<strong>Annotation Processing Tool</strong>的简称，即<strong>编译时注解处理器</strong>。它是一个javac的工具，在编译时，通过注解，按照规则自动生成相关代码的工具。</p>\n<p><strong>APT与Glide什么关系？</strong></p>\n<p>我们通常通过在build.gradle加入这样一段代码来引入Glide库。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repositories &#123;</span><br><span class=\"line\">  google()</span><br><span class=\"line\">  jcenter()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  implementation <span class=\"string\">&#x27;com.github.bumptech.glide:glide:4.11.0&#x27;</span></span><br><span class=\"line\">  annotationProcessor <span class=\"string\">&#x27;com.github.bumptech.glide:compiler:4.11.0&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有一个<code>annotationProcessor</code>，这就是对Glide提供的APT进行引用。我们查看Glide的源码结构，可以看到一个名为<em>annotation</em>的文件夹，这里就是与APT有关的部分。</p>\n<p><img src=\"/images/glide_struct.jpg\" alt=\"Glide Struct\"></p>\n<p>接下来我们先通过GIF优化，看一看Glide的APT能实现的神奇效果，在这之后，再来分析Glide是如何通过APT实现的。</p>\n<blockquote>\n<p><strong>注意：</strong>如果使用kotlin需要先加入<code>apply plugin: &#39;kotlin-kapt&#39;</code>插件，并且将<code>annotationProcessor</code>改成<code>kapt</code>。</p>\n</blockquote>\n<h2 id=\"GIF优化\"><a href=\"#GIF优化\" class=\"headerlink\" title=\"GIF优化\"></a>GIF优化</h2><p><strong>为什么要优化GIF？</strong></p>\n<p>有人可能会有疑问，Glide相比其他图片加载框架的优势之一，就是支持GIF，为什么还要做优化呢？</p>\n<p>先看两个截图来对比优化前后的CPU和内存使用情况。</p>\n<p><img src=\"/images/gif_before_optimization.png\" alt=\"优化前\"></p>\n<p><img src=\"/images/gif_after_optimization.png\" alt=\"优化后\"></p>\n<p>我们可以看出，优化后，CPU和内存状况都好了很多，那么我们是怎么做的呢？这就需要用到谷歌官方的两个库——<a href=\"https://android.googlesource.com/platform/external/giflib/+/refs/heads/master\">giflib</a>和<a href=\"https://android.googlesource.com/platform/frameworks/ex/+/refs/heads/master/framesequence/\">FrameSequence</a>，这两个库需要我们自己编译成.so文件，具体可以参考示例项目<a href=\"https://github.com/boybeak/GifHelper\">GifHelper</a>。</p>\n<p>我们查看GifHolder中的代码。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GifHolder</span>(v: View) : AbsHolder&lt;GifItem&gt;(v) &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> gifIV = view&lt;ImageView&gt;(R.id.gifIV)</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onBind</span><span class=\"params\">(item: <span class=\"type\">GifItem</span>, position: <span class=\"type\">Int</span>, absAdapter: <span class=\"type\">AnyAdapter</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item.useGifX) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 优化后的加载方式</span></span><br><span class=\"line\">    \tGlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 优化前的加载方式</span></span><br><span class=\"line\">      Glide.with(itemView).asGif().load(item.source()).into(gifIV)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，加载后有这样一条语句：<code>GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</code>，也许你会懵逼，哪里有GlideApp？哪里有asGifX()方法？我引入Glide后怎么没有看到这两个东西？这就涉及到了APT的内容了。想要看Glide官方文档的可以看<a href=\"http://bumptech.github.io/glide/doc/configuration.html#glidemodule\">这里</a>。</p>\n<p>一切的起因，要从**@GlideModule**这个注解说起，我们打开demo中的MyAppGlideModule类，可以看到这个类有一个@GlideModule注解。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GlideModule</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyAppGlideModule</span> : <span class=\"type\">AppGlideModule</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">registerComponents</span><span class=\"params\">(context: <span class=\"type\">Context</span>, glide: <span class=\"type\">Glide</span>, registry: <span class=\"type\">Registry</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.registerComponents(context, glide, registry)</span><br><span class=\"line\">    registry.append(Registry.BUCKET_GIF, InputStream::<span class=\"keyword\">class</span>.java,</span><br><span class=\"line\">                    FrameSequenceDrawable::<span class=\"keyword\">class</span>.java, GifDecoder(glide.bitmapPool))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再点开这个注解的源码，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.CLASS)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> GlideModule &#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Returns the name of the class that will be used as a replacement for &#123;<span class=\"doctag\">@code</span></span></span><br><span class=\"line\"><span class=\"comment\">   * com.bumptech.glide.Glide&#125; in Applications that depend on Glide&#x27;s generated code.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  String <span class=\"title function_\">glideName</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;GlideApp&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们现在看到“GlideApp”了，是glideName这个注解属性的默认值。我们来逐条分析一下这个注解类的相关信息：</p>\n<ul>\n<li><code>@Target(ElementType.TYPE)</code>：指明这个注解的作用对象——只对类生效；</li>\n<li><code>@Retention(RetentionPolicy.CLASS)</code>：指明了这个注解的作用阶段——编译时记录在class文件中；</li>\n<li><code>public @interface GlideModule</code>：这是一个注解接口，接口名<strong>GlideModule</strong>；</li>\n<li><code>String glideName() default &quot;GlideApp&quot;</code>：这个注解接口需要一个名为<em>glideName</em>的属性，属性默认值为“GlideApp”。</li>\n</ul>\n<blockquote>\n<p>RetentionPolicy：</p>\n<ul>\n<li><strong>SOURCE</strong>：这样的注解会被编译器擦除，只在编码阶段生效，目的是为了提示开发者，比如**@IntDef<strong>、</strong>@StringDef<strong>、</strong>@Visibility<strong>、</strong>@NonNull**；</li>\n<li><strong>CLASS</strong>：记录在class文件中，编译时对编译器可见，运行时对VM不可见，这是RetentionPolicy的默认值，比如**@NotNull**;</li>\n<li><strong>RUNTIME</strong>：记录在class文件中，在运行时需要反射获取其属性值，比如**@Column**。</li>\n</ul>\n</blockquote>\n<p>就是这个**@GlideModule**属性，为我们生成了GlideApp类，这其中的生成过程，我们稍后再说，先把Gif优化的流程说完。</p>\n<p>添加**@GlideModule**后，再次编译看，是否有了GlideApp这个类了。</p>\n<p>我们再来看<em>MyAppGlideModule</em>中的代码，<code>registry.append</code>方法，这是为Glide添加一种解析类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">* @param bucket 要添加的类型id.</span></span><br><span class=\"line\"><span class=\"comment\">* @param dataClass 要从什么数据进行解析。 (&#123;@link java.io.InputStream&#125;, &#123;@link</span></span><br><span class=\"line\"><span class=\"comment\">*     java.io.FileDescriptor&#125; etc).</span></span><br><span class=\"line\"><span class=\"comment\">* @param resourceClass 要解析成什么数据。 (&#123;@link android.graphics.Bitmap&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">*     &#123;@link com.bumptech.glide.load.resource.gif.GifDrawable&#125; etc).</span></span><br><span class=\"line\"><span class=\"comment\">* @param decoder 用什么解码器进行解析 &#123;@link ResourceDecoder&#125;。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;Data, TResource&gt; Registry <span class=\"title function_\">append</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> String bucket,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> Class&lt;Data&gt; dataClass,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> Class&lt;TResource&gt; resourceClass,</span></span><br><span class=\"line\"><span class=\"params\">  <span class=\"meta\">@NonNull</span> ResourceDecoder&lt;Data, TResource&gt; decoder)</span> &#123;</span><br><span class=\"line\">  decoderRegistry.append(bucket, decoder, dataClass, resourceClass);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来就要引入谷歌官方的两个类库了，<a href=\"https://android.googlesource.com/platform/frameworks/ex/+/android-9.0.0_r16/framesequence/\">FrameSquence</a>和<a href=\"https://android.googlesource.com/platform/external/giflib/+/android-9.0.0_r16\">giflib</a>。大家可以根据需要下载对应版本的库，不过这两个库的版本最好要对应。</p>\n<p>下载后需要编译，项目结构参考<a href=\"https://github.com/boybeak/GifHelper\">GifHelper</a>项目中的framesequence&#x2F;src&#x2F;main&#x2F;jni文件夹。注意，需要将FrameSequence_gif.h中的include部分进行修改。</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">- #include &quot;config.h&quot;</span></span><br><span class=\"line\"><span class=\"deletion\">- #include &quot;gif_lib.h&quot;</span></span><br><span class=\"line\">改成</span><br><span class=\"line\"><span class=\"addition\">+ #include &quot;giflib/config.h&quot;</span></span><br><span class=\"line\"><span class=\"addition\">+ #include &quot;giflib/gif_lib.h&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后执行ndk-build，则会在jni同级的目录下，生成一个libs文件夹，.so文件就在这里。</p>\n<p>接下来需要去自定义GifDecoder.java了，直接上代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GifDecoder</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> bmpPool: BitmapPool) : ResourceDecoder&lt;InputStream, FrameSequenceDrawable&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> headerParser = DefaultImageHeaderParser()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">handles</span><span class=\"params\">(source: <span class=\"type\">InputStream</span>, options: <span class=\"type\">Options</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !(options.<span class=\"keyword\">get</span>(GifOptions.DISABLE_ANIMATION) ?: <span class=\"literal\">true</span>)</span><br><span class=\"line\">            &amp;&amp; headerParser.getType(source) == ImageHeaderParser.ImageType.GIF</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">decode</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        source: <span class=\"type\">InputStream</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        width: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        height: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        options: <span class=\"type\">Options</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span></span>: Resource&lt;FrameSequenceDrawable&gt;? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> fs = FrameSequence.decodeStream(source)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> fsd = FrameSequenceDrawable(fs, <span class=\"keyword\">object</span> : FrameSequenceDrawable.BitmapProvider &#123;</span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">acquireBitmap</span><span class=\"params\">(minWidth: <span class=\"type\">Int</span>, minHeight: <span class=\"type\">Int</span>)</span></span>: Bitmap &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> bmpPool.<span class=\"keyword\">get</span>(minWidth, minHeight, Bitmap.Config.ARGB_8888)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">releaseBitmap</span><span class=\"params\">(bitmap: <span class=\"type\">Bitmap</span>?)</span></span> &#123;</span><br><span class=\"line\">                bmpPool.put(bitmap)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> GifResource(fsd)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类里只需要实现两个方法：<code>handles</code>和<code>decode</code>：</p>\n<ul>\n<li>handles：能否解析该输入源，能则返回true；</li>\n<li>decode：如果handles返回true，则执行此方法，返回一个Resource对象包裹住目标类型对象。</li>\n</ul>\n<p>我们通过Glide自带的<em>ImageHeaderParser</em>来检测该输入流是否是gif图像的输入流，如果是且可以执行动画，则进行decode操作。</p>\n<p>我们着重看decode方法，这里需要重点看的是，在构建<em>FrameSequenceDrawable</em>时候，传入了一个<em>BitmapProvider</em>对象，这就是提高Gif效率的关键，在这个<em>BitmapProvider</em>里面，我们通过BitmapPool，去寻找可用尺寸的Bitmap，通过<strong>池化</strong>的方式，减小了内存开销，增加里Bitmap利用率。</p>\n<p>接下来看，如何添加<code>asGifX</code>方法。我们都知道，传统的Glide调用方式如下图：</p>\n<p><code>Glide.with(itemView).asGif().load(item.source()).into(gifIV)</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">A[Glide] --&gt;|&quot;with(xxx)&quot;| B[RequestManager] --&gt;|&quot;asGif&quot;| C[RequestBuilder];</span><br></pre></td></tr></table></figure>\n\n<p>而新的方式却不同，如下图：</p>\n<p><code>GlideApp.with(itemView).asGifX().load(item.source()).into(gifIV)</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">A[GlideApp] --&gt;|&quot;with(xxx)&quot;| B[GlideRequests]  --&gt;|asGifX| C[GlideRequest];</span><br></pre></td></tr></table></figure>\n\n<p>这其中的<em>GlideRequest</em>和<em>GlideRequest</em>，同样都是生成的类，其中GlideRequests继承自RequestManager，GlideRequest继承自RequestBuilder。</p>\n<p>这两个类的生成，同样是**@GlideModule**的作用，但是<code>asGifX</code>这个方法是什么时候定义的呢？我们去查看<code>asGifX</code>这个方法的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@see</span> GifExtension#asGifX(RequestBuilder)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@CheckResult</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> GlideRequest&lt;FrameSequenceDrawable&gt; <span class=\"title function_\">asGifX</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (GlideRequest&lt;FrameSequenceDrawable&gt;) GifExtension.asGifX(<span class=\"built_in\">this</span>.as(FrameSequenceDrawable.class));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到实际上这个类的具体实现，是依靠GifExtension类，我们去看这个类的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GlideExtension</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GifExtension</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"meta\">@GlideType(FrameSequenceDrawable.class)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestBuilder&lt;FrameSequenceDrawable&gt; <span class=\"title function_\">asGifX</span><span class=\"params\">(RequestBuilder&lt;FrameSequenceDrawable&gt; requestBuilder)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> requestBuilder.apply(RequestOptions</span><br><span class=\"line\">                .decodeTypeOf(FrameSequenceDrawable.class)</span><br><span class=\"line\">                .lock());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">GifExtension</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类需要我们自己实现，并且需要标记**@GlideExtension**注解，又是注解的功劳。</p>\n<p>到此为止，Gif优化的主流程就全部讲完了，接下来就要看这两个注解——**@GlideModule<strong>和</strong>@GlideExtension**到底做了什么？</p>\n<h2 id=\"GlideModule和-GlideExtension\"><a href=\"#GlideModule和-GlideExtension\" class=\"headerlink\" title=\"@GlideModule和@GlideExtension\"></a>@GlideModule和@GlideExtension</h2><p>源码在Glide项目的annotation&#x2F;compiler内，这种APT项目的入口文件标记在src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;gradle内，这其中有一个incremental.annotation.processors文件，我们查看其内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.bumptech.glide.annotation.compiler.GlideAnnotationProcessor,aggregating</span><br></pre></td></tr></table></figure>\n\n<p>可以得知，程序入口在GlideAnnotationProcessor这个类，查看这个类的源码，我只提取了关键部分：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GlideAnnotationProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractProcessor</span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">private</span> LibraryModuleProcessor libraryModuleProcessor;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> AppModuleProcessor appModuleProcessor;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> isGeneratedAppGlideModuleWritten;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ExtensionProcessor extensionProcessor;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title function_\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Set&lt;String&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">    result.addAll(libraryModuleProcessor.getSupportedAnnotationTypes());</span><br><span class=\"line\">    result.addAll(extensionProcessor.getSupportedAnnotationTypes());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment env)</span> &#123;</span><br><span class=\"line\">    processorUtil.process();</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">newModulesWritten</span> <span class=\"operator\">=</span> libraryModuleProcessor.processModules(env);</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">newExtensionWritten</span> <span class=\"operator\">=</span> extensionProcessor.processExtensions(env);</span><br><span class=\"line\">    appModuleProcessor.processModules(set, env);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newExtensionWritten || newModulesWritten) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isGeneratedAppGlideModuleWritten) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Cannot process annotations after writing AppGlideModule&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isGeneratedAppGlideModuleWritten) &#123;</span><br><span class=\"line\">      isGeneratedAppGlideModuleWritten = appModuleProcessor.maybeWriteAppModule();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>getSupportedAnnotationTypes</code>方法中标记了，支持哪些注解的解析，其中<code>libraryModuleProcessor.getSupportedAnnotationTypes()</code>中返回了**@GlideModule<strong>，<code>extensionProcessor.getSupportedAnnotationTypes()</code>中返回了</strong>@GlideExtension**。</li>\n<li>process方法中开始了对注解的处理。</li>\n</ul>\n<p>注解的处理，需要你对<a href=\"https://github.com/square/javapoet\"><strong>javapoet</strong></a>有一点点了解，如果暂时不想去了解，你只需要知道，这个类库是通过字符串和占位符来生成Java代码的工具类库，因为接下来的生成代码工作，Glide就是通过这个类库来实现的。</p>\n<p>具体的生成过程不再赘述，从入口类<em>GlideAnnotationProcessor</em>追踪下去，就能看到。</p>\n<h2 id=\"为什么优化能提高效率？\"><a href=\"#为什么优化能提高效率？\" class=\"headerlink\" title=\"为什么优化能提高效率？\"></a>为什么优化能提高效率？</h2><p>Glide默认Gif加载方案，是通过GifDrawable来实现的，而GifDrawable是通过GifFrameLoader来加载帧数据的。具体代码分析可以看参考文章，我这里简单来说一下原因：</p>\n<ul>\n<li>默认方案是串行执行的，比如在加载显示第N帧，这一帧显示完毕，再去解析第N+1帧，当播放第N+1帧的时间窗口到了以后，如果已经解析完毕，则能正常显示，如果不能解析完毕，则会卡顿了；</li>\n<li>GifFrameLoader内部是用了一个mainLooper的handler来进行流程控制，具体可以看GifFrameLoader里的代码，这种方式本身在时间上就不是准时的，与应用内其他各种系统共享mainLooper，如果其他事件执行占用时间较长，也会影响这里的效率了。</li>\n</ul>\n<p>我们再来说说优化方案，优化的原因也简单说一下：</p>\n<ul>\n<li>优化方案是<strong>并行+双缓冲</strong>执行的，在显示第N帧的BitmapA同时，会有一个后台线程在解析第N+1帧的BitmapB，当需要显示第N+1帧BitmapB的时候，两帧的Bitmap交换，BitmapA则进入后台线程去解析第N+2帧了；</li>\n<li>在native去解析数据，效率更高；</li>\n<li>通过BitmapPool提高了内存利用率。</li>\n</ul>\n<p>借用参考文章里的一张图</p>\n<p><img src=\"/images/gif.webp\" alt=\"Gif\"></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://juejin.im/post/6854573219425288199\">Glide加载Gif的卡顿优化思路分析</a></p>\n"},{"layout":"post","title":"Jetpack之Lifecycle源码分析","author":"boybeak","_content":"\n\n这是一篇解析jetpack库中的**Lifecycle**库的分析文章。\n\n```groovy\ndef lifecycle_version = \"2.2.0\"\n// Lifecycles only (without ViewModel or LiveData)\nimplementation \"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version\"\n// Annotation processor\nkapt \"androidx.lifecycle:lifecycle-compiler:$lifecycle_version\"\n```\n\n```kotlin\nclass MyObserver : LifecycleObserver {\n    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)\n    fun onCreate() {\n\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n    fun onPause() {\n\n    }\n}\n```\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        lifecycle.addObserver(MyObserver())\n    }\n}\n```\n\n这是一个很典型的Lifecycle库的使用过程，通过注解的方式，在*MyObserver*中声明对应的生命周期函数，然后将这个*MyObserver*实例添加到*MainActivity*的lifecycle中去。\n\n看到与注解相关，熟悉框架源码的朋友可能已经知道如何去分析了，很可能用到**注解处理器**，与[**ARouter**](https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html)类似，Lifecycle的工作流程也分成两部分——**编译时**和**运行时**。\n\n简要的说，在编译时，生成**LifecycleObserver**的辅助类；在运行时，*addObserver*方法被调用后，解析出对应observer的辅助类。\n\n## 生命周期探知\n\n在正式详解这两个过程前，我们需要先要了解Lifecycle库是如何感知生命周期的呢？\n\n读过Glide源码(附上[Glide源码解读](https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B01.html))的同学可能知道，Glide感知生命周期是通过一个无UI的fragment来实现的，其实，Lifecycle也是这么做的。\n\n对外提供生命周期的类，需要实现LifecycleOwner接口。\n\n```kotlin\npublic interface LifecycleOwner {\n    /**\n     * Returns the Lifecycle of the provider.\n     *\n     * @return The lifecycle of the provider.\n     */\n    @NonNull\n    Lifecycle getLifecycle();\n}\n```\n\n我们以*AppCompatActivity*为例去查看它是如何实现的这个接口，我们查看其父类中有一个*ComponentActivity*类(AppCompatActivity -> FragmentActivity -> ComponentActivity)。\n\n```kotlin\npublic class ComponentActivity extends androidx.core.app.ComponentActivity implements\n        LifecycleOwner,\n        ViewModelStoreOwner,\n        SavedStateRegistryOwner,\n        OnBackPressedDispatcherOwner {\n        @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mSavedStateRegistryController.performRestore(savedInstanceState);\n        ReportFragment.injectIfNeededIn(this);\n        if (mContentLayoutId != 0) {\n            setContentView(mContentLayoutId);\n        }\n    }\n}\n```\n\n注意此处，有一个*ReportFragment*执行了injectIfNeededIn方法，在这个方法中，就是检测是否已经添加了这个*ReportFragment*，如果没添加则添加一个。继续查看这个*ReportFragment*的源码，可以在其生命周期函数中，执行了分发生命周期的流程。\n\n```kotlin\npublic class ReportFragment extends Fragment {\n  static void dispatch(@NonNull Activity activity, @NonNull Lifecycle.Event event) {\n    if (activity instanceof LifecycleRegistryOwner) {\n      ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);\n      return;\n    }\n\n    if (activity instanceof LifecycleOwner) { // 3\n      Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();\n      if (lifecycle instanceof LifecycleRegistry) {\n        ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);\n      }\n    }\n  }\n\n  private void dispatchCreate(ActivityInitializationListener listener) {\n    if (listener != null) {\n      listener.onCreate();\n    }\n  }\n\n  @Override\n  public void onActivityCreated(Bundle savedInstanceState) {\n    super.onActivityCreated(savedInstanceState);\n    dispatchCreate(mProcessListener);\n    dispatch(Lifecycle.Event.ON_CREATE); // 1\n  }\n\n  private void dispatch(@NonNull Lifecycle.Event event) {\n    if (Build.VERSION.SDK_INT < 29) {\n      // Only dispatch events from ReportFragment on API levels prior\n      // to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks\n      // added in ReportFragment.injectIfNeededIn\n      dispatch(getActivity(), event); // 2\n    }\n  }\n\n}\n```\n\n看代码中我标注的注释顺序onActivityCreated -> dispatch(Lifecycle.Event) -> dispatch(Activity, Lifecycle.Event)，我们看到最后一个流程中，拿到*Lifecycle*对象后，判断是否为*LifecycleRegistry*类，如果是，则调用handleLifecycleEvent方法。这里，*ComponentActivity*提供的*Lifecycle*对象就是*LifecycleRegistry*类。\n\n经过这样一个流程，我们就将感知生命周期的无UI的*ReportFragment*与执行事件的*LifecycleRegistry*进行了连接。这样我们就获得了感知生命周期的能力了。\n\n那么具体是如何执行到*MyObserver*对应的生命周期的方法的呢？\n\n> 或许你看到这里，会觉得很简单，在*LifecycleRegistry*维护一个observer队列，然后在执行handleLifecycleEvent方法的时候，通过反射从*MyObserver*中筛选出带有**@OnLifecycleEvent**注解的方法，如果注解中的值与事件event相等，则通过method.invoke()来调用。\n>\n> 可是谷歌工程师并没有这么做，因为在执行事件时候，经过这么多反射，效率会很低。那么正确的流程是怎么样的？这就需要我们关注上面提到的两个流程了——**编译时**和**运行时**。\n\n\n\n## 编译时\n\n参考[Lifecycle-compiler](https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/lifecycle/lifecycle-compiler)源码。\n\n通过注解处理器，AS为我们生成了MyObserver的辅助类——*MyObserver_LifecycleAdapter*。\n\n```java\npublic class MyObserver_LifecycleAdapter implements GeneratedAdapter {\n  final MyObserver mReceiver;\n\n  MyObserver_LifecycleAdapter(MyObserver receiver) {\n    this.mReceiver = receiver;\n  }\n\n  @Override\n  public void callMethods(LifecycleOwner owner, Lifecycle.Event event, boolean onAny,\n      MethodCallsLogger logger) {\n    boolean hasLogger = logger != null;\n    if (onAny) {\n      return;\n    }\n    if (event == Lifecycle.Event.ON_CREATE) {\n      if (!hasLogger || logger.approveCall(\"onCreate\", 1)) {\n        mReceiver.onCreate();\n      }\n      return;\n    }\n    if (event == Lifecycle.Event.ON_PAUSE) {\n      if (!hasLogger || logger.approveCall(\"onPause\", 1)) {\n        mReceiver.onPause();\n      }\n      return;\n    }\n  }\n}\n```\n\n我们可以看到，实际的生命周期事件分发是在这里完成的。那么这个辅助类是在哪里被使用到的呢？\n\n接下来就是**运行时**发挥作用的时候了。\n\n\n\n## 运行时\n\n运行时的起点，是从*addObserver*开始的。\n\n我们查看*LifecycleRegistry#addObserver*方法。\n\n```java\nprivate FastSafeIterableMap<LifecycleObserver, ObserverWithState> mObserverMap =\n            new FastSafeIterableMap<>();\n@Override\npublic void addObserver(@NonNull LifecycleObserver observer) {\n  State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n  ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);\n  ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\n  ...\n}\n```\n\n我们可以看到，*LifecycleRegistry*中并不是直接维护observer对象，而是维护*ObserverWithState*对象。\n\n```java\nstatic class ObserverWithState {\n  State mState;\n  LifecycleEventObserver mLifecycleObserver;\n\n  ObserverWithState(LifecycleObserver observer, State initialState) {\n    mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);\n    mState = initialState;\n  }\n\n  void dispatchEvent(LifecycleOwner owner, Event event) {\n    State newState = getStateAfter(event);\n    mState = min(mState, newState);\n    mLifecycleObserver.onStateChanged(owner, event);\n    mState = newState;\n  }\n}\n```\n\n在这个类的构造方法中，执行了一个`mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);`\n\n在我们的案例中，这个方法返回了一个*SingleGeneratedAdapterObserver*类，我们查看这个类的代码。\n\n```java\nclass SingleGeneratedAdapterObserver implements LifecycleEventObserver {\n\n    private final GeneratedAdapter mGeneratedAdapter;\n\n    SingleGeneratedAdapterObserver(GeneratedAdapter generatedAdapter) {\n        mGeneratedAdapter = generatedAdapter;\n    }\n\n    @Override\n    public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {\n        mGeneratedAdapter.callMethods(source, event, false, null);\n        mGeneratedAdapter.callMethods(source, event, true, null);\n    }\n}\n```\n\n也就是在这里，调用了*MyObserver_LifecycleAdapter*的*callMethods*方法。\n\n那么是如何找到*MyObserver_LifecycleAdapter*方法的呢？\n\n在*Lifecycling*类中，通过observer的类名来找的，我们看到有这样的一个方法：\n\n```java\npublic static String getAdapterName(String className) {\n  return className.replace(\".\", \"_\") + \"_LifecycleAdapter\";\n}\n```\n\n这样，整个流程就串起来了。\n\n\n\n## 总结\n\n编译时：生成*XXX_LifecycleAdapter*类，用来分发不同的生命周期事件。\n\n运行时：在addObserver时候，通过类名找到这个*XXX_LifecycleAdapter*类，生成对象在*LifecycleRegistry*中进行维护；在ReportFragment方法中触发生命周期时候，调用*LifecycleRegistry*的*handleLifecycleEvent*方法进行具体的生命周期事件分发。\n\n总体来看，其整个流程并不复杂，我们可以看到ARouter、Glide的影子，读过其他源码后，理解这个并不难。","source":"_posts/2022-09-17-Jetpack之Lifecycle源码分析.md","raw":"---\nlayout: post\ntitle: Jetpack之Lifecycle源码分析\nauthor: boybeak\ncategory: 源码分析\ntags: Android\n---\n\n\n这是一篇解析jetpack库中的**Lifecycle**库的分析文章。\n\n```groovy\ndef lifecycle_version = \"2.2.0\"\n// Lifecycles only (without ViewModel or LiveData)\nimplementation \"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version\"\n// Annotation processor\nkapt \"androidx.lifecycle:lifecycle-compiler:$lifecycle_version\"\n```\n\n```kotlin\nclass MyObserver : LifecycleObserver {\n    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)\n    fun onCreate() {\n\n    }\n\n    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n    fun onPause() {\n\n    }\n}\n```\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        lifecycle.addObserver(MyObserver())\n    }\n}\n```\n\n这是一个很典型的Lifecycle库的使用过程，通过注解的方式，在*MyObserver*中声明对应的生命周期函数，然后将这个*MyObserver*实例添加到*MainActivity*的lifecycle中去。\n\n看到与注解相关，熟悉框架源码的朋友可能已经知道如何去分析了，很可能用到**注解处理器**，与[**ARouter**](https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html)类似，Lifecycle的工作流程也分成两部分——**编译时**和**运行时**。\n\n简要的说，在编译时，生成**LifecycleObserver**的辅助类；在运行时，*addObserver*方法被调用后，解析出对应observer的辅助类。\n\n## 生命周期探知\n\n在正式详解这两个过程前，我们需要先要了解Lifecycle库是如何感知生命周期的呢？\n\n读过Glide源码(附上[Glide源码解读](https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B01.html))的同学可能知道，Glide感知生命周期是通过一个无UI的fragment来实现的，其实，Lifecycle也是这么做的。\n\n对外提供生命周期的类，需要实现LifecycleOwner接口。\n\n```kotlin\npublic interface LifecycleOwner {\n    /**\n     * Returns the Lifecycle of the provider.\n     *\n     * @return The lifecycle of the provider.\n     */\n    @NonNull\n    Lifecycle getLifecycle();\n}\n```\n\n我们以*AppCompatActivity*为例去查看它是如何实现的这个接口，我们查看其父类中有一个*ComponentActivity*类(AppCompatActivity -> FragmentActivity -> ComponentActivity)。\n\n```kotlin\npublic class ComponentActivity extends androidx.core.app.ComponentActivity implements\n        LifecycleOwner,\n        ViewModelStoreOwner,\n        SavedStateRegistryOwner,\n        OnBackPressedDispatcherOwner {\n        @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mSavedStateRegistryController.performRestore(savedInstanceState);\n        ReportFragment.injectIfNeededIn(this);\n        if (mContentLayoutId != 0) {\n            setContentView(mContentLayoutId);\n        }\n    }\n}\n```\n\n注意此处，有一个*ReportFragment*执行了injectIfNeededIn方法，在这个方法中，就是检测是否已经添加了这个*ReportFragment*，如果没添加则添加一个。继续查看这个*ReportFragment*的源码，可以在其生命周期函数中，执行了分发生命周期的流程。\n\n```kotlin\npublic class ReportFragment extends Fragment {\n  static void dispatch(@NonNull Activity activity, @NonNull Lifecycle.Event event) {\n    if (activity instanceof LifecycleRegistryOwner) {\n      ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);\n      return;\n    }\n\n    if (activity instanceof LifecycleOwner) { // 3\n      Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();\n      if (lifecycle instanceof LifecycleRegistry) {\n        ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);\n      }\n    }\n  }\n\n  private void dispatchCreate(ActivityInitializationListener listener) {\n    if (listener != null) {\n      listener.onCreate();\n    }\n  }\n\n  @Override\n  public void onActivityCreated(Bundle savedInstanceState) {\n    super.onActivityCreated(savedInstanceState);\n    dispatchCreate(mProcessListener);\n    dispatch(Lifecycle.Event.ON_CREATE); // 1\n  }\n\n  private void dispatch(@NonNull Lifecycle.Event event) {\n    if (Build.VERSION.SDK_INT < 29) {\n      // Only dispatch events from ReportFragment on API levels prior\n      // to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks\n      // added in ReportFragment.injectIfNeededIn\n      dispatch(getActivity(), event); // 2\n    }\n  }\n\n}\n```\n\n看代码中我标注的注释顺序onActivityCreated -> dispatch(Lifecycle.Event) -> dispatch(Activity, Lifecycle.Event)，我们看到最后一个流程中，拿到*Lifecycle*对象后，判断是否为*LifecycleRegistry*类，如果是，则调用handleLifecycleEvent方法。这里，*ComponentActivity*提供的*Lifecycle*对象就是*LifecycleRegistry*类。\n\n经过这样一个流程，我们就将感知生命周期的无UI的*ReportFragment*与执行事件的*LifecycleRegistry*进行了连接。这样我们就获得了感知生命周期的能力了。\n\n那么具体是如何执行到*MyObserver*对应的生命周期的方法的呢？\n\n> 或许你看到这里，会觉得很简单，在*LifecycleRegistry*维护一个observer队列，然后在执行handleLifecycleEvent方法的时候，通过反射从*MyObserver*中筛选出带有**@OnLifecycleEvent**注解的方法，如果注解中的值与事件event相等，则通过method.invoke()来调用。\n>\n> 可是谷歌工程师并没有这么做，因为在执行事件时候，经过这么多反射，效率会很低。那么正确的流程是怎么样的？这就需要我们关注上面提到的两个流程了——**编译时**和**运行时**。\n\n\n\n## 编译时\n\n参考[Lifecycle-compiler](https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/lifecycle/lifecycle-compiler)源码。\n\n通过注解处理器，AS为我们生成了MyObserver的辅助类——*MyObserver_LifecycleAdapter*。\n\n```java\npublic class MyObserver_LifecycleAdapter implements GeneratedAdapter {\n  final MyObserver mReceiver;\n\n  MyObserver_LifecycleAdapter(MyObserver receiver) {\n    this.mReceiver = receiver;\n  }\n\n  @Override\n  public void callMethods(LifecycleOwner owner, Lifecycle.Event event, boolean onAny,\n      MethodCallsLogger logger) {\n    boolean hasLogger = logger != null;\n    if (onAny) {\n      return;\n    }\n    if (event == Lifecycle.Event.ON_CREATE) {\n      if (!hasLogger || logger.approveCall(\"onCreate\", 1)) {\n        mReceiver.onCreate();\n      }\n      return;\n    }\n    if (event == Lifecycle.Event.ON_PAUSE) {\n      if (!hasLogger || logger.approveCall(\"onPause\", 1)) {\n        mReceiver.onPause();\n      }\n      return;\n    }\n  }\n}\n```\n\n我们可以看到，实际的生命周期事件分发是在这里完成的。那么这个辅助类是在哪里被使用到的呢？\n\n接下来就是**运行时**发挥作用的时候了。\n\n\n\n## 运行时\n\n运行时的起点，是从*addObserver*开始的。\n\n我们查看*LifecycleRegistry#addObserver*方法。\n\n```java\nprivate FastSafeIterableMap<LifecycleObserver, ObserverWithState> mObserverMap =\n            new FastSafeIterableMap<>();\n@Override\npublic void addObserver(@NonNull LifecycleObserver observer) {\n  State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n  ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);\n  ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\n  ...\n}\n```\n\n我们可以看到，*LifecycleRegistry*中并不是直接维护observer对象，而是维护*ObserverWithState*对象。\n\n```java\nstatic class ObserverWithState {\n  State mState;\n  LifecycleEventObserver mLifecycleObserver;\n\n  ObserverWithState(LifecycleObserver observer, State initialState) {\n    mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);\n    mState = initialState;\n  }\n\n  void dispatchEvent(LifecycleOwner owner, Event event) {\n    State newState = getStateAfter(event);\n    mState = min(mState, newState);\n    mLifecycleObserver.onStateChanged(owner, event);\n    mState = newState;\n  }\n}\n```\n\n在这个类的构造方法中，执行了一个`mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);`\n\n在我们的案例中，这个方法返回了一个*SingleGeneratedAdapterObserver*类，我们查看这个类的代码。\n\n```java\nclass SingleGeneratedAdapterObserver implements LifecycleEventObserver {\n\n    private final GeneratedAdapter mGeneratedAdapter;\n\n    SingleGeneratedAdapterObserver(GeneratedAdapter generatedAdapter) {\n        mGeneratedAdapter = generatedAdapter;\n    }\n\n    @Override\n    public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {\n        mGeneratedAdapter.callMethods(source, event, false, null);\n        mGeneratedAdapter.callMethods(source, event, true, null);\n    }\n}\n```\n\n也就是在这里，调用了*MyObserver_LifecycleAdapter*的*callMethods*方法。\n\n那么是如何找到*MyObserver_LifecycleAdapter*方法的呢？\n\n在*Lifecycling*类中，通过observer的类名来找的，我们看到有这样的一个方法：\n\n```java\npublic static String getAdapterName(String className) {\n  return className.replace(\".\", \"_\") + \"_LifecycleAdapter\";\n}\n```\n\n这样，整个流程就串起来了。\n\n\n\n## 总结\n\n编译时：生成*XXX_LifecycleAdapter*类，用来分发不同的生命周期事件。\n\n运行时：在addObserver时候，通过类名找到这个*XXX_LifecycleAdapter*类，生成对象在*LifecycleRegistry*中进行维护；在ReportFragment方法中触发生命周期时候，调用*LifecycleRegistry*的*handleLifecycleEvent*方法进行具体的生命周期事件分发。\n\n总体来看，其整个流程并不复杂，我们可以看到ARouter、Glide的影子，读过其他源码后，理解这个并不难。","slug":"2022-09-17-Jetpack之Lifecycle源码分析","published":1,"date":"2021-03-12T05:08:47.000Z","updated":"2022-09-19T01:34:24.087Z","comments":1,"photos":[],"link":"","_id":"cldqukh880006pcjg8qov3zk6","content":"<p>这是一篇解析jetpack库中的<strong>Lifecycle</strong>库的分析文章。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> lifecycle_version = <span class=\"string\">&quot;2.2.0&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// Lifecycles only (without ViewModel or LiveData)</span></span><br><span class=\"line\">implementation <span class=\"string\">&quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// Annotation processor</span></span><br><span class=\"line\">kapt <span class=\"string\">&quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyObserver</span> : <span class=\"type\">LifecycleObserver</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPause</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        lifecycle.addObserver(MyObserver())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个很典型的Lifecycle库的使用过程，通过注解的方式，在<em>MyObserver</em>中声明对应的生命周期函数，然后将这个<em>MyObserver</em>实例添加到<em>MainActivity</em>的lifecycle中去。</p>\n<p>看到与注解相关，熟悉框架源码的朋友可能已经知道如何去分析了，很可能用到<strong>注解处理器</strong>，与<a href=\"https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html\"><strong>ARouter</strong></a>类似，Lifecycle的工作流程也分成两部分——<strong>编译时</strong>和<strong>运行时</strong>。</p>\n<p>简要的说，在编译时，生成<strong>LifecycleObserver</strong>的辅助类；在运行时，<em>addObserver</em>方法被调用后，解析出对应observer的辅助类。</p>\n<h2 id=\"生命周期探知\"><a href=\"#生命周期探知\" class=\"headerlink\" title=\"生命周期探知\"></a>生命周期探知</h2><p>在正式详解这两个过程前，我们需要先要了解Lifecycle库是如何感知生命周期的呢？</p>\n<p>读过Glide源码(附上<a href=\"https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B01.html\">Glide源码解读</a>)的同学可能知道，Glide感知生命周期是通过一个无UI的fragment来实现的，其实，Lifecycle也是这么做的。</p>\n<p>对外提供生命周期的类，需要实现LifecycleOwner接口。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">LifecycleOwner</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the Lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> The lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    Lifecycle getLifecycle();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们以<em>AppCompatActivity</em>为例去查看它是如何实现的这个接口，我们查看其父类中有一个<em>ComponentActivity</em>类(AppCompatActivity -&gt; FragmentActivity -&gt; ComponentActivity)。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ComponentActivity</span> <span class=\"title\">extends</span> <span class=\"title\">androidx</span>.<span class=\"title\">core</span>.<span class=\"title\">app</span>.<span class=\"title\">ComponentActivity</span> <span class=\"title\">implements</span></span><br><span class=\"line\">        LifecycleOwner,</span><br><span class=\"line\">        ViewModelStoreOwner,</span><br><span class=\"line\">        SavedStateRegistryOwner,</span><br><span class=\"line\">        OnBackPressedDispatcherOwner &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void onCreate(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        mSavedStateRegistryController.performRestore(savedInstanceState);</span><br><span class=\"line\">        ReportFragment.injectIfNeededIn(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentLayoutId != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            setContentView(mContentLayoutId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意此处，有一个<em>ReportFragment</em>执行了injectIfNeededIn方法，在这个方法中，就是检测是否已经添加了这个<em>ReportFragment</em>，如果没添加则添加一个。继续查看这个<em>ReportFragment</em>的源码，可以在其生命周期函数中，执行了分发生命周期的流程。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReportFragment</span> <span class=\"title\">extends</span> <span class=\"title\">Fragment</span> &#123;</span><br><span class=\"line\">  static void dispatch(<span class=\"meta\">@NonNull</span> Activity activity, <span class=\"meta\">@NonNull</span> Lifecycle.Event event) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity instanceof LifecycleRegistryOwner) &#123;</span><br><span class=\"line\">      ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity instanceof LifecycleOwner) &#123; <span class=\"comment\">// 3</span></span><br><span class=\"line\">      Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (lifecycle instanceof LifecycleRegistry) &#123;</span><br><span class=\"line\">        ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> void dispatchCreate(ActivityInitializationListener listener) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listener != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      listener.onCreate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> void onActivityCreated(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onActivityCreated(savedInstanceState);</span><br><span class=\"line\">    dispatchCreate(mProcessListener);</span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_CREATE); <span class=\"comment\">// 1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> void dispatch(<span class=\"meta\">@NonNull</span> Lifecycle.Event event) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &lt; <span class=\"number\">29</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Only dispatch events from ReportFragment on API levels prior</span></span><br><span class=\"line\">      <span class=\"comment\">// to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks</span></span><br><span class=\"line\">      <span class=\"comment\">// added in ReportFragment.injectIfNeededIn</span></span><br><span class=\"line\">      dispatch(getActivity(), event); <span class=\"comment\">// 2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看代码中我标注的注释顺序onActivityCreated -&gt; dispatch(Lifecycle.Event) -&gt; dispatch(Activity, Lifecycle.Event)，我们看到最后一个流程中，拿到<em>Lifecycle</em>对象后，判断是否为<em>LifecycleRegistry</em>类，如果是，则调用handleLifecycleEvent方法。这里，<em>ComponentActivity</em>提供的<em>Lifecycle</em>对象就是<em>LifecycleRegistry</em>类。</p>\n<p>经过这样一个流程，我们就将感知生命周期的无UI的<em>ReportFragment</em>与执行事件的<em>LifecycleRegistry</em>进行了连接。这样我们就获得了感知生命周期的能力了。</p>\n<p>那么具体是如何执行到<em>MyObserver</em>对应的生命周期的方法的呢？</p>\n<blockquote>\n<p>或许你看到这里，会觉得很简单，在<em>LifecycleRegistry</em>维护一个observer队列，然后在执行handleLifecycleEvent方法的时候，通过反射从<em>MyObserver</em>中筛选出带有**@OnLifecycleEvent**注解的方法，如果注解中的值与事件event相等，则通过method.invoke()来调用。</p>\n<p>可是谷歌工程师并没有这么做，因为在执行事件时候，经过这么多反射，效率会很低。那么正确的流程是怎么样的？这就需要我们关注上面提到的两个流程了——<strong>编译时</strong>和<strong>运行时</strong>。</p>\n</blockquote>\n<h2 id=\"编译时\"><a href=\"#编译时\" class=\"headerlink\" title=\"编译时\"></a>编译时</h2><p>参考<a href=\"https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/lifecycle/lifecycle-compiler\">Lifecycle-compiler</a>源码。</p>\n<p>通过注解处理器，AS为我们生成了MyObserver的辅助类——<em>MyObserver_LifecycleAdapter</em>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyObserver_LifecycleAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">GeneratedAdapter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> MyObserver mReceiver;</span><br><span class=\"line\"></span><br><span class=\"line\">  MyObserver_LifecycleAdapter(MyObserver receiver) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.mReceiver = receiver;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">callMethods</span><span class=\"params\">(LifecycleOwner owner, Lifecycle.Event event, <span class=\"type\">boolean</span> onAny,</span></span><br><span class=\"line\"><span class=\"params\">      MethodCallsLogger logger)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">hasLogger</span> <span class=\"operator\">=</span> logger != <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (onAny) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event == Lifecycle.Event.ON_CREATE) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!hasLogger || logger.approveCall(<span class=\"string\">&quot;onCreate&quot;</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        mReceiver.onCreate();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event == Lifecycle.Event.ON_PAUSE) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!hasLogger || logger.approveCall(<span class=\"string\">&quot;onPause&quot;</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        mReceiver.onPause();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，实际的生命周期事件分发是在这里完成的。那么这个辅助类是在哪里被使用到的呢？</p>\n<p>接下来就是<strong>运行时</strong>发挥作用的时候了。</p>\n<h2 id=\"运行时\"><a href=\"#运行时\" class=\"headerlink\" title=\"运行时\"></a>运行时</h2><p>运行时的起点，是从<em>addObserver</em>开始的。</p>\n<p>我们查看<em>LifecycleRegistry#addObserver</em>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">FastSafeIterableMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addObserver</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleObserver observer)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">State</span> <span class=\"variable\">initialState</span> <span class=\"operator\">=</span> mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class=\"line\">  <span class=\"type\">ObserverWithState</span> <span class=\"variable\">statefulObserver</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObserverWithState</span>(observer, initialState);</span><br><span class=\"line\">  <span class=\"type\">ObserverWithState</span> <span class=\"variable\">previous</span> <span class=\"operator\">=</span> mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，<em>LifecycleRegistry</em>中并不是直接维护observer对象，而是维护<em>ObserverWithState</em>对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObserverWithState</span> &#123;</span><br><span class=\"line\">  State mState;</span><br><span class=\"line\">  LifecycleEventObserver mLifecycleObserver;</span><br><span class=\"line\"></span><br><span class=\"line\">  ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class=\"line\">    mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br><span class=\"line\">    mState = initialState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">dispatchEvent</span><span class=\"params\">(LifecycleOwner owner, Event event)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">State</span> <span class=\"variable\">newState</span> <span class=\"operator\">=</span> getStateAfter(event);</span><br><span class=\"line\">    mState = min(mState, newState);</span><br><span class=\"line\">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class=\"line\">    mState = newState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个类的构造方法中，执行了一个<code>mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</code></p>\n<p>在我们的案例中，这个方法返回了一个<em>SingleGeneratedAdapterObserver</em>类，我们查看这个类的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingleGeneratedAdapterObserver</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">LifecycleEventObserver</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> GeneratedAdapter mGeneratedAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\">    SingleGeneratedAdapterObserver(GeneratedAdapter generatedAdapter) &#123;</span><br><span class=\"line\">        mGeneratedAdapter = generatedAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onStateChanged</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner source, <span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class=\"line\">        mGeneratedAdapter.callMethods(source, event, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        mGeneratedAdapter.callMethods(source, event, <span class=\"literal\">true</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是在这里，调用了<em>MyObserver_LifecycleAdapter</em>的<em>callMethods</em>方法。</p>\n<p>那么是如何找到<em>MyObserver_LifecycleAdapter</em>方法的呢？</p>\n<p>在<em>Lifecycling</em>类中，通过observer的类名来找的，我们看到有这样的一个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">getAdapterName</span><span class=\"params\">(String className)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> className.replace(<span class=\"string\">&quot;.&quot;</span>, <span class=\"string\">&quot;_&quot;</span>) + <span class=\"string\">&quot;_LifecycleAdapter&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，整个流程就串起来了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>编译时：生成<em>XXX_LifecycleAdapter</em>类，用来分发不同的生命周期事件。</p>\n<p>运行时：在addObserver时候，通过类名找到这个<em>XXX_LifecycleAdapter</em>类，生成对象在<em>LifecycleRegistry</em>中进行维护；在ReportFragment方法中触发生命周期时候，调用<em>LifecycleRegistry</em>的<em>handleLifecycleEvent</em>方法进行具体的生命周期事件分发。</p>\n<p>总体来看，其整个流程并不复杂，我们可以看到ARouter、Glide的影子，读过其他源码后，理解这个并不难。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是一篇解析jetpack库中的<strong>Lifecycle</strong>库的分析文章。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> lifecycle_version = <span class=\"string\">&quot;2.2.0&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// Lifecycles only (without ViewModel or LiveData)</span></span><br><span class=\"line\">implementation <span class=\"string\">&quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// Annotation processor</span></span><br><span class=\"line\">kapt <span class=\"string\">&quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyObserver</span> : <span class=\"type\">LifecycleObserver</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onPause</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        lifecycle.addObserver(MyObserver())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个很典型的Lifecycle库的使用过程，通过注解的方式，在<em>MyObserver</em>中声明对应的生命周期函数，然后将这个<em>MyObserver</em>实例添加到<em>MainActivity</em>的lifecycle中去。</p>\n<p>看到与注解相关，熟悉框架源码的朋友可能已经知道如何去分析了，很可能用到<strong>注解处理器</strong>，与<a href=\"https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html\"><strong>ARouter</strong></a>类似，Lifecycle的工作流程也分成两部分——<strong>编译时</strong>和<strong>运行时</strong>。</p>\n<p>简要的说，在编译时，生成<strong>LifecycleObserver</strong>的辅助类；在运行时，<em>addObserver</em>方法被调用后，解析出对应observer的辅助类。</p>\n<h2 id=\"生命周期探知\"><a href=\"#生命周期探知\" class=\"headerlink\" title=\"生命周期探知\"></a>生命周期探知</h2><p>在正式详解这两个过程前，我们需要先要了解Lifecycle库是如何感知生命周期的呢？</p>\n<p>读过Glide源码(附上<a href=\"https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B01.html\">Glide源码解读</a>)的同学可能知道，Glide感知生命周期是通过一个无UI的fragment来实现的，其实，Lifecycle也是这么做的。</p>\n<p>对外提供生命周期的类，需要实现LifecycleOwner接口。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">LifecycleOwner</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the Lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> The lifecycle of the provider.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    Lifecycle getLifecycle();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们以<em>AppCompatActivity</em>为例去查看它是如何实现的这个接口，我们查看其父类中有一个<em>ComponentActivity</em>类(AppCompatActivity -&gt; FragmentActivity -&gt; ComponentActivity)。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ComponentActivity</span> <span class=\"title\">extends</span> <span class=\"title\">androidx</span>.<span class=\"title\">core</span>.<span class=\"title\">app</span>.<span class=\"title\">ComponentActivity</span> <span class=\"title\">implements</span></span><br><span class=\"line\">        LifecycleOwner,</span><br><span class=\"line\">        ViewModelStoreOwner,</span><br><span class=\"line\">        SavedStateRegistryOwner,</span><br><span class=\"line\">        OnBackPressedDispatcherOwner &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void onCreate(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        mSavedStateRegistryController.performRestore(savedInstanceState);</span><br><span class=\"line\">        ReportFragment.injectIfNeededIn(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentLayoutId != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            setContentView(mContentLayoutId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意此处，有一个<em>ReportFragment</em>执行了injectIfNeededIn方法，在这个方法中，就是检测是否已经添加了这个<em>ReportFragment</em>，如果没添加则添加一个。继续查看这个<em>ReportFragment</em>的源码，可以在其生命周期函数中，执行了分发生命周期的流程。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReportFragment</span> <span class=\"title\">extends</span> <span class=\"title\">Fragment</span> &#123;</span><br><span class=\"line\">  static void dispatch(<span class=\"meta\">@NonNull</span> Activity activity, <span class=\"meta\">@NonNull</span> Lifecycle.Event event) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity instanceof LifecycleRegistryOwner) &#123;</span><br><span class=\"line\">      ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity instanceof LifecycleOwner) &#123; <span class=\"comment\">// 3</span></span><br><span class=\"line\">      Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (lifecycle instanceof LifecycleRegistry) &#123;</span><br><span class=\"line\">        ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> void dispatchCreate(ActivityInitializationListener listener) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listener != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      listener.onCreate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> void onActivityCreated(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onActivityCreated(savedInstanceState);</span><br><span class=\"line\">    dispatchCreate(mProcessListener);</span><br><span class=\"line\">    dispatch(Lifecycle.Event.ON_CREATE); <span class=\"comment\">// 1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> void dispatch(<span class=\"meta\">@NonNull</span> Lifecycle.Event event) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &lt; <span class=\"number\">29</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Only dispatch events from ReportFragment on API levels prior</span></span><br><span class=\"line\">      <span class=\"comment\">// to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks</span></span><br><span class=\"line\">      <span class=\"comment\">// added in ReportFragment.injectIfNeededIn</span></span><br><span class=\"line\">      dispatch(getActivity(), event); <span class=\"comment\">// 2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看代码中我标注的注释顺序onActivityCreated -&gt; dispatch(Lifecycle.Event) -&gt; dispatch(Activity, Lifecycle.Event)，我们看到最后一个流程中，拿到<em>Lifecycle</em>对象后，判断是否为<em>LifecycleRegistry</em>类，如果是，则调用handleLifecycleEvent方法。这里，<em>ComponentActivity</em>提供的<em>Lifecycle</em>对象就是<em>LifecycleRegistry</em>类。</p>\n<p>经过这样一个流程，我们就将感知生命周期的无UI的<em>ReportFragment</em>与执行事件的<em>LifecycleRegistry</em>进行了连接。这样我们就获得了感知生命周期的能力了。</p>\n<p>那么具体是如何执行到<em>MyObserver</em>对应的生命周期的方法的呢？</p>\n<blockquote>\n<p>或许你看到这里，会觉得很简单，在<em>LifecycleRegistry</em>维护一个observer队列，然后在执行handleLifecycleEvent方法的时候，通过反射从<em>MyObserver</em>中筛选出带有**@OnLifecycleEvent**注解的方法，如果注解中的值与事件event相等，则通过method.invoke()来调用。</p>\n<p>可是谷歌工程师并没有这么做，因为在执行事件时候，经过这么多反射，效率会很低。那么正确的流程是怎么样的？这就需要我们关注上面提到的两个流程了——<strong>编译时</strong>和<strong>运行时</strong>。</p>\n</blockquote>\n<h2 id=\"编译时\"><a href=\"#编译时\" class=\"headerlink\" title=\"编译时\"></a>编译时</h2><p>参考<a href=\"https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev/lifecycle/lifecycle-compiler\">Lifecycle-compiler</a>源码。</p>\n<p>通过注解处理器，AS为我们生成了MyObserver的辅助类——<em>MyObserver_LifecycleAdapter</em>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyObserver_LifecycleAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">GeneratedAdapter</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> MyObserver mReceiver;</span><br><span class=\"line\"></span><br><span class=\"line\">  MyObserver_LifecycleAdapter(MyObserver receiver) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.mReceiver = receiver;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">callMethods</span><span class=\"params\">(LifecycleOwner owner, Lifecycle.Event event, <span class=\"type\">boolean</span> onAny,</span></span><br><span class=\"line\"><span class=\"params\">      MethodCallsLogger logger)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">hasLogger</span> <span class=\"operator\">=</span> logger != <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (onAny) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event == Lifecycle.Event.ON_CREATE) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!hasLogger || logger.approveCall(<span class=\"string\">&quot;onCreate&quot;</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        mReceiver.onCreate();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event == Lifecycle.Event.ON_PAUSE) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!hasLogger || logger.approveCall(<span class=\"string\">&quot;onPause&quot;</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        mReceiver.onPause();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，实际的生命周期事件分发是在这里完成的。那么这个辅助类是在哪里被使用到的呢？</p>\n<p>接下来就是<strong>运行时</strong>发挥作用的时候了。</p>\n<h2 id=\"运行时\"><a href=\"#运行时\" class=\"headerlink\" title=\"运行时\"></a>运行时</h2><p>运行时的起点，是从<em>addObserver</em>开始的。</p>\n<p>我们查看<em>LifecycleRegistry#addObserver</em>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">FastSafeIterableMap</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addObserver</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleObserver observer)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">State</span> <span class=\"variable\">initialState</span> <span class=\"operator\">=</span> mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class=\"line\">  <span class=\"type\">ObserverWithState</span> <span class=\"variable\">statefulObserver</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObserverWithState</span>(observer, initialState);</span><br><span class=\"line\">  <span class=\"type\">ObserverWithState</span> <span class=\"variable\">previous</span> <span class=\"operator\">=</span> mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，<em>LifecycleRegistry</em>中并不是直接维护observer对象，而是维护<em>ObserverWithState</em>对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObserverWithState</span> &#123;</span><br><span class=\"line\">  State mState;</span><br><span class=\"line\">  LifecycleEventObserver mLifecycleObserver;</span><br><span class=\"line\"></span><br><span class=\"line\">  ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class=\"line\">    mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br><span class=\"line\">    mState = initialState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">dispatchEvent</span><span class=\"params\">(LifecycleOwner owner, Event event)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">State</span> <span class=\"variable\">newState</span> <span class=\"operator\">=</span> getStateAfter(event);</span><br><span class=\"line\">    mState = min(mState, newState);</span><br><span class=\"line\">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class=\"line\">    mState = newState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个类的构造方法中，执行了一个<code>mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</code></p>\n<p>在我们的案例中，这个方法返回了一个<em>SingleGeneratedAdapterObserver</em>类，我们查看这个类的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingleGeneratedAdapterObserver</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">LifecycleEventObserver</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> GeneratedAdapter mGeneratedAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\">    SingleGeneratedAdapterObserver(GeneratedAdapter generatedAdapter) &#123;</span><br><span class=\"line\">        mGeneratedAdapter = generatedAdapter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onStateChanged</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner source, <span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class=\"line\">        mGeneratedAdapter.callMethods(source, event, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        mGeneratedAdapter.callMethods(source, event, <span class=\"literal\">true</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是在这里，调用了<em>MyObserver_LifecycleAdapter</em>的<em>callMethods</em>方法。</p>\n<p>那么是如何找到<em>MyObserver_LifecycleAdapter</em>方法的呢？</p>\n<p>在<em>Lifecycling</em>类中，通过observer的类名来找的，我们看到有这样的一个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">getAdapterName</span><span class=\"params\">(String className)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> className.replace(<span class=\"string\">&quot;.&quot;</span>, <span class=\"string\">&quot;_&quot;</span>) + <span class=\"string\">&quot;_LifecycleAdapter&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，整个流程就串起来了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>编译时：生成<em>XXX_LifecycleAdapter</em>类，用来分发不同的生命周期事件。</p>\n<p>运行时：在addObserver时候，通过类名找到这个<em>XXX_LifecycleAdapter</em>类，生成对象在<em>LifecycleRegistry</em>中进行维护；在ReportFragment方法中触发生命周期时候，调用<em>LifecycleRegistry</em>的<em>handleLifecycleEvent</em>方法进行具体的生命周期事件分发。</p>\n<p>总体来看，其整个流程并不复杂，我们可以看到ARouter、Glide的影子，读过其他源码后，理解这个并不难。</p>\n"},{"layout":"post","title":"Jetpack之LiveData源码分析","author":"boybeak","_content":"\n\n在阅读这篇文章前，需要先对[**Lifecycle**]({{site.base_url}}/源码分析系列/Jetpack之Lifecycle源码分析.md)有所了解。\n\nLifecycle是LiveData的根基，先有了生命周期的管理，才能进行安全不泄漏的数据观察。\n\n先要引入LiveData：\n\n```groovy\nimplementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0\"\n\ndef activity_version = \"1.1.0\"\n// Kotlin，引入这个扩展，可以使用by viewModels()方法\nimplementation \"androidx.activity:activity-ktx:$activity_version\"\n```\n\n典型的用法如下：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    private val vm by viewModels<MainVM>()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        vm.data.observe(this) {\n            Toast.makeText(this@MainActivity, it, Toast.LENGTH_SHORT).show()\n        }\n\n        vm.start()\n\n    }\n}\n```\n\n```kotlin\nclass MainVM : ViewModel() {\n\n    val data = MutableLiveData<String>()\n\n    fun start() {\n        data.value = \"start\"\n        Thread {\n            Thread.sleep(2000)\n            data.postValue(\"run after 2000ms\")\n        }.start()\n    }\n\n}\n```\n\n从这两段代码中，我们就可以看出典型的用法，主要是在三个方法上，*observe*、*setValue*和*postValue*。我们就从这三个方法入手去探究LiveData的工作机制。\n\n## observe方法\n\n```java\n// LiveData.java\n\n@MainThread\npublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {\n  assertMainThread(\"observe\");\n  if (owner.getLifecycle().getCurrentState() == DESTROYED) {\n    // ignore\n    return;\n  }\n  LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);\n  ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n  if (existing != null && !existing.isAttachedTo(owner)) {\n    throw new IllegalArgumentException(\"Cannot add the same observer\"\n                                       + \" with different lifecycles\");\n  }\n  if (existing != null) {\n    return;\n  }\n  owner.getLifecycle().addObserver(wrapper);\n}\n```\n\n1. 只允许在主线程中监听数据变化，并且如果*LifecycleOwner*已经处于**DESTROYED**状态，则忽略这次监听请求。\n2. 以*LifecycleOwner*和*Observer*创建一个*LifecycleBoundObserver*对象，这个对象继承了*ObserverWrapper*类，同时实现了*LifecycleEventObserver*接口，看到这个接口，我们便明白了*LiveData*能够生命周期安全的监听数据变化的原因了。\n3. 这个*LifecycleBoundObserver*对象需要存储在一个*SafeIterableMap*当中去，在存储时候，会通过observer判断是否已经存在一个*ObserverWrapper*对象existing，如果已经存在则分为两种：a. 如果existing没有attach在owner上，则说明，existing已经attach在另外一个*LifecycleOwner*上了，这是不允许的，此时需要抛出异常；b. 如果没有attach在另外一个*LifecycleOwner*上，则说明此时监听的就是当前的owner上，则不需要再次添加监听，直接返回。如果existing不存在，则向owner.getLifecycle()添加监听。\n\n\n\n## setValue和postValue方法\n\n在子线程中更新数据，需要调用postValue方法，实际上，这个方法就是通过一个MainHandler去post一个*Runnable*的方式切换到主线程中执行setValue方法。所以，我们重点看setValue方法即可。\n\n```java\n// LiveData.java\n\n@MainThread\nprotected void setValue(T value) {\n  assertMainThread(\"setValue\");\n  mVersion++;\n  mData = value;\n  dispatchingValue(null);\n}\n```\n\n这里需要注意到的是`mVersion++`这句话，*LiveData*就是通过版本号来记录新的值的。继续看dispatchingValue方法。\n\n\n\n### dispatchingValue\n\n```java\n@SuppressWarnings(\"WeakerAccess\") /* synthetic access */\nvoid dispatchingValue(@Nullable ObserverWrapper initiator) {\n  if (mDispatchingValue) {\t\t\t\t// ①\n    mDispatchInvalidated = true;\n    return;\n  }\n  mDispatchingValue = true;\n  do {\n    mDispatchInvalidated = false;\t// ②\n    if (initiator != null) {\n      considerNotify(initiator);\n      initiator = null;\n    } else {\n      for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =\n           mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n        considerNotify(iterator.next().getValue());\n        if (mDispatchInvalidated) { // ③\n          break;\n        }\n      }\n    }\n  } while (mDispatchInvalidated);\n  mDispatchingValue = false;\n}\n```\n\n在这里，涉及到两个方法，1. 第一个dispatchingValue —— 用来分发控制数据更新流程；2. considerNotify具体执行数据更新操作。\n\n这个方法是双信号量控制分发流程，**mDispatchingValue**和**mDispatchInvalidated**，之所以这样设计，按照我的理解，是考虑到了dispatchingValue方法多线程重入的问题，但是依我看来，这样做没必要，因为这个方法的几处调用，都是在主线程上，不可能出现第一次调用没有执行完，就又被调用一次的可能，也可能是设计者考虑到未来的扩展或者在这个库涉及之初有多线程调用的情况才这样写的，先按照有重入可能来分析。\n\n我们先要弄清这两个信号量的作用：mDispatchingValue表示是否正在执行分发数据更新的操作，mDispatchInvalidated表示是否中断正在进行的分发，开始新一轮分发。\n\n这个方法是根据传入的参数，有两个执行流程，一个是执行具体某个ObserverWrapper的数据更新操作，另外一个就是批量更新所有observer的数据操作。我们以setValue触发的dispatchingValue(null)批量更新操作为例进行分析。\n\n注意我在上段代码中的序号①②③注释，我们分步骤进行分析：\n\n> 假设，此时我们有两个observer。\n>\n> 初始状态 **mDispatchingValue = false, mDispatchInvalidated = false**\n>\n> 当**第一次**调用开始后，会顺利通过①处判断，然后进入do - while循环，并且在②处先将mDispatchInvalidated信号量置为false，所以，一般情况下，这个while循环只会执行一次；\n>\n> \n>\n> 信号量：**mDispatchingValue = true, mDispatchInvalidated = false**\n>\n> 由于initiator参数为null，所以会进入到else分支中的for循环中，这里需要注意的是，每一次for循环结束时候，都判断一次mDispatchInvalidated信号量，也就是注释③处；\n>\n> 假设我们执行了第一个observer后，dispatchingValue方法进行了**第二次**调用，由于此时mDispatchingValue信号量为true，所以会进入①处if条件判断语句，将mDispatchInvalidated信号量置为true并且直接return了；\n>\n> \n>\n> 信号量：**mDispatchingValue = true, mDispatchInvalidated = true**\n>\n> 此时，第一次调用的for循环体就会因为mDispatchInvalidated变成了true，而退出for循环，while循环开始判断条件，同样因为mDispatchInvalidated为true，回再次执行while循环，执行新值更新；\n>\n> 最后退出dispatchingValue方法后，两个信号量都置为false。\n\n这样做的目的，或许是为了及时抛弃旧值通知，开始新值通知。\n\n\n\n### considerNotify\n\n```java\n\n\n@SuppressWarnings(\"unchecked\")\nprivate void considerNotify(ObserverWrapper observer) {\n  if (!observer.mActive) {\n    return;\n  }\n  // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.\n  //\n  // we still first check observer.active to keep it as the entrance for events. So even if\n  // the observer moved to an active state, if we've not received that event, we better not\n  // notify for a more predictable notification order.\n  if (!observer.shouldBeActive()) {\n    observer.activeStateChanged(false);\n    return;\n  }\n  if (observer.mLastVersion >= mVersion) {\n    return;\n  }\n  observer.mLastVersion = mVersion;\n  observer.mObserver.onChanged((T) mData);\n}\n```\n\n这个方法是具体执行通知观察者值变化的地方。\n\n那么LiveData是如何判断新值和旧值的呢？\n\n在setValue方法中，有一个`mVersion++`语句，每次设置新值都会触发这个mVersion的自增，然后在considerNotify方法中，去校验observer是否处于active状态以及新值版本号与observer中的版本号，如果observer**应当**处于非active状态而仍然处于active状态(**因为状态可能由于handler机制并没有及时变更**)，则进行状态变更并返回，并且如果`observer.mLastVersion >= mVersion`，则直接返回，因为此时observer已经更新过此值。**也就是说，只有observer处于active状态且当前mVersion > observer.mVersion的时候，才去通知observer更新值**。\n\n接下来，着重看一下*LifecycleBoundObserver*和*ObserverWrapper*这个两个类。\n\n\n\n## LifecycleBoundObserver和ObserverWrapper\n\n*ObserverWrapper*是*Observer*的抽象包装类，代码很简单：\n\n```java\nprivate abstract class ObserverWrapper {\n  final Observer<? super T> mObserver;\n  boolean mActive;\n  int mLastVersion = START_VERSION;\n\n  ObserverWrapper(Observer<? super T> observer) {\n    mObserver = observer;\n  }\n\n  abstract boolean shouldBeActive();\n\n  boolean isAttachedTo(LifecycleOwner owner) {\n    return false;\n  }\n\n  void detachObserver() {\n  }\n\n  void activeStateChanged(boolean newActive) {\n    if (newActive == mActive) {\n      return;\n    }\n    // immediately set active state, so we'd never dispatch anything to inactive\n    // owner\n    mActive = newActive;\n    boolean wasInactive = LiveData.this.mActiveCount == 0;\n    LiveData.this.mActiveCount += mActive ? 1 : -1;\n    if (wasInactive && mActive) {\n      onActive();\n    }\n    if (LiveData.this.mActiveCount == 0 && !mActive) {\n      onInactive();\n    }\n    if (mActive) {\n      dispatchingValue(this);\n    }\n  }\n}\n```\n\n在activeStateChanged方法中，先判断是否是状态的改变，如果`newActive == mActive`说明激活状态未改变，则直接返回；然后判断按照激活的observer数目和mActive状态，来判断LiveData的状态，并调用其空回调函数；最后如果mActive为true，则进行针对这个*ObserverWrapper*的事件分发。\n\n*ObserverWrapper*有两个子类，*LifecycleBoundObserver*和*AlwaysActiveObserver*，*AlwaysActiveObserver*是与生命周期无关的observer，需要谨慎使用，在适当的时候，通过removeObserver来删除，我们重点看*LifecycleBoundObserver*。\n\n*LifecycleBoundObserver*同时实现了*LifecycleEventObserver*，这就使得这个类具备了生命周期关联性。\n\n```java\nclass LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver {\n  @NonNull\n  final LifecycleOwner mOwner;\n\n  LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<? super T> observer) {\n    super(observer);\n    mOwner = owner;\n  }\n\n  @Override\n  boolean shouldBeActive() {\n    return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);\n  }\n\n  @Override\n  public void onStateChanged(@NonNull LifecycleOwner source,\n                             @NonNull Lifecycle.Event event) {\n    if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {\n      removeObserver(mObserver);\n      return;\n    }\n    activeStateChanged(shouldBeActive());\n  }\n\n  @Override\n  boolean isAttachedTo(LifecycleOwner owner) {\n    return mOwner == owner;\n  }\n\n  @Override\n  void detachObserver() {\n    mOwner.getLifecycle().removeObserver(this);\n  }\n}\n```\n\n在onStateChanged方法中，当生命周期处于**DESTROYED**状态时候，则删除这个observer。除此以外，当mOwner的生命周期处于**STARTED**之后的状态，则认为`shouldBeActive`，当生命周期函数onStateChanged被触发时候，将设置是否active。\n\n\n\n## 总结\n\n通过LiveData的这些特性，我们可以实现Activity - Fragment, Fragment - Fragment的通信，另外也可以做应用的事件总线，比如**LiveEventBus**。","source":"_posts/2022-09-17-Jetpack之LiveData源码分析.md","raw":"---\nlayout: post\ntitle: Jetpack之LiveData源码分析\nauthor: boybeak\ncategory: 源码分析\ntags: Android\n---\n\n\n在阅读这篇文章前，需要先对[**Lifecycle**]({{site.base_url}}/源码分析系列/Jetpack之Lifecycle源码分析.md)有所了解。\n\nLifecycle是LiveData的根基，先有了生命周期的管理，才能进行安全不泄漏的数据观察。\n\n先要引入LiveData：\n\n```groovy\nimplementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0\"\n\ndef activity_version = \"1.1.0\"\n// Kotlin，引入这个扩展，可以使用by viewModels()方法\nimplementation \"androidx.activity:activity-ktx:$activity_version\"\n```\n\n典型的用法如下：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    private val vm by viewModels<MainVM>()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        vm.data.observe(this) {\n            Toast.makeText(this@MainActivity, it, Toast.LENGTH_SHORT).show()\n        }\n\n        vm.start()\n\n    }\n}\n```\n\n```kotlin\nclass MainVM : ViewModel() {\n\n    val data = MutableLiveData<String>()\n\n    fun start() {\n        data.value = \"start\"\n        Thread {\n            Thread.sleep(2000)\n            data.postValue(\"run after 2000ms\")\n        }.start()\n    }\n\n}\n```\n\n从这两段代码中，我们就可以看出典型的用法，主要是在三个方法上，*observe*、*setValue*和*postValue*。我们就从这三个方法入手去探究LiveData的工作机制。\n\n## observe方法\n\n```java\n// LiveData.java\n\n@MainThread\npublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {\n  assertMainThread(\"observe\");\n  if (owner.getLifecycle().getCurrentState() == DESTROYED) {\n    // ignore\n    return;\n  }\n  LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);\n  ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n  if (existing != null && !existing.isAttachedTo(owner)) {\n    throw new IllegalArgumentException(\"Cannot add the same observer\"\n                                       + \" with different lifecycles\");\n  }\n  if (existing != null) {\n    return;\n  }\n  owner.getLifecycle().addObserver(wrapper);\n}\n```\n\n1. 只允许在主线程中监听数据变化，并且如果*LifecycleOwner*已经处于**DESTROYED**状态，则忽略这次监听请求。\n2. 以*LifecycleOwner*和*Observer*创建一个*LifecycleBoundObserver*对象，这个对象继承了*ObserverWrapper*类，同时实现了*LifecycleEventObserver*接口，看到这个接口，我们便明白了*LiveData*能够生命周期安全的监听数据变化的原因了。\n3. 这个*LifecycleBoundObserver*对象需要存储在一个*SafeIterableMap*当中去，在存储时候，会通过observer判断是否已经存在一个*ObserverWrapper*对象existing，如果已经存在则分为两种：a. 如果existing没有attach在owner上，则说明，existing已经attach在另外一个*LifecycleOwner*上了，这是不允许的，此时需要抛出异常；b. 如果没有attach在另外一个*LifecycleOwner*上，则说明此时监听的就是当前的owner上，则不需要再次添加监听，直接返回。如果existing不存在，则向owner.getLifecycle()添加监听。\n\n\n\n## setValue和postValue方法\n\n在子线程中更新数据，需要调用postValue方法，实际上，这个方法就是通过一个MainHandler去post一个*Runnable*的方式切换到主线程中执行setValue方法。所以，我们重点看setValue方法即可。\n\n```java\n// LiveData.java\n\n@MainThread\nprotected void setValue(T value) {\n  assertMainThread(\"setValue\");\n  mVersion++;\n  mData = value;\n  dispatchingValue(null);\n}\n```\n\n这里需要注意到的是`mVersion++`这句话，*LiveData*就是通过版本号来记录新的值的。继续看dispatchingValue方法。\n\n\n\n### dispatchingValue\n\n```java\n@SuppressWarnings(\"WeakerAccess\") /* synthetic access */\nvoid dispatchingValue(@Nullable ObserverWrapper initiator) {\n  if (mDispatchingValue) {\t\t\t\t// ①\n    mDispatchInvalidated = true;\n    return;\n  }\n  mDispatchingValue = true;\n  do {\n    mDispatchInvalidated = false;\t// ②\n    if (initiator != null) {\n      considerNotify(initiator);\n      initiator = null;\n    } else {\n      for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =\n           mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n        considerNotify(iterator.next().getValue());\n        if (mDispatchInvalidated) { // ③\n          break;\n        }\n      }\n    }\n  } while (mDispatchInvalidated);\n  mDispatchingValue = false;\n}\n```\n\n在这里，涉及到两个方法，1. 第一个dispatchingValue —— 用来分发控制数据更新流程；2. considerNotify具体执行数据更新操作。\n\n这个方法是双信号量控制分发流程，**mDispatchingValue**和**mDispatchInvalidated**，之所以这样设计，按照我的理解，是考虑到了dispatchingValue方法多线程重入的问题，但是依我看来，这样做没必要，因为这个方法的几处调用，都是在主线程上，不可能出现第一次调用没有执行完，就又被调用一次的可能，也可能是设计者考虑到未来的扩展或者在这个库涉及之初有多线程调用的情况才这样写的，先按照有重入可能来分析。\n\n我们先要弄清这两个信号量的作用：mDispatchingValue表示是否正在执行分发数据更新的操作，mDispatchInvalidated表示是否中断正在进行的分发，开始新一轮分发。\n\n这个方法是根据传入的参数，有两个执行流程，一个是执行具体某个ObserverWrapper的数据更新操作，另外一个就是批量更新所有observer的数据操作。我们以setValue触发的dispatchingValue(null)批量更新操作为例进行分析。\n\n注意我在上段代码中的序号①②③注释，我们分步骤进行分析：\n\n> 假设，此时我们有两个observer。\n>\n> 初始状态 **mDispatchingValue = false, mDispatchInvalidated = false**\n>\n> 当**第一次**调用开始后，会顺利通过①处判断，然后进入do - while循环，并且在②处先将mDispatchInvalidated信号量置为false，所以，一般情况下，这个while循环只会执行一次；\n>\n> \n>\n> 信号量：**mDispatchingValue = true, mDispatchInvalidated = false**\n>\n> 由于initiator参数为null，所以会进入到else分支中的for循环中，这里需要注意的是，每一次for循环结束时候，都判断一次mDispatchInvalidated信号量，也就是注释③处；\n>\n> 假设我们执行了第一个observer后，dispatchingValue方法进行了**第二次**调用，由于此时mDispatchingValue信号量为true，所以会进入①处if条件判断语句，将mDispatchInvalidated信号量置为true并且直接return了；\n>\n> \n>\n> 信号量：**mDispatchingValue = true, mDispatchInvalidated = true**\n>\n> 此时，第一次调用的for循环体就会因为mDispatchInvalidated变成了true，而退出for循环，while循环开始判断条件，同样因为mDispatchInvalidated为true，回再次执行while循环，执行新值更新；\n>\n> 最后退出dispatchingValue方法后，两个信号量都置为false。\n\n这样做的目的，或许是为了及时抛弃旧值通知，开始新值通知。\n\n\n\n### considerNotify\n\n```java\n\n\n@SuppressWarnings(\"unchecked\")\nprivate void considerNotify(ObserverWrapper observer) {\n  if (!observer.mActive) {\n    return;\n  }\n  // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.\n  //\n  // we still first check observer.active to keep it as the entrance for events. So even if\n  // the observer moved to an active state, if we've not received that event, we better not\n  // notify for a more predictable notification order.\n  if (!observer.shouldBeActive()) {\n    observer.activeStateChanged(false);\n    return;\n  }\n  if (observer.mLastVersion >= mVersion) {\n    return;\n  }\n  observer.mLastVersion = mVersion;\n  observer.mObserver.onChanged((T) mData);\n}\n```\n\n这个方法是具体执行通知观察者值变化的地方。\n\n那么LiveData是如何判断新值和旧值的呢？\n\n在setValue方法中，有一个`mVersion++`语句，每次设置新值都会触发这个mVersion的自增，然后在considerNotify方法中，去校验observer是否处于active状态以及新值版本号与observer中的版本号，如果observer**应当**处于非active状态而仍然处于active状态(**因为状态可能由于handler机制并没有及时变更**)，则进行状态变更并返回，并且如果`observer.mLastVersion >= mVersion`，则直接返回，因为此时observer已经更新过此值。**也就是说，只有observer处于active状态且当前mVersion > observer.mVersion的时候，才去通知observer更新值**。\n\n接下来，着重看一下*LifecycleBoundObserver*和*ObserverWrapper*这个两个类。\n\n\n\n## LifecycleBoundObserver和ObserverWrapper\n\n*ObserverWrapper*是*Observer*的抽象包装类，代码很简单：\n\n```java\nprivate abstract class ObserverWrapper {\n  final Observer<? super T> mObserver;\n  boolean mActive;\n  int mLastVersion = START_VERSION;\n\n  ObserverWrapper(Observer<? super T> observer) {\n    mObserver = observer;\n  }\n\n  abstract boolean shouldBeActive();\n\n  boolean isAttachedTo(LifecycleOwner owner) {\n    return false;\n  }\n\n  void detachObserver() {\n  }\n\n  void activeStateChanged(boolean newActive) {\n    if (newActive == mActive) {\n      return;\n    }\n    // immediately set active state, so we'd never dispatch anything to inactive\n    // owner\n    mActive = newActive;\n    boolean wasInactive = LiveData.this.mActiveCount == 0;\n    LiveData.this.mActiveCount += mActive ? 1 : -1;\n    if (wasInactive && mActive) {\n      onActive();\n    }\n    if (LiveData.this.mActiveCount == 0 && !mActive) {\n      onInactive();\n    }\n    if (mActive) {\n      dispatchingValue(this);\n    }\n  }\n}\n```\n\n在activeStateChanged方法中，先判断是否是状态的改变，如果`newActive == mActive`说明激活状态未改变，则直接返回；然后判断按照激活的observer数目和mActive状态，来判断LiveData的状态，并调用其空回调函数；最后如果mActive为true，则进行针对这个*ObserverWrapper*的事件分发。\n\n*ObserverWrapper*有两个子类，*LifecycleBoundObserver*和*AlwaysActiveObserver*，*AlwaysActiveObserver*是与生命周期无关的observer，需要谨慎使用，在适当的时候，通过removeObserver来删除，我们重点看*LifecycleBoundObserver*。\n\n*LifecycleBoundObserver*同时实现了*LifecycleEventObserver*，这就使得这个类具备了生命周期关联性。\n\n```java\nclass LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver {\n  @NonNull\n  final LifecycleOwner mOwner;\n\n  LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<? super T> observer) {\n    super(observer);\n    mOwner = owner;\n  }\n\n  @Override\n  boolean shouldBeActive() {\n    return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);\n  }\n\n  @Override\n  public void onStateChanged(@NonNull LifecycleOwner source,\n                             @NonNull Lifecycle.Event event) {\n    if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {\n      removeObserver(mObserver);\n      return;\n    }\n    activeStateChanged(shouldBeActive());\n  }\n\n  @Override\n  boolean isAttachedTo(LifecycleOwner owner) {\n    return mOwner == owner;\n  }\n\n  @Override\n  void detachObserver() {\n    mOwner.getLifecycle().removeObserver(this);\n  }\n}\n```\n\n在onStateChanged方法中，当生命周期处于**DESTROYED**状态时候，则删除这个observer。除此以外，当mOwner的生命周期处于**STARTED**之后的状态，则认为`shouldBeActive`，当生命周期函数onStateChanged被触发时候，将设置是否active。\n\n\n\n## 总结\n\n通过LiveData的这些特性，我们可以实现Activity - Fragment, Fragment - Fragment的通信，另外也可以做应用的事件总线，比如**LiveEventBus**。","slug":"2022-09-17-Jetpack之LiveData源码分析","published":1,"date":"2021-01-01T08:52:19.000Z","updated":"2022-09-19T01:34:26.135Z","comments":1,"photos":[],"link":"","_id":"cldqukh8h000apcjg797a0h3u","content":"<p>在阅读这篇文章前，需要先对[**Lifecycle**](&#x2F;源码分析系列&#x2F;Jetpack之Lifecycle源码分析.md)有所了解。</p>\n<p>Lifecycle是LiveData的根基，先有了生命周期的管理，才能进行安全不泄漏的数据观察。</p>\n<p>先要引入LiveData：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> activity_version = <span class=\"string\">&quot;1.1.0&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// Kotlin，引入这个扩展，可以使用by viewModels()方法</span></span><br><span class=\"line\">implementation <span class=\"string\">&quot;androidx.activity:activity-ktx:$activity_version&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>典型的用法如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> vm <span class=\"keyword\">by</span> viewModels&lt;MainVM&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.<span class=\"keyword\">data</span>.observe(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span><span class=\"symbol\">@MainActivity</span>, it, Toast.LENGTH_SHORT).show()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.start()</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainVM</span> : <span class=\"type\">ViewModel</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"keyword\">data</span> = MutableLiveData&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">start</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">data</span>.value = <span class=\"string\">&quot;start&quot;</span></span><br><span class=\"line\">        Thread &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2000</span>)</span><br><span class=\"line\">            <span class=\"keyword\">data</span>.postValue(<span class=\"string\">&quot;run after 2000ms&quot;</span>)</span><br><span class=\"line\">        &#125;.start()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从这两段代码中，我们就可以看出典型的用法，主要是在三个方法上，<em>observe</em>、<em>setValue</em>和<em>postValue</em>。我们就从这三个方法入手去探究LiveData的工作机制。</p>\n<h2 id=\"observe方法\"><a href=\"#observe方法\" class=\"headerlink\" title=\"observe方法\"></a>observe方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LiveData.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">observe</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, <span class=\"meta\">@NonNull</span> Observer&lt;? <span class=\"built_in\">super</span> T&gt; observer)</span> &#123;</span><br><span class=\"line\">  assertMainThread(<span class=\"string\">&quot;observe&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ignore</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"type\">LifecycleBoundObserver</span> <span class=\"variable\">wrapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LifecycleBoundObserver</span>(owner, observer);</span><br><span class=\"line\">  <span class=\"type\">ObserverWrapper</span> <span class=\"variable\">existing</span> <span class=\"operator\">=</span> mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (existing != <span class=\"literal\">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Cannot add the same observer&quot;</span></span><br><span class=\"line\">                                       + <span class=\"string\">&quot; with different lifecycles&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (existing != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  owner.getLifecycle().addObserver(wrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>只允许在主线程中监听数据变化，并且如果<em>LifecycleOwner</em>已经处于<strong>DESTROYED</strong>状态，则忽略这次监听请求。</li>\n<li>以<em>LifecycleOwner</em>和<em>Observer</em>创建一个<em>LifecycleBoundObserver</em>对象，这个对象继承了<em>ObserverWrapper</em>类，同时实现了<em>LifecycleEventObserver</em>接口，看到这个接口，我们便明白了<em>LiveData</em>能够生命周期安全的监听数据变化的原因了。</li>\n<li>这个<em>LifecycleBoundObserver</em>对象需要存储在一个<em>SafeIterableMap</em>当中去，在存储时候，会通过observer判断是否已经存在一个<em>ObserverWrapper</em>对象existing，如果已经存在则分为两种：a. 如果existing没有attach在owner上，则说明，existing已经attach在另外一个<em>LifecycleOwner</em>上了，这是不允许的，此时需要抛出异常；b. 如果没有attach在另外一个<em>LifecycleOwner</em>上，则说明此时监听的就是当前的owner上，则不需要再次添加监听，直接返回。如果existing不存在，则向owner.getLifecycle()添加监听。</li>\n</ol>\n<h2 id=\"setValue和postValue方法\"><a href=\"#setValue和postValue方法\" class=\"headerlink\" title=\"setValue和postValue方法\"></a>setValue和postValue方法</h2><p>在子线程中更新数据，需要调用postValue方法，实际上，这个方法就是通过一个MainHandler去post一个<em>Runnable</em>的方式切换到主线程中执行setValue方法。所以，我们重点看setValue方法即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LiveData.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">  assertMainThread(<span class=\"string\">&quot;setValue&quot;</span>);</span><br><span class=\"line\">  mVersion++;</span><br><span class=\"line\">  mData = value;</span><br><span class=\"line\">  dispatchingValue(<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意到的是<code>mVersion++</code>这句话，<em>LiveData</em>就是通过版本号来记录新的值的。继续看dispatchingValue方法。</p>\n<h3 id=\"dispatchingValue\"><a href=\"#dispatchingValue\" class=\"headerlink\" title=\"dispatchingValue\"></a>dispatchingValue</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class=\"comment\">/* synthetic access */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">dispatchingValue</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> ObserverWrapper initiator)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mDispatchingValue) &#123;\t\t\t\t<span class=\"comment\">// ①</span></span><br><span class=\"line\">    mDispatchInvalidated = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mDispatchingValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    mDispatchInvalidated = <span class=\"literal\">false</span>;\t<span class=\"comment\">// ②</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initiator != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      considerNotify(initiator);</span><br><span class=\"line\">      initiator = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"built_in\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">           mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">        considerNotify(iterator.next().getValue());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123; <span class=\"comment\">// ③</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">  mDispatchingValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，涉及到两个方法，1. 第一个dispatchingValue —— 用来分发控制数据更新流程；2. considerNotify具体执行数据更新操作。</p>\n<p>这个方法是双信号量控制分发流程，<strong>mDispatchingValue</strong>和<strong>mDispatchInvalidated</strong>，之所以这样设计，按照我的理解，是考虑到了dispatchingValue方法多线程重入的问题，但是依我看来，这样做没必要，因为这个方法的几处调用，都是在主线程上，不可能出现第一次调用没有执行完，就又被调用一次的可能，也可能是设计者考虑到未来的扩展或者在这个库涉及之初有多线程调用的情况才这样写的，先按照有重入可能来分析。</p>\n<p>我们先要弄清这两个信号量的作用：mDispatchingValue表示是否正在执行分发数据更新的操作，mDispatchInvalidated表示是否中断正在进行的分发，开始新一轮分发。</p>\n<p>这个方法是根据传入的参数，有两个执行流程，一个是执行具体某个ObserverWrapper的数据更新操作，另外一个就是批量更新所有observer的数据操作。我们以setValue触发的dispatchingValue(null)批量更新操作为例进行分析。</p>\n<p>注意我在上段代码中的序号①②③注释，我们分步骤进行分析：</p>\n<blockquote>\n<p>假设，此时我们有两个observer。</p>\n<p>初始状态 <strong>mDispatchingValue &#x3D; false, mDispatchInvalidated &#x3D; false</strong></p>\n<p>当<strong>第一次</strong>调用开始后，会顺利通过①处判断，然后进入do - while循环，并且在②处先将mDispatchInvalidated信号量置为false，所以，一般情况下，这个while循环只会执行一次；</p>\n<p>信号量：<strong>mDispatchingValue &#x3D; true, mDispatchInvalidated &#x3D; false</strong></p>\n<p>由于initiator参数为null，所以会进入到else分支中的for循环中，这里需要注意的是，每一次for循环结束时候，都判断一次mDispatchInvalidated信号量，也就是注释③处；</p>\n<p>假设我们执行了第一个observer后，dispatchingValue方法进行了<strong>第二次</strong>调用，由于此时mDispatchingValue信号量为true，所以会进入①处if条件判断语句，将mDispatchInvalidated信号量置为true并且直接return了；</p>\n<p>信号量：<strong>mDispatchingValue &#x3D; true, mDispatchInvalidated &#x3D; true</strong></p>\n<p>此时，第一次调用的for循环体就会因为mDispatchInvalidated变成了true，而退出for循环，while循环开始判断条件，同样因为mDispatchInvalidated为true，回再次执行while循环，执行新值更新；</p>\n<p>最后退出dispatchingValue方法后，两个信号量都置为false。</p>\n</blockquote>\n<p>这样做的目的，或许是为了及时抛弃旧值通知，开始新值通知。</p>\n<h3 id=\"considerNotify\"><a href=\"#considerNotify\" class=\"headerlink\" title=\"considerNotify\"></a>considerNotify</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class=\"line\">  <span class=\"comment\">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class=\"line\">  <span class=\"comment\">// notify for a more predictable notification order.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">    observer.activeStateChanged(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  observer.mLastVersion = mVersion;</span><br><span class=\"line\">  observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法是具体执行通知观察者值变化的地方。</p>\n<p>那么LiveData是如何判断新值和旧值的呢？</p>\n<p>在setValue方法中，有一个<code>mVersion++</code>语句，每次设置新值都会触发这个mVersion的自增，然后在considerNotify方法中，去校验observer是否处于active状态以及新值版本号与observer中的版本号，如果observer<strong>应当</strong>处于非active状态而仍然处于active状态(<strong>因为状态可能由于handler机制并没有及时变更</strong>)，则进行状态变更并返回，并且如果<code>observer.mLastVersion &gt;= mVersion</code>，则直接返回，因为此时observer已经更新过此值。<strong>也就是说，只有observer处于active状态且当前mVersion &gt; observer.mVersion的时候，才去通知observer更新值</strong>。</p>\n<p>接下来，着重看一下<em>LifecycleBoundObserver</em>和<em>ObserverWrapper</em>这个两个类。</p>\n<h2 id=\"LifecycleBoundObserver和ObserverWrapper\"><a href=\"#LifecycleBoundObserver和ObserverWrapper\" class=\"headerlink\" title=\"LifecycleBoundObserver和ObserverWrapper\"></a>LifecycleBoundObserver和ObserverWrapper</h2><p><em>ObserverWrapper</em>是<em>Observer</em>的抽象包装类，代码很简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObserverWrapper</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Observer&lt;? <span class=\"built_in\">super</span> T&gt; mObserver;</span><br><span class=\"line\">  <span class=\"type\">boolean</span> mActive;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">mLastVersion</span> <span class=\"operator\">=</span> START_VERSION;</span><br><span class=\"line\"></span><br><span class=\"line\">  ObserverWrapper(Observer&lt;? <span class=\"built_in\">super</span> T&gt; observer) &#123;</span><br><span class=\"line\">    mObserver = observer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldBeActive</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"title function_\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">detachObserver</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">activeStateChanged</span><span class=\"params\">(<span class=\"type\">boolean</span> newActive)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newActive == mActive) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class=\"line\">    <span class=\"comment\">// owner</span></span><br><span class=\"line\">    mActive = newActive;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">wasInactive</span> <span class=\"operator\">=</span> LiveData.<span class=\"built_in\">this</span>.mActiveCount == <span class=\"number\">0</span>;</span><br><span class=\"line\">    LiveData.<span class=\"built_in\">this</span>.mActiveCount += mActive ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class=\"line\">      onActive();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LiveData.<span class=\"built_in\">this</span>.mActiveCount == <span class=\"number\">0</span> &amp;&amp; !mActive) &#123;</span><br><span class=\"line\">      onInactive();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mActive) &#123;</span><br><span class=\"line\">      dispatchingValue(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在activeStateChanged方法中，先判断是否是状态的改变，如果<code>newActive == mActive</code>说明激活状态未改变，则直接返回；然后判断按照激活的observer数目和mActive状态，来判断LiveData的状态，并调用其空回调函数；最后如果mActive为true，则进行针对这个<em>ObserverWrapper</em>的事件分发。</p>\n<p><em>ObserverWrapper</em>有两个子类，<em>LifecycleBoundObserver</em>和<em>AlwaysActiveObserver</em>，<em>AlwaysActiveObserver</em>是与生命周期无关的observer，需要谨慎使用，在适当的时候，通过removeObserver来删除，我们重点看<em>LifecycleBoundObserver</em>。</p>\n<p><em>LifecycleBoundObserver</em>同时实现了<em>LifecycleEventObserver</em>，这就使得这个类具备了生命周期关联性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LifecycleBoundObserver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ObserverWrapper</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">LifecycleEventObserver</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> LifecycleOwner mOwner;</span><br><span class=\"line\"></span><br><span class=\"line\">  LifecycleBoundObserver(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class=\"built_in\">super</span> T&gt; observer) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(observer);</span><br><span class=\"line\">    mOwner = owner;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"title function_\">shouldBeActive</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onStateChanged</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner source,</span></span><br><span class=\"line\"><span class=\"params\">                             <span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">      removeObserver(mObserver);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    activeStateChanged(shouldBeActive());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"title function_\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mOwner == owner;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">detachObserver</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    mOwner.getLifecycle().removeObserver(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在onStateChanged方法中，当生命周期处于<strong>DESTROYED</strong>状态时候，则删除这个observer。除此以外，当mOwner的生命周期处于<strong>STARTED</strong>之后的状态，则认为<code>shouldBeActive</code>，当生命周期函数onStateChanged被触发时候，将设置是否active。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过LiveData的这些特性，我们可以实现Activity - Fragment, Fragment - Fragment的通信，另外也可以做应用的事件总线，比如<strong>LiveEventBus</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在阅读这篇文章前，需要先对[**Lifecycle**](&#x2F;源码分析系列&#x2F;Jetpack之Lifecycle源码分析.md)有所了解。</p>\n<p>Lifecycle是LiveData的根基，先有了生命周期的管理，才能进行安全不泄漏的数据观察。</p>\n<p>先要引入LiveData：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> activity_version = <span class=\"string\">&quot;1.1.0&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// Kotlin，引入这个扩展，可以使用by viewModels()方法</span></span><br><span class=\"line\">implementation <span class=\"string\">&quot;androidx.activity:activity-ktx:$activity_version&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>典型的用法如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> vm <span class=\"keyword\">by</span> viewModels&lt;MainVM&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.<span class=\"keyword\">data</span>.observe(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            Toast.makeText(<span class=\"keyword\">this</span><span class=\"symbol\">@MainActivity</span>, it, Toast.LENGTH_SHORT).show()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.start()</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainVM</span> : <span class=\"type\">ViewModel</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> <span class=\"keyword\">data</span> = MutableLiveData&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">start</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">data</span>.value = <span class=\"string\">&quot;start&quot;</span></span><br><span class=\"line\">        Thread &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2000</span>)</span><br><span class=\"line\">            <span class=\"keyword\">data</span>.postValue(<span class=\"string\">&quot;run after 2000ms&quot;</span>)</span><br><span class=\"line\">        &#125;.start()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从这两段代码中，我们就可以看出典型的用法，主要是在三个方法上，<em>observe</em>、<em>setValue</em>和<em>postValue</em>。我们就从这三个方法入手去探究LiveData的工作机制。</p>\n<h2 id=\"observe方法\"><a href=\"#observe方法\" class=\"headerlink\" title=\"observe方法\"></a>observe方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LiveData.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">observe</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, <span class=\"meta\">@NonNull</span> Observer&lt;? <span class=\"built_in\">super</span> T&gt; observer)</span> &#123;</span><br><span class=\"line\">  assertMainThread(<span class=\"string\">&quot;observe&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ignore</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"type\">LifecycleBoundObserver</span> <span class=\"variable\">wrapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LifecycleBoundObserver</span>(owner, observer);</span><br><span class=\"line\">  <span class=\"type\">ObserverWrapper</span> <span class=\"variable\">existing</span> <span class=\"operator\">=</span> mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (existing != <span class=\"literal\">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Cannot add the same observer&quot;</span></span><br><span class=\"line\">                                       + <span class=\"string\">&quot; with different lifecycles&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (existing != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  owner.getLifecycle().addObserver(wrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>只允许在主线程中监听数据变化，并且如果<em>LifecycleOwner</em>已经处于<strong>DESTROYED</strong>状态，则忽略这次监听请求。</li>\n<li>以<em>LifecycleOwner</em>和<em>Observer</em>创建一个<em>LifecycleBoundObserver</em>对象，这个对象继承了<em>ObserverWrapper</em>类，同时实现了<em>LifecycleEventObserver</em>接口，看到这个接口，我们便明白了<em>LiveData</em>能够生命周期安全的监听数据变化的原因了。</li>\n<li>这个<em>LifecycleBoundObserver</em>对象需要存储在一个<em>SafeIterableMap</em>当中去，在存储时候，会通过observer判断是否已经存在一个<em>ObserverWrapper</em>对象existing，如果已经存在则分为两种：a. 如果existing没有attach在owner上，则说明，existing已经attach在另外一个<em>LifecycleOwner</em>上了，这是不允许的，此时需要抛出异常；b. 如果没有attach在另外一个<em>LifecycleOwner</em>上，则说明此时监听的就是当前的owner上，则不需要再次添加监听，直接返回。如果existing不存在，则向owner.getLifecycle()添加监听。</li>\n</ol>\n<h2 id=\"setValue和postValue方法\"><a href=\"#setValue和postValue方法\" class=\"headerlink\" title=\"setValue和postValue方法\"></a>setValue和postValue方法</h2><p>在子线程中更新数据，需要调用postValue方法，实际上，这个方法就是通过一个MainHandler去post一个<em>Runnable</em>的方式切换到主线程中执行setValue方法。所以，我们重点看setValue方法即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LiveData.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">  assertMainThread(<span class=\"string\">&quot;setValue&quot;</span>);</span><br><span class=\"line\">  mVersion++;</span><br><span class=\"line\">  mData = value;</span><br><span class=\"line\">  dispatchingValue(<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意到的是<code>mVersion++</code>这句话，<em>LiveData</em>就是通过版本号来记录新的值的。继续看dispatchingValue方法。</p>\n<h3 id=\"dispatchingValue\"><a href=\"#dispatchingValue\" class=\"headerlink\" title=\"dispatchingValue\"></a>dispatchingValue</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class=\"comment\">/* synthetic access */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">dispatchingValue</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> ObserverWrapper initiator)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mDispatchingValue) &#123;\t\t\t\t<span class=\"comment\">// ①</span></span><br><span class=\"line\">    mDispatchInvalidated = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mDispatchingValue = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    mDispatchInvalidated = <span class=\"literal\">false</span>;\t<span class=\"comment\">// ②</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initiator != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      considerNotify(initiator);</span><br><span class=\"line\">      initiator = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"built_in\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">           mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">        considerNotify(iterator.next().getValue());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123; <span class=\"comment\">// ③</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">  mDispatchingValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，涉及到两个方法，1. 第一个dispatchingValue —— 用来分发控制数据更新流程；2. considerNotify具体执行数据更新操作。</p>\n<p>这个方法是双信号量控制分发流程，<strong>mDispatchingValue</strong>和<strong>mDispatchInvalidated</strong>，之所以这样设计，按照我的理解，是考虑到了dispatchingValue方法多线程重入的问题，但是依我看来，这样做没必要，因为这个方法的几处调用，都是在主线程上，不可能出现第一次调用没有执行完，就又被调用一次的可能，也可能是设计者考虑到未来的扩展或者在这个库涉及之初有多线程调用的情况才这样写的，先按照有重入可能来分析。</p>\n<p>我们先要弄清这两个信号量的作用：mDispatchingValue表示是否正在执行分发数据更新的操作，mDispatchInvalidated表示是否中断正在进行的分发，开始新一轮分发。</p>\n<p>这个方法是根据传入的参数，有两个执行流程，一个是执行具体某个ObserverWrapper的数据更新操作，另外一个就是批量更新所有observer的数据操作。我们以setValue触发的dispatchingValue(null)批量更新操作为例进行分析。</p>\n<p>注意我在上段代码中的序号①②③注释，我们分步骤进行分析：</p>\n<blockquote>\n<p>假设，此时我们有两个observer。</p>\n<p>初始状态 <strong>mDispatchingValue &#x3D; false, mDispatchInvalidated &#x3D; false</strong></p>\n<p>当<strong>第一次</strong>调用开始后，会顺利通过①处判断，然后进入do - while循环，并且在②处先将mDispatchInvalidated信号量置为false，所以，一般情况下，这个while循环只会执行一次；</p>\n<p>信号量：<strong>mDispatchingValue &#x3D; true, mDispatchInvalidated &#x3D; false</strong></p>\n<p>由于initiator参数为null，所以会进入到else分支中的for循环中，这里需要注意的是，每一次for循环结束时候，都判断一次mDispatchInvalidated信号量，也就是注释③处；</p>\n<p>假设我们执行了第一个observer后，dispatchingValue方法进行了<strong>第二次</strong>调用，由于此时mDispatchingValue信号量为true，所以会进入①处if条件判断语句，将mDispatchInvalidated信号量置为true并且直接return了；</p>\n<p>信号量：<strong>mDispatchingValue &#x3D; true, mDispatchInvalidated &#x3D; true</strong></p>\n<p>此时，第一次调用的for循环体就会因为mDispatchInvalidated变成了true，而退出for循环，while循环开始判断条件，同样因为mDispatchInvalidated为true，回再次执行while循环，执行新值更新；</p>\n<p>最后退出dispatchingValue方法后，两个信号量都置为false。</p>\n</blockquote>\n<p>这样做的目的，或许是为了及时抛弃旧值通知，开始新值通知。</p>\n<h3 id=\"considerNotify\"><a href=\"#considerNotify\" class=\"headerlink\" title=\"considerNotify\"></a>considerNotify</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class=\"line\">  <span class=\"comment\">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class=\"line\">  <span class=\"comment\">// notify for a more predictable notification order.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">    observer.activeStateChanged(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  observer.mLastVersion = mVersion;</span><br><span class=\"line\">  observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法是具体执行通知观察者值变化的地方。</p>\n<p>那么LiveData是如何判断新值和旧值的呢？</p>\n<p>在setValue方法中，有一个<code>mVersion++</code>语句，每次设置新值都会触发这个mVersion的自增，然后在considerNotify方法中，去校验observer是否处于active状态以及新值版本号与observer中的版本号，如果observer<strong>应当</strong>处于非active状态而仍然处于active状态(<strong>因为状态可能由于handler机制并没有及时变更</strong>)，则进行状态变更并返回，并且如果<code>observer.mLastVersion &gt;= mVersion</code>，则直接返回，因为此时observer已经更新过此值。<strong>也就是说，只有observer处于active状态且当前mVersion &gt; observer.mVersion的时候，才去通知observer更新值</strong>。</p>\n<p>接下来，着重看一下<em>LifecycleBoundObserver</em>和<em>ObserverWrapper</em>这个两个类。</p>\n<h2 id=\"LifecycleBoundObserver和ObserverWrapper\"><a href=\"#LifecycleBoundObserver和ObserverWrapper\" class=\"headerlink\" title=\"LifecycleBoundObserver和ObserverWrapper\"></a>LifecycleBoundObserver和ObserverWrapper</h2><p><em>ObserverWrapper</em>是<em>Observer</em>的抽象包装类，代码很简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObserverWrapper</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Observer&lt;? <span class=\"built_in\">super</span> T&gt; mObserver;</span><br><span class=\"line\">  <span class=\"type\">boolean</span> mActive;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">mLastVersion</span> <span class=\"operator\">=</span> START_VERSION;</span><br><span class=\"line\"></span><br><span class=\"line\">  ObserverWrapper(Observer&lt;? <span class=\"built_in\">super</span> T&gt; observer) &#123;</span><br><span class=\"line\">    mObserver = observer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldBeActive</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"title function_\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">detachObserver</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">activeStateChanged</span><span class=\"params\">(<span class=\"type\">boolean</span> newActive)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newActive == mActive) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class=\"line\">    <span class=\"comment\">// owner</span></span><br><span class=\"line\">    mActive = newActive;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">wasInactive</span> <span class=\"operator\">=</span> LiveData.<span class=\"built_in\">this</span>.mActiveCount == <span class=\"number\">0</span>;</span><br><span class=\"line\">    LiveData.<span class=\"built_in\">this</span>.mActiveCount += mActive ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class=\"line\">      onActive();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (LiveData.<span class=\"built_in\">this</span>.mActiveCount == <span class=\"number\">0</span> &amp;&amp; !mActive) &#123;</span><br><span class=\"line\">      onInactive();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mActive) &#123;</span><br><span class=\"line\">      dispatchingValue(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在activeStateChanged方法中，先判断是否是状态的改变，如果<code>newActive == mActive</code>说明激活状态未改变，则直接返回；然后判断按照激活的observer数目和mActive状态，来判断LiveData的状态，并调用其空回调函数；最后如果mActive为true，则进行针对这个<em>ObserverWrapper</em>的事件分发。</p>\n<p><em>ObserverWrapper</em>有两个子类，<em>LifecycleBoundObserver</em>和<em>AlwaysActiveObserver</em>，<em>AlwaysActiveObserver</em>是与生命周期无关的observer，需要谨慎使用，在适当的时候，通过removeObserver来删除，我们重点看<em>LifecycleBoundObserver</em>。</p>\n<p><em>LifecycleBoundObserver</em>同时实现了<em>LifecycleEventObserver</em>，这就使得这个类具备了生命周期关联性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LifecycleBoundObserver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ObserverWrapper</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">LifecycleEventObserver</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> LifecycleOwner mOwner;</span><br><span class=\"line\"></span><br><span class=\"line\">  LifecycleBoundObserver(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class=\"built_in\">super</span> T&gt; observer) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(observer);</span><br><span class=\"line\">    mOwner = owner;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"title function_\">shouldBeActive</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onStateChanged</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LifecycleOwner source,</span></span><br><span class=\"line\"><span class=\"params\">                             <span class=\"meta\">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">      removeObserver(mObserver);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    activeStateChanged(shouldBeActive());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"title function_\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mOwner == owner;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"title function_\">detachObserver</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    mOwner.getLifecycle().removeObserver(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在onStateChanged方法中，当生命周期处于<strong>DESTROYED</strong>状态时候，则删除这个observer。除此以外，当mOwner的生命周期处于<strong>STARTED</strong>之后的状态，则认为<code>shouldBeActive</code>，当生命周期函数onStateChanged被触发时候，将设置是否active。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过LiveData的这些特性，我们可以实现Activity - Fragment, Fragment - Fragment的通信，另外也可以做应用的事件总线，比如<strong>LiveEventBus</strong>。</p>\n"},{"layout":"post","title":"LeakCanary原理分析","author":"boybeak","_content":"\n\n```groovy\ndependencies {\n  // debugImplementation because LeakCanary should only run in debug builds.\n  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.5'\n}\n```\n\n只需要这样简单配置，就能接入LeakCanary内存泄漏分析，到底是怎样做到的？\n\n我们将这个问题分成两个问题：\n\n1. 如何**自动**进行初始化的；\n2. 如何检测到内存泄漏的。\n\n\n\n## 如何自动进行初始化的\n\n这部分，我们可以分成两部分去理解——**自动**和**初始化**。\n\n### 自动\n\n这一切还要从`ActivityThread`说起。`ActivityThread`中，执行了一些应用启动的初始化工作，在`ActivityThread`源码中，我们可以看到其内部类`class H extends Handler`的`handleMessage`方法中，有很多与应用相关的一些基本操作，比如**BIND_APPLICATION**, **EXIT_APPLICATION**, **CREATE_SERVICE**, **BIND_SERVICE**等，其中需要我们关注的是**BIND_APPLICATION**。\n\n```java\npublic void handleMessage(Message msg) {\n            ....\n            switch (msg.what) {\n                case BIND_APPLICATION:\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\n                    AppBindData data = (AppBindData)msg.obj;\n                    handleBindApplication(data);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                    break;\n                ....\n            }\n  ....\n}\n```\n\n我们可以看到，其中调用了`handleBindApplication`方法。进入这个方法查看。\n\n```java\n@UnsupportedAppUsage\nprivate void handleBindApplication(AppBindData data) {\n  ....\n  Application app;\n  final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();\n  final StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();\n  try {\n    // If the app is being launched for full backup or restore, bring it up in\n    // a restricted environment with the base application class.\n    app = data.info.makeApplication(data.restrictedBackupMode, null);\n    // Propagate autofill compat state\n    app.setAutofillOptions(data.autofillOptions);\n    // Propagate Content Capture options\n    app.setContentCaptureOptions(data.contentCaptureOptions);\n    mInitialApplication = app;\n    // don't bring up providers in restricted mode; they may depend on the\n    // app's custom Application class\n    if (!data.restrictedBackupMode) {\n      if (!ArrayUtils.isEmpty(data.providers)) {\n        installContentProviders(app, data.providers);\n      }\n    }\n    // Do this after providers, since instrumentation tests generally start their\n    // test thread at this point, and we don't want that racing.\n    try {\n      mInstrumentation.onCreate(data.instrumentationArgs);\n    }\n    catch (Exception e) {\n      throw new RuntimeException(\n        \"Exception thrown in onCreate() of \"\n        + data.instrumentationName + \": \" + e.toString(), e);\n    }\n    try {\n      mInstrumentation.callApplicationOnCreate(app);\n    } catch (Exception e) {\n      if (!mInstrumentation.onException(app, e)) {\n        throw new RuntimeException(\n          \"Unable to create application \" + app.getClass().getName()\n          + \": \" + e.toString(), e);\n      }\n    }\n  } finally {\n    // If the app targets < O-MR1, or doesn't change the thread policy\n    // during startup, clobber the policy to maintain behavior of b/36951662\n    if (data.appInfo.targetSdkVersion < Build.VERSION_CODES.O_MR1\n        || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) {\n      StrictMode.setThreadPolicy(savedPolicy);\n    }\n  }\n  ....\n}\n```\n\n从这个方法中，我们可以找到这样一段代码，需要重点关注的是，`ContentProvider`的初始化是先于`Application.onCreate`的，且是被`ActivityThread`**自动**执行的。\n\n接下来再看LeakCanary源码。找到[**AppWatcherInstaller.kt**](https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt)这个类。\n\n```kotlin\n/**\n * Content providers are loaded before the application class is created. [AppWatcherInstaller] is\n * used to install [leakcanary.AppWatcher] on application start.\n */\ninternal sealed class AppWatcherInstaller : ContentProvider() {\n\n  /**\n   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.\n   */\n  internal class MainProcess : AppWatcherInstaller()\n\n  /**\n   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,\n   * [LeakCanaryProcess] automatically sets up the LeakCanary code\n   */\n  internal class LeakCanaryProcess : AppWatcherInstaller()\n\n  override fun onCreate(): Boolean {\n    val application = context!!.applicationContext as Application\n    AppWatcher.manualInstall(application)\n    return true\n  }\n\n  override fun query(\n    uri: Uri,\n    strings: Array<String>?,\n    s: String?,\n    strings1: Array<String>?,\n    s1: String?\n  ): Cursor? {\n    return null\n  }\n\n  override fun getType(uri: Uri): String? {\n    return null\n  }\n\n  override fun insert(\n    uri: Uri,\n    contentValues: ContentValues?\n  ): Uri? {\n    return null\n  }\n\n  override fun delete(\n    uri: Uri,\n    s: String?,\n    strings: Array<String>?\n  ): Int {\n    return 0\n  }\n\n  override fun update(\n    uri: Uri,\n    contentValues: ContentValues?,\n    s: String?,\n    strings: Array<String>?\n  ): Int {\n    return 0\n  }\n}\n```\n\n我们可以看到，这个类是一个`ContentProvider`的子类，其query, insert等方法根本没有实际作用，有实际作用的只有`onCreate`方法，在这个方法中，执行了`AppWatcher`的install工作。\n\n这里我们就可以看出来，LeakCanary就是利用`ContentProvider`的`onCreate`方法自动执行的特性，来自动“安装”这个类库的。\n\n### 初始化\n\n通过追踪`AppWatcher.manualInstall(application)`这句代码，我们可以追踪到[**InternalLeakCanary.kt**](https://github.com/square/leakcanary/blob/main/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt)的`install`方法，如下：\n\n```kotlin\nfun install(application: Application) {\n  checkMainThread()\n  if (this::application.isInitialized) {\n    return\n  }\n  InternalAppWatcher.application = application\n  if (isDebuggableBuild) {\n    SharkLog.logger = DefaultCanaryLog()\n  }\n\n  val configProvider = { AppWatcher.config }\n  ActivityDestroyWatcher.install(application, objectWatcher, configProvider)\n  FragmentDestroyWatcher.install(application, objectWatcher, configProvider)\n  onAppWatcherInstalled(application)\n}\n```\n\n我们可以看到，先后执行了`ActivityDestroyWatcher.install`,`FragmentDestroyWatcher.install`和`onAppWatcherInstalled(application)`方法。\n\n其中在`onAppWatcherInstalled`创建了LeakCanary图标的快捷方式，用于方便查看内存泄漏的路径信息。最终实现的具体过程可以查看[**InternalLeakCanary.kt**](https://github.com/square/leakcanary/blob/main/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt)的`addDynamicShortcut`方法。\n\n其他的两段代码——`ActivityDestroyWatcher.install`和`FragmentDestroyWatcher.install`，分别对应着两个类——`ActivityDestroyWatcher`和`FragmentDestroyWatcher`。这两个类相对来说比较简单，主要工作就是执行了`application.registerActivityLifecycleCallbacks`这段代码，目的是为了监听每个Activity的onDestroy事件。这也是判断该Activity是否泄漏的开端。\n\n以`ActivityDestroyWatcher`为例，其ActivityLifecycleCallback中代码如下：\n\n```kotlin\nprivate val lifecycleCallbacks =\n    object : Application.ActivityLifecycleCallbacks by noOpDelegate() {\n      override fun onActivityDestroyed(activity: Activity) {\n        if (configProvider().watchActivities) {\n          objectWatcher.watch(\n              activity, \"${activity::class.java.name} received Activity#onDestroy() callback\"\n          )\n        }\n      }\n    }\n```\n\n我们可以看到，这其中，最终是`objectWatcher`来进行内存泄漏监控的。\n\n\n\n## 如何检测到内存泄漏的\n\n这里涉及到两个关键的类：**[`ObjectWatcher`](https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt)**和**[`KeyedWeakReference`](https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt)**。\n\n`KeyedWeakReference`是`WeakReference`的子类，添加了额外的属性，代码十分简单，如下：\n\n```kotlin\nclass KeyedWeakReference(\n  referent: Any,\n  val key: String,\n  val description: String,\n  val watchUptimeMillis: Long,\n  referenceQueue: ReferenceQueue<Any>\n) : WeakReference<Any>(\n    referent, referenceQueue\n) {\n  /**\n   * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn't\n   * been yet.\n   */\n  @Volatile\n  var retainedUptimeMillis = -1L\n\n  companion object {\n    @Volatile\n    @JvmStatic var heapDumpUptimeMillis = 0L\n  }\n}\n```\n\n接下来我们看`ObjectWatcher`中的`watchObject`方法。\n\n```kotlin\n  /**\n   * Watches the provided [watchedObject].\n   *\n   * @param description Describes why the object is watched.\n   */\n  @Synchronized fun watch(\n    watchedObject: Any,\n    description: String\n  ) {\n    if (!isEnabled()) {\n      return\n    }\n    removeWeaklyReachableObjects()\n    val key = UUID.randomUUID()\n        .toString()\n    val watchUptimeMillis = clock.uptimeMillis()\n    val reference =\n      KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)\n    SharkLog.d {\n      \"Watching \" +\n          (if (watchedObject is Class<*>) watchedObject.toString() else \"instance of ${watchedObject.javaClass.name}\") +\n          (if (description.isNotEmpty()) \" ($description)\" else \"\") +\n          \" with key $key\"\n    }\n\n    watchedObjects[key] = reference\n    checkRetainedExecutor.execute {\n      moveToRetained(key)\n    }\n  }\n```\n\n这里分为三步：\n\n1. 执行`removeWeaklyReachableObjects()`方法，这个方法之后讲到；\n2. 生成一个`KeyedWeakReference`对象，并将这个对象添加到`watchedObjects`去；\n3. 定时执行`moveToRetained`方法。\n\n- 我们先看第二步，生成`KeyedWeakReference`对象时候，传入了一个一个`ReferenceQueue`对象，这是检测对象是否被回收的关键。假如一个对象O，被弱引用WR持有的时候，同时这个弱引用WR在构造时候传入了一个`ReferenceQueue`对象Q，则这个对象O被回收时候，WR将会被添加到Q中去，这样，通过检测Q中有没有值，便可以知道O有没有被回收掉。这也就是第一步做的事。\n\n- 接下来我们查看`removeWeaklyReachableObjects`方法中做了什么。\n\n```kotlin\nprivate fun removeWeaklyReachableObjects() {\n  // WeakReferences are enqueued as soon as the object to which they point to becomes weakly\n  // reachable. This is before finalization or garbage collection has actually happened.\n  var ref: KeyedWeakReference?\n  do {\n    ref = queue.poll() as KeyedWeakReference?\n    if (ref != null) {\n      watchedObjects.remove(ref.key)\n    }\n  } while (ref != null)\n}\n```\n\n在这个方法中，从queue中取值，取出来ref，则说明被ref修饰的对象已经被回收了，则将这个弱引用ref从`watchedObjects`清除掉。\n\n- 接下来到了第三步，这一步实际上是一个定时5秒(LeakCanary默认)去将watchedObjects中残留的引用，移入到`retainedObjects`中去。我们来看其中代码：\n\n```kotlin\n@Synchronized private fun moveToRetained(key: String) {\n  removeWeaklyReachableObjects()\n  val retainedRef = watchedObjects[key]\n  if (retainedRef != null) {\n    retainedRef.retainedUptimeMillis = clock.uptimeMillis()\n    onObjectRetainedListeners.forEach { it.onObjectRetained() }\n  }\n}\n```\n\n执行这个任务的Executor实际实现在[**InternalAppWatcher.kt**](https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt)中，代码如下：\n\n```kotlin\nprivate val checkRetainedExecutor = Executor {\n  mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)\n}\n```\n\n我们发现，在`moveToRetained`中，还是先执行了`removeWeaklyReachableObjects`这一方法。目的是再次清除已经被回收的对象。如果经过这一步，仍然有引用留在watchedObjects中，则可以认为，这些对象泄漏了。\n\n```kotlin\n/**\n   * Returns the objects that are currently considered retained. Useful for logging purposes.\n   * Be careful with those objects and release them ASAP as you may creating longer lived leaks\n   * then the one that are already there.\n   */\nval retainedObjects: List<Any>\n@Synchronized get() {\n  removeWeaklyReachableObjects()\n  val instances = mutableListOf<Any>()\n  for (weakReference in watchedObjects.values) {\n    if (weakReference.retainedUptimeMillis != -1L) {\n      val instance = weakReference.get()\n      if (instance != null) {\n        instances.add(instance)\n      }\n    }\n  }\n  return instances\n}\n```\n\n\n\n## 总结\n\n不要在发行版本中使用LeakCanary，因为一系列初始化动作，可能会导致应用启动较慢。如果要用，请使用LeakCanary-Object-Watcher，或者直接使用Buggly这样的成熟框架。","source":"_posts/2022-09-17-LeakCanary原理分析.md","raw":"---\nlayout: post\ntitle: LeakCanary原理分析\nauthor: boybeak\ncategory: 源码分析\ntags: Android\n---\n\n\n```groovy\ndependencies {\n  // debugImplementation because LeakCanary should only run in debug builds.\n  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.5'\n}\n```\n\n只需要这样简单配置，就能接入LeakCanary内存泄漏分析，到底是怎样做到的？\n\n我们将这个问题分成两个问题：\n\n1. 如何**自动**进行初始化的；\n2. 如何检测到内存泄漏的。\n\n\n\n## 如何自动进行初始化的\n\n这部分，我们可以分成两部分去理解——**自动**和**初始化**。\n\n### 自动\n\n这一切还要从`ActivityThread`说起。`ActivityThread`中，执行了一些应用启动的初始化工作，在`ActivityThread`源码中，我们可以看到其内部类`class H extends Handler`的`handleMessage`方法中，有很多与应用相关的一些基本操作，比如**BIND_APPLICATION**, **EXIT_APPLICATION**, **CREATE_SERVICE**, **BIND_SERVICE**等，其中需要我们关注的是**BIND_APPLICATION**。\n\n```java\npublic void handleMessage(Message msg) {\n            ....\n            switch (msg.what) {\n                case BIND_APPLICATION:\n                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\n                    AppBindData data = (AppBindData)msg.obj;\n                    handleBindApplication(data);\n                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                    break;\n                ....\n            }\n  ....\n}\n```\n\n我们可以看到，其中调用了`handleBindApplication`方法。进入这个方法查看。\n\n```java\n@UnsupportedAppUsage\nprivate void handleBindApplication(AppBindData data) {\n  ....\n  Application app;\n  final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();\n  final StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();\n  try {\n    // If the app is being launched for full backup or restore, bring it up in\n    // a restricted environment with the base application class.\n    app = data.info.makeApplication(data.restrictedBackupMode, null);\n    // Propagate autofill compat state\n    app.setAutofillOptions(data.autofillOptions);\n    // Propagate Content Capture options\n    app.setContentCaptureOptions(data.contentCaptureOptions);\n    mInitialApplication = app;\n    // don't bring up providers in restricted mode; they may depend on the\n    // app's custom Application class\n    if (!data.restrictedBackupMode) {\n      if (!ArrayUtils.isEmpty(data.providers)) {\n        installContentProviders(app, data.providers);\n      }\n    }\n    // Do this after providers, since instrumentation tests generally start their\n    // test thread at this point, and we don't want that racing.\n    try {\n      mInstrumentation.onCreate(data.instrumentationArgs);\n    }\n    catch (Exception e) {\n      throw new RuntimeException(\n        \"Exception thrown in onCreate() of \"\n        + data.instrumentationName + \": \" + e.toString(), e);\n    }\n    try {\n      mInstrumentation.callApplicationOnCreate(app);\n    } catch (Exception e) {\n      if (!mInstrumentation.onException(app, e)) {\n        throw new RuntimeException(\n          \"Unable to create application \" + app.getClass().getName()\n          + \": \" + e.toString(), e);\n      }\n    }\n  } finally {\n    // If the app targets < O-MR1, or doesn't change the thread policy\n    // during startup, clobber the policy to maintain behavior of b/36951662\n    if (data.appInfo.targetSdkVersion < Build.VERSION_CODES.O_MR1\n        || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) {\n      StrictMode.setThreadPolicy(savedPolicy);\n    }\n  }\n  ....\n}\n```\n\n从这个方法中，我们可以找到这样一段代码，需要重点关注的是，`ContentProvider`的初始化是先于`Application.onCreate`的，且是被`ActivityThread`**自动**执行的。\n\n接下来再看LeakCanary源码。找到[**AppWatcherInstaller.kt**](https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt)这个类。\n\n```kotlin\n/**\n * Content providers are loaded before the application class is created. [AppWatcherInstaller] is\n * used to install [leakcanary.AppWatcher] on application start.\n */\ninternal sealed class AppWatcherInstaller : ContentProvider() {\n\n  /**\n   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.\n   */\n  internal class MainProcess : AppWatcherInstaller()\n\n  /**\n   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,\n   * [LeakCanaryProcess] automatically sets up the LeakCanary code\n   */\n  internal class LeakCanaryProcess : AppWatcherInstaller()\n\n  override fun onCreate(): Boolean {\n    val application = context!!.applicationContext as Application\n    AppWatcher.manualInstall(application)\n    return true\n  }\n\n  override fun query(\n    uri: Uri,\n    strings: Array<String>?,\n    s: String?,\n    strings1: Array<String>?,\n    s1: String?\n  ): Cursor? {\n    return null\n  }\n\n  override fun getType(uri: Uri): String? {\n    return null\n  }\n\n  override fun insert(\n    uri: Uri,\n    contentValues: ContentValues?\n  ): Uri? {\n    return null\n  }\n\n  override fun delete(\n    uri: Uri,\n    s: String?,\n    strings: Array<String>?\n  ): Int {\n    return 0\n  }\n\n  override fun update(\n    uri: Uri,\n    contentValues: ContentValues?,\n    s: String?,\n    strings: Array<String>?\n  ): Int {\n    return 0\n  }\n}\n```\n\n我们可以看到，这个类是一个`ContentProvider`的子类，其query, insert等方法根本没有实际作用，有实际作用的只有`onCreate`方法，在这个方法中，执行了`AppWatcher`的install工作。\n\n这里我们就可以看出来，LeakCanary就是利用`ContentProvider`的`onCreate`方法自动执行的特性，来自动“安装”这个类库的。\n\n### 初始化\n\n通过追踪`AppWatcher.manualInstall(application)`这句代码，我们可以追踪到[**InternalLeakCanary.kt**](https://github.com/square/leakcanary/blob/main/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt)的`install`方法，如下：\n\n```kotlin\nfun install(application: Application) {\n  checkMainThread()\n  if (this::application.isInitialized) {\n    return\n  }\n  InternalAppWatcher.application = application\n  if (isDebuggableBuild) {\n    SharkLog.logger = DefaultCanaryLog()\n  }\n\n  val configProvider = { AppWatcher.config }\n  ActivityDestroyWatcher.install(application, objectWatcher, configProvider)\n  FragmentDestroyWatcher.install(application, objectWatcher, configProvider)\n  onAppWatcherInstalled(application)\n}\n```\n\n我们可以看到，先后执行了`ActivityDestroyWatcher.install`,`FragmentDestroyWatcher.install`和`onAppWatcherInstalled(application)`方法。\n\n其中在`onAppWatcherInstalled`创建了LeakCanary图标的快捷方式，用于方便查看内存泄漏的路径信息。最终实现的具体过程可以查看[**InternalLeakCanary.kt**](https://github.com/square/leakcanary/blob/main/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt)的`addDynamicShortcut`方法。\n\n其他的两段代码——`ActivityDestroyWatcher.install`和`FragmentDestroyWatcher.install`，分别对应着两个类——`ActivityDestroyWatcher`和`FragmentDestroyWatcher`。这两个类相对来说比较简单，主要工作就是执行了`application.registerActivityLifecycleCallbacks`这段代码，目的是为了监听每个Activity的onDestroy事件。这也是判断该Activity是否泄漏的开端。\n\n以`ActivityDestroyWatcher`为例，其ActivityLifecycleCallback中代码如下：\n\n```kotlin\nprivate val lifecycleCallbacks =\n    object : Application.ActivityLifecycleCallbacks by noOpDelegate() {\n      override fun onActivityDestroyed(activity: Activity) {\n        if (configProvider().watchActivities) {\n          objectWatcher.watch(\n              activity, \"${activity::class.java.name} received Activity#onDestroy() callback\"\n          )\n        }\n      }\n    }\n```\n\n我们可以看到，这其中，最终是`objectWatcher`来进行内存泄漏监控的。\n\n\n\n## 如何检测到内存泄漏的\n\n这里涉及到两个关键的类：**[`ObjectWatcher`](https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt)**和**[`KeyedWeakReference`](https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt)**。\n\n`KeyedWeakReference`是`WeakReference`的子类，添加了额外的属性，代码十分简单，如下：\n\n```kotlin\nclass KeyedWeakReference(\n  referent: Any,\n  val key: String,\n  val description: String,\n  val watchUptimeMillis: Long,\n  referenceQueue: ReferenceQueue<Any>\n) : WeakReference<Any>(\n    referent, referenceQueue\n) {\n  /**\n   * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn't\n   * been yet.\n   */\n  @Volatile\n  var retainedUptimeMillis = -1L\n\n  companion object {\n    @Volatile\n    @JvmStatic var heapDumpUptimeMillis = 0L\n  }\n}\n```\n\n接下来我们看`ObjectWatcher`中的`watchObject`方法。\n\n```kotlin\n  /**\n   * Watches the provided [watchedObject].\n   *\n   * @param description Describes why the object is watched.\n   */\n  @Synchronized fun watch(\n    watchedObject: Any,\n    description: String\n  ) {\n    if (!isEnabled()) {\n      return\n    }\n    removeWeaklyReachableObjects()\n    val key = UUID.randomUUID()\n        .toString()\n    val watchUptimeMillis = clock.uptimeMillis()\n    val reference =\n      KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)\n    SharkLog.d {\n      \"Watching \" +\n          (if (watchedObject is Class<*>) watchedObject.toString() else \"instance of ${watchedObject.javaClass.name}\") +\n          (if (description.isNotEmpty()) \" ($description)\" else \"\") +\n          \" with key $key\"\n    }\n\n    watchedObjects[key] = reference\n    checkRetainedExecutor.execute {\n      moveToRetained(key)\n    }\n  }\n```\n\n这里分为三步：\n\n1. 执行`removeWeaklyReachableObjects()`方法，这个方法之后讲到；\n2. 生成一个`KeyedWeakReference`对象，并将这个对象添加到`watchedObjects`去；\n3. 定时执行`moveToRetained`方法。\n\n- 我们先看第二步，生成`KeyedWeakReference`对象时候，传入了一个一个`ReferenceQueue`对象，这是检测对象是否被回收的关键。假如一个对象O，被弱引用WR持有的时候，同时这个弱引用WR在构造时候传入了一个`ReferenceQueue`对象Q，则这个对象O被回收时候，WR将会被添加到Q中去，这样，通过检测Q中有没有值，便可以知道O有没有被回收掉。这也就是第一步做的事。\n\n- 接下来我们查看`removeWeaklyReachableObjects`方法中做了什么。\n\n```kotlin\nprivate fun removeWeaklyReachableObjects() {\n  // WeakReferences are enqueued as soon as the object to which they point to becomes weakly\n  // reachable. This is before finalization or garbage collection has actually happened.\n  var ref: KeyedWeakReference?\n  do {\n    ref = queue.poll() as KeyedWeakReference?\n    if (ref != null) {\n      watchedObjects.remove(ref.key)\n    }\n  } while (ref != null)\n}\n```\n\n在这个方法中，从queue中取值，取出来ref，则说明被ref修饰的对象已经被回收了，则将这个弱引用ref从`watchedObjects`清除掉。\n\n- 接下来到了第三步，这一步实际上是一个定时5秒(LeakCanary默认)去将watchedObjects中残留的引用，移入到`retainedObjects`中去。我们来看其中代码：\n\n```kotlin\n@Synchronized private fun moveToRetained(key: String) {\n  removeWeaklyReachableObjects()\n  val retainedRef = watchedObjects[key]\n  if (retainedRef != null) {\n    retainedRef.retainedUptimeMillis = clock.uptimeMillis()\n    onObjectRetainedListeners.forEach { it.onObjectRetained() }\n  }\n}\n```\n\n执行这个任务的Executor实际实现在[**InternalAppWatcher.kt**](https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt)中，代码如下：\n\n```kotlin\nprivate val checkRetainedExecutor = Executor {\n  mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)\n}\n```\n\n我们发现，在`moveToRetained`中，还是先执行了`removeWeaklyReachableObjects`这一方法。目的是再次清除已经被回收的对象。如果经过这一步，仍然有引用留在watchedObjects中，则可以认为，这些对象泄漏了。\n\n```kotlin\n/**\n   * Returns the objects that are currently considered retained. Useful for logging purposes.\n   * Be careful with those objects and release them ASAP as you may creating longer lived leaks\n   * then the one that are already there.\n   */\nval retainedObjects: List<Any>\n@Synchronized get() {\n  removeWeaklyReachableObjects()\n  val instances = mutableListOf<Any>()\n  for (weakReference in watchedObjects.values) {\n    if (weakReference.retainedUptimeMillis != -1L) {\n      val instance = weakReference.get()\n      if (instance != null) {\n        instances.add(instance)\n      }\n    }\n  }\n  return instances\n}\n```\n\n\n\n## 总结\n\n不要在发行版本中使用LeakCanary，因为一系列初始化动作，可能会导致应用启动较慢。如果要用，请使用LeakCanary-Object-Watcher，或者直接使用Buggly这样的成熟框架。","slug":"2022-09-17-LeakCanary原理分析","published":1,"date":"2020-11-03T14:07:34.000Z","updated":"2022-09-19T01:34:28.388Z","comments":1,"photos":[],"link":"","_id":"cldqukh8n000cpcjgd7ccb2wi","content":"<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugImplementation because LeakCanary should only run in debug builds.</span></span><br><span class=\"line\">  debugImplementation <span class=\"string\">&#x27;com.squareup.leakcanary:leakcanary-android:2.5&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只需要这样简单配置，就能接入LeakCanary内存泄漏分析，到底是怎样做到的？</p>\n<p>我们将这个问题分成两个问题：</p>\n<ol>\n<li>如何<strong>自动</strong>进行初始化的；</li>\n<li>如何检测到内存泄漏的。</li>\n</ol>\n<h2 id=\"如何自动进行初始化的\"><a href=\"#如何自动进行初始化的\" class=\"headerlink\" title=\"如何自动进行初始化的\"></a>如何自动进行初始化的</h2><p>这部分，我们可以分成两部分去理解——<strong>自动</strong>和<strong>初始化</strong>。</p>\n<h3 id=\"自动\"><a href=\"#自动\" class=\"headerlink\" title=\"自动\"></a>自动</h3><p>这一切还要从<code>ActivityThread</code>说起。<code>ActivityThread</code>中，执行了一些应用启动的初始化工作，在<code>ActivityThread</code>源码中，我们可以看到其内部类<code>class H extends Handler</code>的<code>handleMessage</code>方法中，有很多与应用相关的一些基本操作，比如<strong>BIND_APPLICATION</strong>, <strong>EXIT_APPLICATION</strong>, <strong>CREATE_SERVICE</strong>, <strong>BIND_SERVICE</strong>等，其中需要我们关注的是<strong>BIND_APPLICATION</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> BIND_APPLICATION:</span><br><span class=\"line\">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;bindApplication&quot;</span>);</span><br><span class=\"line\">                    <span class=\"type\">AppBindData</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> (AppBindData)msg.obj;</span><br><span class=\"line\">                    handleBindApplication(data);</span><br><span class=\"line\">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                ....</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">  ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，其中调用了<code>handleBindApplication</code>方法。进入这个方法查看。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleBindApplication</span><span class=\"params\">(AppBindData data)</span> &#123;</span><br><span class=\"line\">  ....</span><br><span class=\"line\">  Application app;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> StrictMode.<span class=\"type\">ThreadPolicy</span> <span class=\"variable\">savedPolicy</span> <span class=\"operator\">=</span> StrictMode.allowThreadDiskWrites();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> StrictMode.<span class=\"type\">ThreadPolicy</span> <span class=\"variable\">writesAllowedPolicy</span> <span class=\"operator\">=</span> StrictMode.getThreadPolicy();</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class=\"line\">    <span class=\"comment\">// a restricted environment with the base application class.</span></span><br><span class=\"line\">    app = data.info.makeApplication(data.restrictedBackupMode, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Propagate autofill compat state</span></span><br><span class=\"line\">    app.setAutofillOptions(data.autofillOptions);</span><br><span class=\"line\">    <span class=\"comment\">// Propagate Content Capture options</span></span><br><span class=\"line\">    app.setContentCaptureOptions(data.contentCaptureOptions);</span><br><span class=\"line\">    mInitialApplication = app;</span><br><span class=\"line\">    <span class=\"comment\">// don&#x27;t bring up providers in restricted mode; they may depend on the</span></span><br><span class=\"line\">    <span class=\"comment\">// app&#x27;s custom Application class</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class=\"line\">        installContentProviders(app, data.providers);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class=\"line\">    <span class=\"comment\">// test thread at this point, and we don&#x27;t want that racing.</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(</span><br><span class=\"line\">        <span class=\"string\">&quot;Exception thrown in onCreate() of &quot;</span></span><br><span class=\"line\">        + data.instrumentationName + <span class=\"string\">&quot;: &quot;</span> + e.toString(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      mInstrumentation.callApplicationOnCreate(app);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(</span><br><span class=\"line\">          <span class=\"string\">&quot;Unable to create application &quot;</span> + app.getClass().getName()</span><br><span class=\"line\">          + <span class=\"string\">&quot;: &quot;</span> + e.toString(), e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If the app targets &lt; O-MR1, or doesn&#x27;t change the thread policy</span></span><br><span class=\"line\">    <span class=\"comment\">// during startup, clobber the policy to maintain behavior of b/36951662</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class=\"line\">        || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class=\"line\">      StrictMode.setThreadPolicy(savedPolicy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从这个方法中，我们可以找到这样一段代码，需要重点关注的是，<code>ContentProvider</code>的初始化是先于<code>Application.onCreate</code>的，且是被<code>ActivityThread</code><strong>自动</strong>执行的。</p>\n<p>接下来再看LeakCanary源码。找到<a href=\"https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt\"><strong>AppWatcherInstaller.kt</strong></a>这个类。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Content providers are loaded before the application class is created. [AppWatcherInstaller] is</span></span><br><span class=\"line\"><span class=\"comment\"> * used to install [leakcanary.AppWatcher] on application start.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">sealed</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppWatcherInstaller</span> : <span class=\"type\">ContentProvider</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">internal</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainProcess</span> : <span class=\"type\">AppWatcherInstaller</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span></span><br><span class=\"line\"><span class=\"comment\">   * [LeakCanaryProcess] automatically sets up the LeakCanary code</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">internal</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LeakCanaryProcess</span> : <span class=\"type\">AppWatcherInstaller</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> application = context!!.applicationContext <span class=\"keyword\">as</span> Application</span><br><span class=\"line\">    AppWatcher.manualInstall(application)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">query</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    uri: <span class=\"type\">Uri</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    strings: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;?,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    s: <span class=\"type\">String</span>?,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    strings1: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;?,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    s1: <span class=\"type\">String</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  )</span></span>: Cursor? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getType</span><span class=\"params\">(uri: <span class=\"type\">Uri</span>)</span></span>: String? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insert</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    uri: <span class=\"type\">Uri</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    contentValues: <span class=\"type\">ContentValues</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  )</span></span>: Uri? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">delete</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    uri: <span class=\"type\">Uri</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    s: <span class=\"type\">String</span>?,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    strings: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  )</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">update</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    uri: <span class=\"type\">Uri</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    contentValues: <span class=\"type\">ContentValues</span>?,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    s: <span class=\"type\">String</span>?,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    strings: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  )</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，这个类是一个<code>ContentProvider</code>的子类，其query, insert等方法根本没有实际作用，有实际作用的只有<code>onCreate</code>方法，在这个方法中，执行了<code>AppWatcher</code>的install工作。</p>\n<p>这里我们就可以看出来，LeakCanary就是利用<code>ContentProvider</code>的<code>onCreate</code>方法自动执行的特性，来自动“安装”这个类库的。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>通过追踪<code>AppWatcher.manualInstall(application)</code>这句代码，我们可以追踪到<a href=\"https://github.com/square/leakcanary/blob/main/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt\"><strong>InternalLeakCanary.kt</strong></a>的<code>install</code>方法，如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">install</span><span class=\"params\">(application: <span class=\"type\">Application</span>)</span></span> &#123;</span><br><span class=\"line\">  checkMainThread()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>::application.isInitialized) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  InternalAppWatcher.application = application</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isDebuggableBuild) &#123;</span><br><span class=\"line\">    SharkLog.logger = DefaultCanaryLog()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> configProvider = &#123; AppWatcher.config &#125;</span><br><span class=\"line\">  ActivityDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class=\"line\">  FragmentDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class=\"line\">  onAppWatcherInstalled(application)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，先后执行了<code>ActivityDestroyWatcher.install</code>,<code>FragmentDestroyWatcher.install</code>和<code>onAppWatcherInstalled(application)</code>方法。</p>\n<p>其中在<code>onAppWatcherInstalled</code>创建了LeakCanary图标的快捷方式，用于方便查看内存泄漏的路径信息。最终实现的具体过程可以查看<a href=\"https://github.com/square/leakcanary/blob/main/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt\"><strong>InternalLeakCanary.kt</strong></a>的<code>addDynamicShortcut</code>方法。</p>\n<p>其他的两段代码——<code>ActivityDestroyWatcher.install</code>和<code>FragmentDestroyWatcher.install</code>，分别对应着两个类——<code>ActivityDestroyWatcher</code>和<code>FragmentDestroyWatcher</code>。这两个类相对来说比较简单，主要工作就是执行了<code>application.registerActivityLifecycleCallbacks</code>这段代码，目的是为了监听每个Activity的onDestroy事件。这也是判断该Activity是否泄漏的开端。</p>\n<p>以<code>ActivityDestroyWatcher</code>为例，其ActivityLifecycleCallback中代码如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> lifecycleCallbacks =</span><br><span class=\"line\">    <span class=\"keyword\">object</span> : Application.ActivityLifecycleCallbacks <span class=\"keyword\">by</span> noOpDelegate() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(activity: <span class=\"type\">Activity</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (configProvider().watchActivities) &#123;</span><br><span class=\"line\">          objectWatcher.watch(</span><br><span class=\"line\">              activity, <span class=\"string\">&quot;<span class=\"subst\">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span></span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，这其中，最终是<code>objectWatcher</code>来进行内存泄漏监控的。</p>\n<h2 id=\"如何检测到内存泄漏的\"><a href=\"#如何检测到内存泄漏的\" class=\"headerlink\" title=\"如何检测到内存泄漏的\"></a>如何检测到内存泄漏的</h2><p>这里涉及到两个关键的类：**<a href=\"https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt\"><code>ObjectWatcher</code></a><strong>和</strong><a href=\"https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt\"><code>KeyedWeakReference</code></a>**。</p>\n<p><code>KeyedWeakReference</code>是<code>WeakReference</code>的子类，添加了额外的属性，代码十分简单，如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">KeyedWeakReference</span>(</span><br><span class=\"line\">  referent: Any,</span><br><span class=\"line\">  <span class=\"keyword\">val</span> key: String,</span><br><span class=\"line\">  <span class=\"keyword\">val</span> description: String,</span><br><span class=\"line\">  <span class=\"keyword\">val</span> watchUptimeMillis: <span class=\"built_in\">Long</span>,</span><br><span class=\"line\">  referenceQueue: ReferenceQueue&lt;Any&gt;</span><br><span class=\"line\">) : WeakReference&lt;Any&gt;(</span><br><span class=\"line\">    referent, referenceQueue</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn&#x27;t</span></span><br><span class=\"line\"><span class=\"comment\">   * been yet.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> retainedUptimeMillis = -<span class=\"number\">1L</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">    <span class=\"meta\">@JvmStatic</span> <span class=\"keyword\">var</span> heapDumpUptimeMillis = <span class=\"number\">0L</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们看<code>ObjectWatcher</code>中的<code>watchObject</code>方法。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Watches the provided [watchedObject].</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> description Describes why the object is watched.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Synchronized</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">watch</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  watchedObject: <span class=\"type\">Any</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  description: <span class=\"type\">String</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isEnabled()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  removeWeaklyReachableObjects()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> key = UUID.randomUUID()</span><br><span class=\"line\">      .toString()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> reference =</span><br><span class=\"line\">    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class=\"line\">  SharkLog.d &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Watching &quot;</span> +</span><br><span class=\"line\">        (<span class=\"keyword\">if</span> (watchedObject <span class=\"keyword\">is</span> Class&lt;*&gt;) watchedObject.toString() <span class=\"keyword\">else</span> <span class=\"string\">&quot;instance of <span class=\"subst\">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +</span><br><span class=\"line\">        (<span class=\"keyword\">if</span> (description.isNotEmpty()) <span class=\"string\">&quot; (<span class=\"variable\">$description</span>)&quot;</span> <span class=\"keyword\">else</span> <span class=\"string\">&quot;&quot;</span>) +</span><br><span class=\"line\">        <span class=\"string\">&quot; with key <span class=\"variable\">$key</span>&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  watchedObjects[key] = reference</span><br><span class=\"line\">  checkRetainedExecutor.execute &#123;</span><br><span class=\"line\">    moveToRetained(key)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里分为三步：</p>\n<ol>\n<li>执行<code>removeWeaklyReachableObjects()</code>方法，这个方法之后讲到；</li>\n<li>生成一个<code>KeyedWeakReference</code>对象，并将这个对象添加到<code>watchedObjects</code>去；</li>\n<li>定时执行<code>moveToRetained</code>方法。</li>\n</ol>\n<ul>\n<li><p>我们先看第二步，生成<code>KeyedWeakReference</code>对象时候，传入了一个一个<code>ReferenceQueue</code>对象，这是检测对象是否被回收的关键。假如一个对象O，被弱引用WR持有的时候，同时这个弱引用WR在构造时候传入了一个<code>ReferenceQueue</code>对象Q，则这个对象O被回收时候，WR将会被添加到Q中去，这样，通过检测Q中有没有值，便可以知道O有没有被回收掉。这也就是第一步做的事。</p>\n</li>\n<li><p>接下来我们查看<code>removeWeaklyReachableObjects</code>方法中做了什么。</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">removeWeaklyReachableObjects</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class=\"line\">  <span class=\"comment\">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ref: KeyedWeakReference?</span><br><span class=\"line\">  <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    ref = queue.poll() <span class=\"keyword\">as</span> KeyedWeakReference?</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ref != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      watchedObjects.remove(ref.key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">while</span> (ref != <span class=\"literal\">null</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个方法中，从queue中取值，取出来ref，则说明被ref修饰的对象已经被回收了，则将这个弱引用ref从<code>watchedObjects</code>清除掉。</p>\n<ul>\n<li>接下来到了第三步，这一步实际上是一个定时5秒(LeakCanary默认)去将watchedObjects中残留的引用，移入到<code>retainedObjects</code>中去。我们来看其中代码：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Synchronized</span> <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">moveToRetained</span><span class=\"params\">(key: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">  removeWeaklyReachableObjects()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> retainedRef = watchedObjects[key]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (retainedRef != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class=\"line\">    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行这个任务的Executor实际实现在<a href=\"https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt\"><strong>InternalAppWatcher.kt</strong></a>中，代码如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> checkRetainedExecutor = Executor &#123;</span><br><span class=\"line\">  mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们发现，在<code>moveToRetained</code>中，还是先执行了<code>removeWeaklyReachableObjects</code>这一方法。目的是再次清除已经被回收的对象。如果经过这一步，仍然有引用留在watchedObjects中，则可以认为，这些对象泄漏了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Returns the objects that are currently considered retained. Useful for logging purposes.</span></span><br><span class=\"line\"><span class=\"comment\">   * Be careful with those objects and release them ASAP as you may creating longer lived leaks</span></span><br><span class=\"line\"><span class=\"comment\">   * then the one that are already there.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> retainedObjects: List&lt;Any&gt;</span><br><span class=\"line\"><span class=\"meta\">@Synchronized</span> <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">  removeWeaklyReachableObjects()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> instances = mutableListOf&lt;Any&gt;()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (weakReference <span class=\"keyword\">in</span> watchedObjects.values) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (weakReference.retainedUptimeMillis != -<span class=\"number\">1L</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> instance = weakReference.<span class=\"keyword\">get</span>()</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (instance != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        instances.add(instance)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instances</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>不要在发行版本中使用LeakCanary，因为一系列初始化动作，可能会导致应用启动较慢。如果要用，请使用LeakCanary-Object-Watcher，或者直接使用Buggly这样的成熟框架。</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  <span class=\"comment\">// debugImplementation because LeakCanary should only run in debug builds.</span></span><br><span class=\"line\">  debugImplementation <span class=\"string\">&#x27;com.squareup.leakcanary:leakcanary-android:2.5&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只需要这样简单配置，就能接入LeakCanary内存泄漏分析，到底是怎样做到的？</p>\n<p>我们将这个问题分成两个问题：</p>\n<ol>\n<li>如何<strong>自动</strong>进行初始化的；</li>\n<li>如何检测到内存泄漏的。</li>\n</ol>\n<h2 id=\"如何自动进行初始化的\"><a href=\"#如何自动进行初始化的\" class=\"headerlink\" title=\"如何自动进行初始化的\"></a>如何自动进行初始化的</h2><p>这部分，我们可以分成两部分去理解——<strong>自动</strong>和<strong>初始化</strong>。</p>\n<h3 id=\"自动\"><a href=\"#自动\" class=\"headerlink\" title=\"自动\"></a>自动</h3><p>这一切还要从<code>ActivityThread</code>说起。<code>ActivityThread</code>中，执行了一些应用启动的初始化工作，在<code>ActivityThread</code>源码中，我们可以看到其内部类<code>class H extends Handler</code>的<code>handleMessage</code>方法中，有很多与应用相关的一些基本操作，比如<strong>BIND_APPLICATION</strong>, <strong>EXIT_APPLICATION</strong>, <strong>CREATE_SERVICE</strong>, <strong>BIND_SERVICE</strong>等，其中需要我们关注的是<strong>BIND_APPLICATION</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">            ....</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> BIND_APPLICATION:</span><br><span class=\"line\">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;bindApplication&quot;</span>);</span><br><span class=\"line\">                    <span class=\"type\">AppBindData</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> (AppBindData)msg.obj;</span><br><span class=\"line\">                    handleBindApplication(data);</span><br><span class=\"line\">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                ....</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">  ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，其中调用了<code>handleBindApplication</code>方法。进入这个方法查看。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleBindApplication</span><span class=\"params\">(AppBindData data)</span> &#123;</span><br><span class=\"line\">  ....</span><br><span class=\"line\">  Application app;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> StrictMode.<span class=\"type\">ThreadPolicy</span> <span class=\"variable\">savedPolicy</span> <span class=\"operator\">=</span> StrictMode.allowThreadDiskWrites();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> StrictMode.<span class=\"type\">ThreadPolicy</span> <span class=\"variable\">writesAllowedPolicy</span> <span class=\"operator\">=</span> StrictMode.getThreadPolicy();</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class=\"line\">    <span class=\"comment\">// a restricted environment with the base application class.</span></span><br><span class=\"line\">    app = data.info.makeApplication(data.restrictedBackupMode, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Propagate autofill compat state</span></span><br><span class=\"line\">    app.setAutofillOptions(data.autofillOptions);</span><br><span class=\"line\">    <span class=\"comment\">// Propagate Content Capture options</span></span><br><span class=\"line\">    app.setContentCaptureOptions(data.contentCaptureOptions);</span><br><span class=\"line\">    mInitialApplication = app;</span><br><span class=\"line\">    <span class=\"comment\">// don&#x27;t bring up providers in restricted mode; they may depend on the</span></span><br><span class=\"line\">    <span class=\"comment\">// app&#x27;s custom Application class</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class=\"line\">        installContentProviders(app, data.providers);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class=\"line\">    <span class=\"comment\">// test thread at this point, and we don&#x27;t want that racing.</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(</span><br><span class=\"line\">        <span class=\"string\">&quot;Exception thrown in onCreate() of &quot;</span></span><br><span class=\"line\">        + data.instrumentationName + <span class=\"string\">&quot;: &quot;</span> + e.toString(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      mInstrumentation.callApplicationOnCreate(app);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(</span><br><span class=\"line\">          <span class=\"string\">&quot;Unable to create application &quot;</span> + app.getClass().getName()</span><br><span class=\"line\">          + <span class=\"string\">&quot;: &quot;</span> + e.toString(), e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If the app targets &lt; O-MR1, or doesn&#x27;t change the thread policy</span></span><br><span class=\"line\">    <span class=\"comment\">// during startup, clobber the policy to maintain behavior of b/36951662</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class=\"line\">        || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class=\"line\">      StrictMode.setThreadPolicy(savedPolicy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从这个方法中，我们可以找到这样一段代码，需要重点关注的是，<code>ContentProvider</code>的初始化是先于<code>Application.onCreate</code>的，且是被<code>ActivityThread</code><strong>自动</strong>执行的。</p>\n<p>接下来再看LeakCanary源码。找到<a href=\"https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt\"><strong>AppWatcherInstaller.kt</strong></a>这个类。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Content providers are loaded before the application class is created. [AppWatcherInstaller] is</span></span><br><span class=\"line\"><span class=\"comment\"> * used to install [leakcanary.AppWatcher] on application start.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">sealed</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppWatcherInstaller</span> : <span class=\"type\">ContentProvider</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">internal</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainProcess</span> : <span class=\"type\">AppWatcherInstaller</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span></span><br><span class=\"line\"><span class=\"comment\">   * [LeakCanaryProcess] automatically sets up the LeakCanary code</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">internal</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LeakCanaryProcess</span> : <span class=\"type\">AppWatcherInstaller</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> application = context!!.applicationContext <span class=\"keyword\">as</span> Application</span><br><span class=\"line\">    AppWatcher.manualInstall(application)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">query</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    uri: <span class=\"type\">Uri</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    strings: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;?,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    s: <span class=\"type\">String</span>?,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    strings1: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;?,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    s1: <span class=\"type\">String</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  )</span></span>: Cursor? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getType</span><span class=\"params\">(uri: <span class=\"type\">Uri</span>)</span></span>: String? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">insert</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    uri: <span class=\"type\">Uri</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    contentValues: <span class=\"type\">ContentValues</span>?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  )</span></span>: Uri? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">delete</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    uri: <span class=\"type\">Uri</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    s: <span class=\"type\">String</span>?,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    strings: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  )</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">update</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    uri: <span class=\"type\">Uri</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    contentValues: <span class=\"type\">ContentValues</span>?,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    s: <span class=\"type\">String</span>?,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    strings: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;?</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  )</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，这个类是一个<code>ContentProvider</code>的子类，其query, insert等方法根本没有实际作用，有实际作用的只有<code>onCreate</code>方法，在这个方法中，执行了<code>AppWatcher</code>的install工作。</p>\n<p>这里我们就可以看出来，LeakCanary就是利用<code>ContentProvider</code>的<code>onCreate</code>方法自动执行的特性，来自动“安装”这个类库的。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>通过追踪<code>AppWatcher.manualInstall(application)</code>这句代码，我们可以追踪到<a href=\"https://github.com/square/leakcanary/blob/main/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt\"><strong>InternalLeakCanary.kt</strong></a>的<code>install</code>方法，如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">install</span><span class=\"params\">(application: <span class=\"type\">Application</span>)</span></span> &#123;</span><br><span class=\"line\">  checkMainThread()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>::application.isInitialized) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  InternalAppWatcher.application = application</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isDebuggableBuild) &#123;</span><br><span class=\"line\">    SharkLog.logger = DefaultCanaryLog()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">val</span> configProvider = &#123; AppWatcher.config &#125;</span><br><span class=\"line\">  ActivityDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class=\"line\">  FragmentDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class=\"line\">  onAppWatcherInstalled(application)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，先后执行了<code>ActivityDestroyWatcher.install</code>,<code>FragmentDestroyWatcher.install</code>和<code>onAppWatcherInstalled(application)</code>方法。</p>\n<p>其中在<code>onAppWatcherInstalled</code>创建了LeakCanary图标的快捷方式，用于方便查看内存泄漏的路径信息。最终实现的具体过程可以查看<a href=\"https://github.com/square/leakcanary/blob/main/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt\"><strong>InternalLeakCanary.kt</strong></a>的<code>addDynamicShortcut</code>方法。</p>\n<p>其他的两段代码——<code>ActivityDestroyWatcher.install</code>和<code>FragmentDestroyWatcher.install</code>，分别对应着两个类——<code>ActivityDestroyWatcher</code>和<code>FragmentDestroyWatcher</code>。这两个类相对来说比较简单，主要工作就是执行了<code>application.registerActivityLifecycleCallbacks</code>这段代码，目的是为了监听每个Activity的onDestroy事件。这也是判断该Activity是否泄漏的开端。</p>\n<p>以<code>ActivityDestroyWatcher</code>为例，其ActivityLifecycleCallback中代码如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> lifecycleCallbacks =</span><br><span class=\"line\">    <span class=\"keyword\">object</span> : Application.ActivityLifecycleCallbacks <span class=\"keyword\">by</span> noOpDelegate() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onActivityDestroyed</span><span class=\"params\">(activity: <span class=\"type\">Activity</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (configProvider().watchActivities) &#123;</span><br><span class=\"line\">          objectWatcher.watch(</span><br><span class=\"line\">              activity, <span class=\"string\">&quot;<span class=\"subst\">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span></span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，这其中，最终是<code>objectWatcher</code>来进行内存泄漏监控的。</p>\n<h2 id=\"如何检测到内存泄漏的\"><a href=\"#如何检测到内存泄漏的\" class=\"headerlink\" title=\"如何检测到内存泄漏的\"></a>如何检测到内存泄漏的</h2><p>这里涉及到两个关键的类：**<a href=\"https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt\"><code>ObjectWatcher</code></a><strong>和</strong><a href=\"https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt\"><code>KeyedWeakReference</code></a>**。</p>\n<p><code>KeyedWeakReference</code>是<code>WeakReference</code>的子类，添加了额外的属性，代码十分简单，如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">KeyedWeakReference</span>(</span><br><span class=\"line\">  referent: Any,</span><br><span class=\"line\">  <span class=\"keyword\">val</span> key: String,</span><br><span class=\"line\">  <span class=\"keyword\">val</span> description: String,</span><br><span class=\"line\">  <span class=\"keyword\">val</span> watchUptimeMillis: <span class=\"built_in\">Long</span>,</span><br><span class=\"line\">  referenceQueue: ReferenceQueue&lt;Any&gt;</span><br><span class=\"line\">) : WeakReference&lt;Any&gt;(</span><br><span class=\"line\">    referent, referenceQueue</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn&#x27;t</span></span><br><span class=\"line\"><span class=\"comment\">   * been yet.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> retainedUptimeMillis = -<span class=\"number\">1L</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Volatile</span></span><br><span class=\"line\">    <span class=\"meta\">@JvmStatic</span> <span class=\"keyword\">var</span> heapDumpUptimeMillis = <span class=\"number\">0L</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们看<code>ObjectWatcher</code>中的<code>watchObject</code>方法。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Watches the provided [watchedObject].</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> description Describes why the object is watched.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Synchronized</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">watch</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  watchedObject: <span class=\"type\">Any</span>,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  description: <span class=\"type\">String</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isEnabled()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  removeWeaklyReachableObjects()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> key = UUID.randomUUID()</span><br><span class=\"line\">      .toString()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> reference =</span><br><span class=\"line\">    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class=\"line\">  SharkLog.d &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Watching &quot;</span> +</span><br><span class=\"line\">        (<span class=\"keyword\">if</span> (watchedObject <span class=\"keyword\">is</span> Class&lt;*&gt;) watchedObject.toString() <span class=\"keyword\">else</span> <span class=\"string\">&quot;instance of <span class=\"subst\">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +</span><br><span class=\"line\">        (<span class=\"keyword\">if</span> (description.isNotEmpty()) <span class=\"string\">&quot; (<span class=\"variable\">$description</span>)&quot;</span> <span class=\"keyword\">else</span> <span class=\"string\">&quot;&quot;</span>) +</span><br><span class=\"line\">        <span class=\"string\">&quot; with key <span class=\"variable\">$key</span>&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  watchedObjects[key] = reference</span><br><span class=\"line\">  checkRetainedExecutor.execute &#123;</span><br><span class=\"line\">    moveToRetained(key)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里分为三步：</p>\n<ol>\n<li>执行<code>removeWeaklyReachableObjects()</code>方法，这个方法之后讲到；</li>\n<li>生成一个<code>KeyedWeakReference</code>对象，并将这个对象添加到<code>watchedObjects</code>去；</li>\n<li>定时执行<code>moveToRetained</code>方法。</li>\n</ol>\n<ul>\n<li><p>我们先看第二步，生成<code>KeyedWeakReference</code>对象时候，传入了一个一个<code>ReferenceQueue</code>对象，这是检测对象是否被回收的关键。假如一个对象O，被弱引用WR持有的时候，同时这个弱引用WR在构造时候传入了一个<code>ReferenceQueue</code>对象Q，则这个对象O被回收时候，WR将会被添加到Q中去，这样，通过检测Q中有没有值，便可以知道O有没有被回收掉。这也就是第一步做的事。</p>\n</li>\n<li><p>接下来我们查看<code>removeWeaklyReachableObjects</code>方法中做了什么。</p>\n</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">removeWeaklyReachableObjects</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class=\"line\">  <span class=\"comment\">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ref: KeyedWeakReference?</span><br><span class=\"line\">  <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    ref = queue.poll() <span class=\"keyword\">as</span> KeyedWeakReference?</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ref != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      watchedObjects.remove(ref.key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">while</span> (ref != <span class=\"literal\">null</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个方法中，从queue中取值，取出来ref，则说明被ref修饰的对象已经被回收了，则将这个弱引用ref从<code>watchedObjects</code>清除掉。</p>\n<ul>\n<li>接下来到了第三步，这一步实际上是一个定时5秒(LeakCanary默认)去将watchedObjects中残留的引用，移入到<code>retainedObjects</code>中去。我们来看其中代码：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Synchronized</span> <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">moveToRetained</span><span class=\"params\">(key: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">  removeWeaklyReachableObjects()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> retainedRef = watchedObjects[key]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (retainedRef != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class=\"line\">    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行这个任务的Executor实际实现在<a href=\"https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt\"><strong>InternalAppWatcher.kt</strong></a>中，代码如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> checkRetainedExecutor = Executor &#123;</span><br><span class=\"line\">  mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们发现，在<code>moveToRetained</code>中，还是先执行了<code>removeWeaklyReachableObjects</code>这一方法。目的是再次清除已经被回收的对象。如果经过这一步，仍然有引用留在watchedObjects中，则可以认为，这些对象泄漏了。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Returns the objects that are currently considered retained. Useful for logging purposes.</span></span><br><span class=\"line\"><span class=\"comment\">   * Be careful with those objects and release them ASAP as you may creating longer lived leaks</span></span><br><span class=\"line\"><span class=\"comment\">   * then the one that are already there.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> retainedObjects: List&lt;Any&gt;</span><br><span class=\"line\"><span class=\"meta\">@Synchronized</span> <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">  removeWeaklyReachableObjects()</span><br><span class=\"line\">  <span class=\"keyword\">val</span> instances = mutableListOf&lt;Any&gt;()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (weakReference <span class=\"keyword\">in</span> watchedObjects.values) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (weakReference.retainedUptimeMillis != -<span class=\"number\">1L</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> instance = weakReference.<span class=\"keyword\">get</span>()</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (instance != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        instances.add(instance)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instances</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>不要在发行版本中使用LeakCanary，因为一系列初始化动作，可能会导致应用启动较慢。如果要用，请使用LeakCanary-Object-Watcher，或者直接使用Buggly这样的成熟框架。</p>\n"},{"layout":"post","title":"LiveEventBus源码分析","author":"boybeak","_content":"\n\n> 不再分析了，理解了LiveData后，不难理解这个框架。\n\n阅读本文前，请先阅读[《Jetpack之LiveData源码分析》]({{site.base_url}}/源码分析系列/LiveEventBus源码分析.md)。因为**LiveEventBus**是基于**LiveData**构建的。\n\n源码地址：[LiveEventBus](https://github.com/JeremyLiao/LiveEventBus)\n\n典型用法如下：\n\n```java\n// 监听消息\nLiveEventBus\n\t.get(\"some_key\", String.class)\n\t.observe(this, new Observer<String>() {\n\t    @Override\n\t    public void onChanged(@Nullable String s) {\n\t    }\n\t});\n```\n\n```java\n// 发送消息\nLiveEventBus\n\t.get(\"some_key\")\n\t.post(some_value);\n```\n\n其实，这三个方法就是最核心的，get、observe和post。通过get获取一个Observable对象，通过observe进行监听，通过post发送消息。我们就从这三个方法入手去分析其源码。\n\n\n\n## get方法分析\n\n跟踪get方法，不难发现，是由*LiveEventBusCore*单例提供的with()方法返回的*Observable*，*LiveEventBusCore*中有一个名为bus的Map<String, LiveEvent<Object>>的成员变量，就是在这个变量中，以key - value的形式，保存了*Obserable*对象。observe方法与post方法都是由*Obserable*提供的。*Observable*是一个接口，它有一个唯一的实现类：**LiveEvent**。也就是说，observe方法与post方法的具体实现，都是由*LiveEvent*类提供。\n\n主要代码如下：\n\n##LiveEvent \n\n```java\nprivate class LiveEvent<T> implements Observable<T> {\n  @NonNull\n  private final String key;\n  private final LifecycleLiveData<T> liveData;\t// 继承自MutableLiveData，实现生命周期感知\n  private final Map<Observer, ObserverWrapper<T>> observerMap = new HashMap<>(); // 存储ObserverWrapper对象\n  private final Handler mainHandler = new Handler(Looper.getMainLooper()); // 便于切换到主线程\n  \n  /**\n  * 进程内发送消息\n  *\n  * @param value 发送的消息\n  */\n  @Override\n  public void post(T value) {\n    if (ThreadUtils.isMainThread()) {\n      postInternal(value);\n    } else {\n      mainHandler.post(new PostValueTask(value));\n    }\n  }\n  \n  /**\n  * 注册一个Observer，生命周期感知，自动取消订阅\n  *\n  * @param owner    LifecycleOwner\n  * @param observer 观察者\n  */\n  @Override\n  public void observe(@NonNull final LifecycleOwner owner, @NonNull final Observer<T> observer) {\n    if (ThreadUtils.isMainThread()) {\n      observeInternal(owner, observer);\n    } else {\n      mainHandler.post(new Runnable() {\n        @Override\n        public void run() {\n          observeInternal(owner, observer);\n        }\n      });\n    }\n  }\n  \n}\n```\n\n*LiveEvent*中通过一个成员变量`Map<Observer, ObserverWrapper<T>> observerMap`来存储*ObserverWrapper*。\n\n*ObserverWrapper*是**LiveData**库中的*Observer*类的子类，","source":"_posts/2022-09-17-LiveEventBus源码分析.md","raw":"---\nlayout: post\ntitle: LiveEventBus源码分析\nauthor: boybeak\ncategory: 源码分析\ntags: Android\n---\n\n\n> 不再分析了，理解了LiveData后，不难理解这个框架。\n\n阅读本文前，请先阅读[《Jetpack之LiveData源码分析》]({{site.base_url}}/源码分析系列/LiveEventBus源码分析.md)。因为**LiveEventBus**是基于**LiveData**构建的。\n\n源码地址：[LiveEventBus](https://github.com/JeremyLiao/LiveEventBus)\n\n典型用法如下：\n\n```java\n// 监听消息\nLiveEventBus\n\t.get(\"some_key\", String.class)\n\t.observe(this, new Observer<String>() {\n\t    @Override\n\t    public void onChanged(@Nullable String s) {\n\t    }\n\t});\n```\n\n```java\n// 发送消息\nLiveEventBus\n\t.get(\"some_key\")\n\t.post(some_value);\n```\n\n其实，这三个方法就是最核心的，get、observe和post。通过get获取一个Observable对象，通过observe进行监听，通过post发送消息。我们就从这三个方法入手去分析其源码。\n\n\n\n## get方法分析\n\n跟踪get方法，不难发现，是由*LiveEventBusCore*单例提供的with()方法返回的*Observable*，*LiveEventBusCore*中有一个名为bus的Map<String, LiveEvent<Object>>的成员变量，就是在这个变量中，以key - value的形式，保存了*Obserable*对象。observe方法与post方法都是由*Obserable*提供的。*Observable*是一个接口，它有一个唯一的实现类：**LiveEvent**。也就是说，observe方法与post方法的具体实现，都是由*LiveEvent*类提供。\n\n主要代码如下：\n\n##LiveEvent \n\n```java\nprivate class LiveEvent<T> implements Observable<T> {\n  @NonNull\n  private final String key;\n  private final LifecycleLiveData<T> liveData;\t// 继承自MutableLiveData，实现生命周期感知\n  private final Map<Observer, ObserverWrapper<T>> observerMap = new HashMap<>(); // 存储ObserverWrapper对象\n  private final Handler mainHandler = new Handler(Looper.getMainLooper()); // 便于切换到主线程\n  \n  /**\n  * 进程内发送消息\n  *\n  * @param value 发送的消息\n  */\n  @Override\n  public void post(T value) {\n    if (ThreadUtils.isMainThread()) {\n      postInternal(value);\n    } else {\n      mainHandler.post(new PostValueTask(value));\n    }\n  }\n  \n  /**\n  * 注册一个Observer，生命周期感知，自动取消订阅\n  *\n  * @param owner    LifecycleOwner\n  * @param observer 观察者\n  */\n  @Override\n  public void observe(@NonNull final LifecycleOwner owner, @NonNull final Observer<T> observer) {\n    if (ThreadUtils.isMainThread()) {\n      observeInternal(owner, observer);\n    } else {\n      mainHandler.post(new Runnable() {\n        @Override\n        public void run() {\n          observeInternal(owner, observer);\n        }\n      });\n    }\n  }\n  \n}\n```\n\n*LiveEvent*中通过一个成员变量`Map<Observer, ObserverWrapper<T>> observerMap`来存储*ObserverWrapper*。\n\n*ObserverWrapper*是**LiveData**库中的*Observer*类的子类，","slug":"2022-09-17-LiveEventBus源码分析","published":1,"date":"2021-01-03T07:36:25.000Z","updated":"2022-09-19T01:34:06.246Z","comments":1,"photos":[],"link":"","_id":"cldqukh8p000hpcjgfwnobl3h","content":"<blockquote>\n<p>不再分析了，理解了LiveData后，不难理解这个框架。</p>\n</blockquote>\n<p>阅读本文前，请先阅读[《Jetpack之LiveData源码分析》](&#x2F;源码分析系列&#x2F;LiveEventBus源码分析.md)。因为<strong>LiveEventBus</strong>是基于<strong>LiveData</strong>构建的。</p>\n<p>源码地址：<a href=\"https://github.com/JeremyLiao/LiveEventBus\">LiveEventBus</a></p>\n<p>典型用法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听消息</span></span><br><span class=\"line\">LiveEventBus</span><br><span class=\"line\">\t.get(<span class=\"string\">&quot;some_key&quot;</span>, String.class)</span><br><span class=\"line\">\t.observe(<span class=\"built_in\">this</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Observer</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">\t    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onChanged</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> String s)</span> &#123;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">LiveEventBus</span><br><span class=\"line\">\t.get(<span class=\"string\">&quot;some_key&quot;</span>)</span><br><span class=\"line\">\t.post(some_value);</span><br></pre></td></tr></table></figure>\n\n<p>其实，这三个方法就是最核心的，get、observe和post。通过get获取一个Observable对象，通过observe进行监听，通过post发送消息。我们就从这三个方法入手去分析其源码。</p>\n<h2 id=\"get方法分析\"><a href=\"#get方法分析\" class=\"headerlink\" title=\"get方法分析\"></a>get方法分析</h2><p>跟踪get方法，不难发现，是由<em>LiveEventBusCore</em>单例提供的with()方法返回的<em>Observable</em>，<em>LiveEventBusCore</em>中有一个名为bus的Map&lt;String, LiveEvent<Object>&gt;的成员变量，就是在这个变量中，以key - value的形式，保存了<em>Obserable</em>对象。observe方法与post方法都是由<em>Obserable</em>提供的。<em>Observable</em>是一个接口，它有一个唯一的实现类：<strong>LiveEvent</strong>。也就是说，observe方法与post方法的具体实现，都是由<em>LiveEvent</em>类提供。</p>\n<p>主要代码如下：</p>\n<p>##LiveEvent </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LiveEvent</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Observable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String key;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LifecycleLiveData&lt;T&gt; liveData;\t<span class=\"comment\">// 继承自MutableLiveData，实现生命周期感知</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Observer, ObserverWrapper&lt;T&gt;&gt; observerMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(); <span class=\"comment\">// 存储ObserverWrapper对象</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Handler</span> <span class=\"variable\">mainHandler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(Looper.getMainLooper()); <span class=\"comment\">// 便于切换到主线程</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 进程内发送消息</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> value 发送的消息</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">post</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ThreadUtils.isMainThread()) &#123;</span><br><span class=\"line\">      postInternal(value);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      mainHandler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">PostValueTask</span>(value));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 注册一个Observer，生命周期感知，自动取消订阅</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> owner    LifecycleOwner</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> observer 观察者</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">observe</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> LifecycleOwner owner, <span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> Observer&lt;T&gt; observer)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ThreadUtils.isMainThread()) &#123;</span><br><span class=\"line\">      observeInternal(owner, observer);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      mainHandler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          observeInternal(owner, observer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>LiveEvent</em>中通过一个成员变量<code>Map&lt;Observer, ObserverWrapper&lt;T&gt;&gt; observerMap</code>来存储<em>ObserverWrapper</em>。</p>\n<p><em>ObserverWrapper</em>是<strong>LiveData</strong>库中的<em>Observer</em>类的子类，</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>不再分析了，理解了LiveData后，不难理解这个框架。</p>\n</blockquote>\n<p>阅读本文前，请先阅读[《Jetpack之LiveData源码分析》](&#x2F;源码分析系列&#x2F;LiveEventBus源码分析.md)。因为<strong>LiveEventBus</strong>是基于<strong>LiveData</strong>构建的。</p>\n<p>源码地址：<a href=\"https://github.com/JeremyLiao/LiveEventBus\">LiveEventBus</a></p>\n<p>典型用法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听消息</span></span><br><span class=\"line\">LiveEventBus</span><br><span class=\"line\">\t.get(<span class=\"string\">&quot;some_key&quot;</span>, String.class)</span><br><span class=\"line\">\t.observe(<span class=\"built_in\">this</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Observer</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">\t    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onChanged</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> String s)</span> &#123;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">LiveEventBus</span><br><span class=\"line\">\t.get(<span class=\"string\">&quot;some_key&quot;</span>)</span><br><span class=\"line\">\t.post(some_value);</span><br></pre></td></tr></table></figure>\n\n<p>其实，这三个方法就是最核心的，get、observe和post。通过get获取一个Observable对象，通过observe进行监听，通过post发送消息。我们就从这三个方法入手去分析其源码。</p>\n<h2 id=\"get方法分析\"><a href=\"#get方法分析\" class=\"headerlink\" title=\"get方法分析\"></a>get方法分析</h2><p>跟踪get方法，不难发现，是由<em>LiveEventBusCore</em>单例提供的with()方法返回的<em>Observable</em>，<em>LiveEventBusCore</em>中有一个名为bus的Map&lt;String, LiveEvent<Object>&gt;的成员变量，就是在这个变量中，以key - value的形式，保存了<em>Obserable</em>对象。observe方法与post方法都是由<em>Obserable</em>提供的。<em>Observable</em>是一个接口，它有一个唯一的实现类：<strong>LiveEvent</strong>。也就是说，observe方法与post方法的具体实现，都是由<em>LiveEvent</em>类提供。</p>\n<p>主要代码如下：</p>\n<p>##LiveEvent </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LiveEvent</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Observable</span>&lt;T&gt; &#123;</span><br><span class=\"line\">  <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String key;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LifecycleLiveData&lt;T&gt; liveData;\t<span class=\"comment\">// 继承自MutableLiveData，实现生命周期感知</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Observer, ObserverWrapper&lt;T&gt;&gt; observerMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(); <span class=\"comment\">// 存储ObserverWrapper对象</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Handler</span> <span class=\"variable\">mainHandler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(Looper.getMainLooper()); <span class=\"comment\">// 便于切换到主线程</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 进程内发送消息</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> value 发送的消息</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">post</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ThreadUtils.isMainThread()) &#123;</span><br><span class=\"line\">      postInternal(value);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      mainHandler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">PostValueTask</span>(value));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 注册一个Observer，生命周期感知，自动取消订阅</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> owner    LifecycleOwner</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> observer 观察者</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">observe</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> LifecycleOwner owner, <span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> Observer&lt;T&gt; observer)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ThreadUtils.isMainThread()) &#123;</span><br><span class=\"line\">      observeInternal(owner, observer);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      mainHandler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          observeInternal(owner, observer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>LiveEvent</em>中通过一个成员变量<code>Map&lt;Observer, ObserverWrapper&lt;T&gt;&gt; observerMap</code>来存储<em>ObserverWrapper</em>。</p>\n<p><em>ObserverWrapper</em>是<strong>LiveData</strong>库中的<em>Observer</em>类的子类，</p>\n"},{"layout":"post","title":"IRouter——自己手撸一个路由框架","author":"boybeak","_content":"\n\n现在最流行的路由框架应该是阿里的ARouter，这几乎是组件化应用的必备了。但是ARouter用起来稍微有一点不爽，不爽在以下两点：\n\n1. 没有一个规范化的api式的调用方式：项目大了，调用路由的方法分布在项目各处，难以查找；\n2. 对startActivityForResult支持不够友好：按照传统方式，在onActivityResult中处理，比较分散。\n\n基于以上问题，闲来无事，手撸一个自己的路由框架[IRouter](https://github.com/boybeak/Routerfit)，基本使用方式如下：\n\n```kotlin\ninterface IRouterService {\n    @RouteTo(\"topic/detail\")\n    fun topicDetail(@Key(\"topic\") topic: Topic): Navigator\n}\n\nval iRouter = IRouter.Builder()\n    .isDebug(BuildConfig.DEBUG)\n    .errorActivity(ErrorActivity::class.java)\n    .build()\n    .create(IRouterService::class.java)\n\niRouter.topicDetail(topic).startActivity(this@MainActivity)\n\n// OR\n\niRouter.topicDetail(topic).startActivityForResult(this, 100) { requestCode, resultCode, data ->\n}\n```\n\n具体的配置方式请参考[IRouter](https://github.com/boybeak/Routerfit)，本文主要是解析源码。\n\n如此调用方式，很像是Retrofit的方式，打开一个activity就像请求一个api一样。从这里可以体现出解决了上述的两个痛点：\n\n1. 类似API的调用方式，集中管理路由路径；\n2. startActivityForResult中添加回调，哪里调用，就在哪里处理结果，结构紧凑。\n\n下面进入源码解析。\n\n与[ARouter源码分析](https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html)这篇文章一样，我们分析时候要按照时态去分析这个框架在**运行时**和**编译时**做的事情。\n\n## 运行时\n\n其实从上述调用的方式，有过热门开源框架源码阅读经验的，都能猜出个大概。\n\n先从**IRouter**这个类创建*IRouterService*实例说起。使用过Retrofit的同学都知道，创建一个接口类，通过注解标注方法，不用提供具体的实现流程，就能完成网络请求。其实这并不难，这是通过动态代理实现的。我们来看IRouter.create的代码：\n\n```java\npublic <T> T create(Class<T> tClass) {\n  return (T) Proxy.newProxyInstance(tClass.getClassLoader(), new Class[]{tClass},\n    new InvocationHandler() {\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            return parseMethod(method, args);\n        }\n    });\n}\n```\n\n通过动态代理，我们创建了一个*IRouterService*的实现类，这个类在调用相关方法的时候，比如*topicDetail*这个方法，都会经由*InvocationHandler*的*invoke*方法来代理完成。\n\n接下来，从invoke中调用了parseMethod方法，这个方法比较简单，主要是用于解析方法注解和参数注解，取出其中的值，比如跳转路径path和参数的key - value键值对，**通过path查询出相对应的Activity的class**，这些值最终汇总起来，返回一个Navigator对象，这个就是真正要执行跳转的地方。\n\n上面提到*通过path查询出Activity对应的class*，既然要查询，肯定要事先存储后才能被查询到。这就涉及到**编译时**做的工作了。\n\n\n\n## 编译时\n\n### 一、APT部分\n\n其实读过其他一些开源框架的人对这部分一定不会陌生。\n\n这部分工作与ARouter类似，就是通过**@RoutePath**注解标记目标Activity，然后再通过注解处理器来获取到path - activity.class的对应关系，将这个对应关系，生成成一个类，我们查看一个生成的类的示例如下：\n\n```java\npackage com.github.boybeak.irouter.loader;\n\nimport com.github.boybeak.irouter.core.BaseLoader;\nimport java.lang.Override;\nimport java.lang.String;\n\npublic class V2ex$Topic$Loader extends BaseLoader {\n  @Override\n  public String getHeader() {\n    return \"topic\";\n  }\n\n  @Override\n  public void loadIntoMap() {\n    load(\"detail\", com.v2ex.activity.TopicActivity.class);\n  }\n}\n```\n\n这些所有生成的类在一个包名`com.github.boybeak.irouter.loader`底下，这很重要，因为我们要在接下来的过程，通过这个包名去筛选生成的loader类。\n\n理解这部分，需要对APT(注解处理器)和java poet比较了解。\n\n\n\n### 二、ASM部分\n\n不太了解ASM的，可以通过这篇文章[ASM库介绍与使用](https://boybeak.github.io/android/ASM.html)来了解，简单来说，ASM就是一款修改class文件的工具。能用来动态生成class文件，也可以修改已经存在的class文件。\n\n有这样的利器，我们能做的事就太多了。\n\n这部分，其实我就是参考了ARouter的做法，改成了自己的一些逻辑。\n\n接下来我们要编写的是一个gradle plugin，我们主要是利用其中的**Transform**工具，官方解释在[这里](https://developer.android.com/reference/tools/gradle-api/7.0/com/android/build/api/transform/Transform)，其作用就是在编译时，会挨个遍历我们的源码、类库、jar包等。附上一个教程[Gradle 学习之 Android 插件的 Transform API](https://juejin.cn/post/6844903891138674696)。\n\nPath - activity.class的对应关系是通过**LoaderManager**来查询的，我们看一下这个类的代码：\n\n```java\npublic final class LoaderManager {\n    private static final LoaderManager sManager = new LoaderManager();\n\n    public static LoaderManager getInstance() {\n        return sManager;\n    }\n\n    private final Map<String, DelegateLoader> loadersMap = new HashMap<>();\n    private boolean isInitialized = false;\n\n    private LoaderManager() {\n        init();\n    }\n\n    private void init() {\n        if (isInitialized) {\n            return;\n        }\n        load();\n        isInitialized = true;\n    }\n\n    private void load() {\n    }\n\n    private void loadInto(BaseLoader loader) {\n        String header = loader.getHeader();\n        obtainLoader(header).mergeOtherLoaders(loader);\n    }\n\n    private DelegateLoader obtainLoader(String header) {\n        DelegateLoader delegateLoader = loadersMap.get(header);\n        if (delegateLoader == null) {\n            delegateLoader = new DelegateLoader(header);\n            loadersMap.put(header, delegateLoader);\n        }\n        return delegateLoader;\n    }\n\n    public Class<?> get(String path) {\n        String[] segments = path.split(\"/\");\n        final String header = segments[0];\n        final String tail = segments[1];\n        return loadersMap.get(header).getTargetClass(tail);\n    }\n\n}\n```\n\n我们需要注意其中的一个方法——`load`，我们看到，这个类在构建方法里调用了init方法，init里又调用了load方法，但是这个load方法却是留白的。这样调用有什么用呢？\n\n其实这个留白方法是我们为ASM留的一个修改的入口。\n\n```groovy\napply plugin: 'i-router-register'\n```\n\n在app.gradle中，使用这个插件，我们的transform就能顺利运行起来发挥作用了。\n\n我们需要查看一下RegisterTransform的代码了：\n\n```java\npublic class RegisterTransform extends Transform {\n  @Override\n  public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {\n    super.transform(transformInvocation);\n\n    scanner.scan(transformInvocation, (loaderManagerJar, loaderManagerEntryName, loaders) -> {\n      Asm.getInstance().generateCode(loaderManagerJar, loaderManagerEntryName, loaders);\n    });\n  }\n}\n```\n\n这里使用了Scanner来扫描TransformInvocation类，Scanner是我们自定义的类，主要作用就是通过包名和类名，查找我们的loader类和LoaderManager所在的jar包。我们查看其scan方法：\n\n```java\nfor (TransformInput input : transformInvocation.getInputs()) {\n  for (JarInput jarInput : input.getJarInputs()) {\n    // 这里处理第三方类库，引用的module和jar文件\n  }\n  for (DirectoryInput directoryInput : input.getDirectoryInputs()) {\n    // 这里处理应用了这个plugin的module的相关class文件\n  }\n}\nonScanFinish.onScanFinish(loaderManagerJar, loaderManagerEntryName, loaderClzList);\n```\n\n通过回调，我们将查找到的loader类和LoaderManager所在jar返回给transform，并交由我们的asm工具来处理。\n\n```java\npublic class ASM {\n  private static class HackMethodVisitor extends MethodVisitor {\n\n    private List<String> loaders = null;\n\n    public HackMethodVisitor(int api, MethodVisitor methodVisitor, List<String> loaders) {\n      super(api, methodVisitor);\n      this.loaders = loaders;\n    }\n\n    @Override\n    public void visitInsn(int opcode) {\n      for (String loader : loaders) {\n        mv.visitVarInsn(Opcodes.ALOAD, 0);\n        mv.visitTypeInsn(Opcodes.NEW, loader);\n        mv.visitInsn(Opcodes.DUP);\n        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, loader, \"<init>\", \"()V\", false);\n        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"com/github/boybeak/irouter/core/LoaderManager\", \"loadInto\", \"(Lcom/github/boybeak/irouter/core/BaseLoader;)V\", false);\n      }\n\n      super.visitInsn(opcode);\n    }\n  }\n}\n```\n\n主要的修改逻辑就在HackMethodVisitor这个类中，注意其中的visitInsn方法，这就是ASM真正发挥作用的地方，这里的逻辑就是为loadInto方法添加加载loader的代码。\n\n以demo中的v2ex为例，修改后的代码load代码如下：\n\n![LoaderManager](/images/jd_loader_manager.jpg)\n\n\n\n## 最后一点细节\n\n到目前为止，主要的流程已经结束了，接下来是一些细节部分。\n\n- LoaderManager在加载loader的时候，会针对path做归并，比如同为app/main和app/user被归并为一组，这样在使用的时候，可以按组做实际载入。\n- 用于跳转的Navigator是有缓存的，用来减少查询次数，因为path - activity.class的对应关系并不是动态变化的，如果缓存中有已经用过的，则清空其intent的参数部分重复利用即可。\n- 对于startActivityForResult的集中调用，可以参考我的另外一个开源项目——[Starter](https://github.com/boybeak/Starter)中的SAFR项目。这里在FragmentActivity中，通过一个fragment去代理了startActivityForResult的过程，从而拦截了回调结果；类似的，在非FragmentActivity中，通过了一个全透明的代理了此过程，这里学习了**Glide**通过一个fragment来探测生命周期的方式。\n\n## 总结\n\n通过这样一个自己动手的过程，我们熟悉了的编写APT和gradle plugin的过程，学会了ASM的基本用法。\n\n在这个项目中，学习了很多其他优秀开源项目的经验，比如：\n\n- 主流程是参考了ARouter，但是去掉了应用启动时候，从codeDir找到apk来解析路由路径的过程；\n- 集中的api式调用，参考了Retrofit的动态代理；\n- 通过Fragment拦截startActivityForResult的结果，参考了Glide向宿主activity添加无UI的Fragment的方式。\n\n因此，多读源码可以开拓思维，当自己想开发自己的工具框架时候，就可以信手拈来。","source":"_posts/2022-09-17-手撸一个路由框架IRouter.md","raw":"---\nlayout: post\ntitle: IRouter——自己手撸一个路由框架\nauthor: boybeak\ncategory: 源码分析\ntags: Android\n---\n\n\n现在最流行的路由框架应该是阿里的ARouter，这几乎是组件化应用的必备了。但是ARouter用起来稍微有一点不爽，不爽在以下两点：\n\n1. 没有一个规范化的api式的调用方式：项目大了，调用路由的方法分布在项目各处，难以查找；\n2. 对startActivityForResult支持不够友好：按照传统方式，在onActivityResult中处理，比较分散。\n\n基于以上问题，闲来无事，手撸一个自己的路由框架[IRouter](https://github.com/boybeak/Routerfit)，基本使用方式如下：\n\n```kotlin\ninterface IRouterService {\n    @RouteTo(\"topic/detail\")\n    fun topicDetail(@Key(\"topic\") topic: Topic): Navigator\n}\n\nval iRouter = IRouter.Builder()\n    .isDebug(BuildConfig.DEBUG)\n    .errorActivity(ErrorActivity::class.java)\n    .build()\n    .create(IRouterService::class.java)\n\niRouter.topicDetail(topic).startActivity(this@MainActivity)\n\n// OR\n\niRouter.topicDetail(topic).startActivityForResult(this, 100) { requestCode, resultCode, data ->\n}\n```\n\n具体的配置方式请参考[IRouter](https://github.com/boybeak/Routerfit)，本文主要是解析源码。\n\n如此调用方式，很像是Retrofit的方式，打开一个activity就像请求一个api一样。从这里可以体现出解决了上述的两个痛点：\n\n1. 类似API的调用方式，集中管理路由路径；\n2. startActivityForResult中添加回调，哪里调用，就在哪里处理结果，结构紧凑。\n\n下面进入源码解析。\n\n与[ARouter源码分析](https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html)这篇文章一样，我们分析时候要按照时态去分析这个框架在**运行时**和**编译时**做的事情。\n\n## 运行时\n\n其实从上述调用的方式，有过热门开源框架源码阅读经验的，都能猜出个大概。\n\n先从**IRouter**这个类创建*IRouterService*实例说起。使用过Retrofit的同学都知道，创建一个接口类，通过注解标注方法，不用提供具体的实现流程，就能完成网络请求。其实这并不难，这是通过动态代理实现的。我们来看IRouter.create的代码：\n\n```java\npublic <T> T create(Class<T> tClass) {\n  return (T) Proxy.newProxyInstance(tClass.getClassLoader(), new Class[]{tClass},\n    new InvocationHandler() {\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            return parseMethod(method, args);\n        }\n    });\n}\n```\n\n通过动态代理，我们创建了一个*IRouterService*的实现类，这个类在调用相关方法的时候，比如*topicDetail*这个方法，都会经由*InvocationHandler*的*invoke*方法来代理完成。\n\n接下来，从invoke中调用了parseMethod方法，这个方法比较简单，主要是用于解析方法注解和参数注解，取出其中的值，比如跳转路径path和参数的key - value键值对，**通过path查询出相对应的Activity的class**，这些值最终汇总起来，返回一个Navigator对象，这个就是真正要执行跳转的地方。\n\n上面提到*通过path查询出Activity对应的class*，既然要查询，肯定要事先存储后才能被查询到。这就涉及到**编译时**做的工作了。\n\n\n\n## 编译时\n\n### 一、APT部分\n\n其实读过其他一些开源框架的人对这部分一定不会陌生。\n\n这部分工作与ARouter类似，就是通过**@RoutePath**注解标记目标Activity，然后再通过注解处理器来获取到path - activity.class的对应关系，将这个对应关系，生成成一个类，我们查看一个生成的类的示例如下：\n\n```java\npackage com.github.boybeak.irouter.loader;\n\nimport com.github.boybeak.irouter.core.BaseLoader;\nimport java.lang.Override;\nimport java.lang.String;\n\npublic class V2ex$Topic$Loader extends BaseLoader {\n  @Override\n  public String getHeader() {\n    return \"topic\";\n  }\n\n  @Override\n  public void loadIntoMap() {\n    load(\"detail\", com.v2ex.activity.TopicActivity.class);\n  }\n}\n```\n\n这些所有生成的类在一个包名`com.github.boybeak.irouter.loader`底下，这很重要，因为我们要在接下来的过程，通过这个包名去筛选生成的loader类。\n\n理解这部分，需要对APT(注解处理器)和java poet比较了解。\n\n\n\n### 二、ASM部分\n\n不太了解ASM的，可以通过这篇文章[ASM库介绍与使用](https://boybeak.github.io/android/ASM.html)来了解，简单来说，ASM就是一款修改class文件的工具。能用来动态生成class文件，也可以修改已经存在的class文件。\n\n有这样的利器，我们能做的事就太多了。\n\n这部分，其实我就是参考了ARouter的做法，改成了自己的一些逻辑。\n\n接下来我们要编写的是一个gradle plugin，我们主要是利用其中的**Transform**工具，官方解释在[这里](https://developer.android.com/reference/tools/gradle-api/7.0/com/android/build/api/transform/Transform)，其作用就是在编译时，会挨个遍历我们的源码、类库、jar包等。附上一个教程[Gradle 学习之 Android 插件的 Transform API](https://juejin.cn/post/6844903891138674696)。\n\nPath - activity.class的对应关系是通过**LoaderManager**来查询的，我们看一下这个类的代码：\n\n```java\npublic final class LoaderManager {\n    private static final LoaderManager sManager = new LoaderManager();\n\n    public static LoaderManager getInstance() {\n        return sManager;\n    }\n\n    private final Map<String, DelegateLoader> loadersMap = new HashMap<>();\n    private boolean isInitialized = false;\n\n    private LoaderManager() {\n        init();\n    }\n\n    private void init() {\n        if (isInitialized) {\n            return;\n        }\n        load();\n        isInitialized = true;\n    }\n\n    private void load() {\n    }\n\n    private void loadInto(BaseLoader loader) {\n        String header = loader.getHeader();\n        obtainLoader(header).mergeOtherLoaders(loader);\n    }\n\n    private DelegateLoader obtainLoader(String header) {\n        DelegateLoader delegateLoader = loadersMap.get(header);\n        if (delegateLoader == null) {\n            delegateLoader = new DelegateLoader(header);\n            loadersMap.put(header, delegateLoader);\n        }\n        return delegateLoader;\n    }\n\n    public Class<?> get(String path) {\n        String[] segments = path.split(\"/\");\n        final String header = segments[0];\n        final String tail = segments[1];\n        return loadersMap.get(header).getTargetClass(tail);\n    }\n\n}\n```\n\n我们需要注意其中的一个方法——`load`，我们看到，这个类在构建方法里调用了init方法，init里又调用了load方法，但是这个load方法却是留白的。这样调用有什么用呢？\n\n其实这个留白方法是我们为ASM留的一个修改的入口。\n\n```groovy\napply plugin: 'i-router-register'\n```\n\n在app.gradle中，使用这个插件，我们的transform就能顺利运行起来发挥作用了。\n\n我们需要查看一下RegisterTransform的代码了：\n\n```java\npublic class RegisterTransform extends Transform {\n  @Override\n  public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {\n    super.transform(transformInvocation);\n\n    scanner.scan(transformInvocation, (loaderManagerJar, loaderManagerEntryName, loaders) -> {\n      Asm.getInstance().generateCode(loaderManagerJar, loaderManagerEntryName, loaders);\n    });\n  }\n}\n```\n\n这里使用了Scanner来扫描TransformInvocation类，Scanner是我们自定义的类，主要作用就是通过包名和类名，查找我们的loader类和LoaderManager所在的jar包。我们查看其scan方法：\n\n```java\nfor (TransformInput input : transformInvocation.getInputs()) {\n  for (JarInput jarInput : input.getJarInputs()) {\n    // 这里处理第三方类库，引用的module和jar文件\n  }\n  for (DirectoryInput directoryInput : input.getDirectoryInputs()) {\n    // 这里处理应用了这个plugin的module的相关class文件\n  }\n}\nonScanFinish.onScanFinish(loaderManagerJar, loaderManagerEntryName, loaderClzList);\n```\n\n通过回调，我们将查找到的loader类和LoaderManager所在jar返回给transform，并交由我们的asm工具来处理。\n\n```java\npublic class ASM {\n  private static class HackMethodVisitor extends MethodVisitor {\n\n    private List<String> loaders = null;\n\n    public HackMethodVisitor(int api, MethodVisitor methodVisitor, List<String> loaders) {\n      super(api, methodVisitor);\n      this.loaders = loaders;\n    }\n\n    @Override\n    public void visitInsn(int opcode) {\n      for (String loader : loaders) {\n        mv.visitVarInsn(Opcodes.ALOAD, 0);\n        mv.visitTypeInsn(Opcodes.NEW, loader);\n        mv.visitInsn(Opcodes.DUP);\n        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, loader, \"<init>\", \"()V\", false);\n        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"com/github/boybeak/irouter/core/LoaderManager\", \"loadInto\", \"(Lcom/github/boybeak/irouter/core/BaseLoader;)V\", false);\n      }\n\n      super.visitInsn(opcode);\n    }\n  }\n}\n```\n\n主要的修改逻辑就在HackMethodVisitor这个类中，注意其中的visitInsn方法，这就是ASM真正发挥作用的地方，这里的逻辑就是为loadInto方法添加加载loader的代码。\n\n以demo中的v2ex为例，修改后的代码load代码如下：\n\n![LoaderManager](/images/jd_loader_manager.jpg)\n\n\n\n## 最后一点细节\n\n到目前为止，主要的流程已经结束了，接下来是一些细节部分。\n\n- LoaderManager在加载loader的时候，会针对path做归并，比如同为app/main和app/user被归并为一组，这样在使用的时候，可以按组做实际载入。\n- 用于跳转的Navigator是有缓存的，用来减少查询次数，因为path - activity.class的对应关系并不是动态变化的，如果缓存中有已经用过的，则清空其intent的参数部分重复利用即可。\n- 对于startActivityForResult的集中调用，可以参考我的另外一个开源项目——[Starter](https://github.com/boybeak/Starter)中的SAFR项目。这里在FragmentActivity中，通过一个fragment去代理了startActivityForResult的过程，从而拦截了回调结果；类似的，在非FragmentActivity中，通过了一个全透明的代理了此过程，这里学习了**Glide**通过一个fragment来探测生命周期的方式。\n\n## 总结\n\n通过这样一个自己动手的过程，我们熟悉了的编写APT和gradle plugin的过程，学会了ASM的基本用法。\n\n在这个项目中，学习了很多其他优秀开源项目的经验，比如：\n\n- 主流程是参考了ARouter，但是去掉了应用启动时候，从codeDir找到apk来解析路由路径的过程；\n- 集中的api式调用，参考了Retrofit的动态代理；\n- 通过Fragment拦截startActivityForResult的结果，参考了Glide向宿主activity添加无UI的Fragment的方式。\n\n因此，多读源码可以开拓思维，当自己想开发自己的工具框架时候，就可以信手拈来。","slug":"2022-09-17-手撸一个路由框架IRouter","published":1,"date":"2021-03-08T07:04:09.000Z","updated":"2023-02-05T04:16:16.474Z","_id":"cldqukh8q000kpcjgdk5rgugm","comments":1,"photos":[],"link":"","content":"<p>现在最流行的路由框架应该是阿里的ARouter，这几乎是组件化应用的必备了。但是ARouter用起来稍微有一点不爽，不爽在以下两点：</p>\n<ol>\n<li>没有一个规范化的api式的调用方式：项目大了，调用路由的方法分布在项目各处，难以查找；</li>\n<li>对startActivityForResult支持不够友好：按照传统方式，在onActivityResult中处理，比较分散。</li>\n</ol>\n<p>基于以上问题，闲来无事，手撸一个自己的路由框架<a href=\"https://github.com/boybeak/Routerfit\">IRouter</a>，基本使用方式如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IRouterService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RouteTo(<span class=\"string\">&quot;topic/detail&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">topicDetail</span><span class=\"params\">(<span class=\"meta\">@Key(<span class=\"string\">&quot;topic&quot;</span>)</span> topic: <span class=\"type\">Topic</span>)</span></span>: Navigator</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> iRouter = IRouter.Builder()</span><br><span class=\"line\">    .isDebug(BuildConfig.DEBUG)</span><br><span class=\"line\">    .errorActivity(ErrorActivity::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\">    .build()</span><br><span class=\"line\">    .create(IRouterService::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\"></span><br><span class=\"line\">iRouter.topicDetail(topic).startActivity(<span class=\"keyword\">this</span><span class=\"symbol\">@MainActivity</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// OR</span></span><br><span class=\"line\"></span><br><span class=\"line\">iRouter.topicDetail(topic).startActivityForResult(<span class=\"keyword\">this</span>, <span class=\"number\">100</span>) &#123; requestCode, resultCode, <span class=\"keyword\">data</span> -&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体的配置方式请参考<a href=\"https://github.com/boybeak/Routerfit\">IRouter</a>，本文主要是解析源码。</p>\n<p>如此调用方式，很像是Retrofit的方式，打开一个activity就像请求一个api一样。从这里可以体现出解决了上述的两个痛点：</p>\n<ol>\n<li>类似API的调用方式，集中管理路由路径；</li>\n<li>startActivityForResult中添加回调，哪里调用，就在哪里处理结果，结构紧凑。</li>\n</ol>\n<p>下面进入源码解析。</p>\n<p>与<a href=\"https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html\">ARouter源码分析</a>这篇文章一样，我们分析时候要按照时态去分析这个框架在<strong>运行时</strong>和<strong>编译时</strong>做的事情。</p>\n<h2 id=\"运行时\"><a href=\"#运行时\" class=\"headerlink\" title=\"运行时\"></a>运行时</h2><p>其实从上述调用的方式，有过热门开源框架源码阅读经验的，都能猜出个大概。</p>\n<p>先从<strong>IRouter</strong>这个类创建<em>IRouterService</em>实例说起。使用过Retrofit的同学都知道，创建一个接口类，通过注解标注方法，不用提供具体的实现流程，就能完成网络请求。其实这并不难，这是通过动态代理实现的。我们来看IRouter.create的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">create</span><span class=\"params\">(Class&lt;T&gt; tClass)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(tClass.getClassLoader(), <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;tClass&#125;,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> parseMethod(method, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过动态代理，我们创建了一个<em>IRouterService</em>的实现类，这个类在调用相关方法的时候，比如<em>topicDetail</em>这个方法，都会经由<em>InvocationHandler</em>的<em>invoke</em>方法来代理完成。</p>\n<p>接下来，从invoke中调用了parseMethod方法，这个方法比较简单，主要是用于解析方法注解和参数注解，取出其中的值，比如跳转路径path和参数的key - value键值对，<strong>通过path查询出相对应的Activity的class</strong>，这些值最终汇总起来，返回一个Navigator对象，这个就是真正要执行跳转的地方。</p>\n<p>上面提到<em>通过path查询出Activity对应的class</em>，既然要查询，肯定要事先存储后才能被查询到。这就涉及到<strong>编译时</strong>做的工作了。</p>\n<h2 id=\"编译时\"><a href=\"#编译时\" class=\"headerlink\" title=\"编译时\"></a>编译时</h2><h3 id=\"一、APT部分\"><a href=\"#一、APT部分\" class=\"headerlink\" title=\"一、APT部分\"></a>一、APT部分</h3><p>其实读过其他一些开源框架的人对这部分一定不会陌生。</p>\n<p>这部分工作与ARouter类似，就是通过**@RoutePath**注解标记目标Activity，然后再通过注解处理器来获取到path - activity.class的对应关系，将这个对应关系，生成成一个类，我们查看一个生成的类的示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.github.boybeak.irouter.loader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.boybeak.irouter.core.BaseLoader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.Override;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.String;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">V2ex$Topic$Loader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseLoader</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">getHeader</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;topic&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadIntoMap</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    load(<span class=\"string\">&quot;detail&quot;</span>, com.v2ex.activity.TopicActivity.class);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这些所有生成的类在一个包名<code>com.github.boybeak.irouter.loader</code>底下，这很重要，因为我们要在接下来的过程，通过这个包名去筛选生成的loader类。</p>\n<p>理解这部分，需要对APT(注解处理器)和java poet比较了解。</p>\n<h3 id=\"二、ASM部分\"><a href=\"#二、ASM部分\" class=\"headerlink\" title=\"二、ASM部分\"></a>二、ASM部分</h3><p>不太了解ASM的，可以通过这篇文章<a href=\"https://boybeak.github.io/android/ASM.html\">ASM库介绍与使用</a>来了解，简单来说，ASM就是一款修改class文件的工具。能用来动态生成class文件，也可以修改已经存在的class文件。</p>\n<p>有这样的利器，我们能做的事就太多了。</p>\n<p>这部分，其实我就是参考了ARouter的做法，改成了自己的一些逻辑。</p>\n<p>接下来我们要编写的是一个gradle plugin，我们主要是利用其中的<strong>Transform</strong>工具，官方解释在<a href=\"https://developer.android.com/reference/tools/gradle-api/7.0/com/android/build/api/transform/Transform\">这里</a>，其作用就是在编译时，会挨个遍历我们的源码、类库、jar包等。附上一个教程<a href=\"https://juejin.cn/post/6844903891138674696\">Gradle 学习之 Android 插件的 Transform API</a>。</p>\n<p>Path - activity.class的对应关系是通过<strong>LoaderManager</strong>来查询的，我们看一下这个类的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoaderManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">LoaderManager</span> <span class=\"variable\">sManager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoaderManager</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LoaderManager <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, DelegateLoader&gt; loadersMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">isInitialized</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">LoaderManager</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isInitialized) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        load();</span><br><span class=\"line\">        isInitialized = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">load</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadInto</span><span class=\"params\">(BaseLoader loader)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">header</span> <span class=\"operator\">=</span> loader.getHeader();</span><br><span class=\"line\">        obtainLoader(header).mergeOtherLoaders(loader);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DelegateLoader <span class=\"title function_\">obtainLoader</span><span class=\"params\">(String header)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">DelegateLoader</span> <span class=\"variable\">delegateLoader</span> <span class=\"operator\">=</span> loadersMap.get(header);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delegateLoader == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            delegateLoader = <span class=\"keyword\">new</span> <span class=\"title class_\">DelegateLoader</span>(header);</span><br><span class=\"line\">            loadersMap.put(header, delegateLoader);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> delegateLoader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; get(String path) &#123;</span><br><span class=\"line\">        String[] segments = path.split(<span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">header</span> <span class=\"operator\">=</span> segments[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">tail</span> <span class=\"operator\">=</span> segments[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loadersMap.get(header).getTargetClass(tail);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们需要注意其中的一个方法——<code>load</code>，我们看到，这个类在构建方法里调用了init方法，init里又调用了load方法，但是这个load方法却是留白的。这样调用有什么用呢？</p>\n<p>其实这个留白方法是我们为ASM留的一个修改的入口。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;i-router-register&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在app.gradle中，使用这个插件，我们的transform就能顺利运行起来发挥作用了。</p>\n<p>我们需要查看一下RegisterTransform的代码了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RegisterTransform</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Transform</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">transform</span><span class=\"params\">(TransformInvocation transformInvocation)</span> <span class=\"keyword\">throws</span> TransformException, InterruptedException, IOException &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.transform(transformInvocation);</span><br><span class=\"line\"></span><br><span class=\"line\">    scanner.scan(transformInvocation, (loaderManagerJar, loaderManagerEntryName, loaders) -&gt; &#123;</span><br><span class=\"line\">      Asm.getInstance().generateCode(loaderManagerJar, loaderManagerEntryName, loaders);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里使用了Scanner来扫描TransformInvocation类，Scanner是我们自定义的类，主要作用就是通过包名和类名，查找我们的loader类和LoaderManager所在的jar包。我们查看其scan方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (TransformInput input : transformInvocation.getInputs()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (JarInput jarInput : input.getJarInputs()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里处理第三方类库，引用的module和jar文件</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (DirectoryInput directoryInput : input.getDirectoryInputs()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里处理应用了这个plugin的module的相关class文件</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">onScanFinish.onScanFinish(loaderManagerJar, loaderManagerEntryName, loaderClzList);</span><br></pre></td></tr></table></figure>\n\n<p>通过回调，我们将查找到的loader类和LoaderManager所在jar返回给transform，并交由我们的asm工具来处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ASM</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HackMethodVisitor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MethodVisitor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; loaders = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HackMethodVisitor</span><span class=\"params\">(<span class=\"type\">int</span> api, MethodVisitor methodVisitor, List&lt;String&gt; loaders)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>(api, methodVisitor);</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.loaders = loaders;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitInsn</span><span class=\"params\">(<span class=\"type\">int</span> opcode)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (String loader : loaders) &#123;</span><br><span class=\"line\">        mv.visitVarInsn(Opcodes.ALOAD, <span class=\"number\">0</span>);</span><br><span class=\"line\">        mv.visitTypeInsn(Opcodes.NEW, loader);</span><br><span class=\"line\">        mv.visitInsn(Opcodes.DUP);</span><br><span class=\"line\">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, loader, <span class=\"string\">&quot;&lt;init&gt;&quot;</span>, <span class=\"string\">&quot;()V&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class=\"string\">&quot;com/github/boybeak/irouter/core/LoaderManager&quot;</span>, <span class=\"string\">&quot;loadInto&quot;</span>, <span class=\"string\">&quot;(Lcom/github/boybeak/irouter/core/BaseLoader;)V&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">super</span>.visitInsn(opcode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要的修改逻辑就在HackMethodVisitor这个类中，注意其中的visitInsn方法，这就是ASM真正发挥作用的地方，这里的逻辑就是为loadInto方法添加加载loader的代码。</p>\n<p>以demo中的v2ex为例，修改后的代码load代码如下：</p>\n<p><img src=\"/images/jd_loader_manager.jpg\" alt=\"LoaderManager\"></p>\n<h2 id=\"最后一点细节\"><a href=\"#最后一点细节\" class=\"headerlink\" title=\"最后一点细节\"></a>最后一点细节</h2><p>到目前为止，主要的流程已经结束了，接下来是一些细节部分。</p>\n<ul>\n<li>LoaderManager在加载loader的时候，会针对path做归并，比如同为app&#x2F;main和app&#x2F;user被归并为一组，这样在使用的时候，可以按组做实际载入。</li>\n<li>用于跳转的Navigator是有缓存的，用来减少查询次数，因为path - activity.class的对应关系并不是动态变化的，如果缓存中有已经用过的，则清空其intent的参数部分重复利用即可。</li>\n<li>对于startActivityForResult的集中调用，可以参考我的另外一个开源项目——<a href=\"https://github.com/boybeak/Starter\">Starter</a>中的SAFR项目。这里在FragmentActivity中，通过一个fragment去代理了startActivityForResult的过程，从而拦截了回调结果；类似的，在非FragmentActivity中，通过了一个全透明的代理了此过程，这里学习了<strong>Glide</strong>通过一个fragment来探测生命周期的方式。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这样一个自己动手的过程，我们熟悉了的编写APT和gradle plugin的过程，学会了ASM的基本用法。</p>\n<p>在这个项目中，学习了很多其他优秀开源项目的经验，比如：</p>\n<ul>\n<li>主流程是参考了ARouter，但是去掉了应用启动时候，从codeDir找到apk来解析路由路径的过程；</li>\n<li>集中的api式调用，参考了Retrofit的动态代理；</li>\n<li>通过Fragment拦截startActivityForResult的结果，参考了Glide向宿主activity添加无UI的Fragment的方式。</li>\n</ul>\n<p>因此，多读源码可以开拓思维，当自己想开发自己的工具框架时候，就可以信手拈来。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>现在最流行的路由框架应该是阿里的ARouter，这几乎是组件化应用的必备了。但是ARouter用起来稍微有一点不爽，不爽在以下两点：</p>\n<ol>\n<li>没有一个规范化的api式的调用方式：项目大了，调用路由的方法分布在项目各处，难以查找；</li>\n<li>对startActivityForResult支持不够友好：按照传统方式，在onActivityResult中处理，比较分散。</li>\n</ol>\n<p>基于以上问题，闲来无事，手撸一个自己的路由框架<a href=\"https://github.com/boybeak/Routerfit\">IRouter</a>，基本使用方式如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IRouterService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RouteTo(<span class=\"string\">&quot;topic/detail&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">topicDetail</span><span class=\"params\">(<span class=\"meta\">@Key(<span class=\"string\">&quot;topic&quot;</span>)</span> topic: <span class=\"type\">Topic</span>)</span></span>: Navigator</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> iRouter = IRouter.Builder()</span><br><span class=\"line\">    .isDebug(BuildConfig.DEBUG)</span><br><span class=\"line\">    .errorActivity(ErrorActivity::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\">    .build()</span><br><span class=\"line\">    .create(IRouterService::<span class=\"keyword\">class</span>.java)</span><br><span class=\"line\"></span><br><span class=\"line\">iRouter.topicDetail(topic).startActivity(<span class=\"keyword\">this</span><span class=\"symbol\">@MainActivity</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// OR</span></span><br><span class=\"line\"></span><br><span class=\"line\">iRouter.topicDetail(topic).startActivityForResult(<span class=\"keyword\">this</span>, <span class=\"number\">100</span>) &#123; requestCode, resultCode, <span class=\"keyword\">data</span> -&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体的配置方式请参考<a href=\"https://github.com/boybeak/Routerfit\">IRouter</a>，本文主要是解析源码。</p>\n<p>如此调用方式，很像是Retrofit的方式，打开一个activity就像请求一个api一样。从这里可以体现出解决了上述的两个痛点：</p>\n<ol>\n<li>类似API的调用方式，集中管理路由路径；</li>\n<li>startActivityForResult中添加回调，哪里调用，就在哪里处理结果，结构紧凑。</li>\n</ol>\n<p>下面进入源码解析。</p>\n<p>与<a href=\"https://boybeak.github.io/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97/ARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html\">ARouter源码分析</a>这篇文章一样，我们分析时候要按照时态去分析这个框架在<strong>运行时</strong>和<strong>编译时</strong>做的事情。</p>\n<h2 id=\"运行时\"><a href=\"#运行时\" class=\"headerlink\" title=\"运行时\"></a>运行时</h2><p>其实从上述调用的方式，有过热门开源框架源码阅读经验的，都能猜出个大概。</p>\n<p>先从<strong>IRouter</strong>这个类创建<em>IRouterService</em>实例说起。使用过Retrofit的同学都知道，创建一个接口类，通过注解标注方法，不用提供具体的实现流程，就能完成网络请求。其实这并不难，这是通过动态代理实现的。我们来看IRouter.create的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">create</span><span class=\"params\">(Class&lt;T&gt; tClass)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(tClass.getClassLoader(), <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;tClass&#125;,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> parseMethod(method, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过动态代理，我们创建了一个<em>IRouterService</em>的实现类，这个类在调用相关方法的时候，比如<em>topicDetail</em>这个方法，都会经由<em>InvocationHandler</em>的<em>invoke</em>方法来代理完成。</p>\n<p>接下来，从invoke中调用了parseMethod方法，这个方法比较简单，主要是用于解析方法注解和参数注解，取出其中的值，比如跳转路径path和参数的key - value键值对，<strong>通过path查询出相对应的Activity的class</strong>，这些值最终汇总起来，返回一个Navigator对象，这个就是真正要执行跳转的地方。</p>\n<p>上面提到<em>通过path查询出Activity对应的class</em>，既然要查询，肯定要事先存储后才能被查询到。这就涉及到<strong>编译时</strong>做的工作了。</p>\n<h2 id=\"编译时\"><a href=\"#编译时\" class=\"headerlink\" title=\"编译时\"></a>编译时</h2><h3 id=\"一、APT部分\"><a href=\"#一、APT部分\" class=\"headerlink\" title=\"一、APT部分\"></a>一、APT部分</h3><p>其实读过其他一些开源框架的人对这部分一定不会陌生。</p>\n<p>这部分工作与ARouter类似，就是通过**@RoutePath**注解标记目标Activity，然后再通过注解处理器来获取到path - activity.class的对应关系，将这个对应关系，生成成一个类，我们查看一个生成的类的示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.github.boybeak.irouter.loader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.github.boybeak.irouter.core.BaseLoader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.Override;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.String;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">V2ex$Topic$Loader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseLoader</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">getHeader</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;topic&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadIntoMap</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    load(<span class=\"string\">&quot;detail&quot;</span>, com.v2ex.activity.TopicActivity.class);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这些所有生成的类在一个包名<code>com.github.boybeak.irouter.loader</code>底下，这很重要，因为我们要在接下来的过程，通过这个包名去筛选生成的loader类。</p>\n<p>理解这部分，需要对APT(注解处理器)和java poet比较了解。</p>\n<h3 id=\"二、ASM部分\"><a href=\"#二、ASM部分\" class=\"headerlink\" title=\"二、ASM部分\"></a>二、ASM部分</h3><p>不太了解ASM的，可以通过这篇文章<a href=\"https://boybeak.github.io/android/ASM.html\">ASM库介绍与使用</a>来了解，简单来说，ASM就是一款修改class文件的工具。能用来动态生成class文件，也可以修改已经存在的class文件。</p>\n<p>有这样的利器，我们能做的事就太多了。</p>\n<p>这部分，其实我就是参考了ARouter的做法，改成了自己的一些逻辑。</p>\n<p>接下来我们要编写的是一个gradle plugin，我们主要是利用其中的<strong>Transform</strong>工具，官方解释在<a href=\"https://developer.android.com/reference/tools/gradle-api/7.0/com/android/build/api/transform/Transform\">这里</a>，其作用就是在编译时，会挨个遍历我们的源码、类库、jar包等。附上一个教程<a href=\"https://juejin.cn/post/6844903891138674696\">Gradle 学习之 Android 插件的 Transform API</a>。</p>\n<p>Path - activity.class的对应关系是通过<strong>LoaderManager</strong>来查询的，我们看一下这个类的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoaderManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">LoaderManager</span> <span class=\"variable\">sManager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoaderManager</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LoaderManager <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, DelegateLoader&gt; loadersMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">isInitialized</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">LoaderManager</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isInitialized) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        load();</span><br><span class=\"line\">        isInitialized = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">load</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadInto</span><span class=\"params\">(BaseLoader loader)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">header</span> <span class=\"operator\">=</span> loader.getHeader();</span><br><span class=\"line\">        obtainLoader(header).mergeOtherLoaders(loader);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DelegateLoader <span class=\"title function_\">obtainLoader</span><span class=\"params\">(String header)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">DelegateLoader</span> <span class=\"variable\">delegateLoader</span> <span class=\"operator\">=</span> loadersMap.get(header);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delegateLoader == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            delegateLoader = <span class=\"keyword\">new</span> <span class=\"title class_\">DelegateLoader</span>(header);</span><br><span class=\"line\">            loadersMap.put(header, delegateLoader);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> delegateLoader;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; get(String path) &#123;</span><br><span class=\"line\">        String[] segments = path.split(<span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">header</span> <span class=\"operator\">=</span> segments[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">tail</span> <span class=\"operator\">=</span> segments[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loadersMap.get(header).getTargetClass(tail);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们需要注意其中的一个方法——<code>load</code>，我们看到，这个类在构建方法里调用了init方法，init里又调用了load方法，但是这个load方法却是留白的。这样调用有什么用呢？</p>\n<p>其实这个留白方法是我们为ASM留的一个修改的入口。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;i-router-register&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在app.gradle中，使用这个插件，我们的transform就能顺利运行起来发挥作用了。</p>\n<p>我们需要查看一下RegisterTransform的代码了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RegisterTransform</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Transform</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">transform</span><span class=\"params\">(TransformInvocation transformInvocation)</span> <span class=\"keyword\">throws</span> TransformException, InterruptedException, IOException &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.transform(transformInvocation);</span><br><span class=\"line\"></span><br><span class=\"line\">    scanner.scan(transformInvocation, (loaderManagerJar, loaderManagerEntryName, loaders) -&gt; &#123;</span><br><span class=\"line\">      Asm.getInstance().generateCode(loaderManagerJar, loaderManagerEntryName, loaders);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里使用了Scanner来扫描TransformInvocation类，Scanner是我们自定义的类，主要作用就是通过包名和类名，查找我们的loader类和LoaderManager所在的jar包。我们查看其scan方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (TransformInput input : transformInvocation.getInputs()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (JarInput jarInput : input.getJarInputs()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里处理第三方类库，引用的module和jar文件</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (DirectoryInput directoryInput : input.getDirectoryInputs()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里处理应用了这个plugin的module的相关class文件</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">onScanFinish.onScanFinish(loaderManagerJar, loaderManagerEntryName, loaderClzList);</span><br></pre></td></tr></table></figure>\n\n<p>通过回调，我们将查找到的loader类和LoaderManager所在jar返回给transform，并交由我们的asm工具来处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ASM</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HackMethodVisitor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MethodVisitor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; loaders = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HackMethodVisitor</span><span class=\"params\">(<span class=\"type\">int</span> api, MethodVisitor methodVisitor, List&lt;String&gt; loaders)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>(api, methodVisitor);</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.loaders = loaders;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitInsn</span><span class=\"params\">(<span class=\"type\">int</span> opcode)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (String loader : loaders) &#123;</span><br><span class=\"line\">        mv.visitVarInsn(Opcodes.ALOAD, <span class=\"number\">0</span>);</span><br><span class=\"line\">        mv.visitTypeInsn(Opcodes.NEW, loader);</span><br><span class=\"line\">        mv.visitInsn(Opcodes.DUP);</span><br><span class=\"line\">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, loader, <span class=\"string\">&quot;&lt;init&gt;&quot;</span>, <span class=\"string\">&quot;()V&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class=\"string\">&quot;com/github/boybeak/irouter/core/LoaderManager&quot;</span>, <span class=\"string\">&quot;loadInto&quot;</span>, <span class=\"string\">&quot;(Lcom/github/boybeak/irouter/core/BaseLoader;)V&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">super</span>.visitInsn(opcode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要的修改逻辑就在HackMethodVisitor这个类中，注意其中的visitInsn方法，这就是ASM真正发挥作用的地方，这里的逻辑就是为loadInto方法添加加载loader的代码。</p>\n<p>以demo中的v2ex为例，修改后的代码load代码如下：</p>\n<p><img src=\"/images/jd_loader_manager.jpg\" alt=\"LoaderManager\"></p>\n<h2 id=\"最后一点细节\"><a href=\"#最后一点细节\" class=\"headerlink\" title=\"最后一点细节\"></a>最后一点细节</h2><p>到目前为止，主要的流程已经结束了，接下来是一些细节部分。</p>\n<ul>\n<li>LoaderManager在加载loader的时候，会针对path做归并，比如同为app&#x2F;main和app&#x2F;user被归并为一组，这样在使用的时候，可以按组做实际载入。</li>\n<li>用于跳转的Navigator是有缓存的，用来减少查询次数，因为path - activity.class的对应关系并不是动态变化的，如果缓存中有已经用过的，则清空其intent的参数部分重复利用即可。</li>\n<li>对于startActivityForResult的集中调用，可以参考我的另外一个开源项目——<a href=\"https://github.com/boybeak/Starter\">Starter</a>中的SAFR项目。这里在FragmentActivity中，通过一个fragment去代理了startActivityForResult的过程，从而拦截了回调结果；类似的，在非FragmentActivity中，通过了一个全透明的代理了此过程，这里学习了<strong>Glide</strong>通过一个fragment来探测生命周期的方式。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这样一个自己动手的过程，我们熟悉了的编写APT和gradle plugin的过程，学会了ASM的基本用法。</p>\n<p>在这个项目中，学习了很多其他优秀开源项目的经验，比如：</p>\n<ul>\n<li>主流程是参考了ARouter，但是去掉了应用启动时候，从codeDir找到apk来解析路由路径的过程；</li>\n<li>集中的api式调用，参考了Retrofit的动态代理；</li>\n<li>通过Fragment拦截startActivityForResult的结果，参考了Glide向宿主activity添加无UI的Fragment的方式。</li>\n</ul>\n<p>因此，多读源码可以开拓思维，当自己想开发自己的工具框架时候，就可以信手拈来。</p>\n"},{"layout":"post","title":"AMS启动流程","author":"boybeak","_content":"\n\nAMS是ActivityManagerService的简称，看名字，似乎是Activity的manager，实际上，它管理的可不只是Activity。\n\n## 系统启动流程\n\n```mermaid\ngraph TD;\n    style A fill:#fff\n    style F fill:#5befb9\n    Z{{Boot ROM}} --> A([Boot Loader]);\n    A --> B(Kernel);\n    B --> C(\"init(pid=1)/C++ Framework Native\");\n    C --> D(Zygote/Android Runtime);\n    D --> E(System Server/Java Framework);\n    E --> F(Apps);\n```\n\n> **面试题：一个应用启动，为什么不从init进程或者SystemServer进程fork，而是从Zygote进程fork。**\n>\n> *Zygote作为一个孵化器，可以提前加载一些资源，这样fork时给予[Copy-on-Write](https://zhuanlan.zhihu.com/p/48147304)机制创建的其他进程能够直接利用这些资源，而不用重新加载。比如system_server就可以直接使用Zygote中的JNI函数、共享库、常用的类以及主题资源。*\n>\n> *SystemServer相比Zygote多运行了AMS、WMS等服务，这些对于一个应用程序来说是不需要的，另外fork对多线程不友好，仅会将发起调用的线程拷贝到子进程，这可能会导致死锁，而SystemServer中肯定是有很多多线程的。*\n>\n> **如何导致死锁的？**\n>\n> 在POSIX标准中，fork行为是这样的：赋值整个用户空间的数据（通常使用copy-on-write的策略，所以可以实现速度很快）以及所有系统对象，然后仅复制当前线程到子进程。这里：所有父进程中别的线程，到了子进程都是突然蒸发掉的。\n>\n> 对于锁来说，从OS看，每个锁都有一个所有者，即最后依次lock它的线程。假设这样一个环境，在fork之前，有一个子线程lock了某个锁，获得了对锁的所有权，fork以后，在子进程中，所有的额外线程都人间蒸发了，而锁却被正常赋值了，在子进程看来，这个锁没有主人，所以没有任何人可以对它解锁，当子进程中的某个线程想lock这个锁时候，不再有任何手段可以解开了，程序发生死锁。\n\n## Zygote集成启动\n\n```mermaid\ngraph TD;\n    A[\"init.cpp - main()\"] --> B[解析init.zygote.rc];\n    B --> C[\"启动main类型服务 do_class_start()\"];\n    C --> D[\"启动zygote服务 start()\"];\n    D --> E[\"创建Zygote进程 fork()\"];\n    E --> |execv|F[\"app_main.cpp - main()\"];\n```\n\n\n\n## System Server进程启动\n\n```mermaid\ngraph TD;\n    A[\"app_main.cpp - main()\"] --> B[\"AndroidRuntime.start()\"];\n    B --> C[\"startVM()\"];\n    C --> D[\"startReg()\"];\n    D --> E[\"ZygoteInit.main()\"];\n    E --> F[\"registerZygoteSocket()\"];\n    F --> G[\"preload\"];\n    G --> H[\"startSystemServer\"];\n    H --> I[\"runSelectLoop\"];\n```\n\n[SystemServer.java](https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/services/java/com/android/server/SystemServer.java)\n\n\n\n## AMS启动流程\n\n[ActivityManagerService.java](https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActivityManagerService.java)\n\n在SystemServer的`startBootstrapServices`方法中，开始了AMS的启动。\n\n### AMS启动过程中做了哪些事？\n\n与`adb shell dumpsys`相关的一些process服务，比如`meminfo`、`gfxinfo`、`dbinfo`等，具体请参考`setSystemProcess`方法。\n\n## Activity启动流程\n\nActivityStactSupervisor\n\n```mermaid\nflowchart LR;\nA[ActivityStactSupervisor] --> B[mHomeStack];\nA --> C[mFocusedStack];\nsubgraph ActivityStack[\"ActivityStack\"]\n  subgraph TaskRecord\n    AR1[ActivityRecord]\n    AR2[ActivityRecord]\n    AR3[ActivityRecord]\n  end\n  subgraph TaskRecord2\n    AR4[ActivityRecord]\n    AR5[ActivityRecord]\n    AR6[ActivityRecord]\n  end\nend\nB --> ActivityStack;\nC --> ActivityStack;\n```\n\nActivity启动简图\n\n\n\n> 面试题：Zygote为什么不采用Binder机制进行IPC通信。\n>\n> Binder机制中存在Binder线程池，是多线程的，如果Zygote采用Binder的话，就存在了上面说的fork多线程死锁问题了。其实严格来说，Binder机制不一定要多线程，所谓的Binder线程只不过是在循环读取Binder驱动消息而已，只注册一个Binder线程也是可以工作的，比如ServiceManager，实际上Zygote尽管没有采用Binder机制，它也不是单线程的，但它在fork前主动停止了其他线程，fork后重新启动了。\n\n```mermaid\ngraph TD;\n  A([Launcher]) --> B{\"SystemServer - AMS<br>(app是否启动)\"};\n  B --> |否, 请求创建app进程|C[Zygote];\n  B -.-> |\"是, 1. ActivityManager.getService()\"|D(App):::app;\n  C -->|fork| D\n  D -->|\"2. mgr.attachApplication(mAppThread, startSeq)\"| B;\n\tclassDef app fill:#5befb9\n```\n\nActivity启动细节图\n\n**Launcher到AMS阶段**\n\n```mermaid\nsequenceDiagram\n\tparticipant A as Launcher\n\tparticipant B as Activity\n\tparticipant C as Instrumentation\n\tparticipant D as IActivityManager\n\tparticipant E as AMS\n\t\n\tA ->> B: startActivity\n\tB --> B: startActivityForResult\n\tB ->> C: execStartActivity\n\tC ->> D: startActivity\n\tD ->> E: startActivity\n```\n\n**AMS到ApplicationThread阶段**\n\n```mermaid\nsequenceDiagram\n\tparticipant A as AMS\n\tparticipant B as ActivityStart\n\tparticipant C as ActivityStackSupervisor\n\tparticipant D as ActivityStack\n\tparticipant E as ApplicationThread\n\tA ->> A: startActivityStarter\n\tA ->> B: startActivityMyWait\n\tB ->> B: startActivityLocked\n\tB ->> B: startActivity\n\tB ->> B: startActivityUnchecked\n\tB ->> C: startSpecificActivityLocked\n```\n\n**ApplicationThread到Activity**\n\n","source":"_posts/2022-09-19-AMS启动流程.md","raw":"---\nlayout: post\ntitle: AMS启动流程\nauthor: boybeak\ncategory: Android技巧\ntags: Android\n---\n\n\nAMS是ActivityManagerService的简称，看名字，似乎是Activity的manager，实际上，它管理的可不只是Activity。\n\n## 系统启动流程\n\n```mermaid\ngraph TD;\n    style A fill:#fff\n    style F fill:#5befb9\n    Z{{Boot ROM}} --> A([Boot Loader]);\n    A --> B(Kernel);\n    B --> C(\"init(pid=1)/C++ Framework Native\");\n    C --> D(Zygote/Android Runtime);\n    D --> E(System Server/Java Framework);\n    E --> F(Apps);\n```\n\n> **面试题：一个应用启动，为什么不从init进程或者SystemServer进程fork，而是从Zygote进程fork。**\n>\n> *Zygote作为一个孵化器，可以提前加载一些资源，这样fork时给予[Copy-on-Write](https://zhuanlan.zhihu.com/p/48147304)机制创建的其他进程能够直接利用这些资源，而不用重新加载。比如system_server就可以直接使用Zygote中的JNI函数、共享库、常用的类以及主题资源。*\n>\n> *SystemServer相比Zygote多运行了AMS、WMS等服务，这些对于一个应用程序来说是不需要的，另外fork对多线程不友好，仅会将发起调用的线程拷贝到子进程，这可能会导致死锁，而SystemServer中肯定是有很多多线程的。*\n>\n> **如何导致死锁的？**\n>\n> 在POSIX标准中，fork行为是这样的：赋值整个用户空间的数据（通常使用copy-on-write的策略，所以可以实现速度很快）以及所有系统对象，然后仅复制当前线程到子进程。这里：所有父进程中别的线程，到了子进程都是突然蒸发掉的。\n>\n> 对于锁来说，从OS看，每个锁都有一个所有者，即最后依次lock它的线程。假设这样一个环境，在fork之前，有一个子线程lock了某个锁，获得了对锁的所有权，fork以后，在子进程中，所有的额外线程都人间蒸发了，而锁却被正常赋值了，在子进程看来，这个锁没有主人，所以没有任何人可以对它解锁，当子进程中的某个线程想lock这个锁时候，不再有任何手段可以解开了，程序发生死锁。\n\n## Zygote集成启动\n\n```mermaid\ngraph TD;\n    A[\"init.cpp - main()\"] --> B[解析init.zygote.rc];\n    B --> C[\"启动main类型服务 do_class_start()\"];\n    C --> D[\"启动zygote服务 start()\"];\n    D --> E[\"创建Zygote进程 fork()\"];\n    E --> |execv|F[\"app_main.cpp - main()\"];\n```\n\n\n\n## System Server进程启动\n\n```mermaid\ngraph TD;\n    A[\"app_main.cpp - main()\"] --> B[\"AndroidRuntime.start()\"];\n    B --> C[\"startVM()\"];\n    C --> D[\"startReg()\"];\n    D --> E[\"ZygoteInit.main()\"];\n    E --> F[\"registerZygoteSocket()\"];\n    F --> G[\"preload\"];\n    G --> H[\"startSystemServer\"];\n    H --> I[\"runSelectLoop\"];\n```\n\n[SystemServer.java](https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/services/java/com/android/server/SystemServer.java)\n\n\n\n## AMS启动流程\n\n[ActivityManagerService.java](https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActivityManagerService.java)\n\n在SystemServer的`startBootstrapServices`方法中，开始了AMS的启动。\n\n### AMS启动过程中做了哪些事？\n\n与`adb shell dumpsys`相关的一些process服务，比如`meminfo`、`gfxinfo`、`dbinfo`等，具体请参考`setSystemProcess`方法。\n\n## Activity启动流程\n\nActivityStactSupervisor\n\n```mermaid\nflowchart LR;\nA[ActivityStactSupervisor] --> B[mHomeStack];\nA --> C[mFocusedStack];\nsubgraph ActivityStack[\"ActivityStack\"]\n  subgraph TaskRecord\n    AR1[ActivityRecord]\n    AR2[ActivityRecord]\n    AR3[ActivityRecord]\n  end\n  subgraph TaskRecord2\n    AR4[ActivityRecord]\n    AR5[ActivityRecord]\n    AR6[ActivityRecord]\n  end\nend\nB --> ActivityStack;\nC --> ActivityStack;\n```\n\nActivity启动简图\n\n\n\n> 面试题：Zygote为什么不采用Binder机制进行IPC通信。\n>\n> Binder机制中存在Binder线程池，是多线程的，如果Zygote采用Binder的话，就存在了上面说的fork多线程死锁问题了。其实严格来说，Binder机制不一定要多线程，所谓的Binder线程只不过是在循环读取Binder驱动消息而已，只注册一个Binder线程也是可以工作的，比如ServiceManager，实际上Zygote尽管没有采用Binder机制，它也不是单线程的，但它在fork前主动停止了其他线程，fork后重新启动了。\n\n```mermaid\ngraph TD;\n  A([Launcher]) --> B{\"SystemServer - AMS<br>(app是否启动)\"};\n  B --> |否, 请求创建app进程|C[Zygote];\n  B -.-> |\"是, 1. ActivityManager.getService()\"|D(App):::app;\n  C -->|fork| D\n  D -->|\"2. mgr.attachApplication(mAppThread, startSeq)\"| B;\n\tclassDef app fill:#5befb9\n```\n\nActivity启动细节图\n\n**Launcher到AMS阶段**\n\n```mermaid\nsequenceDiagram\n\tparticipant A as Launcher\n\tparticipant B as Activity\n\tparticipant C as Instrumentation\n\tparticipant D as IActivityManager\n\tparticipant E as AMS\n\t\n\tA ->> B: startActivity\n\tB --> B: startActivityForResult\n\tB ->> C: execStartActivity\n\tC ->> D: startActivity\n\tD ->> E: startActivity\n```\n\n**AMS到ApplicationThread阶段**\n\n```mermaid\nsequenceDiagram\n\tparticipant A as AMS\n\tparticipant B as ActivityStart\n\tparticipant C as ActivityStackSupervisor\n\tparticipant D as ActivityStack\n\tparticipant E as ApplicationThread\n\tA ->> A: startActivityStarter\n\tA ->> B: startActivityMyWait\n\tB ->> B: startActivityLocked\n\tB ->> B: startActivity\n\tB ->> B: startActivityUnchecked\n\tB ->> C: startSpecificActivityLocked\n```\n\n**ApplicationThread到Activity**\n\n","slug":"2022-09-19-AMS启动流程","published":1,"date":"2020-10-21T09:25:45.000Z","updated":"2022-09-19T01:28:06.152Z","comments":1,"photos":[],"link":"","_id":"cldqukh8r000npcjg53ej6ibx","content":"<p>AMS是ActivityManagerService的简称，看名字，似乎是Activity的manager，实际上，它管理的可不只是Activity。</p>\n<h2 id=\"系统启动流程\"><a href=\"#系统启动流程\" class=\"headerlink\" title=\"系统启动流程\"></a>系统启动流程</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">    style A fill:#fff</span><br><span class=\"line\">    style F fill:#5befb9</span><br><span class=\"line\">    Z&#123;&#123;Boot ROM&#125;&#125; --&gt; A([Boot Loader]);</span><br><span class=\"line\">    A --&gt; B(Kernel);</span><br><span class=\"line\">    B --&gt; C(&quot;init(pid=1)/C++ Framework Native&quot;);</span><br><span class=\"line\">    C --&gt; D(Zygote/Android Runtime);</span><br><span class=\"line\">    D --&gt; E(System Server/Java Framework);</span><br><span class=\"line\">    E --&gt; F(Apps);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>面试题：一个应用启动，为什么不从init进程或者SystemServer进程fork，而是从Zygote进程fork。</strong></p>\n<p><em>Zygote作为一个孵化器，可以提前加载一些资源，这样fork时给予<a href=\"https://zhuanlan.zhihu.com/p/48147304\">Copy-on-Write</a>机制创建的其他进程能够直接利用这些资源，而不用重新加载。比如system_server就可以直接使用Zygote中的JNI函数、共享库、常用的类以及主题资源。</em></p>\n<p><em>SystemServer相比Zygote多运行了AMS、WMS等服务，这些对于一个应用程序来说是不需要的，另外fork对多线程不友好，仅会将发起调用的线程拷贝到子进程，这可能会导致死锁，而SystemServer中肯定是有很多多线程的。</em></p>\n<p><strong>如何导致死锁的？</strong></p>\n<p>在POSIX标准中，fork行为是这样的：赋值整个用户空间的数据（通常使用copy-on-write的策略，所以可以实现速度很快）以及所有系统对象，然后仅复制当前线程到子进程。这里：所有父进程中别的线程，到了子进程都是突然蒸发掉的。</p>\n<p>对于锁来说，从OS看，每个锁都有一个所有者，即最后依次lock它的线程。假设这样一个环境，在fork之前，有一个子线程lock了某个锁，获得了对锁的所有权，fork以后，在子进程中，所有的额外线程都人间蒸发了，而锁却被正常赋值了，在子进程看来，这个锁没有主人，所以没有任何人可以对它解锁，当子进程中的某个线程想lock这个锁时候，不再有任何手段可以解开了，程序发生死锁。</p>\n</blockquote>\n<h2 id=\"Zygote集成启动\"><a href=\"#Zygote集成启动\" class=\"headerlink\" title=\"Zygote集成启动\"></a>Zygote集成启动</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">    A[&quot;init.cpp - main()&quot;] --&gt; B[解析init.zygote.rc];</span><br><span class=\"line\">    B --&gt; C[&quot;启动main类型服务 do_class_start()&quot;];</span><br><span class=\"line\">    C --&gt; D[&quot;启动zygote服务 start()&quot;];</span><br><span class=\"line\">    D --&gt; E[&quot;创建Zygote进程 fork()&quot;];</span><br><span class=\"line\">    E --&gt; |execv|F[&quot;app_main.cpp - main()&quot;];</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"System-Server进程启动\"><a href=\"#System-Server进程启动\" class=\"headerlink\" title=\"System Server进程启动\"></a>System Server进程启动</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">    A[&quot;app_main.cpp - main()&quot;] --&gt; B[&quot;AndroidRuntime.start()&quot;];</span><br><span class=\"line\">    B --&gt; C[&quot;startVM()&quot;];</span><br><span class=\"line\">    C --&gt; D[&quot;startReg()&quot;];</span><br><span class=\"line\">    D --&gt; E[&quot;ZygoteInit.main()&quot;];</span><br><span class=\"line\">    E --&gt; F[&quot;registerZygoteSocket()&quot;];</span><br><span class=\"line\">    F --&gt; G[&quot;preload&quot;];</span><br><span class=\"line\">    G --&gt; H[&quot;startSystemServer&quot;];</span><br><span class=\"line\">    H --&gt; I[&quot;runSelectLoop&quot;];</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/services/java/com/android/server/SystemServer.java\">SystemServer.java</a></p>\n<h2 id=\"AMS启动流程\"><a href=\"#AMS启动流程\" class=\"headerlink\" title=\"AMS启动流程\"></a>AMS启动流程</h2><p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActivityManagerService.java\">ActivityManagerService.java</a></p>\n<p>在SystemServer的<code>startBootstrapServices</code>方法中，开始了AMS的启动。</p>\n<h3 id=\"AMS启动过程中做了哪些事？\"><a href=\"#AMS启动过程中做了哪些事？\" class=\"headerlink\" title=\"AMS启动过程中做了哪些事？\"></a>AMS启动过程中做了哪些事？</h3><p>与<code>adb shell dumpsys</code>相关的一些process服务，比如<code>meminfo</code>、<code>gfxinfo</code>、<code>dbinfo</code>等，具体请参考<code>setSystemProcess</code>方法。</p>\n<h2 id=\"Activity启动流程\"><a href=\"#Activity启动流程\" class=\"headerlink\" title=\"Activity启动流程\"></a>Activity启动流程</h2><p>ActivityStactSupervisor</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flowchart LR;</span><br><span class=\"line\">A[ActivityStactSupervisor] --&gt; B[mHomeStack];</span><br><span class=\"line\">A --&gt; C[mFocusedStack];</span><br><span class=\"line\">subgraph ActivityStack[&quot;ActivityStack&quot;]</span><br><span class=\"line\">  subgraph TaskRecord</span><br><span class=\"line\">    AR1[ActivityRecord]</span><br><span class=\"line\">    AR2[ActivityRecord]</span><br><span class=\"line\">    AR3[ActivityRecord]</span><br><span class=\"line\">  end</span><br><span class=\"line\">  subgraph TaskRecord2</span><br><span class=\"line\">    AR4[ActivityRecord]</span><br><span class=\"line\">    AR5[ActivityRecord]</span><br><span class=\"line\">    AR6[ActivityRecord]</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br><span class=\"line\">B --&gt; ActivityStack;</span><br><span class=\"line\">C --&gt; ActivityStack;</span><br></pre></td></tr></table></figure>\n\n<p>Activity启动简图</p>\n<blockquote>\n<p>面试题：Zygote为什么不采用Binder机制进行IPC通信。</p>\n<p>Binder机制中存在Binder线程池，是多线程的，如果Zygote采用Binder的话，就存在了上面说的fork多线程死锁问题了。其实严格来说，Binder机制不一定要多线程，所谓的Binder线程只不过是在循环读取Binder驱动消息而已，只注册一个Binder线程也是可以工作的，比如ServiceManager，实际上Zygote尽管没有采用Binder机制，它也不是单线程的，但它在fork前主动停止了其他线程，fork后重新启动了。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">  A([Launcher]) --&gt; B&#123;&quot;SystemServer - AMS&lt;br&gt;(app是否启动)&quot;&#125;;</span><br><span class=\"line\">  B --&gt; |否, 请求创建app进程|C[Zygote];</span><br><span class=\"line\">  B -.-&gt; |&quot;是, 1. ActivityManager.getService()&quot;|D(App):::app;</span><br><span class=\"line\">  C --&gt;|fork| D</span><br><span class=\"line\">  D --&gt;|&quot;2. mgr.attachApplication(mAppThread, startSeq)&quot;| B;</span><br><span class=\"line\">\tclassDef app fill:#5befb9</span><br></pre></td></tr></table></figure>\n\n<p>Activity启动细节图</p>\n<p><strong>Launcher到AMS阶段</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">\tparticipant A as Launcher</span><br><span class=\"line\">\tparticipant B as Activity</span><br><span class=\"line\">\tparticipant C as Instrumentation</span><br><span class=\"line\">\tparticipant D as IActivityManager</span><br><span class=\"line\">\tparticipant E as AMS</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tA -&gt;&gt; B: startActivity</span><br><span class=\"line\">\tB --&gt; B: startActivityForResult</span><br><span class=\"line\">\tB -&gt;&gt; C: execStartActivity</span><br><span class=\"line\">\tC -&gt;&gt; D: startActivity</span><br><span class=\"line\">\tD -&gt;&gt; E: startActivity</span><br></pre></td></tr></table></figure>\n\n<p><strong>AMS到ApplicationThread阶段</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">\tparticipant A as AMS</span><br><span class=\"line\">\tparticipant B as ActivityStart</span><br><span class=\"line\">\tparticipant C as ActivityStackSupervisor</span><br><span class=\"line\">\tparticipant D as ActivityStack</span><br><span class=\"line\">\tparticipant E as ApplicationThread</span><br><span class=\"line\">\tA -&gt;&gt; A: startActivityStarter</span><br><span class=\"line\">\tA -&gt;&gt; B: startActivityMyWait</span><br><span class=\"line\">\tB -&gt;&gt; B: startActivityLocked</span><br><span class=\"line\">\tB -&gt;&gt; B: startActivity</span><br><span class=\"line\">\tB -&gt;&gt; B: startActivityUnchecked</span><br><span class=\"line\">\tB -&gt;&gt; C: startSpecificActivityLocked</span><br></pre></td></tr></table></figure>\n\n<p><strong>ApplicationThread到Activity</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>AMS是ActivityManagerService的简称，看名字，似乎是Activity的manager，实际上，它管理的可不只是Activity。</p>\n<h2 id=\"系统启动流程\"><a href=\"#系统启动流程\" class=\"headerlink\" title=\"系统启动流程\"></a>系统启动流程</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">    style A fill:#fff</span><br><span class=\"line\">    style F fill:#5befb9</span><br><span class=\"line\">    Z&#123;&#123;Boot ROM&#125;&#125; --&gt; A([Boot Loader]);</span><br><span class=\"line\">    A --&gt; B(Kernel);</span><br><span class=\"line\">    B --&gt; C(&quot;init(pid=1)/C++ Framework Native&quot;);</span><br><span class=\"line\">    C --&gt; D(Zygote/Android Runtime);</span><br><span class=\"line\">    D --&gt; E(System Server/Java Framework);</span><br><span class=\"line\">    E --&gt; F(Apps);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>面试题：一个应用启动，为什么不从init进程或者SystemServer进程fork，而是从Zygote进程fork。</strong></p>\n<p><em>Zygote作为一个孵化器，可以提前加载一些资源，这样fork时给予<a href=\"https://zhuanlan.zhihu.com/p/48147304\">Copy-on-Write</a>机制创建的其他进程能够直接利用这些资源，而不用重新加载。比如system_server就可以直接使用Zygote中的JNI函数、共享库、常用的类以及主题资源。</em></p>\n<p><em>SystemServer相比Zygote多运行了AMS、WMS等服务，这些对于一个应用程序来说是不需要的，另外fork对多线程不友好，仅会将发起调用的线程拷贝到子进程，这可能会导致死锁，而SystemServer中肯定是有很多多线程的。</em></p>\n<p><strong>如何导致死锁的？</strong></p>\n<p>在POSIX标准中，fork行为是这样的：赋值整个用户空间的数据（通常使用copy-on-write的策略，所以可以实现速度很快）以及所有系统对象，然后仅复制当前线程到子进程。这里：所有父进程中别的线程，到了子进程都是突然蒸发掉的。</p>\n<p>对于锁来说，从OS看，每个锁都有一个所有者，即最后依次lock它的线程。假设这样一个环境，在fork之前，有一个子线程lock了某个锁，获得了对锁的所有权，fork以后，在子进程中，所有的额外线程都人间蒸发了，而锁却被正常赋值了，在子进程看来，这个锁没有主人，所以没有任何人可以对它解锁，当子进程中的某个线程想lock这个锁时候，不再有任何手段可以解开了，程序发生死锁。</p>\n</blockquote>\n<h2 id=\"Zygote集成启动\"><a href=\"#Zygote集成启动\" class=\"headerlink\" title=\"Zygote集成启动\"></a>Zygote集成启动</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">    A[&quot;init.cpp - main()&quot;] --&gt; B[解析init.zygote.rc];</span><br><span class=\"line\">    B --&gt; C[&quot;启动main类型服务 do_class_start()&quot;];</span><br><span class=\"line\">    C --&gt; D[&quot;启动zygote服务 start()&quot;];</span><br><span class=\"line\">    D --&gt; E[&quot;创建Zygote进程 fork()&quot;];</span><br><span class=\"line\">    E --&gt; |execv|F[&quot;app_main.cpp - main()&quot;];</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"System-Server进程启动\"><a href=\"#System-Server进程启动\" class=\"headerlink\" title=\"System Server进程启动\"></a>System Server进程启动</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">    A[&quot;app_main.cpp - main()&quot;] --&gt; B[&quot;AndroidRuntime.start()&quot;];</span><br><span class=\"line\">    B --&gt; C[&quot;startVM()&quot;];</span><br><span class=\"line\">    C --&gt; D[&quot;startReg()&quot;];</span><br><span class=\"line\">    D --&gt; E[&quot;ZygoteInit.main()&quot;];</span><br><span class=\"line\">    E --&gt; F[&quot;registerZygoteSocket()&quot;];</span><br><span class=\"line\">    F --&gt; G[&quot;preload&quot;];</span><br><span class=\"line\">    G --&gt; H[&quot;startSystemServer&quot;];</span><br><span class=\"line\">    H --&gt; I[&quot;runSelectLoop&quot;];</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/services/java/com/android/server/SystemServer.java\">SystemServer.java</a></p>\n<h2 id=\"AMS启动流程\"><a href=\"#AMS启动流程\" class=\"headerlink\" title=\"AMS启动流程\"></a>AMS启动流程</h2><p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActivityManagerService.java\">ActivityManagerService.java</a></p>\n<p>在SystemServer的<code>startBootstrapServices</code>方法中，开始了AMS的启动。</p>\n<h3 id=\"AMS启动过程中做了哪些事？\"><a href=\"#AMS启动过程中做了哪些事？\" class=\"headerlink\" title=\"AMS启动过程中做了哪些事？\"></a>AMS启动过程中做了哪些事？</h3><p>与<code>adb shell dumpsys</code>相关的一些process服务，比如<code>meminfo</code>、<code>gfxinfo</code>、<code>dbinfo</code>等，具体请参考<code>setSystemProcess</code>方法。</p>\n<h2 id=\"Activity启动流程\"><a href=\"#Activity启动流程\" class=\"headerlink\" title=\"Activity启动流程\"></a>Activity启动流程</h2><p>ActivityStactSupervisor</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flowchart LR;</span><br><span class=\"line\">A[ActivityStactSupervisor] --&gt; B[mHomeStack];</span><br><span class=\"line\">A --&gt; C[mFocusedStack];</span><br><span class=\"line\">subgraph ActivityStack[&quot;ActivityStack&quot;]</span><br><span class=\"line\">  subgraph TaskRecord</span><br><span class=\"line\">    AR1[ActivityRecord]</span><br><span class=\"line\">    AR2[ActivityRecord]</span><br><span class=\"line\">    AR3[ActivityRecord]</span><br><span class=\"line\">  end</span><br><span class=\"line\">  subgraph TaskRecord2</span><br><span class=\"line\">    AR4[ActivityRecord]</span><br><span class=\"line\">    AR5[ActivityRecord]</span><br><span class=\"line\">    AR6[ActivityRecord]</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br><span class=\"line\">B --&gt; ActivityStack;</span><br><span class=\"line\">C --&gt; ActivityStack;</span><br></pre></td></tr></table></figure>\n\n<p>Activity启动简图</p>\n<blockquote>\n<p>面试题：Zygote为什么不采用Binder机制进行IPC通信。</p>\n<p>Binder机制中存在Binder线程池，是多线程的，如果Zygote采用Binder的话，就存在了上面说的fork多线程死锁问题了。其实严格来说，Binder机制不一定要多线程，所谓的Binder线程只不过是在循环读取Binder驱动消息而已，只注册一个Binder线程也是可以工作的，比如ServiceManager，实际上Zygote尽管没有采用Binder机制，它也不是单线程的，但它在fork前主动停止了其他线程，fork后重新启动了。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">  A([Launcher]) --&gt; B&#123;&quot;SystemServer - AMS&lt;br&gt;(app是否启动)&quot;&#125;;</span><br><span class=\"line\">  B --&gt; |否, 请求创建app进程|C[Zygote];</span><br><span class=\"line\">  B -.-&gt; |&quot;是, 1. ActivityManager.getService()&quot;|D(App):::app;</span><br><span class=\"line\">  C --&gt;|fork| D</span><br><span class=\"line\">  D --&gt;|&quot;2. mgr.attachApplication(mAppThread, startSeq)&quot;| B;</span><br><span class=\"line\">\tclassDef app fill:#5befb9</span><br></pre></td></tr></table></figure>\n\n<p>Activity启动细节图</p>\n<p><strong>Launcher到AMS阶段</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">\tparticipant A as Launcher</span><br><span class=\"line\">\tparticipant B as Activity</span><br><span class=\"line\">\tparticipant C as Instrumentation</span><br><span class=\"line\">\tparticipant D as IActivityManager</span><br><span class=\"line\">\tparticipant E as AMS</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tA -&gt;&gt; B: startActivity</span><br><span class=\"line\">\tB --&gt; B: startActivityForResult</span><br><span class=\"line\">\tB -&gt;&gt; C: execStartActivity</span><br><span class=\"line\">\tC -&gt;&gt; D: startActivity</span><br><span class=\"line\">\tD -&gt;&gt; E: startActivity</span><br></pre></td></tr></table></figure>\n\n<p><strong>AMS到ApplicationThread阶段</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">\tparticipant A as AMS</span><br><span class=\"line\">\tparticipant B as ActivityStart</span><br><span class=\"line\">\tparticipant C as ActivityStackSupervisor</span><br><span class=\"line\">\tparticipant D as ActivityStack</span><br><span class=\"line\">\tparticipant E as ApplicationThread</span><br><span class=\"line\">\tA -&gt;&gt; A: startActivityStarter</span><br><span class=\"line\">\tA -&gt;&gt; B: startActivityMyWait</span><br><span class=\"line\">\tB -&gt;&gt; B: startActivityLocked</span><br><span class=\"line\">\tB -&gt;&gt; B: startActivity</span><br><span class=\"line\">\tB -&gt;&gt; B: startActivityUnchecked</span><br><span class=\"line\">\tB -&gt;&gt; C: startSpecificActivityLocked</span><br></pre></td></tr></table></figure>\n\n<p><strong>ApplicationThread到Activity</strong></p>\n"},{"layout":"post","title":"ASM库介绍与使用","author":"boybeak","_content":"\n\n\n> [原文](https://www.jianshu.com/p/905be2a9a700)\n\n前面几篇文章介绍了 .class 文件的结构、JVM 如何加载 .class 文件、JVM 中如何执行方法的调用和访问者模式，其实前面几篇文章都是为这篇文章做铺垫的，如果不知道 .class 文件结构、也不知道在 JVM 中 .class 文件中的方法是如何被执行的，这篇文章中的有些部分可能会看不懂，所以推荐先看下前面几篇文章。\n 这篇文章主要介绍 ASM 库的结构、主要的 API，并且通过两个示例说明如何通过 ASM 修改 .class 文件中的方法和属性。\n\n\n\n![img](/images/ezgif-6-73b502b11e16.jpg)\n\ncatalog.png\n\n### 一. ASM 的结构\n\nASM 库是一款基于 Java 字节码层面的代码分析和修改工具。ASM 可以直接生产二进制的 class 文件，也可以在类被加载入 JVM 之前动态修改类行为。\n ASM 库的结构如下所示：\n\n\n\n![img](/images/4179925-d4f950ec94a12cde.webp)\n\nasm_arch.png\n\n- Core：为其他包提供基础的读、写、转化Java字节码和定义的API，并且可以生成Java字节码和实现大部分字节码的转换，在 [访问者模式和 ASM](https://www.jianshu.com/p/e4b8cb0b3204) 中介绍的几个重要的类就在 Core API 中：ClassReader、ClassVisitor 和 ClassWriter 类.\n- Tree：提供了 Java 字节码在内存中的表现\n- Commons：提供了一些常用的简化字节码生成、转换的类和适配器\n- Util：包含一些帮助类和简单的字节码修改类，有利于在开发或者测试中使用\n- XML：提供一个适配器将XML和SAX-comliant转化成字节码结构，可以允许使用XSLT去定义字节码转化\n\n### 二. Core API 介绍\n\n#### 2.1 ClassVisitor 抽象类\n\n如下所示，在 ClassVisitor 中提供了和类结构同名的一些方法，这些方法会对类中相应的部分进行操作，而且是有顺序的：visit [ visitSource ] [ visitOuterClass ] ( visitAnnotation | visitAttribute )* (visitInnerClass | visitField | visitMethod )* visitEnd\n\n\n\n```java\npublic abstract class ClassVisitor {\n\n        ......\n\n    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces);\n    public void visitSource(String source, String debug);\n    public void visitOuterClass(String owner, String name, String desc);\n    public AnnotationVisitor visitAnnotation(String desc, boolean visible);\n    public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String desc, boolean visible);\n    public void visitAttribute(Attribute attr);\n    public void visitInnerClass(String name, String outerName, String innerName, int access);\n    public FieldVisitor visitField(int access, String name, String desc, String signature, Object value);\n    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions);\n    public void visitEnd();\n}\n```\n\n1. void visit(int version, int access, String name, String signature, String superName, String[] interfaces)\n    该方法是当扫描类时第一个调用的方法，主要用于类声明使用。下面是对方法中各个参数的示意：visit( 类版本 , 修饰符 , 类名 , 泛型信息 , 继承的父类 , 实现的接口)\n2. AnnotationVisitor visitAnnotation(String desc, boolean visible)\n    该方法是当扫描器扫描到类注解声明时进行调用。下面是对方法中各个参数的示意：visitAnnotation(注解类型 , 注解是否可以在 JVM 中可见)。\n3. FieldVisitor visitField(int access, String name, String desc, String signature, Object value)\n    该方法是当扫描器扫描到类中字段时进行调用。下面是对方法中各个参数的示意：visitField(修饰符 , 字段名 , 字段类型 , 泛型描述 , 默认值)\n4. MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions)\n    该方法是当扫描器扫描到类的方法时进行调用。下面是对方法中各个参数的示意：visitMethod(修饰符 , 方法名 , 方法签名 , 泛型信息 , 抛出的异常)\n5. void visitEnd()\n    该方法是当扫描器完成类扫描时才会调用，如果想在类中追加某些方法\n\n#### 2.2 ClassReader 类\n\n这个类会将 .class 文件读入到 ClassReader 中的字节数组中，它的 accept 方法接受一个 ClassVisitor 实现类，并按照顺序调用 ClassVisitor 中的方法\n\n#### 2.3 ClassWriter 类\n\nClassWriter 是一个 ClassVisitor 的子类，是和 ClassReader 对应的类，ClassReader 是将 .class 文件读入到一个字节数组中，ClassWriter 是将修改后的类的字节码内容以字节数组的形式输出。\n\n#### 2.4 MethodVisitor & AdviceAdapter\n\nMethodVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Method 时就转入 MethodVisitor 接口处理。\n AdviceAdapter 是 MethodVisitor 的子类，使用 AdviceAdapter 可以更方便的修改方法的字节码。\n AdviceAdapter 的方法如下所示：\n\n\n\n![img](/images/4179925-f5a428b729962860.webp)\n\nAdviceAdapter.png\n\n其中比较重要的几个方法如下：\n\n1. void visitCode()：表示 ASM 开始扫描这个方法\n2. void onMethodEnter()：进入这个方法\n3. void onMethodExit()：即将从这个方法出去\n4. void onVisitEnd()：表示方法扫码完毕\n\n#### 2.5 FieldVisitor 抽象类\n\nFieldVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Field 时就转入 FieldVisitor 接口处理。和分析 MethodVisitor 的方法一样，也可以查看源码注释进行学习，这里不再详细介绍\n\n#### 2.6 操作流程\n\n1. 需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中\n2. 然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写\n3. 需要事件过滤器 ClassVisitor。在调用 ClassVisitor 的某些方法时会产生一个新的 XXXVisitor 对象，当我们需要修改对应的内容时只要实现自己的 XXXVisitor 并返回就可以了\n\n### 三. 示例\n\n#### 3.1 修改类中方法的字节码\n\n假如现在我们有一个 HelloWorld 类，如下\n\n\n\n```java\npackage com.lijiankun24.asmpractice.demo;\n\npublic class HelloWorld {\n\n    public void sayHello() {\n        try {\n            Thread.sleep(2 * 1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n通过 `javac HelloWorld.java` 和 `javap -verbose HelloWorld.class` 可以查看到 sayName() 方法的字节码如下所示：\n\n\n\n```cpp\n  public void sayHello();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=1\n         0: ldc2_w        #2                  // long 2000l\n         3: invokestatic  #4                  // Method java/lang/Thread.sleep:(J)V\n         6: goto          14\n         9: astore_1\n        10: aload_1\n        11: invokevirtual #6                  // Method java/lang/InterruptedException.printStackTrace:()V\n        14: return\n      Exception table:\n         from    to  target type\n             0     6     9   Class java/lang/InterruptedException\n      LineNumberTable:\n        line 5: 0\n        line 8: 6\n        line 6: 9\n        line 7: 10\n        line 9: 14\n      StackMapTable: number_of_entries = 2\n        frame_type = 73 /* same_locals_1_stack_item */\n          stack = [ class java/lang/InterruptedException ]\n        frame_type = 4 /* same */\n```\n\n我们通过 ASM 修改 HelloWorld.class 字节码文件，实现统计方法执行时间的功能\n\n\n\n```java\npublic class CostTime {\n\n    public static void main(String[] args) {\n        redefinePersonClass();\n    }\n\n    private static void redefinePersonClass() {\n        String className = \"com.lijiankun24.asmpractice.demo.HelloWorld\";\n        try {\n            InputStream inputStream = new FileInputStream(\"/Users/lijiankun/Desktop/HelloWorld.class\");\n            ClassReader reader = new ClassReader(inputStream);                               // 1. 创建 ClassReader 读入 .class 文件到内存中\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);                 // 2. 创建 ClassWriter 对象，将操作之后的字节码的字节数组回写\n            ClassVisitor change = new ChangeVisitor(writer);                                        // 3. 创建自定义的 ClassVisitor 对象\n            reader.accept(change, ClassReader.EXPAND_FRAMES);                                       // 4. 将 ClassVisitor 对象传入 ClassReader 中\n\n            Class clazz = new MyClassLoader().defineClass(className, writer.toByteArray());\n            Object personObj = clazz.newInstance();\n            Method nameMethod = clazz.getDeclaredMethod(\"sayHello\", null);\n            nameMethod.invoke(personObj, null);\n            System.out.println(\"Success!\");\n            byte[] code = writer.toByteArray();                                                               // 获取修改后的 class 文件对应的字节数组\n            try {\n                FileOutputStream fos = new FileOutputStream(\"/Users/lijiankun/Desktop/HelloWorld2.class\");    // 将二进制流写到本地磁盘上\n                fos.write(code);\n                fos.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(\"Failure!\");\n        }\n    }\n\n    static class ChangeVisitor extends ClassVisitor {\n\n        ChangeVisitor(ClassVisitor classVisitor) {\n            super(Opcodes.ASM5, classVisitor);\n        }\n\n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n            MethodVisitor methodVisitor = super.visitMethod(access, name, desc, signature, exceptions);\n            if (name.equals(\"<init>\")) {\n                return methodVisitor;\n            }\n            return new ChangeAdapter(Opcodes.ASM4, methodVisitor, access, name, desc);\n        }\n    }\n\n    static class ChangeAdapter extends AdviceAdapter {\n        private int startTimeId = -1;\n\n        private String methodName = null;\n\n        ChangeAdapter(int api, MethodVisitor mv, int access, String name, String desc) {\n            super(api, mv, access, name, desc);\n            methodName = name;\n        }\n\n        @Override\n        protected void onMethodEnter() {\n            super.onMethodEnter();\n            startTimeId = newLocal(Type.LONG_TYPE);\n            mv.visitMethodInsn(INVOKESTATIC, \"java/lang/System\", \"currentTimeMillis\", \"()J\", false);\n            mv.visitIntInsn(LSTORE, startTimeId);\n        }\n\n        @Override\n        protected void onMethodExit(int opcode) {\n            super.onMethodExit(opcode);\n            int durationId = newLocal(Type.LONG_TYPE);\n            mv.visitMethodInsn(INVOKESTATIC, \"java/lang/System\", \"currentTimeMillis\", \"()J\", false);\n            mv.visitVarInsn(LLOAD, startTimeId);\n            mv.visitInsn(LSUB);\n            mv.visitVarInsn(LSTORE, durationId);\n            mv.visitFieldInsn(GETSTATIC, \"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\");\n            mv.visitTypeInsn(NEW, \"java/lang/StringBuilder\");\n            mv.visitInsn(DUP);\n            mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/StringBuilder\", \"<init>\", \"()V\", false);\n            mv.visitLdcInsn(\"The cost time of \" + methodName + \" is \");\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false);\n            mv.visitVarInsn(LLOAD, durationId);\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(J)Ljava/lang/StringBuilder;\", false);\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"toString\", \"()Ljava/lang/String;\", false);\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\", false);\n        }\n    }\n}\n```\n\n执行结果如下图所示\n\n\n\n![img](/images/4179925-32ee7bd0974a4679.webp)\n\nClass.png\n\n反编译 HelloWorld2.class 文件的内容如下所示\n\n\n\n![img](/images/4179925-af582100631d7eec.webp)\n\nClass1.png\n\n#### 3.2 修改类中属性的字节码\n\n这一节中我们将展示一下如何使用 Core API 对类中的属性进行操作。\n\n假如说，现在有一个 Person.java 类如下所示：\n\n\n\n```java\npublic class Person {\n    public String name;\n    public int sex;\n}\n```\n\n我们想为这个类，添加一个 ‘public int age’ 的属性该怎么添加呢？我们会面对两个问题：\n\n1. 该调用 ASM 的哪个 API 添加属性呢？\n2. 在何时写添加属性的代码？\n\n接下来，我们就一一解决上面的两个问题？\n\n##### 3.2.1 添加属性的 API\n\n按照我们分析的上述的 2.6 操作流程叙述，需要以下三个步骤：\n\n1. 需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中\n2. 然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写\n3. 需要创建一个事件过滤器 ClassVisitor。事件过滤器中的某些方法可以产生一个新的XXXVisitor对象，当我们需要修改对应的内容时只要实现自己的XXXVisitor并返回就可以了\n\n在上面三个步骤中，可以操作的就是 ClassVisitor 了。ClassVisitor 接口提供了和类结构同名的一些方法，这些方法可以对相应的类结构进行操作。\n\n在使用 ClassVisitor 添加类属性的时候，只需要添加一句话就可以了：\n\n\n\n```java\nclassVisitor.visitField(Opcodes.ACC_PUBLIC, \"age\", Type.getDescriptor(int.class), null, null);\n```\n\n![img](/images/4179925-8c703df0b005aae7.webp)\n\nvisitField.png\n\n##### 3.2.2 添加属性的时机\n\n我们先暂且在 ClassVisitor 的 visitEnd() 方法中写入上面的代码，如下所示\n\n\n\n```java\npublic class Transform extends ClassVisitor {  \n\n    public Transform(ClassVisitor cv) {  \n        super(cv);  \n    }  \n\n    @Override  \n    public void visitEnd() {  \n        cv.visitField(Opcodes.ACC_PUBLIC, \"age\", Type.getDescriptor(int.class), null, null);  \n    }  \n}\n```\n\n我们写如下的测试类，测试一下\n\n\n\n```java\npublic class FieldPractice {\n\n    public static void main(String[] args) {\n        addAgeField();\n    }\n\n    private static void addAgeField() {\n        try {\n            InputStream inputStream = new FileInputStream(\"/Users/lijiankun/Desktop/Person.class\");\n            ClassReader reader = new ClassReader(inputStream);\n\n            ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n\n            ClassVisitor visitor = new Transform(writer);\n            reader.accept(visitor, ClassReader.SKIP_DEBUG);\n\n            byte[] classFile = writer.toByteArray();\n            MyClassLoader classLoader = new MyClassLoader();\n            Class clazz = classLoader.defineClass(\"Person\", classFile);\n            Object obj = clazz.newInstance();\n\n            System.out.println(clazz.getDeclaredField(\"name\").get(obj)); //----(1)\n            System.out.println(clazz.getDeclaredField(\"age\").get(obj));  //----(2)\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n其输出入下所示：\n\n\n\n![img](/images/4179925-a718d240e05a2198.webp)\n\nvisitFieldResult.png\n\n那如果我们尝试在 ClassVisitor#visitField() 方法中添加属性可以吗？我们可以修改 Transform 测试一下：\n\n\n\n```java\npublic class Transform extends ClassVisitor {\n\n    Transform(ClassVisitor classVisitor) {\n        super(Opcodes.ASM5, classVisitor);\n    }\n\n    @Override\n    public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {\n        cv.visitField(Opcodes.ACC_PUBLIC, \"age\", Type.getDescriptor(int.class), null, null);\n        return super.visitField(access, name, desc, signature, value);\n    }\n}\n```\n\n还是使用上面的测试代码测试一下，会有如下的测试结果\n\n\n\n![img](/images/4179925-e2e730e41623be28.webp)\n\nvisitFieldError.png\n\n在 Person 类中有重复的属性，为什么会报这个错误呢？\n\n分析 ClassVisitor#visitField() 方法可得知，只要访问类中的一个属性，visitField() 方法就会被调用一次，在 Person 类中有两个属性，所以 visitField() 方法就会被调用两次，也就添加了两次 ‘public int age’ 属性，就报了上述的错误，而 visitEnd() 方法只有在最后才会被调用且只调用一次，所以在 visitEnd() 方法中是添加属性的最佳时机\n\n#### 3.3 ASMifier\n\n可能有人会问，我刚开始学，上面例子中那些 ASM 的代码我还不会写，怎么办呢？ASM 官方为我们提供了 [ASMifier](https://asm.ow2.io/#Q10)，可以帮助我们生成这些晦涩难懂的 ASM 代码。\n\n比如，我想通过 ASM 实现统计一个方法的执行时间，该怎么做呢？一般会有如下的代码：\n\n\n\n```csharp\npackage com.lijiankun24.classpractice;\n\npublic class Demo {\n\n    public void costTime() {\n        long startTime = System.currentTimeMillis();\n        // ......\n        long duration = System.currentTimeMillis() - startTime;\n        System.out.println(\"The cost time of this method is \" + duration + \" ms\");\n    }\n}\n```\n\n那上面这段代码对应的 ASM 代码是什么呢？我们可以通过以下两个步骤，使用 ASMifier 自动生成：\n\n1. 通过 `javac` 编译该 `Demo.java` 文件生成对应的 `Demo.class` 文件，如下所示\n\n\n\n```css\njavac Demo.java\n```\n\n1. 通过 ASMifier 自动生成对应的 ASM 代码。首先需要在[ASM官网](https://asm.ow2.io/#Q10) 下载 `asm-all.jar` 库，我下载的是最新的 `asm-all-5.2.jar`，然后使用如下命令，即可生成\n\n\n\n```java\njava -classpath asm-all-5.2.jar org.objectweb.asm.util.ASMifier Demo.class\n```\n\n截图如下：\n\n\n\n![img](/images/4179925-0cc8712718f08ea0.webp)\n\nDemoDump.png\n\n[深入字节码 -- 玩转 ASM-Bytecode 原 荐](https://my.oschina.net/ta8210/blog/163550)\n [美团热更方案ASM实践](http://www.easemob.com/news/729)\n\n\n\n43人点赞\n\n\n\n[Java 相关]()\n\n\n\n\n\n作者：lijiankun24\n链接：https://www.jianshu.com/p/905be2a9a700\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","source":"_posts/2022-09-19-ASM.md","raw":"---\nlayout: post\ntitle: ASM库介绍与使用\nauthor: boybeak\ncategory: Android技巧\ntags: Android\n---\n\n\n\n> [原文](https://www.jianshu.com/p/905be2a9a700)\n\n前面几篇文章介绍了 .class 文件的结构、JVM 如何加载 .class 文件、JVM 中如何执行方法的调用和访问者模式，其实前面几篇文章都是为这篇文章做铺垫的，如果不知道 .class 文件结构、也不知道在 JVM 中 .class 文件中的方法是如何被执行的，这篇文章中的有些部分可能会看不懂，所以推荐先看下前面几篇文章。\n 这篇文章主要介绍 ASM 库的结构、主要的 API，并且通过两个示例说明如何通过 ASM 修改 .class 文件中的方法和属性。\n\n\n\n![img](/images/ezgif-6-73b502b11e16.jpg)\n\ncatalog.png\n\n### 一. ASM 的结构\n\nASM 库是一款基于 Java 字节码层面的代码分析和修改工具。ASM 可以直接生产二进制的 class 文件，也可以在类被加载入 JVM 之前动态修改类行为。\n ASM 库的结构如下所示：\n\n\n\n![img](/images/4179925-d4f950ec94a12cde.webp)\n\nasm_arch.png\n\n- Core：为其他包提供基础的读、写、转化Java字节码和定义的API，并且可以生成Java字节码和实现大部分字节码的转换，在 [访问者模式和 ASM](https://www.jianshu.com/p/e4b8cb0b3204) 中介绍的几个重要的类就在 Core API 中：ClassReader、ClassVisitor 和 ClassWriter 类.\n- Tree：提供了 Java 字节码在内存中的表现\n- Commons：提供了一些常用的简化字节码生成、转换的类和适配器\n- Util：包含一些帮助类和简单的字节码修改类，有利于在开发或者测试中使用\n- XML：提供一个适配器将XML和SAX-comliant转化成字节码结构，可以允许使用XSLT去定义字节码转化\n\n### 二. Core API 介绍\n\n#### 2.1 ClassVisitor 抽象类\n\n如下所示，在 ClassVisitor 中提供了和类结构同名的一些方法，这些方法会对类中相应的部分进行操作，而且是有顺序的：visit [ visitSource ] [ visitOuterClass ] ( visitAnnotation | visitAttribute )* (visitInnerClass | visitField | visitMethod )* visitEnd\n\n\n\n```java\npublic abstract class ClassVisitor {\n\n        ......\n\n    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces);\n    public void visitSource(String source, String debug);\n    public void visitOuterClass(String owner, String name, String desc);\n    public AnnotationVisitor visitAnnotation(String desc, boolean visible);\n    public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String desc, boolean visible);\n    public void visitAttribute(Attribute attr);\n    public void visitInnerClass(String name, String outerName, String innerName, int access);\n    public FieldVisitor visitField(int access, String name, String desc, String signature, Object value);\n    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions);\n    public void visitEnd();\n}\n```\n\n1. void visit(int version, int access, String name, String signature, String superName, String[] interfaces)\n    该方法是当扫描类时第一个调用的方法，主要用于类声明使用。下面是对方法中各个参数的示意：visit( 类版本 , 修饰符 , 类名 , 泛型信息 , 继承的父类 , 实现的接口)\n2. AnnotationVisitor visitAnnotation(String desc, boolean visible)\n    该方法是当扫描器扫描到类注解声明时进行调用。下面是对方法中各个参数的示意：visitAnnotation(注解类型 , 注解是否可以在 JVM 中可见)。\n3. FieldVisitor visitField(int access, String name, String desc, String signature, Object value)\n    该方法是当扫描器扫描到类中字段时进行调用。下面是对方法中各个参数的示意：visitField(修饰符 , 字段名 , 字段类型 , 泛型描述 , 默认值)\n4. MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions)\n    该方法是当扫描器扫描到类的方法时进行调用。下面是对方法中各个参数的示意：visitMethod(修饰符 , 方法名 , 方法签名 , 泛型信息 , 抛出的异常)\n5. void visitEnd()\n    该方法是当扫描器完成类扫描时才会调用，如果想在类中追加某些方法\n\n#### 2.2 ClassReader 类\n\n这个类会将 .class 文件读入到 ClassReader 中的字节数组中，它的 accept 方法接受一个 ClassVisitor 实现类，并按照顺序调用 ClassVisitor 中的方法\n\n#### 2.3 ClassWriter 类\n\nClassWriter 是一个 ClassVisitor 的子类，是和 ClassReader 对应的类，ClassReader 是将 .class 文件读入到一个字节数组中，ClassWriter 是将修改后的类的字节码内容以字节数组的形式输出。\n\n#### 2.4 MethodVisitor & AdviceAdapter\n\nMethodVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Method 时就转入 MethodVisitor 接口处理。\n AdviceAdapter 是 MethodVisitor 的子类，使用 AdviceAdapter 可以更方便的修改方法的字节码。\n AdviceAdapter 的方法如下所示：\n\n\n\n![img](/images/4179925-f5a428b729962860.webp)\n\nAdviceAdapter.png\n\n其中比较重要的几个方法如下：\n\n1. void visitCode()：表示 ASM 开始扫描这个方法\n2. void onMethodEnter()：进入这个方法\n3. void onMethodExit()：即将从这个方法出去\n4. void onVisitEnd()：表示方法扫码完毕\n\n#### 2.5 FieldVisitor 抽象类\n\nFieldVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Field 时就转入 FieldVisitor 接口处理。和分析 MethodVisitor 的方法一样，也可以查看源码注释进行学习，这里不再详细介绍\n\n#### 2.6 操作流程\n\n1. 需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中\n2. 然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写\n3. 需要事件过滤器 ClassVisitor。在调用 ClassVisitor 的某些方法时会产生一个新的 XXXVisitor 对象，当我们需要修改对应的内容时只要实现自己的 XXXVisitor 并返回就可以了\n\n### 三. 示例\n\n#### 3.1 修改类中方法的字节码\n\n假如现在我们有一个 HelloWorld 类，如下\n\n\n\n```java\npackage com.lijiankun24.asmpractice.demo;\n\npublic class HelloWorld {\n\n    public void sayHello() {\n        try {\n            Thread.sleep(2 * 1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n通过 `javac HelloWorld.java` 和 `javap -verbose HelloWorld.class` 可以查看到 sayName() 方法的字节码如下所示：\n\n\n\n```cpp\n  public void sayHello();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=1\n         0: ldc2_w        #2                  // long 2000l\n         3: invokestatic  #4                  // Method java/lang/Thread.sleep:(J)V\n         6: goto          14\n         9: astore_1\n        10: aload_1\n        11: invokevirtual #6                  // Method java/lang/InterruptedException.printStackTrace:()V\n        14: return\n      Exception table:\n         from    to  target type\n             0     6     9   Class java/lang/InterruptedException\n      LineNumberTable:\n        line 5: 0\n        line 8: 6\n        line 6: 9\n        line 7: 10\n        line 9: 14\n      StackMapTable: number_of_entries = 2\n        frame_type = 73 /* same_locals_1_stack_item */\n          stack = [ class java/lang/InterruptedException ]\n        frame_type = 4 /* same */\n```\n\n我们通过 ASM 修改 HelloWorld.class 字节码文件，实现统计方法执行时间的功能\n\n\n\n```java\npublic class CostTime {\n\n    public static void main(String[] args) {\n        redefinePersonClass();\n    }\n\n    private static void redefinePersonClass() {\n        String className = \"com.lijiankun24.asmpractice.demo.HelloWorld\";\n        try {\n            InputStream inputStream = new FileInputStream(\"/Users/lijiankun/Desktop/HelloWorld.class\");\n            ClassReader reader = new ClassReader(inputStream);                               // 1. 创建 ClassReader 读入 .class 文件到内存中\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);                 // 2. 创建 ClassWriter 对象，将操作之后的字节码的字节数组回写\n            ClassVisitor change = new ChangeVisitor(writer);                                        // 3. 创建自定义的 ClassVisitor 对象\n            reader.accept(change, ClassReader.EXPAND_FRAMES);                                       // 4. 将 ClassVisitor 对象传入 ClassReader 中\n\n            Class clazz = new MyClassLoader().defineClass(className, writer.toByteArray());\n            Object personObj = clazz.newInstance();\n            Method nameMethod = clazz.getDeclaredMethod(\"sayHello\", null);\n            nameMethod.invoke(personObj, null);\n            System.out.println(\"Success!\");\n            byte[] code = writer.toByteArray();                                                               // 获取修改后的 class 文件对应的字节数组\n            try {\n                FileOutputStream fos = new FileOutputStream(\"/Users/lijiankun/Desktop/HelloWorld2.class\");    // 将二进制流写到本地磁盘上\n                fos.write(code);\n                fos.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(\"Failure!\");\n        }\n    }\n\n    static class ChangeVisitor extends ClassVisitor {\n\n        ChangeVisitor(ClassVisitor classVisitor) {\n            super(Opcodes.ASM5, classVisitor);\n        }\n\n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n            MethodVisitor methodVisitor = super.visitMethod(access, name, desc, signature, exceptions);\n            if (name.equals(\"<init>\")) {\n                return methodVisitor;\n            }\n            return new ChangeAdapter(Opcodes.ASM4, methodVisitor, access, name, desc);\n        }\n    }\n\n    static class ChangeAdapter extends AdviceAdapter {\n        private int startTimeId = -1;\n\n        private String methodName = null;\n\n        ChangeAdapter(int api, MethodVisitor mv, int access, String name, String desc) {\n            super(api, mv, access, name, desc);\n            methodName = name;\n        }\n\n        @Override\n        protected void onMethodEnter() {\n            super.onMethodEnter();\n            startTimeId = newLocal(Type.LONG_TYPE);\n            mv.visitMethodInsn(INVOKESTATIC, \"java/lang/System\", \"currentTimeMillis\", \"()J\", false);\n            mv.visitIntInsn(LSTORE, startTimeId);\n        }\n\n        @Override\n        protected void onMethodExit(int opcode) {\n            super.onMethodExit(opcode);\n            int durationId = newLocal(Type.LONG_TYPE);\n            mv.visitMethodInsn(INVOKESTATIC, \"java/lang/System\", \"currentTimeMillis\", \"()J\", false);\n            mv.visitVarInsn(LLOAD, startTimeId);\n            mv.visitInsn(LSUB);\n            mv.visitVarInsn(LSTORE, durationId);\n            mv.visitFieldInsn(GETSTATIC, \"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\");\n            mv.visitTypeInsn(NEW, \"java/lang/StringBuilder\");\n            mv.visitInsn(DUP);\n            mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/StringBuilder\", \"<init>\", \"()V\", false);\n            mv.visitLdcInsn(\"The cost time of \" + methodName + \" is \");\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false);\n            mv.visitVarInsn(LLOAD, durationId);\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(J)Ljava/lang/StringBuilder;\", false);\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"toString\", \"()Ljava/lang/String;\", false);\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\", false);\n        }\n    }\n}\n```\n\n执行结果如下图所示\n\n\n\n![img](/images/4179925-32ee7bd0974a4679.webp)\n\nClass.png\n\n反编译 HelloWorld2.class 文件的内容如下所示\n\n\n\n![img](/images/4179925-af582100631d7eec.webp)\n\nClass1.png\n\n#### 3.2 修改类中属性的字节码\n\n这一节中我们将展示一下如何使用 Core API 对类中的属性进行操作。\n\n假如说，现在有一个 Person.java 类如下所示：\n\n\n\n```java\npublic class Person {\n    public String name;\n    public int sex;\n}\n```\n\n我们想为这个类，添加一个 ‘public int age’ 的属性该怎么添加呢？我们会面对两个问题：\n\n1. 该调用 ASM 的哪个 API 添加属性呢？\n2. 在何时写添加属性的代码？\n\n接下来，我们就一一解决上面的两个问题？\n\n##### 3.2.1 添加属性的 API\n\n按照我们分析的上述的 2.6 操作流程叙述，需要以下三个步骤：\n\n1. 需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中\n2. 然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写\n3. 需要创建一个事件过滤器 ClassVisitor。事件过滤器中的某些方法可以产生一个新的XXXVisitor对象，当我们需要修改对应的内容时只要实现自己的XXXVisitor并返回就可以了\n\n在上面三个步骤中，可以操作的就是 ClassVisitor 了。ClassVisitor 接口提供了和类结构同名的一些方法，这些方法可以对相应的类结构进行操作。\n\n在使用 ClassVisitor 添加类属性的时候，只需要添加一句话就可以了：\n\n\n\n```java\nclassVisitor.visitField(Opcodes.ACC_PUBLIC, \"age\", Type.getDescriptor(int.class), null, null);\n```\n\n![img](/images/4179925-8c703df0b005aae7.webp)\n\nvisitField.png\n\n##### 3.2.2 添加属性的时机\n\n我们先暂且在 ClassVisitor 的 visitEnd() 方法中写入上面的代码，如下所示\n\n\n\n```java\npublic class Transform extends ClassVisitor {  \n\n    public Transform(ClassVisitor cv) {  \n        super(cv);  \n    }  \n\n    @Override  \n    public void visitEnd() {  \n        cv.visitField(Opcodes.ACC_PUBLIC, \"age\", Type.getDescriptor(int.class), null, null);  \n    }  \n}\n```\n\n我们写如下的测试类，测试一下\n\n\n\n```java\npublic class FieldPractice {\n\n    public static void main(String[] args) {\n        addAgeField();\n    }\n\n    private static void addAgeField() {\n        try {\n            InputStream inputStream = new FileInputStream(\"/Users/lijiankun/Desktop/Person.class\");\n            ClassReader reader = new ClassReader(inputStream);\n\n            ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n\n            ClassVisitor visitor = new Transform(writer);\n            reader.accept(visitor, ClassReader.SKIP_DEBUG);\n\n            byte[] classFile = writer.toByteArray();\n            MyClassLoader classLoader = new MyClassLoader();\n            Class clazz = classLoader.defineClass(\"Person\", classFile);\n            Object obj = clazz.newInstance();\n\n            System.out.println(clazz.getDeclaredField(\"name\").get(obj)); //----(1)\n            System.out.println(clazz.getDeclaredField(\"age\").get(obj));  //----(2)\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n其输出入下所示：\n\n\n\n![img](/images/4179925-a718d240e05a2198.webp)\n\nvisitFieldResult.png\n\n那如果我们尝试在 ClassVisitor#visitField() 方法中添加属性可以吗？我们可以修改 Transform 测试一下：\n\n\n\n```java\npublic class Transform extends ClassVisitor {\n\n    Transform(ClassVisitor classVisitor) {\n        super(Opcodes.ASM5, classVisitor);\n    }\n\n    @Override\n    public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {\n        cv.visitField(Opcodes.ACC_PUBLIC, \"age\", Type.getDescriptor(int.class), null, null);\n        return super.visitField(access, name, desc, signature, value);\n    }\n}\n```\n\n还是使用上面的测试代码测试一下，会有如下的测试结果\n\n\n\n![img](/images/4179925-e2e730e41623be28.webp)\n\nvisitFieldError.png\n\n在 Person 类中有重复的属性，为什么会报这个错误呢？\n\n分析 ClassVisitor#visitField() 方法可得知，只要访问类中的一个属性，visitField() 方法就会被调用一次，在 Person 类中有两个属性，所以 visitField() 方法就会被调用两次，也就添加了两次 ‘public int age’ 属性，就报了上述的错误，而 visitEnd() 方法只有在最后才会被调用且只调用一次，所以在 visitEnd() 方法中是添加属性的最佳时机\n\n#### 3.3 ASMifier\n\n可能有人会问，我刚开始学，上面例子中那些 ASM 的代码我还不会写，怎么办呢？ASM 官方为我们提供了 [ASMifier](https://asm.ow2.io/#Q10)，可以帮助我们生成这些晦涩难懂的 ASM 代码。\n\n比如，我想通过 ASM 实现统计一个方法的执行时间，该怎么做呢？一般会有如下的代码：\n\n\n\n```csharp\npackage com.lijiankun24.classpractice;\n\npublic class Demo {\n\n    public void costTime() {\n        long startTime = System.currentTimeMillis();\n        // ......\n        long duration = System.currentTimeMillis() - startTime;\n        System.out.println(\"The cost time of this method is \" + duration + \" ms\");\n    }\n}\n```\n\n那上面这段代码对应的 ASM 代码是什么呢？我们可以通过以下两个步骤，使用 ASMifier 自动生成：\n\n1. 通过 `javac` 编译该 `Demo.java` 文件生成对应的 `Demo.class` 文件，如下所示\n\n\n\n```css\njavac Demo.java\n```\n\n1. 通过 ASMifier 自动生成对应的 ASM 代码。首先需要在[ASM官网](https://asm.ow2.io/#Q10) 下载 `asm-all.jar` 库，我下载的是最新的 `asm-all-5.2.jar`，然后使用如下命令，即可生成\n\n\n\n```java\njava -classpath asm-all-5.2.jar org.objectweb.asm.util.ASMifier Demo.class\n```\n\n截图如下：\n\n\n\n![img](/images/4179925-0cc8712718f08ea0.webp)\n\nDemoDump.png\n\n[深入字节码 -- 玩转 ASM-Bytecode 原 荐](https://my.oschina.net/ta8210/blog/163550)\n [美团热更方案ASM实践](http://www.easemob.com/news/729)\n\n\n\n43人点赞\n\n\n\n[Java 相关]()\n\n\n\n\n\n作者：lijiankun24\n链接：https://www.jianshu.com/p/905be2a9a700\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","slug":"2022-09-19-ASM","published":1,"date":"2020-11-23T10:23:05.000Z","updated":"2023-02-05T04:18:36.087Z","_id":"cldqukh8s000qpcjgc18i7s5d","comments":1,"photos":[],"link":"","content":"<blockquote>\n<p><a href=\"https://www.jianshu.com/p/905be2a9a700\">原文</a></p>\n</blockquote>\n<p>前面几篇文章介绍了 .class 文件的结构、JVM 如何加载 .class 文件、JVM 中如何执行方法的调用和访问者模式，其实前面几篇文章都是为这篇文章做铺垫的，如果不知道 .class 文件结构、也不知道在 JVM 中 .class 文件中的方法是如何被执行的，这篇文章中的有些部分可能会看不懂，所以推荐先看下前面几篇文章。<br> 这篇文章主要介绍 ASM 库的结构、主要的 API，并且通过两个示例说明如何通过 ASM 修改 .class 文件中的方法和属性。</p>\n<p><img src=\"/images/ezgif-6-73b502b11e16.jpg\" alt=\"img\"></p>\n<p>catalog.png</p>\n<h3 id=\"一-ASM-的结构\"><a href=\"#一-ASM-的结构\" class=\"headerlink\" title=\"一. ASM 的结构\"></a>一. ASM 的结构</h3><p>ASM 库是一款基于 Java 字节码层面的代码分析和修改工具。ASM 可以直接生产二进制的 class 文件，也可以在类被加载入 JVM 之前动态修改类行为。<br> ASM 库的结构如下所示：</p>\n<p><img src=\"/images/4179925-d4f950ec94a12cde.webp\" alt=\"img\"></p>\n<p>asm_arch.png</p>\n<ul>\n<li>Core：为其他包提供基础的读、写、转化Java字节码和定义的API，并且可以生成Java字节码和实现大部分字节码的转换，在 <a href=\"https://www.jianshu.com/p/e4b8cb0b3204\">访问者模式和 ASM</a> 中介绍的几个重要的类就在 Core API 中：ClassReader、ClassVisitor 和 ClassWriter 类.</li>\n<li>Tree：提供了 Java 字节码在内存中的表现</li>\n<li>Commons：提供了一些常用的简化字节码生成、转换的类和适配器</li>\n<li>Util：包含一些帮助类和简单的字节码修改类，有利于在开发或者测试中使用</li>\n<li>XML：提供一个适配器将XML和SAX-comliant转化成字节码结构，可以允许使用XSLT去定义字节码转化</li>\n</ul>\n<h3 id=\"二-Core-API-介绍\"><a href=\"#二-Core-API-介绍\" class=\"headerlink\" title=\"二. Core API 介绍\"></a>二. Core API 介绍</h3><h4 id=\"2-1-ClassVisitor-抽象类\"><a href=\"#2-1-ClassVisitor-抽象类\" class=\"headerlink\" title=\"2.1 ClassVisitor 抽象类\"></a>2.1 ClassVisitor 抽象类</h4><p>如下所示，在 ClassVisitor 中提供了和类结构同名的一些方法，这些方法会对类中相应的部分进行操作，而且是有顺序的：visit [ visitSource ] [ visitOuterClass ] ( visitAnnotation | visitAttribute )* (visitInnerClass | visitField | visitMethod )* visitEnd</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassVisitor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visit</span><span class=\"params\">(<span class=\"type\">int</span> version, <span class=\"type\">int</span> access, String name, String signature, String superName, String[] interfaces)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitSource</span><span class=\"params\">(String source, String debug)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitOuterClass</span><span class=\"params\">(String owner, String name, String desc)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> AnnotationVisitor <span class=\"title function_\">visitAnnotation</span><span class=\"params\">(String desc, <span class=\"type\">boolean</span> visible)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> AnnotationVisitor <span class=\"title function_\">visitTypeAnnotation</span><span class=\"params\">(<span class=\"type\">int</span> typeRef, TypePath typePath, String desc, <span class=\"type\">boolean</span> visible)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitAttribute</span><span class=\"params\">(Attribute attr)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitInnerClass</span><span class=\"params\">(String name, String outerName, String innerName, <span class=\"type\">int</span> access)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> FieldVisitor <span class=\"title function_\">visitField</span><span class=\"params\">(<span class=\"type\">int</span> access, String name, String desc, String signature, Object value)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> MethodVisitor <span class=\"title function_\">visitMethod</span><span class=\"params\">(<span class=\"type\">int</span> access, String name, String desc, String signature, String[] exceptions)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitEnd</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>void visit(int version, int access, String name, String signature, String superName, String[] interfaces)<br> 该方法是当扫描类时第一个调用的方法，主要用于类声明使用。下面是对方法中各个参数的示意：visit( 类版本 , 修饰符 , 类名 , 泛型信息 , 继承的父类 , 实现的接口)</li>\n<li>AnnotationVisitor visitAnnotation(String desc, boolean visible)<br> 该方法是当扫描器扫描到类注解声明时进行调用。下面是对方法中各个参数的示意：visitAnnotation(注解类型 , 注解是否可以在 JVM 中可见)。</li>\n<li>FieldVisitor visitField(int access, String name, String desc, String signature, Object value)<br> 该方法是当扫描器扫描到类中字段时进行调用。下面是对方法中各个参数的示意：visitField(修饰符 , 字段名 , 字段类型 , 泛型描述 , 默认值)</li>\n<li>MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions)<br> 该方法是当扫描器扫描到类的方法时进行调用。下面是对方法中各个参数的示意：visitMethod(修饰符 , 方法名 , 方法签名 , 泛型信息 , 抛出的异常)</li>\n<li>void visitEnd()<br> 该方法是当扫描器完成类扫描时才会调用，如果想在类中追加某些方法</li>\n</ol>\n<h4 id=\"2-2-ClassReader-类\"><a href=\"#2-2-ClassReader-类\" class=\"headerlink\" title=\"2.2 ClassReader 类\"></a>2.2 ClassReader 类</h4><p>这个类会将 .class 文件读入到 ClassReader 中的字节数组中，它的 accept 方法接受一个 ClassVisitor 实现类，并按照顺序调用 ClassVisitor 中的方法</p>\n<h4 id=\"2-3-ClassWriter-类\"><a href=\"#2-3-ClassWriter-类\" class=\"headerlink\" title=\"2.3 ClassWriter 类\"></a>2.3 ClassWriter 类</h4><p>ClassWriter 是一个 ClassVisitor 的子类，是和 ClassReader 对应的类，ClassReader 是将 .class 文件读入到一个字节数组中，ClassWriter 是将修改后的类的字节码内容以字节数组的形式输出。</p>\n<h4 id=\"2-4-MethodVisitor-amp-AdviceAdapter\"><a href=\"#2-4-MethodVisitor-amp-AdviceAdapter\" class=\"headerlink\" title=\"2.4 MethodVisitor &amp; AdviceAdapter\"></a>2.4 MethodVisitor &amp; AdviceAdapter</h4><p>MethodVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Method 时就转入 MethodVisitor 接口处理。<br> AdviceAdapter 是 MethodVisitor 的子类，使用 AdviceAdapter 可以更方便的修改方法的字节码。<br> AdviceAdapter 的方法如下所示：</p>\n<p><img src=\"/images/4179925-f5a428b729962860.webp\" alt=\"img\"></p>\n<p>AdviceAdapter.png</p>\n<p>其中比较重要的几个方法如下：</p>\n<ol>\n<li>void visitCode()：表示 ASM 开始扫描这个方法</li>\n<li>void onMethodEnter()：进入这个方法</li>\n<li>void onMethodExit()：即将从这个方法出去</li>\n<li>void onVisitEnd()：表示方法扫码完毕</li>\n</ol>\n<h4 id=\"2-5-FieldVisitor-抽象类\"><a href=\"#2-5-FieldVisitor-抽象类\" class=\"headerlink\" title=\"2.5 FieldVisitor 抽象类\"></a>2.5 FieldVisitor 抽象类</h4><p>FieldVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Field 时就转入 FieldVisitor 接口处理。和分析 MethodVisitor 的方法一样，也可以查看源码注释进行学习，这里不再详细介绍</p>\n<h4 id=\"2-6-操作流程\"><a href=\"#2-6-操作流程\" class=\"headerlink\" title=\"2.6 操作流程\"></a>2.6 操作流程</h4><ol>\n<li>需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中</li>\n<li>然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写</li>\n<li>需要事件过滤器 ClassVisitor。在调用 ClassVisitor 的某些方法时会产生一个新的 XXXVisitor 对象，当我们需要修改对应的内容时只要实现自己的 XXXVisitor 并返回就可以了</li>\n</ol>\n<h3 id=\"三-示例\"><a href=\"#三-示例\" class=\"headerlink\" title=\"三. 示例\"></a>三. 示例</h3><h4 id=\"3-1-修改类中方法的字节码\"><a href=\"#3-1-修改类中方法的字节码\" class=\"headerlink\" title=\"3.1 修改类中方法的字节码\"></a>3.1 修改类中方法的字节码</h4><p>假如现在我们有一个 HelloWorld 类，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.lijiankun24.asmpractice.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>javac HelloWorld.java</code> 和 <code>javap -verbose HelloWorld.class</code> 可以查看到 sayName() 方法的字节码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  descriptor: ()V</span><br><span class=\"line\">  flags: ACC_PUBLIC</span><br><span class=\"line\">  Code:</span><br><span class=\"line\">    stack=<span class=\"number\">2</span>, locals=<span class=\"number\">2</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">       <span class=\"number\">0</span>: ldc2_w        #<span class=\"number\">2</span>                  <span class=\"comment\">// long 2000l</span></span><br><span class=\"line\">       <span class=\"number\">3</span>: invokestatic  #<span class=\"number\">4</span>                  <span class=\"comment\">// Method java/lang/Thread.sleep:(J)V</span></span><br><span class=\"line\">       <span class=\"number\">6</span>: <span class=\"keyword\">goto</span>          <span class=\"number\">14</span></span><br><span class=\"line\">       <span class=\"number\">9</span>: astore_1</span><br><span class=\"line\">      <span class=\"number\">10</span>: aload_1</span><br><span class=\"line\">      <span class=\"number\">11</span>: invokevirtual #<span class=\"number\">6</span>                  <span class=\"comment\">// Method java/lang/InterruptedException.printStackTrace:()V</span></span><br><span class=\"line\">      <span class=\"number\">14</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">    Exception table:</span><br><span class=\"line\">       from    to  target type</span><br><span class=\"line\">           <span class=\"number\">0</span>     <span class=\"number\">6</span>     <span class=\"number\">9</span>   Class java/lang/InterruptedException</span><br><span class=\"line\">    LineNumberTable:</span><br><span class=\"line\">      line <span class=\"number\">5</span>: <span class=\"number\">0</span></span><br><span class=\"line\">      line <span class=\"number\">8</span>: <span class=\"number\">6</span></span><br><span class=\"line\">      line <span class=\"number\">6</span>: <span class=\"number\">9</span></span><br><span class=\"line\">      line <span class=\"number\">7</span>: <span class=\"number\">10</span></span><br><span class=\"line\">      line <span class=\"number\">9</span>: <span class=\"number\">14</span></span><br><span class=\"line\">    StackMapTable: number_of_entries = <span class=\"number\">2</span></span><br><span class=\"line\">      frame_type = <span class=\"number\">73</span> <span class=\"comment\">/* same_locals_1_stack_item */</span></span><br><span class=\"line\">        stack = [ <span class=\"keyword\">class</span> java/lang/InterruptedException ]</span><br><span class=\"line\">      frame_type = <span class=\"number\">4</span> <span class=\"comment\">/* same */</span></span><br></pre></td></tr></table></figure>\n\n<p>我们通过 ASM 修改 HelloWorld.class 字节码文件，实现统计方法执行时间的功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CostTime</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        redefinePersonClass();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">redefinePersonClass</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">className</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;com.lijiankun24.asmpractice.demo.HelloWorld&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;/Users/lijiankun/Desktop/HelloWorld.class&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">ClassReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassReader</span>(inputStream);                               <span class=\"comment\">// 1. 创建 ClassReader 读入 .class 文件到内存中</span></span><br><span class=\"line\">            <span class=\"type\">ClassWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassWriter</span>(reader, ClassWriter.COMPUTE_MAXS);                 <span class=\"comment\">// 2. 创建 ClassWriter 对象，将操作之后的字节码的字节数组回写</span></span><br><span class=\"line\">            <span class=\"type\">ClassVisitor</span> <span class=\"variable\">change</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ChangeVisitor</span>(writer);                                        <span class=\"comment\">// 3. 创建自定义的 ClassVisitor 对象</span></span><br><span class=\"line\">            reader.accept(change, ClassReader.EXPAND_FRAMES);                                       <span class=\"comment\">// 4. 将 ClassVisitor 对象传入 ClassReader 中</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyClassLoader</span>().defineClass(className, writer.toByteArray());</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">personObj</span> <span class=\"operator\">=</span> clazz.newInstance();</span><br><span class=\"line\">            <span class=\"type\">Method</span> <span class=\"variable\">nameMethod</span> <span class=\"operator\">=</span> clazz.getDeclaredMethod(<span class=\"string\">&quot;sayHello&quot;</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">            nameMethod.invoke(personObj, <span class=\"literal\">null</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Success!&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">byte</span>[] code = writer.toByteArray();                                                               <span class=\"comment\">// 获取修改后的 class 文件对应的字节数组</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">FileOutputStream</span> <span class=\"variable\">fos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"string\">&quot;/Users/lijiankun/Desktop/HelloWorld2.class&quot;</span>);    <span class=\"comment\">// 将二进制流写到本地磁盘上</span></span><br><span class=\"line\">                fos.write(code);</span><br><span class=\"line\">                fos.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Failure!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChangeVisitor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassVisitor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ChangeVisitor(ClassVisitor classVisitor) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(Opcodes.ASM5, classVisitor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> MethodVisitor <span class=\"title function_\">visitMethod</span><span class=\"params\">(<span class=\"type\">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">MethodVisitor</span> <span class=\"variable\">methodVisitor</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (name.equals(<span class=\"string\">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> methodVisitor;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ChangeAdapter</span>(Opcodes.ASM4, methodVisitor, access, name, desc);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChangeAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AdviceAdapter</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">startTimeId</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        ChangeAdapter(<span class=\"type\">int</span> api, MethodVisitor mv, <span class=\"type\">int</span> access, String name, String desc) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(api, mv, access, name, desc);</span><br><span class=\"line\">            methodName = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onMethodEnter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.onMethodEnter();</span><br><span class=\"line\">            startTimeId = newLocal(Type.LONG_TYPE);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKESTATIC, <span class=\"string\">&quot;java/lang/System&quot;</span>, <span class=\"string\">&quot;currentTimeMillis&quot;</span>, <span class=\"string\">&quot;()J&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            mv.visitIntInsn(LSTORE, startTimeId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onMethodExit</span><span class=\"params\">(<span class=\"type\">int</span> opcode)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.onMethodExit(opcode);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">durationId</span> <span class=\"operator\">=</span> newLocal(Type.LONG_TYPE);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKESTATIC, <span class=\"string\">&quot;java/lang/System&quot;</span>, <span class=\"string\">&quot;currentTimeMillis&quot;</span>, <span class=\"string\">&quot;()J&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            mv.visitVarInsn(LLOAD, startTimeId);</span><br><span class=\"line\">            mv.visitInsn(LSUB);</span><br><span class=\"line\">            mv.visitVarInsn(LSTORE, durationId);</span><br><span class=\"line\">            mv.visitFieldInsn(GETSTATIC, <span class=\"string\">&quot;java/lang/System&quot;</span>, <span class=\"string\">&quot;out&quot;</span>, <span class=\"string\">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class=\"line\">            mv.visitTypeInsn(NEW, <span class=\"string\">&quot;java/lang/StringBuilder&quot;</span>);</span><br><span class=\"line\">            mv.visitInsn(DUP);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKESPECIAL, <span class=\"string\">&quot;java/lang/StringBuilder&quot;</span>, <span class=\"string\">&quot;&lt;init&gt;&quot;</span>, <span class=\"string\">&quot;()V&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            mv.visitLdcInsn(<span class=\"string\">&quot;The cost time of &quot;</span> + methodName + <span class=\"string\">&quot; is &quot;</span>);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class=\"string\">&quot;java/lang/StringBuilder&quot;</span>, <span class=\"string\">&quot;append&quot;</span>, <span class=\"string\">&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            mv.visitVarInsn(LLOAD, durationId);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class=\"string\">&quot;java/lang/StringBuilder&quot;</span>, <span class=\"string\">&quot;append&quot;</span>, <span class=\"string\">&quot;(J)Ljava/lang/StringBuilder;&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class=\"string\">&quot;java/lang/StringBuilder&quot;</span>, <span class=\"string\">&quot;toString&quot;</span>, <span class=\"string\">&quot;()Ljava/lang/String;&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class=\"string\">&quot;java/io/PrintStream&quot;</span>, <span class=\"string\">&quot;println&quot;</span>, <span class=\"string\">&quot;(Ljava/lang/String;)V&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果如下图所示</p>\n<p><img src=\"/images/4179925-32ee7bd0974a4679.webp\" alt=\"img\"></p>\n<p>Class.png</p>\n<p>反编译 HelloWorld2.class 文件的内容如下所示</p>\n<p><img src=\"/images/4179925-af582100631d7eec.webp\" alt=\"img\"></p>\n<p>Class1.png</p>\n<h4 id=\"3-2-修改类中属性的字节码\"><a href=\"#3-2-修改类中属性的字节码\" class=\"headerlink\" title=\"3.2 修改类中属性的字节码\"></a>3.2 修改类中属性的字节码</h4><p>这一节中我们将展示一下如何使用 Core API 对类中的属性进行操作。</p>\n<p>假如说，现在有一个 Person.java 类如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> sex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们想为这个类，添加一个 ‘public int age’ 的属性该怎么添加呢？我们会面对两个问题：</p>\n<ol>\n<li>该调用 ASM 的哪个 API 添加属性呢？</li>\n<li>在何时写添加属性的代码？</li>\n</ol>\n<p>接下来，我们就一一解决上面的两个问题？</p>\n<h5 id=\"3-2-1-添加属性的-API\"><a href=\"#3-2-1-添加属性的-API\" class=\"headerlink\" title=\"3.2.1 添加属性的 API\"></a>3.2.1 添加属性的 API</h5><p>按照我们分析的上述的 2.6 操作流程叙述，需要以下三个步骤：</p>\n<ol>\n<li>需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中</li>\n<li>然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写</li>\n<li>需要创建一个事件过滤器 ClassVisitor。事件过滤器中的某些方法可以产生一个新的XXXVisitor对象，当我们需要修改对应的内容时只要实现自己的XXXVisitor并返回就可以了</li>\n</ol>\n<p>在上面三个步骤中，可以操作的就是 ClassVisitor 了。ClassVisitor 接口提供了和类结构同名的一些方法，这些方法可以对相应的类结构进行操作。</p>\n<p>在使用 ClassVisitor 添加类属性的时候，只需要添加一句话就可以了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classVisitor.visitField(Opcodes.ACC_PUBLIC, <span class=\"string\">&quot;age&quot;</span>, Type.getDescriptor(<span class=\"type\">int</span>.class), <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/4179925-8c703df0b005aae7.webp\" alt=\"img\"></p>\n<p>visitField.png</p>\n<h5 id=\"3-2-2-添加属性的时机\"><a href=\"#3-2-2-添加属性的时机\" class=\"headerlink\" title=\"3.2.2 添加属性的时机\"></a>3.2.2 添加属性的时机</h5><p>我们先暂且在 ClassVisitor 的 visitEnd() 方法中写入上面的代码，如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Transform</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassVisitor</span> &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Transform</span><span class=\"params\">(ClassVisitor cv)</span> &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">super</span>(cv);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitEnd</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        cv.visitField(Opcodes.ACC_PUBLIC, <span class=\"string\">&quot;age&quot;</span>, Type.getDescriptor(<span class=\"type\">int</span>.class), <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们写如下的测试类，测试一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FieldPractice</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        addAgeField();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addAgeField</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;/Users/lijiankun/Desktop/Person.class&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">ClassReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassReader</span>(inputStream);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">ClassWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">ClassVisitor</span> <span class=\"variable\">visitor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Transform</span>(writer);</span><br><span class=\"line\">            reader.accept(visitor, ClassReader.SKIP_DEBUG);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">byte</span>[] classFile = writer.toByteArray();</span><br><span class=\"line\">            <span class=\"type\">MyClassLoader</span> <span class=\"variable\">classLoader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyClassLoader</span>();</span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> classLoader.defineClass(<span class=\"string\">&quot;Person&quot;</span>, classFile);</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> clazz.newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(clazz.getDeclaredField(<span class=\"string\">&quot;name&quot;</span>).get(obj)); <span class=\"comment\">//----(1)</span></span><br><span class=\"line\">            System.out.println(clazz.getDeclaredField(<span class=\"string\">&quot;age&quot;</span>).get(obj));  <span class=\"comment\">//----(2)</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其输出入下所示：</p>\n<p><img src=\"/images/4179925-a718d240e05a2198.webp\" alt=\"img\"></p>\n<p>visitFieldResult.png</p>\n<p>那如果我们尝试在 ClassVisitor#visitField() 方法中添加属性可以吗？我们可以修改 Transform 测试一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Transform</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassVisitor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Transform(ClassVisitor classVisitor) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(Opcodes.ASM5, classVisitor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> FieldVisitor <span class=\"title function_\">visitField</span><span class=\"params\">(<span class=\"type\">int</span> access, String name, String desc, String signature, Object value)</span> &#123;</span><br><span class=\"line\">        cv.visitField(Opcodes.ACC_PUBLIC, <span class=\"string\">&quot;age&quot;</span>, Type.getDescriptor(<span class=\"type\">int</span>.class), <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.visitField(access, name, desc, signature, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还是使用上面的测试代码测试一下，会有如下的测试结果</p>\n<p><img src=\"/images/4179925-e2e730e41623be28.webp\" alt=\"img\"></p>\n<p>visitFieldError.png</p>\n<p>在 Person 类中有重复的属性，为什么会报这个错误呢？</p>\n<p>分析 ClassVisitor#visitField() 方法可得知，只要访问类中的一个属性，visitField() 方法就会被调用一次，在 Person 类中有两个属性，所以 visitField() 方法就会被调用两次，也就添加了两次 ‘public int age’ 属性，就报了上述的错误，而 visitEnd() 方法只有在最后才会被调用且只调用一次，所以在 visitEnd() 方法中是添加属性的最佳时机</p>\n<h4 id=\"3-3-ASMifier\"><a href=\"#3-3-ASMifier\" class=\"headerlink\" title=\"3.3 ASMifier\"></a>3.3 ASMifier</h4><p>可能有人会问，我刚开始学，上面例子中那些 ASM 的代码我还不会写，怎么办呢？ASM 官方为我们提供了 <a href=\"https://asm.ow2.io/#Q10\">ASMifier</a>，可以帮助我们生成这些晦涩难懂的 ASM 代码。</p>\n<p>比如，我想通过 ASM 实现统计一个方法的执行时间，该怎么做呢？一般会有如下的代码：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.lijiankun24.classpractice;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Demo</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">costTime</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// ......</span></span><br><span class=\"line\">        <span class=\"built_in\">long</span> duration = System.currentTimeMillis() - startTime;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">&quot;The cost time of this method is &quot;</span> + duration + <span class=\"string\">&quot; ms&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那上面这段代码对应的 ASM 代码是什么呢？我们可以通过以下两个步骤，使用 ASMifier 自动生成：</p>\n<ol>\n<li>通过 <code>javac</code> 编译该 <code>Demo.java</code> 文件生成对应的 <code>Demo.class</code> 文件，如下所示</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac Demo<span class=\"selector-class\">.java</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>通过 ASMifier 自动生成对应的 ASM 代码。首先需要在<a href=\"https://asm.ow2.io/#Q10\">ASM官网</a> 下载 <code>asm-all.jar</code> 库，我下载的是最新的 <code>asm-all-5.2.jar</code>，然后使用如下命令，即可生成</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -classpath asm-all-<span class=\"number\">5.2</span>.jar org.objectweb.asm.util.ASMifier Demo.class</span><br></pre></td></tr></table></figure>\n\n<p>截图如下：</p>\n<p><img src=\"/images/4179925-0cc8712718f08ea0.webp\" alt=\"img\"></p>\n<p>DemoDump.png</p>\n<p><a href=\"https://my.oschina.net/ta8210/blog/163550\">深入字节码 – 玩转 ASM-Bytecode 原 荐</a><br> <a href=\"http://www.easemob.com/news/729\">美团热更方案ASM实践</a></p>\n<p>43人点赞</p>\n<p><a href=\"\">Java 相关</a></p>\n<p>作者：lijiankun24<br>链接：<a href=\"https://www.jianshu.com/p/905be2a9a700\">https://www.jianshu.com/p/905be2a9a700</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://www.jianshu.com/p/905be2a9a700\">原文</a></p>\n</blockquote>\n<p>前面几篇文章介绍了 .class 文件的结构、JVM 如何加载 .class 文件、JVM 中如何执行方法的调用和访问者模式，其实前面几篇文章都是为这篇文章做铺垫的，如果不知道 .class 文件结构、也不知道在 JVM 中 .class 文件中的方法是如何被执行的，这篇文章中的有些部分可能会看不懂，所以推荐先看下前面几篇文章。<br> 这篇文章主要介绍 ASM 库的结构、主要的 API，并且通过两个示例说明如何通过 ASM 修改 .class 文件中的方法和属性。</p>\n<p><img src=\"/images/ezgif-6-73b502b11e16.jpg\" alt=\"img\"></p>\n<p>catalog.png</p>\n<h3 id=\"一-ASM-的结构\"><a href=\"#一-ASM-的结构\" class=\"headerlink\" title=\"一. ASM 的结构\"></a>一. ASM 的结构</h3><p>ASM 库是一款基于 Java 字节码层面的代码分析和修改工具。ASM 可以直接生产二进制的 class 文件，也可以在类被加载入 JVM 之前动态修改类行为。<br> ASM 库的结构如下所示：</p>\n<p><img src=\"/images/4179925-d4f950ec94a12cde.webp\" alt=\"img\"></p>\n<p>asm_arch.png</p>\n<ul>\n<li>Core：为其他包提供基础的读、写、转化Java字节码和定义的API，并且可以生成Java字节码和实现大部分字节码的转换，在 <a href=\"https://www.jianshu.com/p/e4b8cb0b3204\">访问者模式和 ASM</a> 中介绍的几个重要的类就在 Core API 中：ClassReader、ClassVisitor 和 ClassWriter 类.</li>\n<li>Tree：提供了 Java 字节码在内存中的表现</li>\n<li>Commons：提供了一些常用的简化字节码生成、转换的类和适配器</li>\n<li>Util：包含一些帮助类和简单的字节码修改类，有利于在开发或者测试中使用</li>\n<li>XML：提供一个适配器将XML和SAX-comliant转化成字节码结构，可以允许使用XSLT去定义字节码转化</li>\n</ul>\n<h3 id=\"二-Core-API-介绍\"><a href=\"#二-Core-API-介绍\" class=\"headerlink\" title=\"二. Core API 介绍\"></a>二. Core API 介绍</h3><h4 id=\"2-1-ClassVisitor-抽象类\"><a href=\"#2-1-ClassVisitor-抽象类\" class=\"headerlink\" title=\"2.1 ClassVisitor 抽象类\"></a>2.1 ClassVisitor 抽象类</h4><p>如下所示，在 ClassVisitor 中提供了和类结构同名的一些方法，这些方法会对类中相应的部分进行操作，而且是有顺序的：visit [ visitSource ] [ visitOuterClass ] ( visitAnnotation | visitAttribute )* (visitInnerClass | visitField | visitMethod )* visitEnd</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassVisitor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visit</span><span class=\"params\">(<span class=\"type\">int</span> version, <span class=\"type\">int</span> access, String name, String signature, String superName, String[] interfaces)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitSource</span><span class=\"params\">(String source, String debug)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitOuterClass</span><span class=\"params\">(String owner, String name, String desc)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> AnnotationVisitor <span class=\"title function_\">visitAnnotation</span><span class=\"params\">(String desc, <span class=\"type\">boolean</span> visible)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> AnnotationVisitor <span class=\"title function_\">visitTypeAnnotation</span><span class=\"params\">(<span class=\"type\">int</span> typeRef, TypePath typePath, String desc, <span class=\"type\">boolean</span> visible)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitAttribute</span><span class=\"params\">(Attribute attr)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitInnerClass</span><span class=\"params\">(String name, String outerName, String innerName, <span class=\"type\">int</span> access)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> FieldVisitor <span class=\"title function_\">visitField</span><span class=\"params\">(<span class=\"type\">int</span> access, String name, String desc, String signature, Object value)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> MethodVisitor <span class=\"title function_\">visitMethod</span><span class=\"params\">(<span class=\"type\">int</span> access, String name, String desc, String signature, String[] exceptions)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitEnd</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>void visit(int version, int access, String name, String signature, String superName, String[] interfaces)<br> 该方法是当扫描类时第一个调用的方法，主要用于类声明使用。下面是对方法中各个参数的示意：visit( 类版本 , 修饰符 , 类名 , 泛型信息 , 继承的父类 , 实现的接口)</li>\n<li>AnnotationVisitor visitAnnotation(String desc, boolean visible)<br> 该方法是当扫描器扫描到类注解声明时进行调用。下面是对方法中各个参数的示意：visitAnnotation(注解类型 , 注解是否可以在 JVM 中可见)。</li>\n<li>FieldVisitor visitField(int access, String name, String desc, String signature, Object value)<br> 该方法是当扫描器扫描到类中字段时进行调用。下面是对方法中各个参数的示意：visitField(修饰符 , 字段名 , 字段类型 , 泛型描述 , 默认值)</li>\n<li>MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions)<br> 该方法是当扫描器扫描到类的方法时进行调用。下面是对方法中各个参数的示意：visitMethod(修饰符 , 方法名 , 方法签名 , 泛型信息 , 抛出的异常)</li>\n<li>void visitEnd()<br> 该方法是当扫描器完成类扫描时才会调用，如果想在类中追加某些方法</li>\n</ol>\n<h4 id=\"2-2-ClassReader-类\"><a href=\"#2-2-ClassReader-类\" class=\"headerlink\" title=\"2.2 ClassReader 类\"></a>2.2 ClassReader 类</h4><p>这个类会将 .class 文件读入到 ClassReader 中的字节数组中，它的 accept 方法接受一个 ClassVisitor 实现类，并按照顺序调用 ClassVisitor 中的方法</p>\n<h4 id=\"2-3-ClassWriter-类\"><a href=\"#2-3-ClassWriter-类\" class=\"headerlink\" title=\"2.3 ClassWriter 类\"></a>2.3 ClassWriter 类</h4><p>ClassWriter 是一个 ClassVisitor 的子类，是和 ClassReader 对应的类，ClassReader 是将 .class 文件读入到一个字节数组中，ClassWriter 是将修改后的类的字节码内容以字节数组的形式输出。</p>\n<h4 id=\"2-4-MethodVisitor-amp-AdviceAdapter\"><a href=\"#2-4-MethodVisitor-amp-AdviceAdapter\" class=\"headerlink\" title=\"2.4 MethodVisitor &amp; AdviceAdapter\"></a>2.4 MethodVisitor &amp; AdviceAdapter</h4><p>MethodVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Method 时就转入 MethodVisitor 接口处理。<br> AdviceAdapter 是 MethodVisitor 的子类，使用 AdviceAdapter 可以更方便的修改方法的字节码。<br> AdviceAdapter 的方法如下所示：</p>\n<p><img src=\"/images/4179925-f5a428b729962860.webp\" alt=\"img\"></p>\n<p>AdviceAdapter.png</p>\n<p>其中比较重要的几个方法如下：</p>\n<ol>\n<li>void visitCode()：表示 ASM 开始扫描这个方法</li>\n<li>void onMethodEnter()：进入这个方法</li>\n<li>void onMethodExit()：即将从这个方法出去</li>\n<li>void onVisitEnd()：表示方法扫码完毕</li>\n</ol>\n<h4 id=\"2-5-FieldVisitor-抽象类\"><a href=\"#2-5-FieldVisitor-抽象类\" class=\"headerlink\" title=\"2.5 FieldVisitor 抽象类\"></a>2.5 FieldVisitor 抽象类</h4><p>FieldVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Field 时就转入 FieldVisitor 接口处理。和分析 MethodVisitor 的方法一样，也可以查看源码注释进行学习，这里不再详细介绍</p>\n<h4 id=\"2-6-操作流程\"><a href=\"#2-6-操作流程\" class=\"headerlink\" title=\"2.6 操作流程\"></a>2.6 操作流程</h4><ol>\n<li>需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中</li>\n<li>然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写</li>\n<li>需要事件过滤器 ClassVisitor。在调用 ClassVisitor 的某些方法时会产生一个新的 XXXVisitor 对象，当我们需要修改对应的内容时只要实现自己的 XXXVisitor 并返回就可以了</li>\n</ol>\n<h3 id=\"三-示例\"><a href=\"#三-示例\" class=\"headerlink\" title=\"三. 示例\"></a>三. 示例</h3><h4 id=\"3-1-修改类中方法的字节码\"><a href=\"#3-1-修改类中方法的字节码\" class=\"headerlink\" title=\"3.1 修改类中方法的字节码\"></a>3.1 修改类中方法的字节码</h4><p>假如现在我们有一个 HelloWorld 类，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.lijiankun24.asmpractice.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>javac HelloWorld.java</code> 和 <code>javap -verbose HelloWorld.class</code> 可以查看到 sayName() 方法的字节码如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  descriptor: ()V</span><br><span class=\"line\">  flags: ACC_PUBLIC</span><br><span class=\"line\">  Code:</span><br><span class=\"line\">    stack=<span class=\"number\">2</span>, locals=<span class=\"number\">2</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">       <span class=\"number\">0</span>: ldc2_w        #<span class=\"number\">2</span>                  <span class=\"comment\">// long 2000l</span></span><br><span class=\"line\">       <span class=\"number\">3</span>: invokestatic  #<span class=\"number\">4</span>                  <span class=\"comment\">// Method java/lang/Thread.sleep:(J)V</span></span><br><span class=\"line\">       <span class=\"number\">6</span>: <span class=\"keyword\">goto</span>          <span class=\"number\">14</span></span><br><span class=\"line\">       <span class=\"number\">9</span>: astore_1</span><br><span class=\"line\">      <span class=\"number\">10</span>: aload_1</span><br><span class=\"line\">      <span class=\"number\">11</span>: invokevirtual #<span class=\"number\">6</span>                  <span class=\"comment\">// Method java/lang/InterruptedException.printStackTrace:()V</span></span><br><span class=\"line\">      <span class=\"number\">14</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">    Exception table:</span><br><span class=\"line\">       from    to  target type</span><br><span class=\"line\">           <span class=\"number\">0</span>     <span class=\"number\">6</span>     <span class=\"number\">9</span>   Class java/lang/InterruptedException</span><br><span class=\"line\">    LineNumberTable:</span><br><span class=\"line\">      line <span class=\"number\">5</span>: <span class=\"number\">0</span></span><br><span class=\"line\">      line <span class=\"number\">8</span>: <span class=\"number\">6</span></span><br><span class=\"line\">      line <span class=\"number\">6</span>: <span class=\"number\">9</span></span><br><span class=\"line\">      line <span class=\"number\">7</span>: <span class=\"number\">10</span></span><br><span class=\"line\">      line <span class=\"number\">9</span>: <span class=\"number\">14</span></span><br><span class=\"line\">    StackMapTable: number_of_entries = <span class=\"number\">2</span></span><br><span class=\"line\">      frame_type = <span class=\"number\">73</span> <span class=\"comment\">/* same_locals_1_stack_item */</span></span><br><span class=\"line\">        stack = [ <span class=\"keyword\">class</span> java/lang/InterruptedException ]</span><br><span class=\"line\">      frame_type = <span class=\"number\">4</span> <span class=\"comment\">/* same */</span></span><br></pre></td></tr></table></figure>\n\n<p>我们通过 ASM 修改 HelloWorld.class 字节码文件，实现统计方法执行时间的功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CostTime</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        redefinePersonClass();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">redefinePersonClass</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">className</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;com.lijiankun24.asmpractice.demo.HelloWorld&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;/Users/lijiankun/Desktop/HelloWorld.class&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">ClassReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassReader</span>(inputStream);                               <span class=\"comment\">// 1. 创建 ClassReader 读入 .class 文件到内存中</span></span><br><span class=\"line\">            <span class=\"type\">ClassWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassWriter</span>(reader, ClassWriter.COMPUTE_MAXS);                 <span class=\"comment\">// 2. 创建 ClassWriter 对象，将操作之后的字节码的字节数组回写</span></span><br><span class=\"line\">            <span class=\"type\">ClassVisitor</span> <span class=\"variable\">change</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ChangeVisitor</span>(writer);                                        <span class=\"comment\">// 3. 创建自定义的 ClassVisitor 对象</span></span><br><span class=\"line\">            reader.accept(change, ClassReader.EXPAND_FRAMES);                                       <span class=\"comment\">// 4. 将 ClassVisitor 对象传入 ClassReader 中</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyClassLoader</span>().defineClass(className, writer.toByteArray());</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">personObj</span> <span class=\"operator\">=</span> clazz.newInstance();</span><br><span class=\"line\">            <span class=\"type\">Method</span> <span class=\"variable\">nameMethod</span> <span class=\"operator\">=</span> clazz.getDeclaredMethod(<span class=\"string\">&quot;sayHello&quot;</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">            nameMethod.invoke(personObj, <span class=\"literal\">null</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Success!&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">byte</span>[] code = writer.toByteArray();                                                               <span class=\"comment\">// 获取修改后的 class 文件对应的字节数组</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">FileOutputStream</span> <span class=\"variable\">fos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"string\">&quot;/Users/lijiankun/Desktop/HelloWorld2.class&quot;</span>);    <span class=\"comment\">// 将二进制流写到本地磁盘上</span></span><br><span class=\"line\">                fos.write(code);</span><br><span class=\"line\">                fos.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Failure!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChangeVisitor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassVisitor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ChangeVisitor(ClassVisitor classVisitor) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(Opcodes.ASM5, classVisitor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> MethodVisitor <span class=\"title function_\">visitMethod</span><span class=\"params\">(<span class=\"type\">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">MethodVisitor</span> <span class=\"variable\">methodVisitor</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (name.equals(<span class=\"string\">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> methodVisitor;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ChangeAdapter</span>(Opcodes.ASM4, methodVisitor, access, name, desc);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChangeAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AdviceAdapter</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">startTimeId</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        ChangeAdapter(<span class=\"type\">int</span> api, MethodVisitor mv, <span class=\"type\">int</span> access, String name, String desc) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(api, mv, access, name, desc);</span><br><span class=\"line\">            methodName = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onMethodEnter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.onMethodEnter();</span><br><span class=\"line\">            startTimeId = newLocal(Type.LONG_TYPE);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKESTATIC, <span class=\"string\">&quot;java/lang/System&quot;</span>, <span class=\"string\">&quot;currentTimeMillis&quot;</span>, <span class=\"string\">&quot;()J&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            mv.visitIntInsn(LSTORE, startTimeId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onMethodExit</span><span class=\"params\">(<span class=\"type\">int</span> opcode)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.onMethodExit(opcode);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">durationId</span> <span class=\"operator\">=</span> newLocal(Type.LONG_TYPE);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKESTATIC, <span class=\"string\">&quot;java/lang/System&quot;</span>, <span class=\"string\">&quot;currentTimeMillis&quot;</span>, <span class=\"string\">&quot;()J&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            mv.visitVarInsn(LLOAD, startTimeId);</span><br><span class=\"line\">            mv.visitInsn(LSUB);</span><br><span class=\"line\">            mv.visitVarInsn(LSTORE, durationId);</span><br><span class=\"line\">            mv.visitFieldInsn(GETSTATIC, <span class=\"string\">&quot;java/lang/System&quot;</span>, <span class=\"string\">&quot;out&quot;</span>, <span class=\"string\">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class=\"line\">            mv.visitTypeInsn(NEW, <span class=\"string\">&quot;java/lang/StringBuilder&quot;</span>);</span><br><span class=\"line\">            mv.visitInsn(DUP);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKESPECIAL, <span class=\"string\">&quot;java/lang/StringBuilder&quot;</span>, <span class=\"string\">&quot;&lt;init&gt;&quot;</span>, <span class=\"string\">&quot;()V&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            mv.visitLdcInsn(<span class=\"string\">&quot;The cost time of &quot;</span> + methodName + <span class=\"string\">&quot; is &quot;</span>);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class=\"string\">&quot;java/lang/StringBuilder&quot;</span>, <span class=\"string\">&quot;append&quot;</span>, <span class=\"string\">&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            mv.visitVarInsn(LLOAD, durationId);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class=\"string\">&quot;java/lang/StringBuilder&quot;</span>, <span class=\"string\">&quot;append&quot;</span>, <span class=\"string\">&quot;(J)Ljava/lang/StringBuilder;&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class=\"string\">&quot;java/lang/StringBuilder&quot;</span>, <span class=\"string\">&quot;toString&quot;</span>, <span class=\"string\">&quot;()Ljava/lang/String;&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class=\"string\">&quot;java/io/PrintStream&quot;</span>, <span class=\"string\">&quot;println&quot;</span>, <span class=\"string\">&quot;(Ljava/lang/String;)V&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果如下图所示</p>\n<p><img src=\"/images/4179925-32ee7bd0974a4679.webp\" alt=\"img\"></p>\n<p>Class.png</p>\n<p>反编译 HelloWorld2.class 文件的内容如下所示</p>\n<p><img src=\"/images/4179925-af582100631d7eec.webp\" alt=\"img\"></p>\n<p>Class1.png</p>\n<h4 id=\"3-2-修改类中属性的字节码\"><a href=\"#3-2-修改类中属性的字节码\" class=\"headerlink\" title=\"3.2 修改类中属性的字节码\"></a>3.2 修改类中属性的字节码</h4><p>这一节中我们将展示一下如何使用 Core API 对类中的属性进行操作。</p>\n<p>假如说，现在有一个 Person.java 类如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> sex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们想为这个类，添加一个 ‘public int age’ 的属性该怎么添加呢？我们会面对两个问题：</p>\n<ol>\n<li>该调用 ASM 的哪个 API 添加属性呢？</li>\n<li>在何时写添加属性的代码？</li>\n</ol>\n<p>接下来，我们就一一解决上面的两个问题？</p>\n<h5 id=\"3-2-1-添加属性的-API\"><a href=\"#3-2-1-添加属性的-API\" class=\"headerlink\" title=\"3.2.1 添加属性的 API\"></a>3.2.1 添加属性的 API</h5><p>按照我们分析的上述的 2.6 操作流程叙述，需要以下三个步骤：</p>\n<ol>\n<li>需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中</li>\n<li>然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写</li>\n<li>需要创建一个事件过滤器 ClassVisitor。事件过滤器中的某些方法可以产生一个新的XXXVisitor对象，当我们需要修改对应的内容时只要实现自己的XXXVisitor并返回就可以了</li>\n</ol>\n<p>在上面三个步骤中，可以操作的就是 ClassVisitor 了。ClassVisitor 接口提供了和类结构同名的一些方法，这些方法可以对相应的类结构进行操作。</p>\n<p>在使用 ClassVisitor 添加类属性的时候，只需要添加一句话就可以了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classVisitor.visitField(Opcodes.ACC_PUBLIC, <span class=\"string\">&quot;age&quot;</span>, Type.getDescriptor(<span class=\"type\">int</span>.class), <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/4179925-8c703df0b005aae7.webp\" alt=\"img\"></p>\n<p>visitField.png</p>\n<h5 id=\"3-2-2-添加属性的时机\"><a href=\"#3-2-2-添加属性的时机\" class=\"headerlink\" title=\"3.2.2 添加属性的时机\"></a>3.2.2 添加属性的时机</h5><p>我们先暂且在 ClassVisitor 的 visitEnd() 方法中写入上面的代码，如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Transform</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassVisitor</span> &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Transform</span><span class=\"params\">(ClassVisitor cv)</span> &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">super</span>(cv);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitEnd</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        cv.visitField(Opcodes.ACC_PUBLIC, <span class=\"string\">&quot;age&quot;</span>, Type.getDescriptor(<span class=\"type\">int</span>.class), <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们写如下的测试类，测试一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FieldPractice</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        addAgeField();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addAgeField</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;/Users/lijiankun/Desktop/Person.class&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">ClassReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassReader</span>(inputStream);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">ClassWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassWriter</span>(ClassWriter.COMPUTE_MAXS);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">ClassVisitor</span> <span class=\"variable\">visitor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Transform</span>(writer);</span><br><span class=\"line\">            reader.accept(visitor, ClassReader.SKIP_DEBUG);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">byte</span>[] classFile = writer.toByteArray();</span><br><span class=\"line\">            <span class=\"type\">MyClassLoader</span> <span class=\"variable\">classLoader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyClassLoader</span>();</span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> classLoader.defineClass(<span class=\"string\">&quot;Person&quot;</span>, classFile);</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> clazz.newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(clazz.getDeclaredField(<span class=\"string\">&quot;name&quot;</span>).get(obj)); <span class=\"comment\">//----(1)</span></span><br><span class=\"line\">            System.out.println(clazz.getDeclaredField(<span class=\"string\">&quot;age&quot;</span>).get(obj));  <span class=\"comment\">//----(2)</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其输出入下所示：</p>\n<p><img src=\"/images/4179925-a718d240e05a2198.webp\" alt=\"img\"></p>\n<p>visitFieldResult.png</p>\n<p>那如果我们尝试在 ClassVisitor#visitField() 方法中添加属性可以吗？我们可以修改 Transform 测试一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Transform</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassVisitor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Transform(ClassVisitor classVisitor) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(Opcodes.ASM5, classVisitor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> FieldVisitor <span class=\"title function_\">visitField</span><span class=\"params\">(<span class=\"type\">int</span> access, String name, String desc, String signature, Object value)</span> &#123;</span><br><span class=\"line\">        cv.visitField(Opcodes.ACC_PUBLIC, <span class=\"string\">&quot;age&quot;</span>, Type.getDescriptor(<span class=\"type\">int</span>.class), <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.visitField(access, name, desc, signature, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还是使用上面的测试代码测试一下，会有如下的测试结果</p>\n<p><img src=\"/images/4179925-e2e730e41623be28.webp\" alt=\"img\"></p>\n<p>visitFieldError.png</p>\n<p>在 Person 类中有重复的属性，为什么会报这个错误呢？</p>\n<p>分析 ClassVisitor#visitField() 方法可得知，只要访问类中的一个属性，visitField() 方法就会被调用一次，在 Person 类中有两个属性，所以 visitField() 方法就会被调用两次，也就添加了两次 ‘public int age’ 属性，就报了上述的错误，而 visitEnd() 方法只有在最后才会被调用且只调用一次，所以在 visitEnd() 方法中是添加属性的最佳时机</p>\n<h4 id=\"3-3-ASMifier\"><a href=\"#3-3-ASMifier\" class=\"headerlink\" title=\"3.3 ASMifier\"></a>3.3 ASMifier</h4><p>可能有人会问，我刚开始学，上面例子中那些 ASM 的代码我还不会写，怎么办呢？ASM 官方为我们提供了 <a href=\"https://asm.ow2.io/#Q10\">ASMifier</a>，可以帮助我们生成这些晦涩难懂的 ASM 代码。</p>\n<p>比如，我想通过 ASM 实现统计一个方法的执行时间，该怎么做呢？一般会有如下的代码：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.lijiankun24.classpractice;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Demo</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">costTime</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"comment\">// ......</span></span><br><span class=\"line\">        <span class=\"built_in\">long</span> duration = System.currentTimeMillis() - startTime;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">&quot;The cost time of this method is &quot;</span> + duration + <span class=\"string\">&quot; ms&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那上面这段代码对应的 ASM 代码是什么呢？我们可以通过以下两个步骤，使用 ASMifier 自动生成：</p>\n<ol>\n<li>通过 <code>javac</code> 编译该 <code>Demo.java</code> 文件生成对应的 <code>Demo.class</code> 文件，如下所示</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac Demo<span class=\"selector-class\">.java</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>通过 ASMifier 自动生成对应的 ASM 代码。首先需要在<a href=\"https://asm.ow2.io/#Q10\">ASM官网</a> 下载 <code>asm-all.jar</code> 库，我下载的是最新的 <code>asm-all-5.2.jar</code>，然后使用如下命令，即可生成</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -classpath asm-all-<span class=\"number\">5.2</span>.jar org.objectweb.asm.util.ASMifier Demo.class</span><br></pre></td></tr></table></figure>\n\n<p>截图如下：</p>\n<p><img src=\"/images/4179925-0cc8712718f08ea0.webp\" alt=\"img\"></p>\n<p>DemoDump.png</p>\n<p><a href=\"https://my.oschina.net/ta8210/blog/163550\">深入字节码 – 玩转 ASM-Bytecode 原 荐</a><br> <a href=\"http://www.easemob.com/news/729\">美团热更方案ASM实践</a></p>\n<p>43人点赞</p>\n<p><a href=\"\">Java 相关</a></p>\n<p>作者：lijiankun24<br>链接：<a href=\"https://www.jianshu.com/p/905be2a9a700\">https://www.jianshu.com/p/905be2a9a700</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n"},{"layout":"post","title":"Activity启动流程","author":"boybeak","_content":"\n\n原文参考：[Activity 启动流程分析(Android10)](https://zhuanlan.zhihu.com/p/150283395)\n\n```mermaid\ngraph TD;\nA(启动Activity) --> B[通过Binder调用AMS的startActivity方法] --> C[通过Intent获取到目标Activity] --> D{目标Activity是否启动} --> |是|E[通过Instrumentation创建Activity] --> F[回调Activity#attach] --> G[回调Activity#onCreate] --> H[准备显示Activity] --> I[Activity#onResume];\nD --> |否|J[通过Zygote进程fork一个App进程]:::zygote --> K[创建Application并回调Application#onCreate]:::zygote --> L[启动ActivityThread主线程消息队列]:::zygote --> E;\nF --> M[创建Window对象并设置Window.Callback接收事件]:::wms;\nG --> N[Activity#setContentView] --> O[Window#setContentView]:::wms;\nH --> P[Window#addView]:::wms;\nclassDef wms fill:#aaffff\nclassDef zygote fill:#ffaa99\n```\n\n途中浅蓝色部分为WMS关联部分，橙色部分为目标App未启动情况下的流程。\n\n## Intent 解析到 Activity\n\n调用 startActivity 之后，经过几步辗转最终会调用到 **AMS** 中，而 AMS 又会调用 ActivityStarter 来启动 Activity。\n解析 Intent 的任务将由`PackageManagerService#resolveIntent`方法来处理。\nIntent 匹配规则太负责了，我本意是想学习启动流程，所以就没深入进去看代码，就这样吧。","source":"_posts/2022-09-19-Activity启动流程.md","raw":"---\nlayout: post\ntitle: Activity启动流程\nauthor: boybeak\ncategory: Android技巧\ntags: Android\n---\n\n\n原文参考：[Activity 启动流程分析(Android10)](https://zhuanlan.zhihu.com/p/150283395)\n\n```mermaid\ngraph TD;\nA(启动Activity) --> B[通过Binder调用AMS的startActivity方法] --> C[通过Intent获取到目标Activity] --> D{目标Activity是否启动} --> |是|E[通过Instrumentation创建Activity] --> F[回调Activity#attach] --> G[回调Activity#onCreate] --> H[准备显示Activity] --> I[Activity#onResume];\nD --> |否|J[通过Zygote进程fork一个App进程]:::zygote --> K[创建Application并回调Application#onCreate]:::zygote --> L[启动ActivityThread主线程消息队列]:::zygote --> E;\nF --> M[创建Window对象并设置Window.Callback接收事件]:::wms;\nG --> N[Activity#setContentView] --> O[Window#setContentView]:::wms;\nH --> P[Window#addView]:::wms;\nclassDef wms fill:#aaffff\nclassDef zygote fill:#ffaa99\n```\n\n途中浅蓝色部分为WMS关联部分，橙色部分为目标App未启动情况下的流程。\n\n## Intent 解析到 Activity\n\n调用 startActivity 之后，经过几步辗转最终会调用到 **AMS** 中，而 AMS 又会调用 ActivityStarter 来启动 Activity。\n解析 Intent 的任务将由`PackageManagerService#resolveIntent`方法来处理。\nIntent 匹配规则太负责了，我本意是想学习启动流程，所以就没深入进去看代码，就这样吧。","slug":"2022-09-19-Activity启动流程","published":1,"date":"2020-10-22T07:22:35.000Z","updated":"2022-09-19T01:34:35.313Z","comments":1,"photos":[],"link":"","_id":"cldqukh8w000upcjgdztd9rgd","content":"<p>原文参考：<a href=\"https://zhuanlan.zhihu.com/p/150283395\">Activity 启动流程分析(Android10)</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">A(启动Activity) --&gt; B[通过Binder调用AMS的startActivity方法] --&gt; C[通过Intent获取到目标Activity] --&gt; D&#123;目标Activity是否启动&#125; --&gt; |是|E[通过Instrumentation创建Activity] --&gt; F[回调Activity#attach] --&gt; G[回调Activity#onCreate] --&gt; H[准备显示Activity] --&gt; I[Activity#onResume];</span><br><span class=\"line\">D --&gt; |否|J[通过Zygote进程fork一个App进程]:::zygote --&gt; K[创建Application并回调Application#onCreate]:::zygote --&gt; L[启动ActivityThread主线程消息队列]:::zygote --&gt; E;</span><br><span class=\"line\">F --&gt; M[创建Window对象并设置Window.Callback接收事件]:::wms;</span><br><span class=\"line\">G --&gt; N[Activity#setContentView] --&gt; O[Window#setContentView]:::wms;</span><br><span class=\"line\">H --&gt; P[Window#addView]:::wms;</span><br><span class=\"line\">classDef wms fill:#aaffff</span><br><span class=\"line\">classDef zygote fill:#ffaa99</span><br></pre></td></tr></table></figure>\n\n<p>途中浅蓝色部分为WMS关联部分，橙色部分为目标App未启动情况下的流程。</p>\n<h2 id=\"Intent-解析到-Activity\"><a href=\"#Intent-解析到-Activity\" class=\"headerlink\" title=\"Intent 解析到 Activity\"></a>Intent 解析到 Activity</h2><p>调用 startActivity 之后，经过几步辗转最终会调用到 <strong>AMS</strong> 中，而 AMS 又会调用 ActivityStarter 来启动 Activity。<br>解析 Intent 的任务将由<code>PackageManagerService#resolveIntent</code>方法来处理。<br>Intent 匹配规则太负责了，我本意是想学习启动流程，所以就没深入进去看代码，就这样吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文参考：<a href=\"https://zhuanlan.zhihu.com/p/150283395\">Activity 启动流程分析(Android10)</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">A(启动Activity) --&gt; B[通过Binder调用AMS的startActivity方法] --&gt; C[通过Intent获取到目标Activity] --&gt; D&#123;目标Activity是否启动&#125; --&gt; |是|E[通过Instrumentation创建Activity] --&gt; F[回调Activity#attach] --&gt; G[回调Activity#onCreate] --&gt; H[准备显示Activity] --&gt; I[Activity#onResume];</span><br><span class=\"line\">D --&gt; |否|J[通过Zygote进程fork一个App进程]:::zygote --&gt; K[创建Application并回调Application#onCreate]:::zygote --&gt; L[启动ActivityThread主线程消息队列]:::zygote --&gt; E;</span><br><span class=\"line\">F --&gt; M[创建Window对象并设置Window.Callback接收事件]:::wms;</span><br><span class=\"line\">G --&gt; N[Activity#setContentView] --&gt; O[Window#setContentView]:::wms;</span><br><span class=\"line\">H --&gt; P[Window#addView]:::wms;</span><br><span class=\"line\">classDef wms fill:#aaffff</span><br><span class=\"line\">classDef zygote fill:#ffaa99</span><br></pre></td></tr></table></figure>\n\n<p>途中浅蓝色部分为WMS关联部分，橙色部分为目标App未启动情况下的流程。</p>\n<h2 id=\"Intent-解析到-Activity\"><a href=\"#Intent-解析到-Activity\" class=\"headerlink\" title=\"Intent 解析到 Activity\"></a>Intent 解析到 Activity</h2><p>调用 startActivity 之后，经过几步辗转最终会调用到 <strong>AMS</strong> 中，而 AMS 又会调用 ActivityStarter 来启动 Activity。<br>解析 Intent 的任务将由<code>PackageManagerService#resolveIntent</code>方法来处理。<br>Intent 匹配规则太负责了，我本意是想学习启动流程，所以就没深入进去看代码，就这样吧。</p>\n"},{"layout":"post","title":"Apk瘦身术","author":"boybeak","_content":"\n\nApk瘦身主要从三方面入手：资源文件、源代码和第三方类库。\n\n## 一、资源文件\n\n### 1.1 删除无用资源文件\n\n#### 1.1.1 Lint工具\n\n菜单 -> Analyze -> Run Inspection by Name，然后输入Unused resources便可以执行查找无用资源文件。自己根据需要进行删除。\n\n#### 1.1.2 shrinkResources\n\n```groovy\nbuildTypes {\n  release {\n    // 不显示Log\n    buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\"\n    //混淆\n    minifyEnabled true\n    // 移除无用的resource文件\n    shrinkResources true\n    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n    signingConfig signingConfigs.release\n  }\n}\n```\n\n使用shrinkResources的前提是，打开混淆minifyEnabled，建议只在release版本开启，不然会使得编译速度变慢。\n\n\n\n### 1.2 图标类资源图片矢量化\n\n对于图标类资源，可以选择用vector-drawable来代替，通过AndroidStudio自带的转换工具可以将svg文件转换为vector-drawable文件。\n\n> 具体操作为，在drawable相关文件夹上右键 -> New -> Vector Assert。\n\n你也可以进行批量转换：[工具地址](https://github.com/vdmeer/svg2vector)\n\n\n\n### 1.3 非图标类资源图片适当压缩与格式选择\n\n#### 1.3.1 使用tinypng有损压缩png图片\n\n通过[Tinypng](http://tinypng.com)官网上传压缩再下载，在保持alpha通道的情况下对png图片的压缩可达到1/3以内，且肉眼基本看不出差别。\n\n#### 1.3.2 使用jpg格式\n\n对于非透明的大图，jpg会比png的大小和内存都更有优势，虽然不是绝对的，但是通常会减少到一半不止。\n\n#### 1.3.3 使用webp格式\n\nwebp格式支持透明度，压缩比比jpg高，但是显示效果却不输于jpg。缺点是在Android端的原生支持不好，从Android4.0+开始原生支持，但是不支持透明度，从Android4.3+开始支持带有透明度的webp。如果不需要兼容到这个版本，可以直接使用。\n\n在Android studio中，在图片资源上右键可以转换为webp。详细参见[创建 WebP 图片](https://developer.android.com/studio/write/convert-webp)。\n\n#### 1.3.4 适当的压缩和尺寸\n\n无论以上哪种格式图片，都可以通过选择合适的尺寸和适当的提高压缩率的方式，来进一步减少文件大小，进而减小apk文件的体积。\n\n#### 1.3.5 帧动画尽可能使用lottie\n\n[Lottie](https://github.com/airbnb/lottie-android)是Aribnb开源的动画库，通过json文件来进行展示动画，动画文件可以通过Adobe AE来制作。\n\n \n\n### 1.4 有限国际化\n\n```groovy\nandroid {\n  defaultConfig {\n    resConfigs \"zh\"\n  }\n}\n```\n\n### 1.5 第三方库中大尺寸的无用资源同名替换\n\n如果在第三方类库中，存在用不到的图片资源文件，可以通过1x1像素的同名图片进行替换。\n\n\n\n### 1.6 使用AndResGuard\n\n[AndResGuard](https://github.com/shwenzhang/AndResGuard)，在gradle文件中就可以直接使用，非常方便。\n\n\n\n## 二、源代码\n\n### 2.1 开启混淆\n\n这是基本操作了，无需多言。\n\n### 2.2 手动修改开源代码\n\n将开源代码中我们不需要的类或者方法等删除掉，但是这需要对开源代码非常了解，而且确保版本兼容性，将来开源库升级或者随着我们产品需求变更对开源库的要求也改变了，都会影响对开源库的修改，不建议使用。\n\n## 三、第三方类库\n\n### 3.1 动态库\n\n#### 3.1.1 删除非必要平台so库\n\n```groovy\nndk {\n  //设置支持的so库架构\n  abiFilters \"armeabi-v7a\"\n}\n```\n\n基本上，对于手机来说，支持armeabi-v7a就足够了。\n\n#### 3.1.2 动态加载so库\n\n如果不是一启动应用就需要初始化的so库，完全可以在需要的时候再下载这个so文件，再通过以下代码进行加载。\n\n```java\nstatic {\n  System.loadLibrary(\"path/to/lib.so\");\n}\n```\n\n\n\n## 其他\n\n### 插件化\n\n将不需要在启动就加载的功能模块，通过插件化，在用户使用的时候再从服务器加载。\n\n### 删除class文件的debug items\n\n不建议使用，这种做法，事倍功半。\n\n","source":"_posts/2022-09-19-Apk瘦身术.md","raw":"---\nlayout: post\ntitle: Apk瘦身术\nauthor: boybeak\ncategory: Android技巧\ntags: Android\n---\n\n\nApk瘦身主要从三方面入手：资源文件、源代码和第三方类库。\n\n## 一、资源文件\n\n### 1.1 删除无用资源文件\n\n#### 1.1.1 Lint工具\n\n菜单 -> Analyze -> Run Inspection by Name，然后输入Unused resources便可以执行查找无用资源文件。自己根据需要进行删除。\n\n#### 1.1.2 shrinkResources\n\n```groovy\nbuildTypes {\n  release {\n    // 不显示Log\n    buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\"\n    //混淆\n    minifyEnabled true\n    // 移除无用的resource文件\n    shrinkResources true\n    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n    signingConfig signingConfigs.release\n  }\n}\n```\n\n使用shrinkResources的前提是，打开混淆minifyEnabled，建议只在release版本开启，不然会使得编译速度变慢。\n\n\n\n### 1.2 图标类资源图片矢量化\n\n对于图标类资源，可以选择用vector-drawable来代替，通过AndroidStudio自带的转换工具可以将svg文件转换为vector-drawable文件。\n\n> 具体操作为，在drawable相关文件夹上右键 -> New -> Vector Assert。\n\n你也可以进行批量转换：[工具地址](https://github.com/vdmeer/svg2vector)\n\n\n\n### 1.3 非图标类资源图片适当压缩与格式选择\n\n#### 1.3.1 使用tinypng有损压缩png图片\n\n通过[Tinypng](http://tinypng.com)官网上传压缩再下载，在保持alpha通道的情况下对png图片的压缩可达到1/3以内，且肉眼基本看不出差别。\n\n#### 1.3.2 使用jpg格式\n\n对于非透明的大图，jpg会比png的大小和内存都更有优势，虽然不是绝对的，但是通常会减少到一半不止。\n\n#### 1.3.3 使用webp格式\n\nwebp格式支持透明度，压缩比比jpg高，但是显示效果却不输于jpg。缺点是在Android端的原生支持不好，从Android4.0+开始原生支持，但是不支持透明度，从Android4.3+开始支持带有透明度的webp。如果不需要兼容到这个版本，可以直接使用。\n\n在Android studio中，在图片资源上右键可以转换为webp。详细参见[创建 WebP 图片](https://developer.android.com/studio/write/convert-webp)。\n\n#### 1.3.4 适当的压缩和尺寸\n\n无论以上哪种格式图片，都可以通过选择合适的尺寸和适当的提高压缩率的方式，来进一步减少文件大小，进而减小apk文件的体积。\n\n#### 1.3.5 帧动画尽可能使用lottie\n\n[Lottie](https://github.com/airbnb/lottie-android)是Aribnb开源的动画库，通过json文件来进行展示动画，动画文件可以通过Adobe AE来制作。\n\n \n\n### 1.4 有限国际化\n\n```groovy\nandroid {\n  defaultConfig {\n    resConfigs \"zh\"\n  }\n}\n```\n\n### 1.5 第三方库中大尺寸的无用资源同名替换\n\n如果在第三方类库中，存在用不到的图片资源文件，可以通过1x1像素的同名图片进行替换。\n\n\n\n### 1.6 使用AndResGuard\n\n[AndResGuard](https://github.com/shwenzhang/AndResGuard)，在gradle文件中就可以直接使用，非常方便。\n\n\n\n## 二、源代码\n\n### 2.1 开启混淆\n\n这是基本操作了，无需多言。\n\n### 2.2 手动修改开源代码\n\n将开源代码中我们不需要的类或者方法等删除掉，但是这需要对开源代码非常了解，而且确保版本兼容性，将来开源库升级或者随着我们产品需求变更对开源库的要求也改变了，都会影响对开源库的修改，不建议使用。\n\n## 三、第三方类库\n\n### 3.1 动态库\n\n#### 3.1.1 删除非必要平台so库\n\n```groovy\nndk {\n  //设置支持的so库架构\n  abiFilters \"armeabi-v7a\"\n}\n```\n\n基本上，对于手机来说，支持armeabi-v7a就足够了。\n\n#### 3.1.2 动态加载so库\n\n如果不是一启动应用就需要初始化的so库，完全可以在需要的时候再下载这个so文件，再通过以下代码进行加载。\n\n```java\nstatic {\n  System.loadLibrary(\"path/to/lib.so\");\n}\n```\n\n\n\n## 其他\n\n### 插件化\n\n将不需要在启动就加载的功能模块，通过插件化，在用户使用的时候再从服务器加载。\n\n### 删除class文件的debug items\n\n不建议使用，这种做法，事倍功半。\n\n","slug":"2022-09-19-Apk瘦身术","published":1,"date":"2020-12-13T09:58:59.000Z","updated":"2022-09-20T02:14:47.050Z","comments":1,"photos":[],"link":"","_id":"cldqukh8y000xpcjg5u08dsoq","content":"<p>Apk瘦身主要从三方面入手：资源文件、源代码和第三方类库。</p>\n<h2 id=\"一、资源文件\"><a href=\"#一、资源文件\" class=\"headerlink\" title=\"一、资源文件\"></a>一、资源文件</h2><h3 id=\"1-1-删除无用资源文件\"><a href=\"#1-1-删除无用资源文件\" class=\"headerlink\" title=\"1.1 删除无用资源文件\"></a>1.1 删除无用资源文件</h3><h4 id=\"1-1-1-Lint工具\"><a href=\"#1-1-1-Lint工具\" class=\"headerlink\" title=\"1.1.1 Lint工具\"></a>1.1.1 Lint工具</h4><p>菜单 -&gt; Analyze -&gt; Run Inspection by Name，然后输入Unused resources便可以执行查找无用资源文件。自己根据需要进行删除。</p>\n<h4 id=\"1-1-2-shrinkResources\"><a href=\"#1-1-2-shrinkResources\" class=\"headerlink\" title=\"1.1.2 shrinkResources\"></a>1.1.2 shrinkResources</h4><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildTypes &#123;</span><br><span class=\"line\">  release &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不显示Log</span></span><br><span class=\"line\">    buildConfigField <span class=\"string\">&quot;boolean&quot;</span>, <span class=\"string\">&quot;LOG_DEBUG&quot;</span>, <span class=\"string\">&quot;false&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">//混淆</span></span><br><span class=\"line\">    minifyEnabled <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\">// 移除无用的resource文件</span></span><br><span class=\"line\">    shrinkResources <span class=\"literal\">true</span></span><br><span class=\"line\">    proguardFiles getDefaultProguardFile(<span class=\"string\">&#x27;proguard-android.txt&#x27;</span>), <span class=\"string\">&#x27;proguard-rules.pro&#x27;</span></span><br><span class=\"line\">    signingConfig signingConfigs.release</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用shrinkResources的前提是，打开混淆minifyEnabled，建议只在release版本开启，不然会使得编译速度变慢。</p>\n<h3 id=\"1-2-图标类资源图片矢量化\"><a href=\"#1-2-图标类资源图片矢量化\" class=\"headerlink\" title=\"1.2 图标类资源图片矢量化\"></a>1.2 图标类资源图片矢量化</h3><p>对于图标类资源，可以选择用vector-drawable来代替，通过AndroidStudio自带的转换工具可以将svg文件转换为vector-drawable文件。</p>\n<blockquote>\n<p>具体操作为，在drawable相关文件夹上右键 -&gt; New -&gt; Vector Assert。</p>\n</blockquote>\n<p>你也可以进行批量转换：<a href=\"https://github.com/vdmeer/svg2vector\">工具地址</a></p>\n<h3 id=\"1-3-非图标类资源图片适当压缩与格式选择\"><a href=\"#1-3-非图标类资源图片适当压缩与格式选择\" class=\"headerlink\" title=\"1.3 非图标类资源图片适当压缩与格式选择\"></a>1.3 非图标类资源图片适当压缩与格式选择</h3><h4 id=\"1-3-1-使用tinypng有损压缩png图片\"><a href=\"#1-3-1-使用tinypng有损压缩png图片\" class=\"headerlink\" title=\"1.3.1 使用tinypng有损压缩png图片\"></a>1.3.1 使用tinypng有损压缩png图片</h4><p>通过<a href=\"http://tinypng.com/\">Tinypng</a>官网上传压缩再下载，在保持alpha通道的情况下对png图片的压缩可达到1&#x2F;3以内，且肉眼基本看不出差别。</p>\n<h4 id=\"1-3-2-使用jpg格式\"><a href=\"#1-3-2-使用jpg格式\" class=\"headerlink\" title=\"1.3.2 使用jpg格式\"></a>1.3.2 使用jpg格式</h4><p>对于非透明的大图，jpg会比png的大小和内存都更有优势，虽然不是绝对的，但是通常会减少到一半不止。</p>\n<h4 id=\"1-3-3-使用webp格式\"><a href=\"#1-3-3-使用webp格式\" class=\"headerlink\" title=\"1.3.3 使用webp格式\"></a>1.3.3 使用webp格式</h4><p>webp格式支持透明度，压缩比比jpg高，但是显示效果却不输于jpg。缺点是在Android端的原生支持不好，从Android4.0+开始原生支持，但是不支持透明度，从Android4.3+开始支持带有透明度的webp。如果不需要兼容到这个版本，可以直接使用。</p>\n<p>在Android studio中，在图片资源上右键可以转换为webp。详细参见<a href=\"https://developer.android.com/studio/write/convert-webp\">创建 WebP 图片</a>。</p>\n<h4 id=\"1-3-4-适当的压缩和尺寸\"><a href=\"#1-3-4-适当的压缩和尺寸\" class=\"headerlink\" title=\"1.3.4 适当的压缩和尺寸\"></a>1.3.4 适当的压缩和尺寸</h4><p>无论以上哪种格式图片，都可以通过选择合适的尺寸和适当的提高压缩率的方式，来进一步减少文件大小，进而减小apk文件的体积。</p>\n<h4 id=\"1-3-5-帧动画尽可能使用lottie\"><a href=\"#1-3-5-帧动画尽可能使用lottie\" class=\"headerlink\" title=\"1.3.5 帧动画尽可能使用lottie\"></a>1.3.5 帧动画尽可能使用lottie</h4><p><a href=\"https://github.com/airbnb/lottie-android\">Lottie</a>是Aribnb开源的动画库，通过json文件来进行展示动画，动画文件可以通过Adobe AE来制作。</p>\n<h3 id=\"1-4-有限国际化\"><a href=\"#1-4-有限国际化\" class=\"headerlink\" title=\"1.4 有限国际化\"></a>1.4 有限国际化</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  defaultConfig &#123;</span><br><span class=\"line\">    resConfigs <span class=\"string\">&quot;zh&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-第三方库中大尺寸的无用资源同名替换\"><a href=\"#1-5-第三方库中大尺寸的无用资源同名替换\" class=\"headerlink\" title=\"1.5 第三方库中大尺寸的无用资源同名替换\"></a>1.5 第三方库中大尺寸的无用资源同名替换</h3><p>如果在第三方类库中，存在用不到的图片资源文件，可以通过1x1像素的同名图片进行替换。</p>\n<h3 id=\"1-6-使用AndResGuard\"><a href=\"#1-6-使用AndResGuard\" class=\"headerlink\" title=\"1.6 使用AndResGuard\"></a>1.6 使用AndResGuard</h3><p><a href=\"https://github.com/shwenzhang/AndResGuard\">AndResGuard</a>，在gradle文件中就可以直接使用，非常方便。</p>\n<h2 id=\"二、源代码\"><a href=\"#二、源代码\" class=\"headerlink\" title=\"二、源代码\"></a>二、源代码</h2><h3 id=\"2-1-开启混淆\"><a href=\"#2-1-开启混淆\" class=\"headerlink\" title=\"2.1 开启混淆\"></a>2.1 开启混淆</h3><p>这是基本操作了，无需多言。</p>\n<h3 id=\"2-2-手动修改开源代码\"><a href=\"#2-2-手动修改开源代码\" class=\"headerlink\" title=\"2.2 手动修改开源代码\"></a>2.2 手动修改开源代码</h3><p>将开源代码中我们不需要的类或者方法等删除掉，但是这需要对开源代码非常了解，而且确保版本兼容性，将来开源库升级或者随着我们产品需求变更对开源库的要求也改变了，都会影响对开源库的修改，不建议使用。</p>\n<h2 id=\"三、第三方类库\"><a href=\"#三、第三方类库\" class=\"headerlink\" title=\"三、第三方类库\"></a>三、第三方类库</h2><h3 id=\"3-1-动态库\"><a href=\"#3-1-动态库\" class=\"headerlink\" title=\"3.1 动态库\"></a>3.1 动态库</h3><h4 id=\"3-1-1-删除非必要平台so库\"><a href=\"#3-1-1-删除非必要平台so库\" class=\"headerlink\" title=\"3.1.1 删除非必要平台so库\"></a>3.1.1 删除非必要平台so库</h4><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ndk &#123;</span><br><span class=\"line\">  <span class=\"comment\">//设置支持的so库架构</span></span><br><span class=\"line\">  abiFilters <span class=\"string\">&quot;armeabi-v7a&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基本上，对于手机来说，支持armeabi-v7a就足够了。</p>\n<h4 id=\"3-1-2-动态加载so库\"><a href=\"#3-1-2-动态加载so库\" class=\"headerlink\" title=\"3.1.2 动态加载so库\"></a>3.1.2 动态加载so库</h4><p>如果不是一启动应用就需要初始化的so库，完全可以在需要的时候再下载这个so文件，再通过以下代码进行加载。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">  System.loadLibrary(<span class=\"string\">&quot;path/to/lib.so&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"插件化\"><a href=\"#插件化\" class=\"headerlink\" title=\"插件化\"></a>插件化</h3><p>将不需要在启动就加载的功能模块，通过插件化，在用户使用的时候再从服务器加载。</p>\n<h3 id=\"删除class文件的debug-items\"><a href=\"#删除class文件的debug-items\" class=\"headerlink\" title=\"删除class文件的debug items\"></a>删除class文件的debug items</h3><p>不建议使用，这种做法，事倍功半。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Apk瘦身主要从三方面入手：资源文件、源代码和第三方类库。</p>\n<h2 id=\"一、资源文件\"><a href=\"#一、资源文件\" class=\"headerlink\" title=\"一、资源文件\"></a>一、资源文件</h2><h3 id=\"1-1-删除无用资源文件\"><a href=\"#1-1-删除无用资源文件\" class=\"headerlink\" title=\"1.1 删除无用资源文件\"></a>1.1 删除无用资源文件</h3><h4 id=\"1-1-1-Lint工具\"><a href=\"#1-1-1-Lint工具\" class=\"headerlink\" title=\"1.1.1 Lint工具\"></a>1.1.1 Lint工具</h4><p>菜单 -&gt; Analyze -&gt; Run Inspection by Name，然后输入Unused resources便可以执行查找无用资源文件。自己根据需要进行删除。</p>\n<h4 id=\"1-1-2-shrinkResources\"><a href=\"#1-1-2-shrinkResources\" class=\"headerlink\" title=\"1.1.2 shrinkResources\"></a>1.1.2 shrinkResources</h4><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildTypes &#123;</span><br><span class=\"line\">  release &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不显示Log</span></span><br><span class=\"line\">    buildConfigField <span class=\"string\">&quot;boolean&quot;</span>, <span class=\"string\">&quot;LOG_DEBUG&quot;</span>, <span class=\"string\">&quot;false&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">//混淆</span></span><br><span class=\"line\">    minifyEnabled <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\">// 移除无用的resource文件</span></span><br><span class=\"line\">    shrinkResources <span class=\"literal\">true</span></span><br><span class=\"line\">    proguardFiles getDefaultProguardFile(<span class=\"string\">&#x27;proguard-android.txt&#x27;</span>), <span class=\"string\">&#x27;proguard-rules.pro&#x27;</span></span><br><span class=\"line\">    signingConfig signingConfigs.release</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用shrinkResources的前提是，打开混淆minifyEnabled，建议只在release版本开启，不然会使得编译速度变慢。</p>\n<h3 id=\"1-2-图标类资源图片矢量化\"><a href=\"#1-2-图标类资源图片矢量化\" class=\"headerlink\" title=\"1.2 图标类资源图片矢量化\"></a>1.2 图标类资源图片矢量化</h3><p>对于图标类资源，可以选择用vector-drawable来代替，通过AndroidStudio自带的转换工具可以将svg文件转换为vector-drawable文件。</p>\n<blockquote>\n<p>具体操作为，在drawable相关文件夹上右键 -&gt; New -&gt; Vector Assert。</p>\n</blockquote>\n<p>你也可以进行批量转换：<a href=\"https://github.com/vdmeer/svg2vector\">工具地址</a></p>\n<h3 id=\"1-3-非图标类资源图片适当压缩与格式选择\"><a href=\"#1-3-非图标类资源图片适当压缩与格式选择\" class=\"headerlink\" title=\"1.3 非图标类资源图片适当压缩与格式选择\"></a>1.3 非图标类资源图片适当压缩与格式选择</h3><h4 id=\"1-3-1-使用tinypng有损压缩png图片\"><a href=\"#1-3-1-使用tinypng有损压缩png图片\" class=\"headerlink\" title=\"1.3.1 使用tinypng有损压缩png图片\"></a>1.3.1 使用tinypng有损压缩png图片</h4><p>通过<a href=\"http://tinypng.com/\">Tinypng</a>官网上传压缩再下载，在保持alpha通道的情况下对png图片的压缩可达到1&#x2F;3以内，且肉眼基本看不出差别。</p>\n<h4 id=\"1-3-2-使用jpg格式\"><a href=\"#1-3-2-使用jpg格式\" class=\"headerlink\" title=\"1.3.2 使用jpg格式\"></a>1.3.2 使用jpg格式</h4><p>对于非透明的大图，jpg会比png的大小和内存都更有优势，虽然不是绝对的，但是通常会减少到一半不止。</p>\n<h4 id=\"1-3-3-使用webp格式\"><a href=\"#1-3-3-使用webp格式\" class=\"headerlink\" title=\"1.3.3 使用webp格式\"></a>1.3.3 使用webp格式</h4><p>webp格式支持透明度，压缩比比jpg高，但是显示效果却不输于jpg。缺点是在Android端的原生支持不好，从Android4.0+开始原生支持，但是不支持透明度，从Android4.3+开始支持带有透明度的webp。如果不需要兼容到这个版本，可以直接使用。</p>\n<p>在Android studio中，在图片资源上右键可以转换为webp。详细参见<a href=\"https://developer.android.com/studio/write/convert-webp\">创建 WebP 图片</a>。</p>\n<h4 id=\"1-3-4-适当的压缩和尺寸\"><a href=\"#1-3-4-适当的压缩和尺寸\" class=\"headerlink\" title=\"1.3.4 适当的压缩和尺寸\"></a>1.3.4 适当的压缩和尺寸</h4><p>无论以上哪种格式图片，都可以通过选择合适的尺寸和适当的提高压缩率的方式，来进一步减少文件大小，进而减小apk文件的体积。</p>\n<h4 id=\"1-3-5-帧动画尽可能使用lottie\"><a href=\"#1-3-5-帧动画尽可能使用lottie\" class=\"headerlink\" title=\"1.3.5 帧动画尽可能使用lottie\"></a>1.3.5 帧动画尽可能使用lottie</h4><p><a href=\"https://github.com/airbnb/lottie-android\">Lottie</a>是Aribnb开源的动画库，通过json文件来进行展示动画，动画文件可以通过Adobe AE来制作。</p>\n<h3 id=\"1-4-有限国际化\"><a href=\"#1-4-有限国际化\" class=\"headerlink\" title=\"1.4 有限国际化\"></a>1.4 有限国际化</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  defaultConfig &#123;</span><br><span class=\"line\">    resConfigs <span class=\"string\">&quot;zh&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-第三方库中大尺寸的无用资源同名替换\"><a href=\"#1-5-第三方库中大尺寸的无用资源同名替换\" class=\"headerlink\" title=\"1.5 第三方库中大尺寸的无用资源同名替换\"></a>1.5 第三方库中大尺寸的无用资源同名替换</h3><p>如果在第三方类库中，存在用不到的图片资源文件，可以通过1x1像素的同名图片进行替换。</p>\n<h3 id=\"1-6-使用AndResGuard\"><a href=\"#1-6-使用AndResGuard\" class=\"headerlink\" title=\"1.6 使用AndResGuard\"></a>1.6 使用AndResGuard</h3><p><a href=\"https://github.com/shwenzhang/AndResGuard\">AndResGuard</a>，在gradle文件中就可以直接使用，非常方便。</p>\n<h2 id=\"二、源代码\"><a href=\"#二、源代码\" class=\"headerlink\" title=\"二、源代码\"></a>二、源代码</h2><h3 id=\"2-1-开启混淆\"><a href=\"#2-1-开启混淆\" class=\"headerlink\" title=\"2.1 开启混淆\"></a>2.1 开启混淆</h3><p>这是基本操作了，无需多言。</p>\n<h3 id=\"2-2-手动修改开源代码\"><a href=\"#2-2-手动修改开源代码\" class=\"headerlink\" title=\"2.2 手动修改开源代码\"></a>2.2 手动修改开源代码</h3><p>将开源代码中我们不需要的类或者方法等删除掉，但是这需要对开源代码非常了解，而且确保版本兼容性，将来开源库升级或者随着我们产品需求变更对开源库的要求也改变了，都会影响对开源库的修改，不建议使用。</p>\n<h2 id=\"三、第三方类库\"><a href=\"#三、第三方类库\" class=\"headerlink\" title=\"三、第三方类库\"></a>三、第三方类库</h2><h3 id=\"3-1-动态库\"><a href=\"#3-1-动态库\" class=\"headerlink\" title=\"3.1 动态库\"></a>3.1 动态库</h3><h4 id=\"3-1-1-删除非必要平台so库\"><a href=\"#3-1-1-删除非必要平台so库\" class=\"headerlink\" title=\"3.1.1 删除非必要平台so库\"></a>3.1.1 删除非必要平台so库</h4><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ndk &#123;</span><br><span class=\"line\">  <span class=\"comment\">//设置支持的so库架构</span></span><br><span class=\"line\">  abiFilters <span class=\"string\">&quot;armeabi-v7a&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基本上，对于手机来说，支持armeabi-v7a就足够了。</p>\n<h4 id=\"3-1-2-动态加载so库\"><a href=\"#3-1-2-动态加载so库\" class=\"headerlink\" title=\"3.1.2 动态加载so库\"></a>3.1.2 动态加载so库</h4><p>如果不是一启动应用就需要初始化的so库，完全可以在需要的时候再下载这个so文件，再通过以下代码进行加载。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">  System.loadLibrary(<span class=\"string\">&quot;path/to/lib.so&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"插件化\"><a href=\"#插件化\" class=\"headerlink\" title=\"插件化\"></a>插件化</h3><p>将不需要在启动就加载的功能模块，通过插件化，在用户使用的时候再从服务器加载。</p>\n<h3 id=\"删除class文件的debug-items\"><a href=\"#删除class文件的debug-items\" class=\"headerlink\" title=\"删除class文件的debug items\"></a>删除class文件的debug items</h3><p>不建议使用，这种做法，事倍功半。</p>\n"},{"layout":"post","title":"App保活术","author":"boybeak","_content":"\n\n**为什么要保活？**\n\n因为Android的Low memory killer机制，在系统内存不足的情况下，系统开始根据自身的一套进程回收机制结束一些进程，以便腾出内存给需要的进程。\n\n\n\n**如何判断内存不足？**\n\n判断的阈值在不同手机上是不一样的，一旦低于该阈值，系统就会杀死对应优先级的进程。\n\n在adb shell下，通过如下命令来查看阈值：\n\n```powershell\ncat /sys/module/lowmemorykiller/parameters/minfree\n```\n\n*注意: 这可能需要root手机。*\n\n返回的结果如下示例：\n\n```powershell\n18432, 23040, 27648, 32256, 55296, 80640\n```\n\n其单位为4kb，也就是内存1页大小。\n\n该值表示的是剩余内存大小，优先级为从高到低，比如当内存小于18432*4kb时，杀死对应的优先级的进程。\n\n![oom_adj](/images/process_priority.jpg)\n\n```mermaid\ngraph TD;\nstyle 关键优先级 fill:#5befb9\nstyle 高级优先级 fill:#6998c6\nstyle 低优先级 fill:#d38a49\nsubgraph 关键优先级\nA(前台进程)\nend\nA(前台进程) --> B(可见进程);\nsubgraph 高级优先级\nB --> C(服务进程);\nend\nC --> D(后台进程);\nsubgraph 低优先级\nD --> E(空进程);\nend\n```\n\n\n\n优先级从高到低依次是，`前台进程`、`可见进程`、`服务进程`、`后台进程`、`空进程`。\n\n\n\n**阈值有6个数，而进程有5种优先级，是如何对应呢？**\n\n实际上，第5个数是ContentProvider的阈值，其他的5个数与线程优先级对应。\n\n\n\n**如何判断线程的优先级？**\n\n```powershell\ncat /proc/<pid>/oom_adj\n```\n\n> 其中的<pid>应替换为对应的**进程ID**，从logcat中可以查看对应的pid。\n\n![oom_adj](/images/oom_adj.png)\n\n取值范围绿色代表比较安全，红色代表比较容易被杀死，白色代表为系统进程。\n\n\n\n## 1像素保活\n\n监听锁屏广播，当屏幕关闭，偷偷创建一个1像素的activity，当屏幕开启，关闭掉这个1像素activity。\n\n关键代码如下:\n\n`ScreenObserverService.java`\n\n```java\n//创建后台service，监听屏幕事件。\nIntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_ON);\nfilter.addAction(Intent.ACTION_SCREEN_OFF);\nregisterReceiver(theReceiver, filter);\n//别忘了在service结束时候，注销掉这个receiver。\n```\n\n`OnePixelActivity.java`\n\n```java\nWindow window = getWindow();\nwindow.setGravity(Gravity.START | Gravity.TOP);\nWindowManager.LayoutParams params = window.getAttributes();\nparams.width = 1;\nparams.height = 1;\nparams.x = 0;\nparams.y = 0;\nwindow.setAttributes(params);\n```\n\n别忘了在Manifest文件中，为这个activity设置一个透明主题。\n\n```xml\n<activity android:name=\".onepixel.OnePixelActivity\"\n            android:excludeFromRecents=\"true\"\n            android:taskAffinity=\"com.github.boybeak.livestock.onepixel\"\n            android:theme=\"@style/OnePixelTheme\"\n            />\n```\n\n> android:excludeFromRecents=\"true\" //不会出现在任务管理器中\n>\n> android:taskAffinity=\"xxxx\"\t\t\t\t//在新的任务栈中创建，不会将其他界面带到前台，配合启动OnePixelActivity时候的Intent.FLAG_ACTIVITY_NEW_TASK使用.\n\n> **注意**：经过实验，这个方案在真机上已经大概率失效了。\n>\n> 1. 收到锁屏广播会有1~3秒延迟；\n> 2. 当OnePixelActivity设置了`excludeFromRecents=\"true\"`后，在锁屏下是启动不起来的；\n> 3. 屏幕重新点亮的广播会有十几秒延迟。\n>\n> 我在一架5T上实验的，其他机型不保证。\n\n## 前台服务\n\n这一方案就是利用一个前台服务，配合Notification，来达到保活。弊端就是，当你的应用没有Notification需求的时候，对于一些敏感用户来说，这就容易引起方案。如下图。\n\n![forground_service](/images/forground_service.png)\n\n所以当你的应用是音乐类播放器，可以将这个通知作为音乐播放控制来使用，但是如果你的应用没有这样的需求，就会引起敏感用户注意，反而有可能被手动杀死甚至卸载。在Android8.0以前，可以通过如下方案消除这个无意义的敏感通知。\n\n```java\npublic class OuterService extends Service {\n  @Override\n  public void onCreate() {\n    startForground(1, new Notification());\n    startService(new Intent(this, InnerService.class));\n  }\n  \n  public static class InnerService extends Service {\n    @Override\n    public void onCreate() {\n      startForground(1, new Notification());\n      stopSelf();\n    }\n  }\n  \n}\n```\n\n这是利用系统漏洞来消除的这个通知，但是在Android8.0以后，同一个ID下，不允许重复创建前台服务，所以使用该方法需要判断版本。\n\n\n\n## 系统广播拉活\n\n**系统拉活**\n\n比如开机广播，电量变化，信号变化，网络变化等。但是在Android7.0后增加了限制，在Android8.0后限制更加严格。所以，这类保活方案已经不可靠了。\n\n> Oreo: https://developer.android.google.cn/about/versions/oreo/background.html#Broadcasts\n>\n> Pie: https://developer.android.google.cn/guide/components/broadcast-exceptions.html\n\n**用户拉活**\n\n大厂的多个APP之间可以互相之间拉活。 \n\n\n\n## Service系统机制拉活\n\n根据Service的onStartCommand方法的返回值，系统会执行不同的拉活方案。一般按照默认返回[START_STICKY](https://developer.android.com/reference/android/app/Service#START_STICKY)就可以。\n\n优点是使用成本低，缺点是不稳定。\n\n\n\n## 账户同步拉活\n\n优点：非常稳定。\n\n\n\n## JobScheduler拉活\n\n\n\n## 双进程守护\n\n\n\n## WorkManager\n\n\n\n## 厂商推送\n\n\n\n## 播放无声音乐\n\n\n\n## 白名单\n\n## Github\n\n[示例代码Livestock](https://github.com/boybeak/Livestock)\n\n## 参考文章\n\n[解读Android进程优先级ADJ算法](http://gityuan.com/2018/05/19/android-process-adj/)\n\n[创建自定义账号类型](https://developer.android.com/training/id-auth/custom_auth)\n\n","source":"_posts/2022-09-19-App保活术.md","raw":"---\nlayout: post\ntitle: App保活术\nauthor: boybeak\ncategory: Android技巧\ntags: Android\n---\n\n\n**为什么要保活？**\n\n因为Android的Low memory killer机制，在系统内存不足的情况下，系统开始根据自身的一套进程回收机制结束一些进程，以便腾出内存给需要的进程。\n\n\n\n**如何判断内存不足？**\n\n判断的阈值在不同手机上是不一样的，一旦低于该阈值，系统就会杀死对应优先级的进程。\n\n在adb shell下，通过如下命令来查看阈值：\n\n```powershell\ncat /sys/module/lowmemorykiller/parameters/minfree\n```\n\n*注意: 这可能需要root手机。*\n\n返回的结果如下示例：\n\n```powershell\n18432, 23040, 27648, 32256, 55296, 80640\n```\n\n其单位为4kb，也就是内存1页大小。\n\n该值表示的是剩余内存大小，优先级为从高到低，比如当内存小于18432*4kb时，杀死对应的优先级的进程。\n\n![oom_adj](/images/process_priority.jpg)\n\n```mermaid\ngraph TD;\nstyle 关键优先级 fill:#5befb9\nstyle 高级优先级 fill:#6998c6\nstyle 低优先级 fill:#d38a49\nsubgraph 关键优先级\nA(前台进程)\nend\nA(前台进程) --> B(可见进程);\nsubgraph 高级优先级\nB --> C(服务进程);\nend\nC --> D(后台进程);\nsubgraph 低优先级\nD --> E(空进程);\nend\n```\n\n\n\n优先级从高到低依次是，`前台进程`、`可见进程`、`服务进程`、`后台进程`、`空进程`。\n\n\n\n**阈值有6个数，而进程有5种优先级，是如何对应呢？**\n\n实际上，第5个数是ContentProvider的阈值，其他的5个数与线程优先级对应。\n\n\n\n**如何判断线程的优先级？**\n\n```powershell\ncat /proc/<pid>/oom_adj\n```\n\n> 其中的<pid>应替换为对应的**进程ID**，从logcat中可以查看对应的pid。\n\n![oom_adj](/images/oom_adj.png)\n\n取值范围绿色代表比较安全，红色代表比较容易被杀死，白色代表为系统进程。\n\n\n\n## 1像素保活\n\n监听锁屏广播，当屏幕关闭，偷偷创建一个1像素的activity，当屏幕开启，关闭掉这个1像素activity。\n\n关键代码如下:\n\n`ScreenObserverService.java`\n\n```java\n//创建后台service，监听屏幕事件。\nIntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_ON);\nfilter.addAction(Intent.ACTION_SCREEN_OFF);\nregisterReceiver(theReceiver, filter);\n//别忘了在service结束时候，注销掉这个receiver。\n```\n\n`OnePixelActivity.java`\n\n```java\nWindow window = getWindow();\nwindow.setGravity(Gravity.START | Gravity.TOP);\nWindowManager.LayoutParams params = window.getAttributes();\nparams.width = 1;\nparams.height = 1;\nparams.x = 0;\nparams.y = 0;\nwindow.setAttributes(params);\n```\n\n别忘了在Manifest文件中，为这个activity设置一个透明主题。\n\n```xml\n<activity android:name=\".onepixel.OnePixelActivity\"\n            android:excludeFromRecents=\"true\"\n            android:taskAffinity=\"com.github.boybeak.livestock.onepixel\"\n            android:theme=\"@style/OnePixelTheme\"\n            />\n```\n\n> android:excludeFromRecents=\"true\" //不会出现在任务管理器中\n>\n> android:taskAffinity=\"xxxx\"\t\t\t\t//在新的任务栈中创建，不会将其他界面带到前台，配合启动OnePixelActivity时候的Intent.FLAG_ACTIVITY_NEW_TASK使用.\n\n> **注意**：经过实验，这个方案在真机上已经大概率失效了。\n>\n> 1. 收到锁屏广播会有1~3秒延迟；\n> 2. 当OnePixelActivity设置了`excludeFromRecents=\"true\"`后，在锁屏下是启动不起来的；\n> 3. 屏幕重新点亮的广播会有十几秒延迟。\n>\n> 我在一架5T上实验的，其他机型不保证。\n\n## 前台服务\n\n这一方案就是利用一个前台服务，配合Notification，来达到保活。弊端就是，当你的应用没有Notification需求的时候，对于一些敏感用户来说，这就容易引起方案。如下图。\n\n![forground_service](/images/forground_service.png)\n\n所以当你的应用是音乐类播放器，可以将这个通知作为音乐播放控制来使用，但是如果你的应用没有这样的需求，就会引起敏感用户注意，反而有可能被手动杀死甚至卸载。在Android8.0以前，可以通过如下方案消除这个无意义的敏感通知。\n\n```java\npublic class OuterService extends Service {\n  @Override\n  public void onCreate() {\n    startForground(1, new Notification());\n    startService(new Intent(this, InnerService.class));\n  }\n  \n  public static class InnerService extends Service {\n    @Override\n    public void onCreate() {\n      startForground(1, new Notification());\n      stopSelf();\n    }\n  }\n  \n}\n```\n\n这是利用系统漏洞来消除的这个通知，但是在Android8.0以后，同一个ID下，不允许重复创建前台服务，所以使用该方法需要判断版本。\n\n\n\n## 系统广播拉活\n\n**系统拉活**\n\n比如开机广播，电量变化，信号变化，网络变化等。但是在Android7.0后增加了限制，在Android8.0后限制更加严格。所以，这类保活方案已经不可靠了。\n\n> Oreo: https://developer.android.google.cn/about/versions/oreo/background.html#Broadcasts\n>\n> Pie: https://developer.android.google.cn/guide/components/broadcast-exceptions.html\n\n**用户拉活**\n\n大厂的多个APP之间可以互相之间拉活。 \n\n\n\n## Service系统机制拉活\n\n根据Service的onStartCommand方法的返回值，系统会执行不同的拉活方案。一般按照默认返回[START_STICKY](https://developer.android.com/reference/android/app/Service#START_STICKY)就可以。\n\n优点是使用成本低，缺点是不稳定。\n\n\n\n## 账户同步拉活\n\n优点：非常稳定。\n\n\n\n## JobScheduler拉活\n\n\n\n## 双进程守护\n\n\n\n## WorkManager\n\n\n\n## 厂商推送\n\n\n\n## 播放无声音乐\n\n\n\n## 白名单\n\n## Github\n\n[示例代码Livestock](https://github.com/boybeak/Livestock)\n\n## 参考文章\n\n[解读Android进程优先级ADJ算法](http://gityuan.com/2018/05/19/android-process-adj/)\n\n[创建自定义账号类型](https://developer.android.com/training/id-auth/custom_auth)\n\n","slug":"2022-09-19-App保活术","published":1,"date":"2020-10-21T04:55:58.000Z","updated":"2023-02-05T04:18:38.597Z","_id":"cldqukh8z0010pcjg98yodi8j","comments":1,"photos":[],"link":"","content":"<p><strong>为什么要保活？</strong></p>\n<p>因为Android的Low memory killer机制，在系统内存不足的情况下，系统开始根据自身的一套进程回收机制结束一些进程，以便腾出内存给需要的进程。</p>\n<p><strong>如何判断内存不足？</strong></p>\n<p>判断的阈值在不同手机上是不一样的，一旦低于该阈值，系统就会杀死对应优先级的进程。</p>\n<p>在adb shell下，通过如下命令来查看阈值：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> /sys/module/lowmemorykiller/parameters/minfree</span><br></pre></td></tr></table></figure>\n\n<p><em>注意: 这可能需要root手机。</em></p>\n<p>返回的结果如下示例：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">18432</span>, <span class=\"number\">23040</span>, <span class=\"number\">27648</span>, <span class=\"number\">32256</span>, <span class=\"number\">55296</span>, <span class=\"number\">80640</span></span><br></pre></td></tr></table></figure>\n\n<p>其单位为4kb，也就是内存1页大小。</p>\n<p>该值表示的是剩余内存大小，优先级为从高到低，比如当内存小于18432*4kb时，杀死对应的优先级的进程。</p>\n<p><img src=\"/images/process_priority.jpg\" alt=\"oom_adj\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">style 关键优先级 fill:#5befb9</span><br><span class=\"line\">style 高级优先级 fill:#6998c6</span><br><span class=\"line\">style 低优先级 fill:#d38a49</span><br><span class=\"line\">subgraph 关键优先级</span><br><span class=\"line\">A(前台进程)</span><br><span class=\"line\">end</span><br><span class=\"line\">A(前台进程) --&gt; B(可见进程);</span><br><span class=\"line\">subgraph 高级优先级</span><br><span class=\"line\">B --&gt; C(服务进程);</span><br><span class=\"line\">end</span><br><span class=\"line\">C --&gt; D(后台进程);</span><br><span class=\"line\">subgraph 低优先级</span><br><span class=\"line\">D --&gt; E(空进程);</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n\n\n<p>优先级从高到低依次是，<code>前台进程</code>、<code>可见进程</code>、<code>服务进程</code>、<code>后台进程</code>、<code>空进程</code>。</p>\n<p><strong>阈值有6个数，而进程有5种优先级，是如何对应呢？</strong></p>\n<p>实际上，第5个数是ContentProvider的阈值，其他的5个数与线程优先级对应。</p>\n<p><strong>如何判断线程的优先级？</strong></p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> /proc/&lt;pid&gt;/oom_adj</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>其中的<pid>应替换为对应的<strong>进程ID</strong>，从logcat中可以查看对应的pid。</p>\n</blockquote>\n<p><img src=\"/images/oom_adj.png\" alt=\"oom_adj\"></p>\n<p>取值范围绿色代表比较安全，红色代表比较容易被杀死，白色代表为系统进程。</p>\n<h2 id=\"1像素保活\"><a href=\"#1像素保活\" class=\"headerlink\" title=\"1像素保活\"></a>1像素保活</h2><p>监听锁屏广播，当屏幕关闭，偷偷创建一个1像素的activity，当屏幕开启，关闭掉这个1像素activity。</p>\n<p>关键代码如下:</p>\n<p><code>ScreenObserverService.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建后台service，监听屏幕事件。</span></span><br><span class=\"line\"><span class=\"type\">IntentFilter</span> <span class=\"variable\">filter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IntentFilter</span>(Intent.ACTION_SCREEN_ON);</span><br><span class=\"line\">filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class=\"line\">registerReceiver(theReceiver, filter);</span><br><span class=\"line\"><span class=\"comment\">//别忘了在service结束时候，注销掉这个receiver。</span></span><br></pre></td></tr></table></figure>\n\n<p><code>OnePixelActivity.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Window</span> <span class=\"variable\">window</span> <span class=\"operator\">=</span> getWindow();</span><br><span class=\"line\">window.setGravity(Gravity.START | Gravity.TOP);</span><br><span class=\"line\">WindowManager.<span class=\"type\">LayoutParams</span> <span class=\"variable\">params</span> <span class=\"operator\">=</span> window.getAttributes();</span><br><span class=\"line\">params.width = <span class=\"number\">1</span>;</span><br><span class=\"line\">params.height = <span class=\"number\">1</span>;</span><br><span class=\"line\">params.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">params.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">window.setAttributes(params);</span><br></pre></td></tr></table></figure>\n\n<p>别忘了在Manifest文件中，为这个activity设置一个透明主题。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.onepixel.OnePixelActivity&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:excludeFromRecents</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;com.github.boybeak.livestock.onepixel&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:theme</span>=<span class=\"string\">&quot;@style/OnePixelTheme&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>android:excludeFromRecents&#x3D;”true” &#x2F;&#x2F;不会出现在任务管理器中</p>\n<p>android:taskAffinity&#x3D;”xxxx”\t\t\t\t&#x2F;&#x2F;在新的任务栈中创建，不会将其他界面带到前台，配合启动OnePixelActivity时候的Intent.FLAG_ACTIVITY_NEW_TASK使用.</p>\n</blockquote>\n<blockquote>\n<p><strong>注意</strong>：经过实验，这个方案在真机上已经大概率失效了。</p>\n<ol>\n<li>收到锁屏广播会有1~3秒延迟；</li>\n<li>当OnePixelActivity设置了<code>excludeFromRecents=&quot;true&quot;</code>后，在锁屏下是启动不起来的；</li>\n<li>屏幕重新点亮的广播会有十几秒延迟。</li>\n</ol>\n<p>我在一架5T上实验的，其他机型不保证。</p>\n</blockquote>\n<h2 id=\"前台服务\"><a href=\"#前台服务\" class=\"headerlink\" title=\"前台服务\"></a>前台服务</h2><p>这一方案就是利用一个前台服务，配合Notification，来达到保活。弊端就是，当你的应用没有Notification需求的时候，对于一些敏感用户来说，这就容易引起方案。如下图。</p>\n<p><img src=\"/images/forground_service.png\" alt=\"forground_service\"></p>\n<p>所以当你的应用是音乐类播放器，可以将这个通知作为音乐播放控制来使用，但是如果你的应用没有这样的需求，就会引起敏感用户注意，反而有可能被手动杀死甚至卸载。在Android8.0以前，可以通过如下方案消除这个无意义的敏感通知。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OuterService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    startForground(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>());</span><br><span class=\"line\">    startService(<span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(<span class=\"built_in\">this</span>, InnerService.class));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InnerService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      startForground(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>());</span><br><span class=\"line\">      stopSelf();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是利用系统漏洞来消除的这个通知，但是在Android8.0以后，同一个ID下，不允许重复创建前台服务，所以使用该方法需要判断版本。</p>\n<h2 id=\"系统广播拉活\"><a href=\"#系统广播拉活\" class=\"headerlink\" title=\"系统广播拉活\"></a>系统广播拉活</h2><p><strong>系统拉活</strong></p>\n<p>比如开机广播，电量变化，信号变化，网络变化等。但是在Android7.0后增加了限制，在Android8.0后限制更加严格。所以，这类保活方案已经不可靠了。</p>\n<blockquote>\n<p>Oreo: <a href=\"https://developer.android.google.cn/about/versions/oreo/background.html#Broadcasts\">https://developer.android.google.cn/about/versions/oreo/background.html#Broadcasts</a></p>\n<p>Pie: <a href=\"https://developer.android.google.cn/guide/components/broadcast-exceptions.html\">https://developer.android.google.cn/guide/components/broadcast-exceptions.html</a></p>\n</blockquote>\n<p><strong>用户拉活</strong></p>\n<p>大厂的多个APP之间可以互相之间拉活。 </p>\n<h2 id=\"Service系统机制拉活\"><a href=\"#Service系统机制拉活\" class=\"headerlink\" title=\"Service系统机制拉活\"></a>Service系统机制拉活</h2><p>根据Service的onStartCommand方法的返回值，系统会执行不同的拉活方案。一般按照默认返回<a href=\"https://developer.android.com/reference/android/app/Service#START_STICKY\">START_STICKY</a>就可以。</p>\n<p>优点是使用成本低，缺点是不稳定。</p>\n<h2 id=\"账户同步拉活\"><a href=\"#账户同步拉活\" class=\"headerlink\" title=\"账户同步拉活\"></a>账户同步拉活</h2><p>优点：非常稳定。</p>\n<h2 id=\"JobScheduler拉活\"><a href=\"#JobScheduler拉活\" class=\"headerlink\" title=\"JobScheduler拉活\"></a>JobScheduler拉活</h2><h2 id=\"双进程守护\"><a href=\"#双进程守护\" class=\"headerlink\" title=\"双进程守护\"></a>双进程守护</h2><h2 id=\"WorkManager\"><a href=\"#WorkManager\" class=\"headerlink\" title=\"WorkManager\"></a>WorkManager</h2><h2 id=\"厂商推送\"><a href=\"#厂商推送\" class=\"headerlink\" title=\"厂商推送\"></a>厂商推送</h2><h2 id=\"播放无声音乐\"><a href=\"#播放无声音乐\" class=\"headerlink\" title=\"播放无声音乐\"></a>播放无声音乐</h2><h2 id=\"白名单\"><a href=\"#白名单\" class=\"headerlink\" title=\"白名单\"></a>白名单</h2><h2 id=\"Github\"><a href=\"#Github\" class=\"headerlink\" title=\"Github\"></a>Github</h2><p><a href=\"https://github.com/boybeak/Livestock\">示例代码Livestock</a></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://gityuan.com/2018/05/19/android-process-adj/\">解读Android进程优先级ADJ算法</a></p>\n<p><a href=\"https://developer.android.com/training/id-auth/custom_auth\">创建自定义账号类型</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>为什么要保活？</strong></p>\n<p>因为Android的Low memory killer机制，在系统内存不足的情况下，系统开始根据自身的一套进程回收机制结束一些进程，以便腾出内存给需要的进程。</p>\n<p><strong>如何判断内存不足？</strong></p>\n<p>判断的阈值在不同手机上是不一样的，一旦低于该阈值，系统就会杀死对应优先级的进程。</p>\n<p>在adb shell下，通过如下命令来查看阈值：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> /sys/module/lowmemorykiller/parameters/minfree</span><br></pre></td></tr></table></figure>\n\n<p><em>注意: 这可能需要root手机。</em></p>\n<p>返回的结果如下示例：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">18432</span>, <span class=\"number\">23040</span>, <span class=\"number\">27648</span>, <span class=\"number\">32256</span>, <span class=\"number\">55296</span>, <span class=\"number\">80640</span></span><br></pre></td></tr></table></figure>\n\n<p>其单位为4kb，也就是内存1页大小。</p>\n<p>该值表示的是剩余内存大小，优先级为从高到低，比如当内存小于18432*4kb时，杀死对应的优先级的进程。</p>\n<p><img src=\"/images/process_priority.jpg\" alt=\"oom_adj\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">style 关键优先级 fill:#5befb9</span><br><span class=\"line\">style 高级优先级 fill:#6998c6</span><br><span class=\"line\">style 低优先级 fill:#d38a49</span><br><span class=\"line\">subgraph 关键优先级</span><br><span class=\"line\">A(前台进程)</span><br><span class=\"line\">end</span><br><span class=\"line\">A(前台进程) --&gt; B(可见进程);</span><br><span class=\"line\">subgraph 高级优先级</span><br><span class=\"line\">B --&gt; C(服务进程);</span><br><span class=\"line\">end</span><br><span class=\"line\">C --&gt; D(后台进程);</span><br><span class=\"line\">subgraph 低优先级</span><br><span class=\"line\">D --&gt; E(空进程);</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n\n\n<p>优先级从高到低依次是，<code>前台进程</code>、<code>可见进程</code>、<code>服务进程</code>、<code>后台进程</code>、<code>空进程</code>。</p>\n<p><strong>阈值有6个数，而进程有5种优先级，是如何对应呢？</strong></p>\n<p>实际上，第5个数是ContentProvider的阈值，其他的5个数与线程优先级对应。</p>\n<p><strong>如何判断线程的优先级？</strong></p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> /proc/&lt;pid&gt;/oom_adj</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>其中的<pid>应替换为对应的<strong>进程ID</strong>，从logcat中可以查看对应的pid。</p>\n</blockquote>\n<p><img src=\"/images/oom_adj.png\" alt=\"oom_adj\"></p>\n<p>取值范围绿色代表比较安全，红色代表比较容易被杀死，白色代表为系统进程。</p>\n<h2 id=\"1像素保活\"><a href=\"#1像素保活\" class=\"headerlink\" title=\"1像素保活\"></a>1像素保活</h2><p>监听锁屏广播，当屏幕关闭，偷偷创建一个1像素的activity，当屏幕开启，关闭掉这个1像素activity。</p>\n<p>关键代码如下:</p>\n<p><code>ScreenObserverService.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建后台service，监听屏幕事件。</span></span><br><span class=\"line\"><span class=\"type\">IntentFilter</span> <span class=\"variable\">filter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IntentFilter</span>(Intent.ACTION_SCREEN_ON);</span><br><span class=\"line\">filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class=\"line\">registerReceiver(theReceiver, filter);</span><br><span class=\"line\"><span class=\"comment\">//别忘了在service结束时候，注销掉这个receiver。</span></span><br></pre></td></tr></table></figure>\n\n<p><code>OnePixelActivity.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Window</span> <span class=\"variable\">window</span> <span class=\"operator\">=</span> getWindow();</span><br><span class=\"line\">window.setGravity(Gravity.START | Gravity.TOP);</span><br><span class=\"line\">WindowManager.<span class=\"type\">LayoutParams</span> <span class=\"variable\">params</span> <span class=\"operator\">=</span> window.getAttributes();</span><br><span class=\"line\">params.width = <span class=\"number\">1</span>;</span><br><span class=\"line\">params.height = <span class=\"number\">1</span>;</span><br><span class=\"line\">params.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">params.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">window.setAttributes(params);</span><br></pre></td></tr></table></figure>\n\n<p>别忘了在Manifest文件中，为这个activity设置一个透明主题。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.onepixel.OnePixelActivity&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:excludeFromRecents</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;com.github.boybeak.livestock.onepixel&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:theme</span>=<span class=\"string\">&quot;@style/OnePixelTheme&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>android:excludeFromRecents&#x3D;”true” &#x2F;&#x2F;不会出现在任务管理器中</p>\n<p>android:taskAffinity&#x3D;”xxxx”\t\t\t\t&#x2F;&#x2F;在新的任务栈中创建，不会将其他界面带到前台，配合启动OnePixelActivity时候的Intent.FLAG_ACTIVITY_NEW_TASK使用.</p>\n</blockquote>\n<blockquote>\n<p><strong>注意</strong>：经过实验，这个方案在真机上已经大概率失效了。</p>\n<ol>\n<li>收到锁屏广播会有1~3秒延迟；</li>\n<li>当OnePixelActivity设置了<code>excludeFromRecents=&quot;true&quot;</code>后，在锁屏下是启动不起来的；</li>\n<li>屏幕重新点亮的广播会有十几秒延迟。</li>\n</ol>\n<p>我在一架5T上实验的，其他机型不保证。</p>\n</blockquote>\n<h2 id=\"前台服务\"><a href=\"#前台服务\" class=\"headerlink\" title=\"前台服务\"></a>前台服务</h2><p>这一方案就是利用一个前台服务，配合Notification，来达到保活。弊端就是，当你的应用没有Notification需求的时候，对于一些敏感用户来说，这就容易引起方案。如下图。</p>\n<p><img src=\"/images/forground_service.png\" alt=\"forground_service\"></p>\n<p>所以当你的应用是音乐类播放器，可以将这个通知作为音乐播放控制来使用，但是如果你的应用没有这样的需求，就会引起敏感用户注意，反而有可能被手动杀死甚至卸载。在Android8.0以前，可以通过如下方案消除这个无意义的敏感通知。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OuterService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    startForground(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>());</span><br><span class=\"line\">    startService(<span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(<span class=\"built_in\">this</span>, InnerService.class));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InnerService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      startForground(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Notification</span>());</span><br><span class=\"line\">      stopSelf();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是利用系统漏洞来消除的这个通知，但是在Android8.0以后，同一个ID下，不允许重复创建前台服务，所以使用该方法需要判断版本。</p>\n<h2 id=\"系统广播拉活\"><a href=\"#系统广播拉活\" class=\"headerlink\" title=\"系统广播拉活\"></a>系统广播拉活</h2><p><strong>系统拉活</strong></p>\n<p>比如开机广播，电量变化，信号变化，网络变化等。但是在Android7.0后增加了限制，在Android8.0后限制更加严格。所以，这类保活方案已经不可靠了。</p>\n<blockquote>\n<p>Oreo: <a href=\"https://developer.android.google.cn/about/versions/oreo/background.html#Broadcasts\">https://developer.android.google.cn/about/versions/oreo/background.html#Broadcasts</a></p>\n<p>Pie: <a href=\"https://developer.android.google.cn/guide/components/broadcast-exceptions.html\">https://developer.android.google.cn/guide/components/broadcast-exceptions.html</a></p>\n</blockquote>\n<p><strong>用户拉活</strong></p>\n<p>大厂的多个APP之间可以互相之间拉活。 </p>\n<h2 id=\"Service系统机制拉活\"><a href=\"#Service系统机制拉活\" class=\"headerlink\" title=\"Service系统机制拉活\"></a>Service系统机制拉活</h2><p>根据Service的onStartCommand方法的返回值，系统会执行不同的拉活方案。一般按照默认返回<a href=\"https://developer.android.com/reference/android/app/Service#START_STICKY\">START_STICKY</a>就可以。</p>\n<p>优点是使用成本低，缺点是不稳定。</p>\n<h2 id=\"账户同步拉活\"><a href=\"#账户同步拉活\" class=\"headerlink\" title=\"账户同步拉活\"></a>账户同步拉活</h2><p>优点：非常稳定。</p>\n<h2 id=\"JobScheduler拉活\"><a href=\"#JobScheduler拉活\" class=\"headerlink\" title=\"JobScheduler拉活\"></a>JobScheduler拉活</h2><h2 id=\"双进程守护\"><a href=\"#双进程守护\" class=\"headerlink\" title=\"双进程守护\"></a>双进程守护</h2><h2 id=\"WorkManager\"><a href=\"#WorkManager\" class=\"headerlink\" title=\"WorkManager\"></a>WorkManager</h2><h2 id=\"厂商推送\"><a href=\"#厂商推送\" class=\"headerlink\" title=\"厂商推送\"></a>厂商推送</h2><h2 id=\"播放无声音乐\"><a href=\"#播放无声音乐\" class=\"headerlink\" title=\"播放无声音乐\"></a>播放无声音乐</h2><h2 id=\"白名单\"><a href=\"#白名单\" class=\"headerlink\" title=\"白名单\"></a>白名单</h2><h2 id=\"Github\"><a href=\"#Github\" class=\"headerlink\" title=\"Github\"></a>Github</h2><p><a href=\"https://github.com/boybeak/Livestock\">示例代码Livestock</a></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"http://gityuan.com/2018/05/19/android-process-adj/\">解读Android进程优先级ADJ算法</a></p>\n<p><a href=\"https://developer.android.com/training/id-auth/custom_auth\">创建自定义账号类型</a></p>\n"},{"layout":"post","title":"Binder机制分析","author":"boybeak","_content":"\n\n参考文章：[写给 Android 应用工程师的 Binder 原理剖析](https://zhuanlan.zhihu.com/p/35519585)\n\n实验代码：[TheBinder](https://github.com/boybeak/TheBinder)\n\nBinder机制可以说是Android的核心。提到Binder，可能会让你想到，通过bindService与`Service`进行通信(也可能是跨进程的通信)，实际上，Android中Binder的使用可以说是无处不在的，包括Activity跳转，详情可以参考[AMS启动流程](https://boybeak.github.io/android/AMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html)。\n\n## 为什么要用Binder?\n\n在Linux系统中，跨进程通信(IPC)方式有很多种，包括Socket、管道、共享内存等。可以Android为何最后选择Binder作为核心的跨进程通信的手段呢？\n\n这需要从两方面去分析——**性能**和**安全性**。\n\n### 1. 性能\n\n首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。\n\n### 2. 安全性\n\n另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。\n\n基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。\n\n用一张表格来总结与对比各种IPC方式。\n\n| IPC方式              | 性能(内存拷贝次数) | 安全性                             |\n| -------------------- | ------------------ | ---------------------------------- |\n| Binder               | 1                  | 通过UID/PID来保证                  |\n| 共享内存             | 0                  | 操作非常复杂，难以保证             |\n| Socket/管道/消息队列 | 2                  | 依靠上层协议做身份识别，非常不可靠 |\n\n\n\n\n\n## 传统IPC是什么样的？\n\n先要了解一些基本概念——**进程隔离**、**用户空间**、**内核空间**、**用户态**、**内核态**。\n\n![IPC](/images/traditional_ipc.jpg)\n\n上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：\n\n- 进程隔离\n- 进程空间划分：用户空间(User Space)/内核空间(Kernel Space)\n- 系统调用：用户态/内核态\n\n\n\n### 进程隔离\n\n顾名思义，就是进程之间内存是不共享的。进程间要进行数据交换，就得采用**进程间通信(IPC)**机制。\n\n\n\n### 进程空间划分：用户空间(User Space)/内核空间(Kernel Space)\n\n现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。\n\n> 简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。\n\n![linux memory](/images/linux_memory.png)\n\n\n\n### 系统调用：用户态/内核态\n\n虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助**系统调用**来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。\n\nLinux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。\n\n当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于**内核运行态（内核态）**。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。\n\n当进程在执行用户自己的代码的时候，我们称其处于**用户运行态（用户态）**。此时处理器在特权级最低的（3级）用户代码中运行。\n\n系统调用主要通过如下两个函数来实现：\n\n```\ncopy_from_user() //将数据从用户空间拷贝到内核空间\ncopy_to_user() //将数据从内核空间拷贝到用户空间\n```\n\n\n\n### Linux下传统IPC通信\n\n![linux ipc](/images/linux_ipc.jpg)\n\n**数据发送进程**：开辟用户空间缓存区 -> 系统调用，进入内核态 -> 开辟内核空间缓存区 ->通过`copy_from_user()`将数据拷贝到内核空间缓存区。\n\n**数据接收进程**：开辟用户空间缓存区 -> 调用`copytouser()`将数据从内核缓存区拷贝到用户空间缓存区。\n\n这样，两个进程就完成了依次进程间通信。\n\n这种传统的 IPC 通信方式有两个问题：\n\n1. 性能低下，一次数据传递需要经历：内存缓存区 --> 内核缓存区 --> 内存缓存区，需要 2 次数据拷贝；\n2. 接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。\n\n\n\n## Binder跨进程通信原理\n\n正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的**动态内核可加载模块**（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。\n\n> 在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 **Binder 驱动**（Binder Dirver）。\n\n那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。\n\n这就不得不通道 Linux 下的另一个概念：**内存映射**。\n\nBinder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。\n\n内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。\n\n\n\n### Binder IPC实现原理\n\nBinder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。\n\n比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘-->内核空间-->用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。\n\n而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。\n\n一次完整的 Binder IPC 通信过程通常是这样：\n\n1. 首先 Binder 驱动在内核空间创建一个数据接收缓存区；\n2. 接着在内核空间开辟一块内核缓存区，建立**内核缓存区**和**内核中数据接收缓存区**之间的映射关系，以及**内核中数据接收缓存区**和**接收进程用户空间地址**的映射关系；\n3. 发送方进程通过系统调用 copy*from*user() 将数据 copy 到内核中的**内核缓存区**，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。\n\n如下图：\n\n![binder](/images/binder.jpg)\n\n注意图中两个红色虚线。我们从图中可以看到，内核空间开辟了两个缓存区——**内核缓存区**和**数据接收缓存区**，这两个缓存区之间存在内存映射，然后**数据接收缓存区**与**数据接收进程的用户空间缓存区**同样有内存映射。当数据发送进程通过`copy_from_user()`将数据拷贝到**内核缓存区**的时候，存在映射关系的数据接收进程用户空间缓存区也就收到了数据。\n\n\n\n## Binder通信模型\n\n跨进程通讯至少包含两个进程，我们将数据发送进程称为**Client**，把数据接收方称为**Server**。\n\n### Client/Server/ServiceManager/驱动\n\n前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。\n\n![img](/images/android_binder.jpg)\n\n[Android Binder 设计与实现](https://link.zhihu.com/?target=http%3A//blog.csdn.net/universus/article/details/6211589)*一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：*\n\n> **Binder 驱动**\n> Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。\n>\n> **ServiceManager 与实名 Binder**\n> ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。\n>\n> 细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER*SET*CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（**这就是那只预先造好的那只鸡**）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。\n>\n> **Client 获得实名 Binder 的引用**\n> Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。\n\n\n\n### Binder通信过程\n\n至此，我们大致能总结出 Binder 通信过程：\n\n1. 首先，一个进程使用 BINDER*SET*CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；\n2. Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。\n3. Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。\n\n我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：\n\n![img](/images/client_server_service_manager.jpg)\n\n\n\n### Binder 通信中的代理模式\n\n我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。\n\n前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。\n\n当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。\n\n![img](/images/binder_data_trans.jpg)\n\n\n\n### Binder的完整定义\n\n现在我们可以对 Binder 做个更加全面的定义了：\n\n- 从进程间通信的角度看，Binder 是一种进程间通信的机制；\n- 从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；\n- 从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理\n- 从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。\n\n\n\n## 实现Binder跨进程通信\n\n一般Android上，使用**AIDL(Android Interface Definition Language)**来实现跨进程通信协议。AIDL主要是对接口进行描述的，包括定义Server为Client提供那些操作服务。通过AIDL文件，Android Studio在编译时候，会自动产生接口类以及代理类。\n\n除了通过AIDL的方式，我们还可以自己手动编写接口类和代理类。\n\n代码请参考[TheBinder](https://github.com/boybeak/TheBinder)，这里展示了两种方式实现Binder IPC。\n\n代码中涉及到了一些Java类。\n\n- **IBinder** : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输。\n- **IInterface** : IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）\n- **Binder** : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。\n- **Stub** : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。\n\n\n\n## 自己实现\n\n代码请参考[TheBinder](https://github.com/boybeak/TheBinder)\n\n代码中有两个module: **withAIDL**和**noAIDL**，分别演示了使用AIDL的方式和不使用ADIL的方式进行Binder IPC。\n\n**NoAIDL**相比**WithAIDL**有一个优点，就是可以在对应的`IInterface`文件中，添加一些自定义的代码，比如添加log代码；由于AIDL的方式是自动生成的代码，所以这些自定义代码是没法添加到对应的`IInterface`文件中。\n\n我们重点关注**noAIDL**\n\n```kotlin\n//INoAIDL.kt\ninterface INoAIDL : IInterface {\n  fun sayHi(name: String)\n  fun showObjN(objN: ObjN): ObjN?\n\n  companion object {\n    private val TAG = INoAIDL::class.java.simpleName\n    private val DESCRIPTOR = INoAIDL::class.java.name\n\n    abstract class Stub : Binder(), INoAIDL {...}\n    class Proxy(private val remote: IBinder) : INoAIDL {...}\n  }\n}\n```\n\n`INoAIDL.kt`文件的大体结构如上代码，我们可以看到，在这个`IInterface`类中：\n\n- 定义两个Server端承诺的服务——`sayHi`和`showObjN`；\n- 两个静态类——一个Stub类和一个Proxy类。\n\n**Stub类**\n\n```kotlin\nabstract class Stub : Binder(), INoAIDL {\n\n  companion object {\n    const val TRANSACTION_sayHi = IBinder.FIRST_CALL_TRANSACTION + 0\n    const val TRANSACTION_showObjN = IBinder.FIRST_CALL_TRANSACTION + 1\n\n    fun asInterface(binder: IBinder?): INoAIDL? {\n      if (binder == null) {\n        return null\n      }\n      val iin = binder.queryLocalInterface(DESCRIPTOR)\n      if (iin != null && iin is INoAIDL) {\n        Log.v(TAG, \"Client and Server in the same Process\")\n        return iin\n      }\n      Log.v(TAG, \"Client and Server in different Processes\")\n      return Proxy(binder)\n    }\n  }\n\n  init {\n    attachInterface(this, DESCRIPTOR)\n  }\n\n  final override fun attachInterface(owner: IInterface?, descriptor: String?) {\n    super.attachInterface(owner, descriptor)\n  }\n\n  override fun onTransact(code: Int, data: Parcel, reply: Parcel?, flags: Int): Boolean {\n    val descriptor = DESCRIPTOR\n    return when(code) {\n      INTERFACE_TRANSACTION -> {\n        reply?.writeString(descriptor)\n        true\n      }\n      TRANSACTION_sayHi -> {\n        data.enforceInterface(descriptor)\n        val name = data.readString() ?: \"\"\n        sayHi(name)\n        reply?.writeNoException()\n        true\n      }\n      TRANSACTION_showObjN -> {\n        data.enforceInterface(descriptor)\n        var objN: ObjN? = null\n        if (0 != data.readInt()) {\n          objN = ObjN.CREATOR.createFromParcel(data)\n        }\n        val _result = showObjN(objN!!)\n        reply?.writeNoException()\n        if (_result != null) {\n          reply?.writeInt(1)\n          _result.writeToParcel(reply, Parcelable.PARCELABLE_WRITE_RETURN_VALUE)\n        } else {\n          reply?.writeInt(0)\n        }\n        true\n      }\n      else -> {\n        super.onTransact(code, data, reply, flags)\n      }\n    }\n  }\n\n  override fun asBinder(): IBinder {\n    return this\n  }\n}\n```\n\n在Manifest文件中我们定义对应Service\n\n```xml\n<service\n  android:name=\".NoAIDLService\"\n  android:enabled=\"true\"\n  android:exported=\"true\"\n  />\n  <!--android:process=\":noAIDL\"-->\n\t<!--把上述属性设置到service中，则是在不同进程中运行-->\n```\n\n我们重点关注`asInterface`方法，在这个方法中，有一个代码片段：\n\n```kotlin\nval iin = binder.queryLocalInterface(DESCRIPTOR)\nif (iin != null && iin is INoAIDL) {\n\tLog.v(TAG, \"Client and Server in the same Process\")\n  return iin\n}\nLog.v(TAG, \"Client and Server in different Processes\")\nreturn Proxy(binder)\n```\n\n通过这样的代码来进行Client和Server是否在不同进程的判断。\n\n- 相同进程：返回`queryLocalInterface`出来的对象，这个对象是在`Stub`构造方法中通过`attachInterface`方法传入的。\n- 不同进程：构造一个`Proxy`类返回。\n\nMainActivity去bind一个Service，Service返回一个Binder。我们打印一下日志。\n\n```kotlin\nclass NoAIDLService : Service() {\n  override fun onBind(intent: Intent): IBinder {\n    return binder.also {\n      Log.v(TAG, \"onBind=$it\")\n    }\n  }\n}\n```\n\n```kotlin\nprivate var noAIDL: INoAIDL? = null\nprivate val noConnection = object : ServiceConnection {\n  override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n    service ?: return\n    Log.v(TAG, \"onServiceConnected service=$service\")\n    noAIDL = INoAIDL.Companion.Stub.asInterface(service)\n    Toast.makeText(this@MainActivity, \"connected to NoAIDLService\", Toast.LENGTH_SHORT).show()\n    Log.v(TAG, \"onServiceConnected noAIDL=${noAIDL}\")\n  }\n}\n\n```\n\n当Client与Server在相同进程，有如下日志：\n\n```\n// NoAIDLService\nonBind=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc\n\n// MainActivity\nonServiceConnected service=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc\nnoAIDL=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc\n```\n\n当Client与Server在不同进程，有如下日志：\n\n```\n// NoAIDLService\nonBind=com.github.boybeak.noaidl.NoAIDLService$binder$1@2d32060\n\n// MainActivity\nonServiceConnected service=android.os.BinderProxy@99b42f6\nnoAIDL=com.github.boybeak.noaidl.INoAIDL$Companion$Proxy@67e8964\n```\n\n我们看到，当Client与Server在相同进程时候，Service的`onBind`方法返回的是什么，MainActivity接收到的就是什么；而当Client与Server在不同进程的时候，则返回的是Binder驱动传递给我们的对象，通过这个对象，我们创造一个 Proxy代理对象。\n\n\n\n我们接下来重点关注`showObjN`方法。\n\n```kotlin\nprivate val binder = object : INoAIDL.Companion.Stub() {\n  override fun showObjN(objN: ObjN): ObjN? {\n    Log.v(TAG, \"showObjN objN=$objN\")\n    return objN\n  }\n}\n```\n\n这个方法中，直接返回传入的参数。\n\n调用的地方这样来写：\n\n```kotlin\nfun showObjN(v: View) {\n  if (noAIDL == null) {\n    Toast.makeText(this, \"Click NOAIDL button first\", Toast.LENGTH_SHORT).show()\n    return\n  }\n  val objN = ObjN()\n  Log.v(TAG, \"showObjN objN=$objN\")\n  val returnObjN = noAIDL?.showObjN(objN)\n  Log.v(TAG, \"showObjN returnObjW=$returnObjN\")\n}\n```\n\n我们来看打印的`objN`日志。\n\n**相同进程情况下：**\n\n```\n// Client进程\ncom.github.boybeak.binder V/MainActivity: showObjN objN=com.github.boybeak.noaidl.ObjN@4c7d499\ncom.github.boybeak.binder V/MainActivity: showObjN returnObjW=com.github.boybeak.noaidl.ObjN@4c7d499\n\n// Server进程\ncom.github.boybeak.binder V/NoAIDLService: showObjN objN=com.github.boybeak.noaidl.ObjN@4c7d499\n```\n\n\n\n**不同进程情况下：**\n\n```\n// Client进程\ncom.github.boybeak.binder V/MainActivity: showObjN objN=com.github.boybeak.noaidl.ObjN@5ab3a61\ncom.github.boybeak.binder V/MainActivity: showObjN returnObjW=com.github.boybeak.noaidl.ObjN@db79986\n\n// Server进程\ncom.github.boybeak.binder V/NoAIDLService: showObjN objN=com.github.boybeak.noaidl.ObjN@1c5381d\n```\n\n\n\n我们可以看到，在相同进程情况下，就是普通的函数调用；在不同进程情况下，Client传入的参数，Server接收到的参数，Client接收到的返回结果，全是不同的对象，这是因为，通过Proxy对象，在跨进程通信时候，将Parcelable对象进行了序列化和反序列化。\n\n\n\n本文是在阅读[**写给 Android 应用工程师的 Binder 原理剖析**](https://zhuanlan.zhihu.com/p/35519585)一文后，加上自己的理解与实验完成，其中部分段落直接复制了原文，因为我觉得，那部分原文已经足够容易理解且没有冗余的文字，感谢原作者[**张磊**](https://www.zhihu.com/people/BaronZ88)，同时附上原文参考资料：\n\n- [Android Binder 设计与实现 - 设计篇](https://link.zhihu.com/?target=http%3A//blog.csdn.net/universus/article/details/6211589)\n- [Android 进程间通信（IPC）机制 Binder 简要介绍和学习计划](https://link.zhihu.com/?target=http%3A//blog.csdn.net/luoshengyang/article/details/6618363)、[《Android 系统源代码情景分析》](https://link.zhihu.com/?target=http%3A//item.jd.com/12248208.html)\n- [Binder 学习指南](https://link.zhihu.com/?target=http%3A//weishu.me/2016/01/12/binder-index-for-newer/)\n- [Binder 系列文章](https://link.zhihu.com/?target=http%3A//gityuan.com/2015/10/31/binder-prepare/)\n- [Android 图文详解 Binder 跨进程通信原理](https://link.zhihu.com/?target=https%3A//blog.csdn.net/carson_ho/article/details/73560642)\n- [Android 深入浅出之 Binder 机制](https://link.zhihu.com/?target=http%3A//www.cnblogs.com/innost/archive/2011/01/09/1931456.html)\n- [用户空间与内核空间](https://link.zhihu.com/?target=http%3A//www.cnblogs.com/Anker/p/3269106.html)\n- [认真分析 mmap ：是什么 为什么 怎么用](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/huxiao-tee/p/4660352.html)\n\n","source":"_posts/2022-09-19-Binder机制分析.md","raw":"---\nlayout: post\ntitle: Binder机制分析\nauthor: boybeak\ncategory: Android技巧\ntags: Android\n---\n\n\n参考文章：[写给 Android 应用工程师的 Binder 原理剖析](https://zhuanlan.zhihu.com/p/35519585)\n\n实验代码：[TheBinder](https://github.com/boybeak/TheBinder)\n\nBinder机制可以说是Android的核心。提到Binder，可能会让你想到，通过bindService与`Service`进行通信(也可能是跨进程的通信)，实际上，Android中Binder的使用可以说是无处不在的，包括Activity跳转，详情可以参考[AMS启动流程](https://boybeak.github.io/android/AMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html)。\n\n## 为什么要用Binder?\n\n在Linux系统中，跨进程通信(IPC)方式有很多种，包括Socket、管道、共享内存等。可以Android为何最后选择Binder作为核心的跨进程通信的手段呢？\n\n这需要从两方面去分析——**性能**和**安全性**。\n\n### 1. 性能\n\n首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。\n\n### 2. 安全性\n\n另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。\n\n基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。\n\n用一张表格来总结与对比各种IPC方式。\n\n| IPC方式              | 性能(内存拷贝次数) | 安全性                             |\n| -------------------- | ------------------ | ---------------------------------- |\n| Binder               | 1                  | 通过UID/PID来保证                  |\n| 共享内存             | 0                  | 操作非常复杂，难以保证             |\n| Socket/管道/消息队列 | 2                  | 依靠上层协议做身份识别，非常不可靠 |\n\n\n\n\n\n## 传统IPC是什么样的？\n\n先要了解一些基本概念——**进程隔离**、**用户空间**、**内核空间**、**用户态**、**内核态**。\n\n![IPC](/images/traditional_ipc.jpg)\n\n上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：\n\n- 进程隔离\n- 进程空间划分：用户空间(User Space)/内核空间(Kernel Space)\n- 系统调用：用户态/内核态\n\n\n\n### 进程隔离\n\n顾名思义，就是进程之间内存是不共享的。进程间要进行数据交换，就得采用**进程间通信(IPC)**机制。\n\n\n\n### 进程空间划分：用户空间(User Space)/内核空间(Kernel Space)\n\n现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。\n\n> 简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。\n\n![linux memory](/images/linux_memory.png)\n\n\n\n### 系统调用：用户态/内核态\n\n虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助**系统调用**来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。\n\nLinux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。\n\n当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于**内核运行态（内核态）**。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。\n\n当进程在执行用户自己的代码的时候，我们称其处于**用户运行态（用户态）**。此时处理器在特权级最低的（3级）用户代码中运行。\n\n系统调用主要通过如下两个函数来实现：\n\n```\ncopy_from_user() //将数据从用户空间拷贝到内核空间\ncopy_to_user() //将数据从内核空间拷贝到用户空间\n```\n\n\n\n### Linux下传统IPC通信\n\n![linux ipc](/images/linux_ipc.jpg)\n\n**数据发送进程**：开辟用户空间缓存区 -> 系统调用，进入内核态 -> 开辟内核空间缓存区 ->通过`copy_from_user()`将数据拷贝到内核空间缓存区。\n\n**数据接收进程**：开辟用户空间缓存区 -> 调用`copytouser()`将数据从内核缓存区拷贝到用户空间缓存区。\n\n这样，两个进程就完成了依次进程间通信。\n\n这种传统的 IPC 通信方式有两个问题：\n\n1. 性能低下，一次数据传递需要经历：内存缓存区 --> 内核缓存区 --> 内存缓存区，需要 2 次数据拷贝；\n2. 接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。\n\n\n\n## Binder跨进程通信原理\n\n正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的**动态内核可加载模块**（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。\n\n> 在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 **Binder 驱动**（Binder Dirver）。\n\n那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。\n\n这就不得不通道 Linux 下的另一个概念：**内存映射**。\n\nBinder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。\n\n内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。\n\n\n\n### Binder IPC实现原理\n\nBinder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。\n\n比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘-->内核空间-->用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。\n\n而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。\n\n一次完整的 Binder IPC 通信过程通常是这样：\n\n1. 首先 Binder 驱动在内核空间创建一个数据接收缓存区；\n2. 接着在内核空间开辟一块内核缓存区，建立**内核缓存区**和**内核中数据接收缓存区**之间的映射关系，以及**内核中数据接收缓存区**和**接收进程用户空间地址**的映射关系；\n3. 发送方进程通过系统调用 copy*from*user() 将数据 copy 到内核中的**内核缓存区**，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。\n\n如下图：\n\n![binder](/images/binder.jpg)\n\n注意图中两个红色虚线。我们从图中可以看到，内核空间开辟了两个缓存区——**内核缓存区**和**数据接收缓存区**，这两个缓存区之间存在内存映射，然后**数据接收缓存区**与**数据接收进程的用户空间缓存区**同样有内存映射。当数据发送进程通过`copy_from_user()`将数据拷贝到**内核缓存区**的时候，存在映射关系的数据接收进程用户空间缓存区也就收到了数据。\n\n\n\n## Binder通信模型\n\n跨进程通讯至少包含两个进程，我们将数据发送进程称为**Client**，把数据接收方称为**Server**。\n\n### Client/Server/ServiceManager/驱动\n\n前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。\n\n![img](/images/android_binder.jpg)\n\n[Android Binder 设计与实现](https://link.zhihu.com/?target=http%3A//blog.csdn.net/universus/article/details/6211589)*一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：*\n\n> **Binder 驱动**\n> Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。\n>\n> **ServiceManager 与实名 Binder**\n> ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。\n>\n> 细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER*SET*CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（**这就是那只预先造好的那只鸡**）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。\n>\n> **Client 获得实名 Binder 的引用**\n> Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。\n\n\n\n### Binder通信过程\n\n至此，我们大致能总结出 Binder 通信过程：\n\n1. 首先，一个进程使用 BINDER*SET*CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；\n2. Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。\n3. Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。\n\n我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：\n\n![img](/images/client_server_service_manager.jpg)\n\n\n\n### Binder 通信中的代理模式\n\n我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。\n\n前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。\n\n当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。\n\n![img](/images/binder_data_trans.jpg)\n\n\n\n### Binder的完整定义\n\n现在我们可以对 Binder 做个更加全面的定义了：\n\n- 从进程间通信的角度看，Binder 是一种进程间通信的机制；\n- 从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；\n- 从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理\n- 从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。\n\n\n\n## 实现Binder跨进程通信\n\n一般Android上，使用**AIDL(Android Interface Definition Language)**来实现跨进程通信协议。AIDL主要是对接口进行描述的，包括定义Server为Client提供那些操作服务。通过AIDL文件，Android Studio在编译时候，会自动产生接口类以及代理类。\n\n除了通过AIDL的方式，我们还可以自己手动编写接口类和代理类。\n\n代码请参考[TheBinder](https://github.com/boybeak/TheBinder)，这里展示了两种方式实现Binder IPC。\n\n代码中涉及到了一些Java类。\n\n- **IBinder** : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输。\n- **IInterface** : IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）\n- **Binder** : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。\n- **Stub** : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。\n\n\n\n## 自己实现\n\n代码请参考[TheBinder](https://github.com/boybeak/TheBinder)\n\n代码中有两个module: **withAIDL**和**noAIDL**，分别演示了使用AIDL的方式和不使用ADIL的方式进行Binder IPC。\n\n**NoAIDL**相比**WithAIDL**有一个优点，就是可以在对应的`IInterface`文件中，添加一些自定义的代码，比如添加log代码；由于AIDL的方式是自动生成的代码，所以这些自定义代码是没法添加到对应的`IInterface`文件中。\n\n我们重点关注**noAIDL**\n\n```kotlin\n//INoAIDL.kt\ninterface INoAIDL : IInterface {\n  fun sayHi(name: String)\n  fun showObjN(objN: ObjN): ObjN?\n\n  companion object {\n    private val TAG = INoAIDL::class.java.simpleName\n    private val DESCRIPTOR = INoAIDL::class.java.name\n\n    abstract class Stub : Binder(), INoAIDL {...}\n    class Proxy(private val remote: IBinder) : INoAIDL {...}\n  }\n}\n```\n\n`INoAIDL.kt`文件的大体结构如上代码，我们可以看到，在这个`IInterface`类中：\n\n- 定义两个Server端承诺的服务——`sayHi`和`showObjN`；\n- 两个静态类——一个Stub类和一个Proxy类。\n\n**Stub类**\n\n```kotlin\nabstract class Stub : Binder(), INoAIDL {\n\n  companion object {\n    const val TRANSACTION_sayHi = IBinder.FIRST_CALL_TRANSACTION + 0\n    const val TRANSACTION_showObjN = IBinder.FIRST_CALL_TRANSACTION + 1\n\n    fun asInterface(binder: IBinder?): INoAIDL? {\n      if (binder == null) {\n        return null\n      }\n      val iin = binder.queryLocalInterface(DESCRIPTOR)\n      if (iin != null && iin is INoAIDL) {\n        Log.v(TAG, \"Client and Server in the same Process\")\n        return iin\n      }\n      Log.v(TAG, \"Client and Server in different Processes\")\n      return Proxy(binder)\n    }\n  }\n\n  init {\n    attachInterface(this, DESCRIPTOR)\n  }\n\n  final override fun attachInterface(owner: IInterface?, descriptor: String?) {\n    super.attachInterface(owner, descriptor)\n  }\n\n  override fun onTransact(code: Int, data: Parcel, reply: Parcel?, flags: Int): Boolean {\n    val descriptor = DESCRIPTOR\n    return when(code) {\n      INTERFACE_TRANSACTION -> {\n        reply?.writeString(descriptor)\n        true\n      }\n      TRANSACTION_sayHi -> {\n        data.enforceInterface(descriptor)\n        val name = data.readString() ?: \"\"\n        sayHi(name)\n        reply?.writeNoException()\n        true\n      }\n      TRANSACTION_showObjN -> {\n        data.enforceInterface(descriptor)\n        var objN: ObjN? = null\n        if (0 != data.readInt()) {\n          objN = ObjN.CREATOR.createFromParcel(data)\n        }\n        val _result = showObjN(objN!!)\n        reply?.writeNoException()\n        if (_result != null) {\n          reply?.writeInt(1)\n          _result.writeToParcel(reply, Parcelable.PARCELABLE_WRITE_RETURN_VALUE)\n        } else {\n          reply?.writeInt(0)\n        }\n        true\n      }\n      else -> {\n        super.onTransact(code, data, reply, flags)\n      }\n    }\n  }\n\n  override fun asBinder(): IBinder {\n    return this\n  }\n}\n```\n\n在Manifest文件中我们定义对应Service\n\n```xml\n<service\n  android:name=\".NoAIDLService\"\n  android:enabled=\"true\"\n  android:exported=\"true\"\n  />\n  <!--android:process=\":noAIDL\"-->\n\t<!--把上述属性设置到service中，则是在不同进程中运行-->\n```\n\n我们重点关注`asInterface`方法，在这个方法中，有一个代码片段：\n\n```kotlin\nval iin = binder.queryLocalInterface(DESCRIPTOR)\nif (iin != null && iin is INoAIDL) {\n\tLog.v(TAG, \"Client and Server in the same Process\")\n  return iin\n}\nLog.v(TAG, \"Client and Server in different Processes\")\nreturn Proxy(binder)\n```\n\n通过这样的代码来进行Client和Server是否在不同进程的判断。\n\n- 相同进程：返回`queryLocalInterface`出来的对象，这个对象是在`Stub`构造方法中通过`attachInterface`方法传入的。\n- 不同进程：构造一个`Proxy`类返回。\n\nMainActivity去bind一个Service，Service返回一个Binder。我们打印一下日志。\n\n```kotlin\nclass NoAIDLService : Service() {\n  override fun onBind(intent: Intent): IBinder {\n    return binder.also {\n      Log.v(TAG, \"onBind=$it\")\n    }\n  }\n}\n```\n\n```kotlin\nprivate var noAIDL: INoAIDL? = null\nprivate val noConnection = object : ServiceConnection {\n  override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n    service ?: return\n    Log.v(TAG, \"onServiceConnected service=$service\")\n    noAIDL = INoAIDL.Companion.Stub.asInterface(service)\n    Toast.makeText(this@MainActivity, \"connected to NoAIDLService\", Toast.LENGTH_SHORT).show()\n    Log.v(TAG, \"onServiceConnected noAIDL=${noAIDL}\")\n  }\n}\n\n```\n\n当Client与Server在相同进程，有如下日志：\n\n```\n// NoAIDLService\nonBind=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc\n\n// MainActivity\nonServiceConnected service=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc\nnoAIDL=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc\n```\n\n当Client与Server在不同进程，有如下日志：\n\n```\n// NoAIDLService\nonBind=com.github.boybeak.noaidl.NoAIDLService$binder$1@2d32060\n\n// MainActivity\nonServiceConnected service=android.os.BinderProxy@99b42f6\nnoAIDL=com.github.boybeak.noaidl.INoAIDL$Companion$Proxy@67e8964\n```\n\n我们看到，当Client与Server在相同进程时候，Service的`onBind`方法返回的是什么，MainActivity接收到的就是什么；而当Client与Server在不同进程的时候，则返回的是Binder驱动传递给我们的对象，通过这个对象，我们创造一个 Proxy代理对象。\n\n\n\n我们接下来重点关注`showObjN`方法。\n\n```kotlin\nprivate val binder = object : INoAIDL.Companion.Stub() {\n  override fun showObjN(objN: ObjN): ObjN? {\n    Log.v(TAG, \"showObjN objN=$objN\")\n    return objN\n  }\n}\n```\n\n这个方法中，直接返回传入的参数。\n\n调用的地方这样来写：\n\n```kotlin\nfun showObjN(v: View) {\n  if (noAIDL == null) {\n    Toast.makeText(this, \"Click NOAIDL button first\", Toast.LENGTH_SHORT).show()\n    return\n  }\n  val objN = ObjN()\n  Log.v(TAG, \"showObjN objN=$objN\")\n  val returnObjN = noAIDL?.showObjN(objN)\n  Log.v(TAG, \"showObjN returnObjW=$returnObjN\")\n}\n```\n\n我们来看打印的`objN`日志。\n\n**相同进程情况下：**\n\n```\n// Client进程\ncom.github.boybeak.binder V/MainActivity: showObjN objN=com.github.boybeak.noaidl.ObjN@4c7d499\ncom.github.boybeak.binder V/MainActivity: showObjN returnObjW=com.github.boybeak.noaidl.ObjN@4c7d499\n\n// Server进程\ncom.github.boybeak.binder V/NoAIDLService: showObjN objN=com.github.boybeak.noaidl.ObjN@4c7d499\n```\n\n\n\n**不同进程情况下：**\n\n```\n// Client进程\ncom.github.boybeak.binder V/MainActivity: showObjN objN=com.github.boybeak.noaidl.ObjN@5ab3a61\ncom.github.boybeak.binder V/MainActivity: showObjN returnObjW=com.github.boybeak.noaidl.ObjN@db79986\n\n// Server进程\ncom.github.boybeak.binder V/NoAIDLService: showObjN objN=com.github.boybeak.noaidl.ObjN@1c5381d\n```\n\n\n\n我们可以看到，在相同进程情况下，就是普通的函数调用；在不同进程情况下，Client传入的参数，Server接收到的参数，Client接收到的返回结果，全是不同的对象，这是因为，通过Proxy对象，在跨进程通信时候，将Parcelable对象进行了序列化和反序列化。\n\n\n\n本文是在阅读[**写给 Android 应用工程师的 Binder 原理剖析**](https://zhuanlan.zhihu.com/p/35519585)一文后，加上自己的理解与实验完成，其中部分段落直接复制了原文，因为我觉得，那部分原文已经足够容易理解且没有冗余的文字，感谢原作者[**张磊**](https://www.zhihu.com/people/BaronZ88)，同时附上原文参考资料：\n\n- [Android Binder 设计与实现 - 设计篇](https://link.zhihu.com/?target=http%3A//blog.csdn.net/universus/article/details/6211589)\n- [Android 进程间通信（IPC）机制 Binder 简要介绍和学习计划](https://link.zhihu.com/?target=http%3A//blog.csdn.net/luoshengyang/article/details/6618363)、[《Android 系统源代码情景分析》](https://link.zhihu.com/?target=http%3A//item.jd.com/12248208.html)\n- [Binder 学习指南](https://link.zhihu.com/?target=http%3A//weishu.me/2016/01/12/binder-index-for-newer/)\n- [Binder 系列文章](https://link.zhihu.com/?target=http%3A//gityuan.com/2015/10/31/binder-prepare/)\n- [Android 图文详解 Binder 跨进程通信原理](https://link.zhihu.com/?target=https%3A//blog.csdn.net/carson_ho/article/details/73560642)\n- [Android 深入浅出之 Binder 机制](https://link.zhihu.com/?target=http%3A//www.cnblogs.com/innost/archive/2011/01/09/1931456.html)\n- [用户空间与内核空间](https://link.zhihu.com/?target=http%3A//www.cnblogs.com/Anker/p/3269106.html)\n- [认真分析 mmap ：是什么 为什么 怎么用](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/huxiao-tee/p/4660352.html)\n\n","slug":"2022-09-19-Binder机制分析","published":1,"date":"2020-10-20T12:00:09.000Z","updated":"2023-02-05T04:18:23.479Z","_id":"cldqukh990014pcjge58fb4hb","comments":1,"photos":[],"link":"","content":"<p>参考文章：<a href=\"https://zhuanlan.zhihu.com/p/35519585\">写给 Android 应用工程师的 Binder 原理剖析</a></p>\n<p>实验代码：<a href=\"https://github.com/boybeak/TheBinder\">TheBinder</a></p>\n<p>Binder机制可以说是Android的核心。提到Binder，可能会让你想到，通过bindService与<code>Service</code>进行通信(也可能是跨进程的通信)，实际上，Android中Binder的使用可以说是无处不在的，包括Activity跳转，详情可以参考<a href=\"https://boybeak.github.io/android/AMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html\">AMS启动流程</a>。</p>\n<h2 id=\"为什么要用Binder\"><a href=\"#为什么要用Binder\" class=\"headerlink\" title=\"为什么要用Binder?\"></a>为什么要用Binder?</h2><p>在Linux系统中，跨进程通信(IPC)方式有很多种，包括Socket、管道、共享内存等。可以Android为何最后选择Binder作为核心的跨进程通信的手段呢？</p>\n<p>这需要从两方面去分析——<strong>性能</strong>和<strong>安全性</strong>。</p>\n<h3 id=\"1-性能\"><a href=\"#1-性能\" class=\"headerlink\" title=\"1. 性能\"></a>1. 性能</h3><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</p>\n<h3 id=\"2-安全性\"><a href=\"#2-安全性\" class=\"headerlink\" title=\"2. 安全性\"></a>2. 安全性</h3><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID&#x2F;进程ID（UID&#x2F;PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID&#x2F;PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>\n<p>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。</p>\n<p>用一张表格来总结与对比各种IPC方式。</p>\n<table>\n<thead>\n<tr>\n<th>IPC方式</th>\n<th>性能(内存拷贝次数)</th>\n<th>安全性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Binder</td>\n<td>1</td>\n<td>通过UID&#x2F;PID来保证</td>\n</tr>\n<tr>\n<td>共享内存</td>\n<td>0</td>\n<td>操作非常复杂，难以保证</td>\n</tr>\n<tr>\n<td>Socket&#x2F;管道&#x2F;消息队列</td>\n<td>2</td>\n<td>依靠上层协议做身份识别，非常不可靠</td>\n</tr>\n</tbody></table>\n<h2 id=\"传统IPC是什么样的？\"><a href=\"#传统IPC是什么样的？\" class=\"headerlink\" title=\"传统IPC是什么样的？\"></a>传统IPC是什么样的？</h2><p>先要了解一些基本概念——<strong>进程隔离</strong>、<strong>用户空间</strong>、<strong>内核空间</strong>、<strong>用户态</strong>、<strong>内核态</strong>。</p>\n<p><img src=\"/images/traditional_ipc.jpg\" alt=\"IPC\"></p>\n<p>上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：</p>\n<ul>\n<li>进程隔离</li>\n<li>进程空间划分：用户空间(User Space)&#x2F;内核空间(Kernel Space)</li>\n<li>系统调用：用户态&#x2F;内核态</li>\n</ul>\n<h3 id=\"进程隔离\"><a href=\"#进程隔离\" class=\"headerlink\" title=\"进程隔离\"></a>进程隔离</h3><p>顾名思义，就是进程之间内存是不共享的。进程间要进行数据交换，就得采用**进程间通信(IPC)**机制。</p>\n<h3 id=\"进程空间划分：用户空间-User-Space-x2F-内核空间-Kernel-Space\"><a href=\"#进程空间划分：用户空间-User-Space-x2F-内核空间-Kernel-Space\" class=\"headerlink\" title=\"进程空间划分：用户空间(User Space)&#x2F;内核空间(Kernel Space)\"></a>进程空间划分：用户空间(User Space)&#x2F;内核空间(Kernel Space)</h3><p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>\n<blockquote>\n<p>简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。</p>\n</blockquote>\n<p><img src=\"/images/linux_memory.png\" alt=\"linux memory\"></p>\n<h3 id=\"系统调用：用户态-x2F-内核态\"><a href=\"#系统调用：用户态-x2F-内核态\" class=\"headerlink\" title=\"系统调用：用户态&#x2F;内核态\"></a>系统调用：用户态&#x2F;内核态</h3><p>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助<strong>系统调用</strong>来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>\n<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>\n<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于<strong>内核运行态（内核态）</strong>。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>\n<p>当进程在执行用户自己的代码的时候，我们称其处于<strong>用户运行态（用户态）</strong>。此时处理器在特权级最低的（3级）用户代码中运行。</p>\n<p>系统调用主要通过如下两个函数来实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy_from_user() //将数据从用户空间拷贝到内核空间</span><br><span class=\"line\">copy_to_user() //将数据从内核空间拷贝到用户空间</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Linux下传统IPC通信\"><a href=\"#Linux下传统IPC通信\" class=\"headerlink\" title=\"Linux下传统IPC通信\"></a>Linux下传统IPC通信</h3><p><img src=\"/images/linux_ipc.jpg\" alt=\"linux ipc\"></p>\n<p><strong>数据发送进程</strong>：开辟用户空间缓存区 -&gt; 系统调用，进入内核态 -&gt; 开辟内核空间缓存区 -&gt;通过<code>copy_from_user()</code>将数据拷贝到内核空间缓存区。</p>\n<p><strong>数据接收进程</strong>：开辟用户空间缓存区 -&gt; 调用<code>copytouser()</code>将数据从内核缓存区拷贝到用户空间缓存区。</p>\n<p>这样，两个进程就完成了依次进程间通信。</p>\n<p>这种传统的 IPC 通信方式有两个问题：</p>\n<ol>\n<li>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>\n<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>\n</ol>\n<h2 id=\"Binder跨进程通信原理\"><a href=\"#Binder跨进程通信原理\" class=\"headerlink\" title=\"Binder跨进程通信原理\"></a>Binder跨进程通信原理</h2><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的<strong>动态内核可加载模块</strong>（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>\n<blockquote>\n<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 <strong>Binder 驱动</strong>（Binder Dirver）。</p>\n</blockquote>\n<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。</p>\n<p>这就不得不通道 Linux 下的另一个概念：<strong>内存映射</strong>。</p>\n<p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>\n<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>\n<h3 id=\"Binder-IPC实现原理\"><a href=\"#Binder-IPC实现原理\" class=\"headerlink\" title=\"Binder IPC实现原理\"></a>Binder IPC实现原理</h3><p>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</p>\n<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I&#x2F;O读写，提高文件读取效率。</p>\n<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。</p>\n<p>一次完整的 Binder IPC 通信过程通常是这样：</p>\n<ol>\n<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>\n<li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>\n<li>发送方进程通过系统调用 copy<em>from</em>user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>\n</ol>\n<p>如下图：</p>\n<p><img src=\"/images/binder.jpg\" alt=\"binder\"></p>\n<p>注意图中两个红色虚线。我们从图中可以看到，内核空间开辟了两个缓存区——<strong>内核缓存区</strong>和<strong>数据接收缓存区</strong>，这两个缓存区之间存在内存映射，然后<strong>数据接收缓存区</strong>与<strong>数据接收进程的用户空间缓存区</strong>同样有内存映射。当数据发送进程通过<code>copy_from_user()</code>将数据拷贝到<strong>内核缓存区</strong>的时候，存在映射关系的数据接收进程用户空间缓存区也就收到了数据。</p>\n<h2 id=\"Binder通信模型\"><a href=\"#Binder通信模型\" class=\"headerlink\" title=\"Binder通信模型\"></a>Binder通信模型</h2><p>跨进程通讯至少包含两个进程，我们将数据发送进程称为<strong>Client</strong>，把数据接收方称为<strong>Server</strong>。</p>\n<h3 id=\"Client-x2F-Server-x2F-ServiceManager-x2F-驱动\"><a href=\"#Client-x2F-Server-x2F-ServiceManager-x2F-驱动\" class=\"headerlink\" title=\"Client&#x2F;Server&#x2F;ServiceManager&#x2F;驱动\"></a>Client&#x2F;Server&#x2F;ServiceManager&#x2F;驱动</h3><p>前面我们介绍过，Binder 是基于 C&#x2F;S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 &#x2F;dev&#x2F;binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>\n<p><img src=\"/images/android_binder.jpg\" alt=\"img\"></p>\n<p><a href=\"https://link.zhihu.com/?target=http://blog.csdn.net/universus/article/details/6211589\">Android Binder 设计与实现</a><em>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</em></p>\n<blockquote>\n<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p>\n<p><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p>\n<p>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p>\n<p><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>\n</blockquote>\n<h3 id=\"Binder通信过程\"><a href=\"#Binder通信过程\" class=\"headerlink\" title=\"Binder通信过程\"></a>Binder通信过程</h3><p>至此，我们大致能总结出 Binder 通信过程：</p>\n<ol>\n<li>首先，一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>\n<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>\n<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>\n</ol>\n<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>\n<p><img src=\"/images/client_server_service_manager.jpg\" alt=\"img\"></p>\n<h3 id=\"Binder-通信中的代理模式\"><a href=\"#Binder-通信中的代理模式\" class=\"headerlink\" title=\"Binder 通信中的代理模式\"></a>Binder 通信中的代理模式</h3><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。</p>\n<p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>\n<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>\n<p><img src=\"/images/binder_data_trans.jpg\" alt=\"img\"></p>\n<h3 id=\"Binder的完整定义\"><a href=\"#Binder的完整定义\" class=\"headerlink\" title=\"Binder的完整定义\"></a>Binder的完整定义</h3><p>现在我们可以对 Binder 做个更加全面的定义了：</p>\n<ul>\n<li>从进程间通信的角度看，Binder 是一种进程间通信的机制；</li>\n<li>从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；</li>\n<li>从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理</li>\n<li>从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。</li>\n</ul>\n<h2 id=\"实现Binder跨进程通信\"><a href=\"#实现Binder跨进程通信\" class=\"headerlink\" title=\"实现Binder跨进程通信\"></a>实现Binder跨进程通信</h2><p>一般Android上，使用**AIDL(Android Interface Definition Language)**来实现跨进程通信协议。AIDL主要是对接口进行描述的，包括定义Server为Client提供那些操作服务。通过AIDL文件，Android Studio在编译时候，会自动产生接口类以及代理类。</p>\n<p>除了通过AIDL的方式，我们还可以自己手动编写接口类和代理类。</p>\n<p>代码请参考<a href=\"https://github.com/boybeak/TheBinder\">TheBinder</a>，这里展示了两种方式实现Binder IPC。</p>\n<p>代码中涉及到了一些Java类。</p>\n<ul>\n<li><strong>IBinder</strong> : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输。</li>\n<li><strong>IInterface</strong> : IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）</li>\n<li><strong>Binder</strong> : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。</li>\n<li><strong>Stub</strong> : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。</li>\n</ul>\n<h2 id=\"自己实现\"><a href=\"#自己实现\" class=\"headerlink\" title=\"自己实现\"></a>自己实现</h2><p>代码请参考<a href=\"https://github.com/boybeak/TheBinder\">TheBinder</a></p>\n<p>代码中有两个module: <strong>withAIDL</strong>和<strong>noAIDL</strong>，分别演示了使用AIDL的方式和不使用ADIL的方式进行Binder IPC。</p>\n<p><strong>NoAIDL</strong>相比<strong>WithAIDL</strong>有一个优点，就是可以在对应的<code>IInterface</code>文件中，添加一些自定义的代码，比如添加log代码；由于AIDL的方式是自动生成的代码，所以这些自定义代码是没法添加到对应的<code>IInterface</code>文件中。</p>\n<p>我们重点关注<strong>noAIDL</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//INoAIDL.kt</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">INoAIDL</span> : <span class=\"type\">IInterface</span> &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">sayHi</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">showObjN</span><span class=\"params\">(objN: <span class=\"type\">ObjN</span>)</span></span>: ObjN?</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> TAG = INoAIDL::<span class=\"keyword\">class</span>.java.simpleName</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> DESCRIPTOR = INoAIDL::<span class=\"keyword\">class</span>.java.name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stub</span> : <span class=\"type\">Binder</span>(), INoAIDL &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Proxy</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> remote: IBinder) : INoAIDL &#123;...&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>INoAIDL.kt</code>文件的大体结构如上代码，我们可以看到，在这个<code>IInterface</code>类中：</p>\n<ul>\n<li>定义两个Server端承诺的服务——<code>sayHi</code>和<code>showObjN</code>；</li>\n<li>两个静态类——一个Stub类和一个Proxy类。</li>\n</ul>\n<p><strong>Stub类</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stub</span> : <span class=\"type\">Binder</span>(), INoAIDL &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> TRANSACTION_sayHi = IBinder.FIRST_CALL_TRANSACTION + <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> TRANSACTION_showObjN = IBinder.FIRST_CALL_TRANSACTION + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">asInterface</span><span class=\"params\">(binder: <span class=\"type\">IBinder</span>?)</span></span>: INoAIDL? &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (binder == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> iin = binder.queryLocalInterface(DESCRIPTOR)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (iin != <span class=\"literal\">null</span> &amp;&amp; iin <span class=\"keyword\">is</span> INoAIDL) &#123;</span><br><span class=\"line\">        Log.v(TAG, <span class=\"string\">&quot;Client and Server in the same Process&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> iin</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      Log.v(TAG, <span class=\"string\">&quot;Client and Server in different Processes&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Proxy(binder)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">    attachInterface(<span class=\"keyword\">this</span>, DESCRIPTOR)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">attachInterface</span><span class=\"params\">(owner: <span class=\"type\">IInterface</span>?, descriptor: <span class=\"type\">String</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.attachInterface(owner, descriptor)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onTransact</span><span class=\"params\">(code: <span class=\"type\">Int</span>, <span class=\"keyword\">data</span>: <span class=\"type\">Parcel</span>, reply: <span class=\"type\">Parcel</span>?, flags: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> descriptor = DESCRIPTOR</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">when</span>(code) &#123;</span><br><span class=\"line\">      INTERFACE_TRANSACTION -&gt; &#123;</span><br><span class=\"line\">        reply?.writeString(descriptor)</span><br><span class=\"line\">        <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      TRANSACTION_sayHi -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">data</span>.enforceInterface(descriptor)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> name = <span class=\"keyword\">data</span>.readString() ?: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        sayHi(name)</span><br><span class=\"line\">        reply?.writeNoException()</span><br><span class=\"line\">        <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      TRANSACTION_showObjN -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">data</span>.enforceInterface(descriptor)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> objN: ObjN? = <span class=\"literal\">null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != <span class=\"keyword\">data</span>.readInt()) &#123;</span><br><span class=\"line\">          objN = ObjN.CREATOR.createFromParcel(<span class=\"keyword\">data</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> _result = showObjN(objN!!)</span><br><span class=\"line\">        reply?.writeNoException()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_result != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          reply?.writeInt(<span class=\"number\">1</span>)</span><br><span class=\"line\">          _result.writeToParcel(reply, Parcelable.PARCELABLE_WRITE_RETURN_VALUE)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          reply?.writeInt(<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onTransact(code, <span class=\"keyword\">data</span>, reply, flags)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">asBinder</span><span class=\"params\">()</span></span>: IBinder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Manifest文件中我们定义对应Service</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.NoAIDLService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:enabled</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  /&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--android:process=&quot;:noAIDL&quot;--&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--把上述属性设置到service中，则是在不同进程中运行--&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们重点关注<code>asInterface</code>方法，在这个方法中，有一个代码片段：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> iin = binder.queryLocalInterface(DESCRIPTOR)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (iin != <span class=\"literal\">null</span> &amp;&amp; iin <span class=\"keyword\">is</span> INoAIDL) &#123;</span><br><span class=\"line\">\tLog.v(TAG, <span class=\"string\">&quot;Client and Server in the same Process&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> iin</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Log.v(TAG, <span class=\"string\">&quot;Client and Server in different Processes&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">return</span> Proxy(binder)</span><br></pre></td></tr></table></figure>\n\n<p>通过这样的代码来进行Client和Server是否在不同进程的判断。</p>\n<ul>\n<li>相同进程：返回<code>queryLocalInterface</code>出来的对象，这个对象是在<code>Stub</code>构造方法中通过<code>attachInterface</code>方法传入的。</li>\n<li>不同进程：构造一个<code>Proxy</code>类返回。</li>\n</ul>\n<p>MainActivity去bind一个Service，Service返回一个Binder。我们打印一下日志。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NoAIDLService</span> : <span class=\"type\">Service</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onBind</span><span class=\"params\">(intent: <span class=\"type\">Intent</span>)</span></span>: IBinder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> binder.also &#123;</span><br><span class=\"line\">      Log.v(TAG, <span class=\"string\">&quot;onBind=<span class=\"variable\">$it</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> noAIDL: INoAIDL? = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> noConnection = <span class=\"keyword\">object</span> : ServiceConnection &#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(name: <span class=\"type\">ComponentName</span>?, service: <span class=\"type\">IBinder</span>?)</span></span> &#123;</span><br><span class=\"line\">    service ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">    Log.v(TAG, <span class=\"string\">&quot;onServiceConnected service=<span class=\"variable\">$service</span>&quot;</span>)</span><br><span class=\"line\">    noAIDL = INoAIDL.Companion.Stub.asInterface(service)</span><br><span class=\"line\">    Toast.makeText(<span class=\"keyword\">this</span><span class=\"symbol\">@MainActivity</span>, <span class=\"string\">&quot;connected to NoAIDLService&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class=\"line\">    Log.v(TAG, <span class=\"string\">&quot;onServiceConnected noAIDL=<span class=\"subst\">$&#123;noAIDL&#125;</span>&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当Client与Server在相同进程，有如下日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// NoAIDLService</span><br><span class=\"line\">onBind=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc</span><br><span class=\"line\"></span><br><span class=\"line\">// MainActivity</span><br><span class=\"line\">onServiceConnected service=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc</span><br><span class=\"line\">noAIDL=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc</span><br></pre></td></tr></table></figure>\n\n<p>当Client与Server在不同进程，有如下日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// NoAIDLService</span><br><span class=\"line\">onBind=com.github.boybeak.noaidl.NoAIDLService$binder$1@2d32060</span><br><span class=\"line\"></span><br><span class=\"line\">// MainActivity</span><br><span class=\"line\">onServiceConnected service=android.os.BinderProxy@99b42f6</span><br><span class=\"line\">noAIDL=com.github.boybeak.noaidl.INoAIDL$Companion$Proxy@67e8964</span><br></pre></td></tr></table></figure>\n\n<p>我们看到，当Client与Server在相同进程时候，Service的<code>onBind</code>方法返回的是什么，MainActivity接收到的就是什么；而当Client与Server在不同进程的时候，则返回的是Binder驱动传递给我们的对象，通过这个对象，我们创造一个 Proxy代理对象。</p>\n<p>我们接下来重点关注<code>showObjN</code>方法。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> binder = <span class=\"keyword\">object</span> : INoAIDL.Companion.Stub() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">showObjN</span><span class=\"params\">(objN: <span class=\"type\">ObjN</span>)</span></span>: ObjN? &#123;</span><br><span class=\"line\">    Log.v(TAG, <span class=\"string\">&quot;showObjN objN=<span class=\"variable\">$objN</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objN</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法中，直接返回传入的参数。</p>\n<p>调用的地方这样来写：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">showObjN</span><span class=\"params\">(v: <span class=\"type\">View</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (noAIDL == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">&quot;Click NOAIDL button first&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> objN = ObjN()</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;showObjN objN=<span class=\"variable\">$objN</span>&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">val</span> returnObjN = noAIDL?.showObjN(objN)</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;showObjN returnObjW=<span class=\"variable\">$returnObjN</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看打印的<code>objN</code>日志。</p>\n<p><strong>相同进程情况下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Client进程</span><br><span class=\"line\">com.github.boybeak.binder V/MainActivity: showObjN objN=com.github.boybeak.noaidl.ObjN@4c7d499</span><br><span class=\"line\">com.github.boybeak.binder V/MainActivity: showObjN returnObjW=com.github.boybeak.noaidl.ObjN@4c7d499</span><br><span class=\"line\"></span><br><span class=\"line\">// Server进程</span><br><span class=\"line\">com.github.boybeak.binder V/NoAIDLService: showObjN objN=com.github.boybeak.noaidl.ObjN@4c7d499</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>不同进程情况下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Client进程</span><br><span class=\"line\">com.github.boybeak.binder V/MainActivity: showObjN objN=com.github.boybeak.noaidl.ObjN@5ab3a61</span><br><span class=\"line\">com.github.boybeak.binder V/MainActivity: showObjN returnObjW=com.github.boybeak.noaidl.ObjN@db79986</span><br><span class=\"line\"></span><br><span class=\"line\">// Server进程</span><br><span class=\"line\">com.github.boybeak.binder V/NoAIDLService: showObjN objN=com.github.boybeak.noaidl.ObjN@1c5381d</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们可以看到，在相同进程情况下，就是普通的函数调用；在不同进程情况下，Client传入的参数，Server接收到的参数，Client接收到的返回结果，全是不同的对象，这是因为，通过Proxy对象，在跨进程通信时候，将Parcelable对象进行了序列化和反序列化。</p>\n<p>本文是在阅读<a href=\"https://zhuanlan.zhihu.com/p/35519585\"><strong>写给 Android 应用工程师的 Binder 原理剖析</strong></a>一文后，加上自己的理解与实验完成，其中部分段落直接复制了原文，因为我觉得，那部分原文已经足够容易理解且没有冗余的文字，感谢原作者<a href=\"https://www.zhihu.com/people/BaronZ88\"><strong>张磊</strong></a>，同时附上原文参考资料：</p>\n<ul>\n<li><a href=\"https://link.zhihu.com/?target=http://blog.csdn.net/universus/article/details/6211589\">Android Binder 设计与实现 - 设计篇</a></li>\n<li><a href=\"https://link.zhihu.com/?target=http://blog.csdn.net/luoshengyang/article/details/6618363\">Android 进程间通信（IPC）机制 Binder 简要介绍和学习计划</a>、<a href=\"https://link.zhihu.com/?target=http://item.jd.com/12248208.html\">《Android 系统源代码情景分析》</a></li>\n<li><a href=\"https://link.zhihu.com/?target=http://weishu.me/2016/01/12/binder-index-for-newer/\">Binder 学习指南</a></li>\n<li><a href=\"https://link.zhihu.com/?target=http://gityuan.com/2015/10/31/binder-prepare/\">Binder 系列文章</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https://blog.csdn.net/carson_ho/article/details/73560642\">Android 图文详解 Binder 跨进程通信原理</a></li>\n<li><a href=\"https://link.zhihu.com/?target=http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html\">Android 深入浅出之 Binder 机制</a></li>\n<li><a href=\"https://link.zhihu.com/?target=http://www.cnblogs.com/Anker/p/3269106.html\">用户空间与内核空间</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https://www.cnblogs.com/huxiao-tee/p/4660352.html\">认真分析 mmap ：是什么 为什么 怎么用</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>参考文章：<a href=\"https://zhuanlan.zhihu.com/p/35519585\">写给 Android 应用工程师的 Binder 原理剖析</a></p>\n<p>实验代码：<a href=\"https://github.com/boybeak/TheBinder\">TheBinder</a></p>\n<p>Binder机制可以说是Android的核心。提到Binder，可能会让你想到，通过bindService与<code>Service</code>进行通信(也可能是跨进程的通信)，实际上，Android中Binder的使用可以说是无处不在的，包括Activity跳转，详情可以参考<a href=\"https://boybeak.github.io/android/AMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html\">AMS启动流程</a>。</p>\n<h2 id=\"为什么要用Binder\"><a href=\"#为什么要用Binder\" class=\"headerlink\" title=\"为什么要用Binder?\"></a>为什么要用Binder?</h2><p>在Linux系统中，跨进程通信(IPC)方式有很多种，包括Socket、管道、共享内存等。可以Android为何最后选择Binder作为核心的跨进程通信的手段呢？</p>\n<p>这需要从两方面去分析——<strong>性能</strong>和<strong>安全性</strong>。</p>\n<h3 id=\"1-性能\"><a href=\"#1-性能\" class=\"headerlink\" title=\"1. 性能\"></a>1. 性能</h3><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</p>\n<h3 id=\"2-安全性\"><a href=\"#2-安全性\" class=\"headerlink\" title=\"2. 安全性\"></a>2. 安全性</h3><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID&#x2F;进程ID（UID&#x2F;PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID&#x2F;PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>\n<p>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。</p>\n<p>用一张表格来总结与对比各种IPC方式。</p>\n<table>\n<thead>\n<tr>\n<th>IPC方式</th>\n<th>性能(内存拷贝次数)</th>\n<th>安全性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Binder</td>\n<td>1</td>\n<td>通过UID&#x2F;PID来保证</td>\n</tr>\n<tr>\n<td>共享内存</td>\n<td>0</td>\n<td>操作非常复杂，难以保证</td>\n</tr>\n<tr>\n<td>Socket&#x2F;管道&#x2F;消息队列</td>\n<td>2</td>\n<td>依靠上层协议做身份识别，非常不可靠</td>\n</tr>\n</tbody></table>\n<h2 id=\"传统IPC是什么样的？\"><a href=\"#传统IPC是什么样的？\" class=\"headerlink\" title=\"传统IPC是什么样的？\"></a>传统IPC是什么样的？</h2><p>先要了解一些基本概念——<strong>进程隔离</strong>、<strong>用户空间</strong>、<strong>内核空间</strong>、<strong>用户态</strong>、<strong>内核态</strong>。</p>\n<p><img src=\"/images/traditional_ipc.jpg\" alt=\"IPC\"></p>\n<p>上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：</p>\n<ul>\n<li>进程隔离</li>\n<li>进程空间划分：用户空间(User Space)&#x2F;内核空间(Kernel Space)</li>\n<li>系统调用：用户态&#x2F;内核态</li>\n</ul>\n<h3 id=\"进程隔离\"><a href=\"#进程隔离\" class=\"headerlink\" title=\"进程隔离\"></a>进程隔离</h3><p>顾名思义，就是进程之间内存是不共享的。进程间要进行数据交换，就得采用**进程间通信(IPC)**机制。</p>\n<h3 id=\"进程空间划分：用户空间-User-Space-x2F-内核空间-Kernel-Space\"><a href=\"#进程空间划分：用户空间-User-Space-x2F-内核空间-Kernel-Space\" class=\"headerlink\" title=\"进程空间划分：用户空间(User Space)&#x2F;内核空间(Kernel Space)\"></a>进程空间划分：用户空间(User Space)&#x2F;内核空间(Kernel Space)</h3><p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>\n<blockquote>\n<p>简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。</p>\n</blockquote>\n<p><img src=\"/images/linux_memory.png\" alt=\"linux memory\"></p>\n<h3 id=\"系统调用：用户态-x2F-内核态\"><a href=\"#系统调用：用户态-x2F-内核态\" class=\"headerlink\" title=\"系统调用：用户态&#x2F;内核态\"></a>系统调用：用户态&#x2F;内核态</h3><p>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助<strong>系统调用</strong>来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>\n<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>\n<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于<strong>内核运行态（内核态）</strong>。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>\n<p>当进程在执行用户自己的代码的时候，我们称其处于<strong>用户运行态（用户态）</strong>。此时处理器在特权级最低的（3级）用户代码中运行。</p>\n<p>系统调用主要通过如下两个函数来实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy_from_user() //将数据从用户空间拷贝到内核空间</span><br><span class=\"line\">copy_to_user() //将数据从内核空间拷贝到用户空间</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Linux下传统IPC通信\"><a href=\"#Linux下传统IPC通信\" class=\"headerlink\" title=\"Linux下传统IPC通信\"></a>Linux下传统IPC通信</h3><p><img src=\"/images/linux_ipc.jpg\" alt=\"linux ipc\"></p>\n<p><strong>数据发送进程</strong>：开辟用户空间缓存区 -&gt; 系统调用，进入内核态 -&gt; 开辟内核空间缓存区 -&gt;通过<code>copy_from_user()</code>将数据拷贝到内核空间缓存区。</p>\n<p><strong>数据接收进程</strong>：开辟用户空间缓存区 -&gt; 调用<code>copytouser()</code>将数据从内核缓存区拷贝到用户空间缓存区。</p>\n<p>这样，两个进程就完成了依次进程间通信。</p>\n<p>这种传统的 IPC 通信方式有两个问题：</p>\n<ol>\n<li>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>\n<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>\n</ol>\n<h2 id=\"Binder跨进程通信原理\"><a href=\"#Binder跨进程通信原理\" class=\"headerlink\" title=\"Binder跨进程通信原理\"></a>Binder跨进程通信原理</h2><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的<strong>动态内核可加载模块</strong>（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>\n<blockquote>\n<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 <strong>Binder 驱动</strong>（Binder Dirver）。</p>\n</blockquote>\n<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。</p>\n<p>这就不得不通道 Linux 下的另一个概念：<strong>内存映射</strong>。</p>\n<p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>\n<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>\n<h3 id=\"Binder-IPC实现原理\"><a href=\"#Binder-IPC实现原理\" class=\"headerlink\" title=\"Binder IPC实现原理\"></a>Binder IPC实现原理</h3><p>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</p>\n<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I&#x2F;O读写，提高文件读取效率。</p>\n<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。</p>\n<p>一次完整的 Binder IPC 通信过程通常是这样：</p>\n<ol>\n<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>\n<li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>\n<li>发送方进程通过系统调用 copy<em>from</em>user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>\n</ol>\n<p>如下图：</p>\n<p><img src=\"/images/binder.jpg\" alt=\"binder\"></p>\n<p>注意图中两个红色虚线。我们从图中可以看到，内核空间开辟了两个缓存区——<strong>内核缓存区</strong>和<strong>数据接收缓存区</strong>，这两个缓存区之间存在内存映射，然后<strong>数据接收缓存区</strong>与<strong>数据接收进程的用户空间缓存区</strong>同样有内存映射。当数据发送进程通过<code>copy_from_user()</code>将数据拷贝到<strong>内核缓存区</strong>的时候，存在映射关系的数据接收进程用户空间缓存区也就收到了数据。</p>\n<h2 id=\"Binder通信模型\"><a href=\"#Binder通信模型\" class=\"headerlink\" title=\"Binder通信模型\"></a>Binder通信模型</h2><p>跨进程通讯至少包含两个进程，我们将数据发送进程称为<strong>Client</strong>，把数据接收方称为<strong>Server</strong>。</p>\n<h3 id=\"Client-x2F-Server-x2F-ServiceManager-x2F-驱动\"><a href=\"#Client-x2F-Server-x2F-ServiceManager-x2F-驱动\" class=\"headerlink\" title=\"Client&#x2F;Server&#x2F;ServiceManager&#x2F;驱动\"></a>Client&#x2F;Server&#x2F;ServiceManager&#x2F;驱动</h3><p>前面我们介绍过，Binder 是基于 C&#x2F;S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 &#x2F;dev&#x2F;binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>\n<p><img src=\"/images/android_binder.jpg\" alt=\"img\"></p>\n<p><a href=\"https://link.zhihu.com/?target=http://blog.csdn.net/universus/article/details/6211589\">Android Binder 设计与实现</a><em>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</em></p>\n<blockquote>\n<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p>\n<p><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p>\n<p>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p>\n<p><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>\n</blockquote>\n<h3 id=\"Binder通信过程\"><a href=\"#Binder通信过程\" class=\"headerlink\" title=\"Binder通信过程\"></a>Binder通信过程</h3><p>至此，我们大致能总结出 Binder 通信过程：</p>\n<ol>\n<li>首先，一个进程使用 BINDER<em>SET</em>CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>\n<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>\n<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>\n</ol>\n<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>\n<p><img src=\"/images/client_server_service_manager.jpg\" alt=\"img\"></p>\n<h3 id=\"Binder-通信中的代理模式\"><a href=\"#Binder-通信中的代理模式\" class=\"headerlink\" title=\"Binder 通信中的代理模式\"></a>Binder 通信中的代理模式</h3><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。</p>\n<p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>\n<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>\n<p><img src=\"/images/binder_data_trans.jpg\" alt=\"img\"></p>\n<h3 id=\"Binder的完整定义\"><a href=\"#Binder的完整定义\" class=\"headerlink\" title=\"Binder的完整定义\"></a>Binder的完整定义</h3><p>现在我们可以对 Binder 做个更加全面的定义了：</p>\n<ul>\n<li>从进程间通信的角度看，Binder 是一种进程间通信的机制；</li>\n<li>从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；</li>\n<li>从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理</li>\n<li>从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。</li>\n</ul>\n<h2 id=\"实现Binder跨进程通信\"><a href=\"#实现Binder跨进程通信\" class=\"headerlink\" title=\"实现Binder跨进程通信\"></a>实现Binder跨进程通信</h2><p>一般Android上，使用**AIDL(Android Interface Definition Language)**来实现跨进程通信协议。AIDL主要是对接口进行描述的，包括定义Server为Client提供那些操作服务。通过AIDL文件，Android Studio在编译时候，会自动产生接口类以及代理类。</p>\n<p>除了通过AIDL的方式，我们还可以自己手动编写接口类和代理类。</p>\n<p>代码请参考<a href=\"https://github.com/boybeak/TheBinder\">TheBinder</a>，这里展示了两种方式实现Binder IPC。</p>\n<p>代码中涉及到了一些Java类。</p>\n<ul>\n<li><strong>IBinder</strong> : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输。</li>\n<li><strong>IInterface</strong> : IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）</li>\n<li><strong>Binder</strong> : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。</li>\n<li><strong>Stub</strong> : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。</li>\n</ul>\n<h2 id=\"自己实现\"><a href=\"#自己实现\" class=\"headerlink\" title=\"自己实现\"></a>自己实现</h2><p>代码请参考<a href=\"https://github.com/boybeak/TheBinder\">TheBinder</a></p>\n<p>代码中有两个module: <strong>withAIDL</strong>和<strong>noAIDL</strong>，分别演示了使用AIDL的方式和不使用ADIL的方式进行Binder IPC。</p>\n<p><strong>NoAIDL</strong>相比<strong>WithAIDL</strong>有一个优点，就是可以在对应的<code>IInterface</code>文件中，添加一些自定义的代码，比如添加log代码；由于AIDL的方式是自动生成的代码，所以这些自定义代码是没法添加到对应的<code>IInterface</code>文件中。</p>\n<p>我们重点关注<strong>noAIDL</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//INoAIDL.kt</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">INoAIDL</span> : <span class=\"type\">IInterface</span> &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">sayHi</span><span class=\"params\">(name: <span class=\"type\">String</span>)</span></span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">showObjN</span><span class=\"params\">(objN: <span class=\"type\">ObjN</span>)</span></span>: ObjN?</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> TAG = INoAIDL::<span class=\"keyword\">class</span>.java.simpleName</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> DESCRIPTOR = INoAIDL::<span class=\"keyword\">class</span>.java.name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stub</span> : <span class=\"type\">Binder</span>(), INoAIDL &#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Proxy</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> remote: IBinder) : INoAIDL &#123;...&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>INoAIDL.kt</code>文件的大体结构如上代码，我们可以看到，在这个<code>IInterface</code>类中：</p>\n<ul>\n<li>定义两个Server端承诺的服务——<code>sayHi</code>和<code>showObjN</code>；</li>\n<li>两个静态类——一个Stub类和一个Proxy类。</li>\n</ul>\n<p><strong>Stub类</strong></p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stub</span> : <span class=\"type\">Binder</span>(), INoAIDL &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> TRANSACTION_sayHi = IBinder.FIRST_CALL_TRANSACTION + <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> TRANSACTION_showObjN = IBinder.FIRST_CALL_TRANSACTION + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">asInterface</span><span class=\"params\">(binder: <span class=\"type\">IBinder</span>?)</span></span>: INoAIDL? &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (binder == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">val</span> iin = binder.queryLocalInterface(DESCRIPTOR)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (iin != <span class=\"literal\">null</span> &amp;&amp; iin <span class=\"keyword\">is</span> INoAIDL) &#123;</span><br><span class=\"line\">        Log.v(TAG, <span class=\"string\">&quot;Client and Server in the same Process&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> iin</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      Log.v(TAG, <span class=\"string\">&quot;Client and Server in different Processes&quot;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Proxy(binder)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">    attachInterface(<span class=\"keyword\">this</span>, DESCRIPTOR)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">attachInterface</span><span class=\"params\">(owner: <span class=\"type\">IInterface</span>?, descriptor: <span class=\"type\">String</span>?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.attachInterface(owner, descriptor)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onTransact</span><span class=\"params\">(code: <span class=\"type\">Int</span>, <span class=\"keyword\">data</span>: <span class=\"type\">Parcel</span>, reply: <span class=\"type\">Parcel</span>?, flags: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> descriptor = DESCRIPTOR</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">when</span>(code) &#123;</span><br><span class=\"line\">      INTERFACE_TRANSACTION -&gt; &#123;</span><br><span class=\"line\">        reply?.writeString(descriptor)</span><br><span class=\"line\">        <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      TRANSACTION_sayHi -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">data</span>.enforceInterface(descriptor)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> name = <span class=\"keyword\">data</span>.readString() ?: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        sayHi(name)</span><br><span class=\"line\">        reply?.writeNoException()</span><br><span class=\"line\">        <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      TRANSACTION_showObjN -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">data</span>.enforceInterface(descriptor)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> objN: ObjN? = <span class=\"literal\">null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != <span class=\"keyword\">data</span>.readInt()) &#123;</span><br><span class=\"line\">          objN = ObjN.CREATOR.createFromParcel(<span class=\"keyword\">data</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> _result = showObjN(objN!!)</span><br><span class=\"line\">        reply?.writeNoException()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_result != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          reply?.writeInt(<span class=\"number\">1</span>)</span><br><span class=\"line\">          _result.writeToParcel(reply, Parcelable.PARCELABLE_WRITE_RETURN_VALUE)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          reply?.writeInt(<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onTransact(code, <span class=\"keyword\">data</span>, reply, flags)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">asBinder</span><span class=\"params\">()</span></span>: IBinder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Manifest文件中我们定义对应Service</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.NoAIDLService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:enabled</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  /&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--android:process=&quot;:noAIDL&quot;--&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--把上述属性设置到service中，则是在不同进程中运行--&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们重点关注<code>asInterface</code>方法，在这个方法中，有一个代码片段：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> iin = binder.queryLocalInterface(DESCRIPTOR)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (iin != <span class=\"literal\">null</span> &amp;&amp; iin <span class=\"keyword\">is</span> INoAIDL) &#123;</span><br><span class=\"line\">\tLog.v(TAG, <span class=\"string\">&quot;Client and Server in the same Process&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> iin</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Log.v(TAG, <span class=\"string\">&quot;Client and Server in different Processes&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">return</span> Proxy(binder)</span><br></pre></td></tr></table></figure>\n\n<p>通过这样的代码来进行Client和Server是否在不同进程的判断。</p>\n<ul>\n<li>相同进程：返回<code>queryLocalInterface</code>出来的对象，这个对象是在<code>Stub</code>构造方法中通过<code>attachInterface</code>方法传入的。</li>\n<li>不同进程：构造一个<code>Proxy</code>类返回。</li>\n</ul>\n<p>MainActivity去bind一个Service，Service返回一个Binder。我们打印一下日志。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NoAIDLService</span> : <span class=\"type\">Service</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onBind</span><span class=\"params\">(intent: <span class=\"type\">Intent</span>)</span></span>: IBinder &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> binder.also &#123;</span><br><span class=\"line\">      Log.v(TAG, <span class=\"string\">&quot;onBind=<span class=\"variable\">$it</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> noAIDL: INoAIDL? = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> noConnection = <span class=\"keyword\">object</span> : ServiceConnection &#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(name: <span class=\"type\">ComponentName</span>?, service: <span class=\"type\">IBinder</span>?)</span></span> &#123;</span><br><span class=\"line\">    service ?: <span class=\"keyword\">return</span></span><br><span class=\"line\">    Log.v(TAG, <span class=\"string\">&quot;onServiceConnected service=<span class=\"variable\">$service</span>&quot;</span>)</span><br><span class=\"line\">    noAIDL = INoAIDL.Companion.Stub.asInterface(service)</span><br><span class=\"line\">    Toast.makeText(<span class=\"keyword\">this</span><span class=\"symbol\">@MainActivity</span>, <span class=\"string\">&quot;connected to NoAIDLService&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class=\"line\">    Log.v(TAG, <span class=\"string\">&quot;onServiceConnected noAIDL=<span class=\"subst\">$&#123;noAIDL&#125;</span>&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当Client与Server在相同进程，有如下日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// NoAIDLService</span><br><span class=\"line\">onBind=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc</span><br><span class=\"line\"></span><br><span class=\"line\">// MainActivity</span><br><span class=\"line\">onServiceConnected service=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc</span><br><span class=\"line\">noAIDL=com.github.boybeak.noaidl.NoAIDLService$binder$1@84abbdc</span><br></pre></td></tr></table></figure>\n\n<p>当Client与Server在不同进程，有如下日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// NoAIDLService</span><br><span class=\"line\">onBind=com.github.boybeak.noaidl.NoAIDLService$binder$1@2d32060</span><br><span class=\"line\"></span><br><span class=\"line\">// MainActivity</span><br><span class=\"line\">onServiceConnected service=android.os.BinderProxy@99b42f6</span><br><span class=\"line\">noAIDL=com.github.boybeak.noaidl.INoAIDL$Companion$Proxy@67e8964</span><br></pre></td></tr></table></figure>\n\n<p>我们看到，当Client与Server在相同进程时候，Service的<code>onBind</code>方法返回的是什么，MainActivity接收到的就是什么；而当Client与Server在不同进程的时候，则返回的是Binder驱动传递给我们的对象，通过这个对象，我们创造一个 Proxy代理对象。</p>\n<p>我们接下来重点关注<code>showObjN</code>方法。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">val</span> binder = <span class=\"keyword\">object</span> : INoAIDL.Companion.Stub() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">showObjN</span><span class=\"params\">(objN: <span class=\"type\">ObjN</span>)</span></span>: ObjN? &#123;</span><br><span class=\"line\">    Log.v(TAG, <span class=\"string\">&quot;showObjN objN=<span class=\"variable\">$objN</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objN</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法中，直接返回传入的参数。</p>\n<p>调用的地方这样来写：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">showObjN</span><span class=\"params\">(v: <span class=\"type\">View</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (noAIDL == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    Toast.makeText(<span class=\"keyword\">this</span>, <span class=\"string\">&quot;Click NOAIDL button first&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> objN = ObjN()</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;showObjN objN=<span class=\"variable\">$objN</span>&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">val</span> returnObjN = noAIDL?.showObjN(objN)</span><br><span class=\"line\">  Log.v(TAG, <span class=\"string\">&quot;showObjN returnObjW=<span class=\"variable\">$returnObjN</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看打印的<code>objN</code>日志。</p>\n<p><strong>相同进程情况下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Client进程</span><br><span class=\"line\">com.github.boybeak.binder V/MainActivity: showObjN objN=com.github.boybeak.noaidl.ObjN@4c7d499</span><br><span class=\"line\">com.github.boybeak.binder V/MainActivity: showObjN returnObjW=com.github.boybeak.noaidl.ObjN@4c7d499</span><br><span class=\"line\"></span><br><span class=\"line\">// Server进程</span><br><span class=\"line\">com.github.boybeak.binder V/NoAIDLService: showObjN objN=com.github.boybeak.noaidl.ObjN@4c7d499</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>不同进程情况下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Client进程</span><br><span class=\"line\">com.github.boybeak.binder V/MainActivity: showObjN objN=com.github.boybeak.noaidl.ObjN@5ab3a61</span><br><span class=\"line\">com.github.boybeak.binder V/MainActivity: showObjN returnObjW=com.github.boybeak.noaidl.ObjN@db79986</span><br><span class=\"line\"></span><br><span class=\"line\">// Server进程</span><br><span class=\"line\">com.github.boybeak.binder V/NoAIDLService: showObjN objN=com.github.boybeak.noaidl.ObjN@1c5381d</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们可以看到，在相同进程情况下，就是普通的函数调用；在不同进程情况下，Client传入的参数，Server接收到的参数，Client接收到的返回结果，全是不同的对象，这是因为，通过Proxy对象，在跨进程通信时候，将Parcelable对象进行了序列化和反序列化。</p>\n<p>本文是在阅读<a href=\"https://zhuanlan.zhihu.com/p/35519585\"><strong>写给 Android 应用工程师的 Binder 原理剖析</strong></a>一文后，加上自己的理解与实验完成，其中部分段落直接复制了原文，因为我觉得，那部分原文已经足够容易理解且没有冗余的文字，感谢原作者<a href=\"https://www.zhihu.com/people/BaronZ88\"><strong>张磊</strong></a>，同时附上原文参考资料：</p>\n<ul>\n<li><a href=\"https://link.zhihu.com/?target=http://blog.csdn.net/universus/article/details/6211589\">Android Binder 设计与实现 - 设计篇</a></li>\n<li><a href=\"https://link.zhihu.com/?target=http://blog.csdn.net/luoshengyang/article/details/6618363\">Android 进程间通信（IPC）机制 Binder 简要介绍和学习计划</a>、<a href=\"https://link.zhihu.com/?target=http://item.jd.com/12248208.html\">《Android 系统源代码情景分析》</a></li>\n<li><a href=\"https://link.zhihu.com/?target=http://weishu.me/2016/01/12/binder-index-for-newer/\">Binder 学习指南</a></li>\n<li><a href=\"https://link.zhihu.com/?target=http://gityuan.com/2015/10/31/binder-prepare/\">Binder 系列文章</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https://blog.csdn.net/carson_ho/article/details/73560642\">Android 图文详解 Binder 跨进程通信原理</a></li>\n<li><a href=\"https://link.zhihu.com/?target=http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html\">Android 深入浅出之 Binder 机制</a></li>\n<li><a href=\"https://link.zhihu.com/?target=http://www.cnblogs.com/Anker/p/3269106.html\">用户空间与内核空间</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https://www.cnblogs.com/huxiao-tee/p/4660352.html\">认真分析 mmap ：是什么 为什么 怎么用</a></li>\n</ul>\n"},{"layout":"post","title":"Intent.FLAG_ACTIVITY_***解密","author":"boybeak","_content":"\n\n最好先看这一篇[Launch Mode]({{$site.base_url}}/android/LaunchMode.html)。\n\n我们将重点针对**FLAG_ACTIVITY_NEW_TASK**、**FLAG_ACTIVITY_CLEAR_TASK**、**FLAG_ACTIVITY_CLEAR_TOP**、**FLAG_ACTIVITY_SINGLE_TOP**四个flag进行讲解。\n\n\n\n[**FLAG_ACTIVITY_NEW_TASK**](https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_NEW_TASK)：\n\n1. 通过非Activity的Context启动一个Activity时候，要使用此flag，比如：ApplicationContext、Service等；\n2. 用于Launcher类应用启动其他应用的时候；\n3. 当试图通过这个flag启动一个activity的时候，如果后台已经有一个任务栈中有运行的一个此类activity实例，将不会创建一个新的activity，而是将整个栈置于前台，并保持上次的状态。比如从另一个应用启动这种场景，或者Notification中。\n4. 如果你想使用startActivityForResult，则**千万不要**在启动的intent添加这个flag。因为onActivityResult回调方法，不会在目标activity执行finish后调用，而是在启动目标activity的时候直接调用，并且收r到resultCode = `RESULT_CANCELED`。\n\n[**FLAG_ACTIVITY_CLEAR_TOP**](https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TOP)：\n\n1. 如果在当前任务栈中已经有了目标类型activity，则再次通过添加了此flag的intent去启动此类型activity，会有两种情况。\n\n   比如有如下图示结构的任务栈:\n\n   ```mermaid\n   graph LR;\n   subgraph Task;\n   D;\n   C;\n   B;\n   A;\n   end;\n   ```\n\n   此时D通过一个添加了`FLAG_ACTIVITY_CLEAR_TOP`的intent去启动了B类型Activity，则C、D执行onDestroy出栈（不会执行finish，触发onDestroy），现在B在栈顶，有如下图示：\n\n   ```mermaid\n   graph LR;\n   subgraph Task;\n   B;\n   A;\n   end;\n   ```\n\n   接下来就有两种情况了。\n\n   情况一：intent中**没有**同时设置`FLAG_ACTIVITY_SINGLE_TOP`，并且B的launchMode是默认值。\n\n   B会finish掉再re-create一个新的B'放在B的位置上。\n\n   情况二：intent中设置了`FLAG_ACTIVITY_SINGLE_TOP`或者是其他类型的launchMode。\n\n   B不会finish（调用finish方法，onDestroy会被触发）掉，而是直接调用其onNewIntent()方法。\n\n   > 或许你认为情况二这与launchMode中的singleTop或者singleTask类似，实则不然，其一，singleTop没有清空压在它上边activity的能力；其二，singleTask收到taskAffinity影响。\n\n2. 与`FLAG_ACTIVITY_NEW_TASK`配合使用。如果想启动一个任务栈的root位置的activity，也就是栈低activity，同时设置这两个值，它会将整个任务栈放置于前台，并且清空其他activit，适用于从Notification启动Activity。\n\n[**FLAG_ACTIVITY_CLEAR_TASK**](https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TASK)：这个flag很特殊，只能于`FLAG_ACTIVITY_NEW_TASK`配合使用。要启动的目标activity的任务栈如果已经存在并且不为空，则将所有activity出栈（不会调用finish方法，onDestroy会被触发），然后创建一个目标类型activity作为这个栈的root。\n\n\n\n[**FLAG_ACTIVITY_SINGLE_TOP**](https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_SINGLE_TOP)：这个flag与launchMode中的singleTop几乎一样，当要启动一个activity时候，如果栈顶就是目标类型activity，则不会创建一个新的activity，而是直接调用栈顶的这个activity的onNewIntent()方法。","source":"_posts/2022-09-19-Intent.FLAG_ACTIVITY_***到底能干啥.md","raw":"---\nlayout: post\ntitle: Intent.FLAG_ACTIVITY_***解密\nauthor: boybeak\ncategory: Android技巧\ntags: Android\n---\n\n\n最好先看这一篇[Launch Mode]({{$site.base_url}}/android/LaunchMode.html)。\n\n我们将重点针对**FLAG_ACTIVITY_NEW_TASK**、**FLAG_ACTIVITY_CLEAR_TASK**、**FLAG_ACTIVITY_CLEAR_TOP**、**FLAG_ACTIVITY_SINGLE_TOP**四个flag进行讲解。\n\n\n\n[**FLAG_ACTIVITY_NEW_TASK**](https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_NEW_TASK)：\n\n1. 通过非Activity的Context启动一个Activity时候，要使用此flag，比如：ApplicationContext、Service等；\n2. 用于Launcher类应用启动其他应用的时候；\n3. 当试图通过这个flag启动一个activity的时候，如果后台已经有一个任务栈中有运行的一个此类activity实例，将不会创建一个新的activity，而是将整个栈置于前台，并保持上次的状态。比如从另一个应用启动这种场景，或者Notification中。\n4. 如果你想使用startActivityForResult，则**千万不要**在启动的intent添加这个flag。因为onActivityResult回调方法，不会在目标activity执行finish后调用，而是在启动目标activity的时候直接调用，并且收r到resultCode = `RESULT_CANCELED`。\n\n[**FLAG_ACTIVITY_CLEAR_TOP**](https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TOP)：\n\n1. 如果在当前任务栈中已经有了目标类型activity，则再次通过添加了此flag的intent去启动此类型activity，会有两种情况。\n\n   比如有如下图示结构的任务栈:\n\n   ```mermaid\n   graph LR;\n   subgraph Task;\n   D;\n   C;\n   B;\n   A;\n   end;\n   ```\n\n   此时D通过一个添加了`FLAG_ACTIVITY_CLEAR_TOP`的intent去启动了B类型Activity，则C、D执行onDestroy出栈（不会执行finish，触发onDestroy），现在B在栈顶，有如下图示：\n\n   ```mermaid\n   graph LR;\n   subgraph Task;\n   B;\n   A;\n   end;\n   ```\n\n   接下来就有两种情况了。\n\n   情况一：intent中**没有**同时设置`FLAG_ACTIVITY_SINGLE_TOP`，并且B的launchMode是默认值。\n\n   B会finish掉再re-create一个新的B'放在B的位置上。\n\n   情况二：intent中设置了`FLAG_ACTIVITY_SINGLE_TOP`或者是其他类型的launchMode。\n\n   B不会finish（调用finish方法，onDestroy会被触发）掉，而是直接调用其onNewIntent()方法。\n\n   > 或许你认为情况二这与launchMode中的singleTop或者singleTask类似，实则不然，其一，singleTop没有清空压在它上边activity的能力；其二，singleTask收到taskAffinity影响。\n\n2. 与`FLAG_ACTIVITY_NEW_TASK`配合使用。如果想启动一个任务栈的root位置的activity，也就是栈低activity，同时设置这两个值，它会将整个任务栈放置于前台，并且清空其他activit，适用于从Notification启动Activity。\n\n[**FLAG_ACTIVITY_CLEAR_TASK**](https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TASK)：这个flag很特殊，只能于`FLAG_ACTIVITY_NEW_TASK`配合使用。要启动的目标activity的任务栈如果已经存在并且不为空，则将所有activity出栈（不会调用finish方法，onDestroy会被触发），然后创建一个目标类型activity作为这个栈的root。\n\n\n\n[**FLAG_ACTIVITY_SINGLE_TOP**](https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_SINGLE_TOP)：这个flag与launchMode中的singleTop几乎一样，当要启动一个activity时候，如果栈顶就是目标类型activity，则不会创建一个新的activity，而是直接调用栈顶的这个activity的onNewIntent()方法。","slug":"2022-09-19-Intent.FLAG_ACTIVITY_***到底能干啥","published":1,"date":"2020-10-26T17:14:40.000Z","updated":"2022-09-19T01:27:36.141Z","comments":1,"photos":[],"link":"","_id":"cldqukh9d0017pcjgawkhadw7","content":"<p>最好先看这一篇[Launch Mode](&#x2F;android&#x2F;LaunchMode.html)。</p>\n<p>我们将重点针对<strong>FLAG_ACTIVITY_NEW_TASK</strong>、<strong>FLAG_ACTIVITY_CLEAR_TASK</strong>、<strong>FLAG_ACTIVITY_CLEAR_TOP</strong>、<strong>FLAG_ACTIVITY_SINGLE_TOP</strong>四个flag进行讲解。</p>\n<p><a href=\"https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_NEW_TASK\"><strong>FLAG_ACTIVITY_NEW_TASK</strong></a>：</p>\n<ol>\n<li>通过非Activity的Context启动一个Activity时候，要使用此flag，比如：ApplicationContext、Service等；</li>\n<li>用于Launcher类应用启动其他应用的时候；</li>\n<li>当试图通过这个flag启动一个activity的时候，如果后台已经有一个任务栈中有运行的一个此类activity实例，将不会创建一个新的activity，而是将整个栈置于前台，并保持上次的状态。比如从另一个应用启动这种场景，或者Notification中。</li>\n<li>如果你想使用startActivityForResult，则<strong>千万不要</strong>在启动的intent添加这个flag。因为onActivityResult回调方法，不会在目标activity执行finish后调用，而是在启动目标activity的时候直接调用，并且收r到resultCode &#x3D; <code>RESULT_CANCELED</code>。</li>\n</ol>\n<p><a href=\"https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TOP\"><strong>FLAG_ACTIVITY_CLEAR_TOP</strong></a>：</p>\n<ol>\n<li><p>如果在当前任务栈中已经有了目标类型activity，则再次通过添加了此flag的intent去启动此类型activity，会有两种情况。</p>\n<p>比如有如下图示结构的任务栈:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">subgraph Task;</span><br><span class=\"line\">D;</span><br><span class=\"line\">C;</span><br><span class=\"line\">B;</span><br><span class=\"line\">A;</span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure>\n\n<p>此时D通过一个添加了<code>FLAG_ACTIVITY_CLEAR_TOP</code>的intent去启动了B类型Activity，则C、D执行onDestroy出栈（不会执行finish，触发onDestroy），现在B在栈顶，有如下图示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">subgraph Task;</span><br><span class=\"line\">B;</span><br><span class=\"line\">A;</span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就有两种情况了。</p>\n<p>情况一：intent中<strong>没有</strong>同时设置<code>FLAG_ACTIVITY_SINGLE_TOP</code>，并且B的launchMode是默认值。</p>\n<p>B会finish掉再re-create一个新的B’放在B的位置上。</p>\n<p>情况二：intent中设置了<code>FLAG_ACTIVITY_SINGLE_TOP</code>或者是其他类型的launchMode。</p>\n<p>B不会finish（调用finish方法，onDestroy会被触发）掉，而是直接调用其onNewIntent()方法。</p>\n<blockquote>\n<p>或许你认为情况二这与launchMode中的singleTop或者singleTask类似，实则不然，其一，singleTop没有清空压在它上边activity的能力；其二，singleTask收到taskAffinity影响。</p>\n</blockquote>\n</li>\n<li><p>与<code>FLAG_ACTIVITY_NEW_TASK</code>配合使用。如果想启动一个任务栈的root位置的activity，也就是栈低activity，同时设置这两个值，它会将整个任务栈放置于前台，并且清空其他activit，适用于从Notification启动Activity。</p>\n</li>\n</ol>\n<p><a href=\"https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TASK\"><strong>FLAG_ACTIVITY_CLEAR_TASK</strong></a>：这个flag很特殊，只能于<code>FLAG_ACTIVITY_NEW_TASK</code>配合使用。要启动的目标activity的任务栈如果已经存在并且不为空，则将所有activity出栈（不会调用finish方法，onDestroy会被触发），然后创建一个目标类型activity作为这个栈的root。</p>\n<p><a href=\"https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_SINGLE_TOP\"><strong>FLAG_ACTIVITY_SINGLE_TOP</strong></a>：这个flag与launchMode中的singleTop几乎一样，当要启动一个activity时候，如果栈顶就是目标类型activity，则不会创建一个新的activity，而是直接调用栈顶的这个activity的onNewIntent()方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最好先看这一篇[Launch Mode](&#x2F;android&#x2F;LaunchMode.html)。</p>\n<p>我们将重点针对<strong>FLAG_ACTIVITY_NEW_TASK</strong>、<strong>FLAG_ACTIVITY_CLEAR_TASK</strong>、<strong>FLAG_ACTIVITY_CLEAR_TOP</strong>、<strong>FLAG_ACTIVITY_SINGLE_TOP</strong>四个flag进行讲解。</p>\n<p><a href=\"https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_NEW_TASK\"><strong>FLAG_ACTIVITY_NEW_TASK</strong></a>：</p>\n<ol>\n<li>通过非Activity的Context启动一个Activity时候，要使用此flag，比如：ApplicationContext、Service等；</li>\n<li>用于Launcher类应用启动其他应用的时候；</li>\n<li>当试图通过这个flag启动一个activity的时候，如果后台已经有一个任务栈中有运行的一个此类activity实例，将不会创建一个新的activity，而是将整个栈置于前台，并保持上次的状态。比如从另一个应用启动这种场景，或者Notification中。</li>\n<li>如果你想使用startActivityForResult，则<strong>千万不要</strong>在启动的intent添加这个flag。因为onActivityResult回调方法，不会在目标activity执行finish后调用，而是在启动目标activity的时候直接调用，并且收r到resultCode &#x3D; <code>RESULT_CANCELED</code>。</li>\n</ol>\n<p><a href=\"https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TOP\"><strong>FLAG_ACTIVITY_CLEAR_TOP</strong></a>：</p>\n<ol>\n<li><p>如果在当前任务栈中已经有了目标类型activity，则再次通过添加了此flag的intent去启动此类型activity，会有两种情况。</p>\n<p>比如有如下图示结构的任务栈:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">subgraph Task;</span><br><span class=\"line\">D;</span><br><span class=\"line\">C;</span><br><span class=\"line\">B;</span><br><span class=\"line\">A;</span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure>\n\n<p>此时D通过一个添加了<code>FLAG_ACTIVITY_CLEAR_TOP</code>的intent去启动了B类型Activity，则C、D执行onDestroy出栈（不会执行finish，触发onDestroy），现在B在栈顶，有如下图示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">subgraph Task;</span><br><span class=\"line\">B;</span><br><span class=\"line\">A;</span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就有两种情况了。</p>\n<p>情况一：intent中<strong>没有</strong>同时设置<code>FLAG_ACTIVITY_SINGLE_TOP</code>，并且B的launchMode是默认值。</p>\n<p>B会finish掉再re-create一个新的B’放在B的位置上。</p>\n<p>情况二：intent中设置了<code>FLAG_ACTIVITY_SINGLE_TOP</code>或者是其他类型的launchMode。</p>\n<p>B不会finish（调用finish方法，onDestroy会被触发）掉，而是直接调用其onNewIntent()方法。</p>\n<blockquote>\n<p>或许你认为情况二这与launchMode中的singleTop或者singleTask类似，实则不然，其一，singleTop没有清空压在它上边activity的能力；其二，singleTask收到taskAffinity影响。</p>\n</blockquote>\n</li>\n<li><p>与<code>FLAG_ACTIVITY_NEW_TASK</code>配合使用。如果想启动一个任务栈的root位置的activity，也就是栈低activity，同时设置这两个值，它会将整个任务栈放置于前台，并且清空其他activit，适用于从Notification启动Activity。</p>\n</li>\n</ol>\n<p><a href=\"https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_CLEAR_TASK\"><strong>FLAG_ACTIVITY_CLEAR_TASK</strong></a>：这个flag很特殊，只能于<code>FLAG_ACTIVITY_NEW_TASK</code>配合使用。要启动的目标activity的任务栈如果已经存在并且不为空，则将所有activity出栈（不会调用finish方法，onDestroy会被触发），然后创建一个目标类型activity作为这个栈的root。</p>\n<p><a href=\"https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_SINGLE_TOP\"><strong>FLAG_ACTIVITY_SINGLE_TOP</strong></a>：这个flag与launchMode中的singleTop几乎一样，当要启动一个activity时候，如果栈顶就是目标类型activity，则不会创建一个新的activity，而是直接调用栈顶的这个activity的onNewIntent()方法。</p>\n"},{"layout":"post","title":"LaunchMode","author":"boybeak","_content":"\n此文是阅读[《Android 面试黑洞——当我按下 Home 键再切回来，会发生什么？》](https://zhuanlan.zhihu.com/p/265946165)一文后的总结，视频地址[Bilibili](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1CA41177Se/)、[Youtube](https://link.zhihu.com/?target=https%3A//youtu.be/r4T9zkhpmII)。\n\n演示代码：\n\n在正式讲解launchMode前，先要理解三个概念：**ActivityStack**, **TaskRecord**, **ActivityRecord**。\n\n```mermaid\ngraph LR;\nstyle TaskRecord-A fill:#aaddff;\nstyle TaskRecord-B fill:#aaddff;\nsubgraph ActivityStack\nsubgraph TaskRecord-A\nA[ActivityRecord-1]\nB[ActivityRecord-2]\nend\nsubgraph TaskRecord-B\nC[ActivityRecord-3]\nD[ActivityRecord-4]\nend\nend\n```\n\n他们的一般结构是这样的。\n\n通过adb命令可以查看当前的ActivityStack、TaskRecord和ActivityRecord的结构。\n\n```powershell\nadb shell dumpsys activity\n```\n\n结果如下(搜索`ACTIVITY MANAGER STARTER (dumpsys activity containers)`)：\n\n```powershell\n...\n\nACTIVITY MANAGER STARTER (dumpsys activity containers)\ncom.android.server.am.ActivityStackSupervisor@299f1c5 type=undefined mode=fullscreen\n  #0 ActivityDisplay={0 numStacks=2} type=undefined mode=fullscreen\n   #1 ActivityStack{694271a stackId=0 type=home mode=fullscreen visible=true translucent=false, 1 tasks} type=home mode=fullscreen\n    #0 TaskRecord{e42980e #2 I=com.android.launcher3/.Launcher U=0 StackId=0 sz=1} type=home mode=fullscreen\n     #0 ActivityRecord{5efeaf4 u0 com.android.launcher3/.Launcher t2} type=home mode=fullscreen\n   #0 ActivityStack{91ac24b stackId=1 type=standard mode=fullscreen visible=false translucent=true, 1 tasks} type=standard mode=fullscreen\n    #0 TaskRecord{583322f #72 A=com.github.boybeak.hellolaunchmode U=0 StackId=1 sz=1} type=standard mode=fullscreen\n     #0 ActivityRecord{a126ec8 u0 com.github.boybeak.hellolaunchmode/.MainActivity t72} type=standard mode=fullscreen\n\n\n...\n```\n\n我们可以看到，此时有两个ActivityStack，索引为0的ActivityStack中，有一个TaskRecord，这个TaskRecord里有一个ActivityRecord，就是我们实验App的MainActivity；索引为1的ActivityStack为我们的Home界面。\n\n\n\n## 四种launchMode的一般行为\n\nLaunchMode共有4个值可以选择：**Standard**、**SingleTop**、**SingleTask**、**SingleInstance**。接下来将分开讲这4个值的作用，实际上，由于Activity的跳转会涉及到两个Activity，比如ActivityA -> ActivityB，ActivityB的跳转行为模式，不止受到自己launchMode的影响，还会受到ActivityA的launchMode的影响。除此以外，还会有其他属性的影响，比如`taskAffinity`、`allowTaskReparenting`、[`documentLaunchMode`](https://developer.android.com/guide/topics/manifest/activity-element#dlmode)等。\n\n**Standard**\n\n这是launchMode的值。它的默认行为是：在当前TaskRecord下创建新Activity。\n\n**SingleTop**\n\nSingleTop的行为是：如果有一个同类型的Activity在当前TaskRecord的栈顶，那么就直接使用这个栈顶的Activity并调用其`onNewIntent()`方法；如果栈顶没有同类型的Activity，则在栈顶创建一个对应的Activity。\n\n**SingleTask**\n\nSingleTask的行为是：在对应`taskAffinity`的TaskRecord中，如果已经有了对应类型的Activity，则直接使用该Activity，并调用`onNewIntent()`方法，如果有其他Activity压在该Activity上，则这些Activity都将出栈，该Activity重回栈顶；如果对应`taskAffinity`的TaskRecord中没有对应类型的Activity，则创建对应类型的Activity并压入栈顶。\n\n> 这里需要注意的是`taskAffinity`对该属性的影响，如果没有为`android:launchMode=\"singleTask\"`的Activity指定`taskAffinity`，则默认值为Application的`taskAffinity`，而Application的默认`taskAffinity`为包名。\n\n**SingleInstance**\n\nSingleInstance的行为是：1，只允许有一个栈中有此Activity，并且这个栈只允许有这一个Activity；2，如果已经有一个栈中有对应的Activity，则直接使用该Activity，并调用`onNewIntent()`方法。\n\n\n\n## SingleInstance对其他三种launchMode的影响\n\n由于SingleInstance是如此的霸道，导致从一个SingleInstance的Activity启动其他类型Activity的话，会改变其他三种模式的一般行为。\n\n**SingleInstanceA -> StandardB**\n\nStandardActivityB将无法在当前栈中创建，会回到默认栈中创建。\n\n**SingleInstanceA -> SingleTopB**\n\n这个行为就很复杂了，可以按照SingleTopB有无`taskAffinity`属性分为两种情况：\n\n- 无`taskAffinity`：则直接在默认的栈中，创建新的SingleTopB或者使用已经存在的SingleTopB。\n- 有`taskAffinity`：则在指定`taskAffinity`的栈中创建创建新的SingleTopB或者使用已经存在的SingleTopB。\n\n> 这里实际上存在一个更为复杂的行为模式：**StandardA -> SingleTopB -> SingleInstanceC -> SingleTopB**。\n>\n> 如果SingleTop有`taskAffinity`属性的话，情况就可以分为两个部分：\n>\n> **StandardA -> SingleTopB**：在StandardA相同TaskRecord中创建SingleTopB的实例singleTopB1。\n>\n> **SingleInstanceC -> SingleTopB**：在指定`taskAffinity`的TaskRecord中，创建SingleTopB的实例singleTopB2。\n>\n> 也就是说，此时有两个SingleTopB对象——singleTopB1和singleTopB2，分别在两个TaskRecord中。\n\n**SingleInstanceA -> SingleTaskB**\n\n比照**SingleInstanceA -> SingleTopB**的例子，同样可以可以按照SingleTaskB有无`taskAffinity`属性分为两种情况：\n\n- 无`taskAffinity`：则直接在默认的栈中，创建新的SingleTaskB或者使用已经存在的SingleTaskB。\n- 有`taskAffinity`：则在指定`taskAffinity`的栈中创建创建新的SingleTaskB或者使用已经存在的SingleTaskB。\n\n\n\n## 总结\n\n大体了解了不同launchMode的行为逻辑，他们的用途可以简单粗暴的归结如下规律：\n\n- standard和singleTop：多用于App内部；\n- singleInstance：多用于开放给外部App来共享使用；\n- singleTask：内部交互和外部调用都会用得上。\n\n当然，不能一概而论，还是要看具体需求。\n\n看起来似乎很复杂，其实只要掌握了`adb shell dumpsys activity`这个命令工具，就能清晰的看到当前Activity的分布情况，就能分析出，你的Activity应该用什么`launchMode`，要不要设置`taskAffinity`。\n\n## 参考文献\n\n[ActivityRecord、TaskRecord、ActivityStack以及Activity启动模式详解](https://www.jianshu.com/p/94816e52cd77)\n\n","source":"_posts/2022-09-19-LaunchMode.md","raw":"---\nlayout: post\ntitle: LaunchMode\nauthor: boybeak\ncategory: Android技巧\ntags: Android\n---\n\n此文是阅读[《Android 面试黑洞——当我按下 Home 键再切回来，会发生什么？》](https://zhuanlan.zhihu.com/p/265946165)一文后的总结，视频地址[Bilibili](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1CA41177Se/)、[Youtube](https://link.zhihu.com/?target=https%3A//youtu.be/r4T9zkhpmII)。\n\n演示代码：\n\n在正式讲解launchMode前，先要理解三个概念：**ActivityStack**, **TaskRecord**, **ActivityRecord**。\n\n```mermaid\ngraph LR;\nstyle TaskRecord-A fill:#aaddff;\nstyle TaskRecord-B fill:#aaddff;\nsubgraph ActivityStack\nsubgraph TaskRecord-A\nA[ActivityRecord-1]\nB[ActivityRecord-2]\nend\nsubgraph TaskRecord-B\nC[ActivityRecord-3]\nD[ActivityRecord-4]\nend\nend\n```\n\n他们的一般结构是这样的。\n\n通过adb命令可以查看当前的ActivityStack、TaskRecord和ActivityRecord的结构。\n\n```powershell\nadb shell dumpsys activity\n```\n\n结果如下(搜索`ACTIVITY MANAGER STARTER (dumpsys activity containers)`)：\n\n```powershell\n...\n\nACTIVITY MANAGER STARTER (dumpsys activity containers)\ncom.android.server.am.ActivityStackSupervisor@299f1c5 type=undefined mode=fullscreen\n  #0 ActivityDisplay={0 numStacks=2} type=undefined mode=fullscreen\n   #1 ActivityStack{694271a stackId=0 type=home mode=fullscreen visible=true translucent=false, 1 tasks} type=home mode=fullscreen\n    #0 TaskRecord{e42980e #2 I=com.android.launcher3/.Launcher U=0 StackId=0 sz=1} type=home mode=fullscreen\n     #0 ActivityRecord{5efeaf4 u0 com.android.launcher3/.Launcher t2} type=home mode=fullscreen\n   #0 ActivityStack{91ac24b stackId=1 type=standard mode=fullscreen visible=false translucent=true, 1 tasks} type=standard mode=fullscreen\n    #0 TaskRecord{583322f #72 A=com.github.boybeak.hellolaunchmode U=0 StackId=1 sz=1} type=standard mode=fullscreen\n     #0 ActivityRecord{a126ec8 u0 com.github.boybeak.hellolaunchmode/.MainActivity t72} type=standard mode=fullscreen\n\n\n...\n```\n\n我们可以看到，此时有两个ActivityStack，索引为0的ActivityStack中，有一个TaskRecord，这个TaskRecord里有一个ActivityRecord，就是我们实验App的MainActivity；索引为1的ActivityStack为我们的Home界面。\n\n\n\n## 四种launchMode的一般行为\n\nLaunchMode共有4个值可以选择：**Standard**、**SingleTop**、**SingleTask**、**SingleInstance**。接下来将分开讲这4个值的作用，实际上，由于Activity的跳转会涉及到两个Activity，比如ActivityA -> ActivityB，ActivityB的跳转行为模式，不止受到自己launchMode的影响，还会受到ActivityA的launchMode的影响。除此以外，还会有其他属性的影响，比如`taskAffinity`、`allowTaskReparenting`、[`documentLaunchMode`](https://developer.android.com/guide/topics/manifest/activity-element#dlmode)等。\n\n**Standard**\n\n这是launchMode的值。它的默认行为是：在当前TaskRecord下创建新Activity。\n\n**SingleTop**\n\nSingleTop的行为是：如果有一个同类型的Activity在当前TaskRecord的栈顶，那么就直接使用这个栈顶的Activity并调用其`onNewIntent()`方法；如果栈顶没有同类型的Activity，则在栈顶创建一个对应的Activity。\n\n**SingleTask**\n\nSingleTask的行为是：在对应`taskAffinity`的TaskRecord中，如果已经有了对应类型的Activity，则直接使用该Activity，并调用`onNewIntent()`方法，如果有其他Activity压在该Activity上，则这些Activity都将出栈，该Activity重回栈顶；如果对应`taskAffinity`的TaskRecord中没有对应类型的Activity，则创建对应类型的Activity并压入栈顶。\n\n> 这里需要注意的是`taskAffinity`对该属性的影响，如果没有为`android:launchMode=\"singleTask\"`的Activity指定`taskAffinity`，则默认值为Application的`taskAffinity`，而Application的默认`taskAffinity`为包名。\n\n**SingleInstance**\n\nSingleInstance的行为是：1，只允许有一个栈中有此Activity，并且这个栈只允许有这一个Activity；2，如果已经有一个栈中有对应的Activity，则直接使用该Activity，并调用`onNewIntent()`方法。\n\n\n\n## SingleInstance对其他三种launchMode的影响\n\n由于SingleInstance是如此的霸道，导致从一个SingleInstance的Activity启动其他类型Activity的话，会改变其他三种模式的一般行为。\n\n**SingleInstanceA -> StandardB**\n\nStandardActivityB将无法在当前栈中创建，会回到默认栈中创建。\n\n**SingleInstanceA -> SingleTopB**\n\n这个行为就很复杂了，可以按照SingleTopB有无`taskAffinity`属性分为两种情况：\n\n- 无`taskAffinity`：则直接在默认的栈中，创建新的SingleTopB或者使用已经存在的SingleTopB。\n- 有`taskAffinity`：则在指定`taskAffinity`的栈中创建创建新的SingleTopB或者使用已经存在的SingleTopB。\n\n> 这里实际上存在一个更为复杂的行为模式：**StandardA -> SingleTopB -> SingleInstanceC -> SingleTopB**。\n>\n> 如果SingleTop有`taskAffinity`属性的话，情况就可以分为两个部分：\n>\n> **StandardA -> SingleTopB**：在StandardA相同TaskRecord中创建SingleTopB的实例singleTopB1。\n>\n> **SingleInstanceC -> SingleTopB**：在指定`taskAffinity`的TaskRecord中，创建SingleTopB的实例singleTopB2。\n>\n> 也就是说，此时有两个SingleTopB对象——singleTopB1和singleTopB2，分别在两个TaskRecord中。\n\n**SingleInstanceA -> SingleTaskB**\n\n比照**SingleInstanceA -> SingleTopB**的例子，同样可以可以按照SingleTaskB有无`taskAffinity`属性分为两种情况：\n\n- 无`taskAffinity`：则直接在默认的栈中，创建新的SingleTaskB或者使用已经存在的SingleTaskB。\n- 有`taskAffinity`：则在指定`taskAffinity`的栈中创建创建新的SingleTaskB或者使用已经存在的SingleTaskB。\n\n\n\n## 总结\n\n大体了解了不同launchMode的行为逻辑，他们的用途可以简单粗暴的归结如下规律：\n\n- standard和singleTop：多用于App内部；\n- singleInstance：多用于开放给外部App来共享使用；\n- singleTask：内部交互和外部调用都会用得上。\n\n当然，不能一概而论，还是要看具体需求。\n\n看起来似乎很复杂，其实只要掌握了`adb shell dumpsys activity`这个命令工具，就能清晰的看到当前Activity的分布情况，就能分析出，你的Activity应该用什么`launchMode`，要不要设置`taskAffinity`。\n\n## 参考文献\n\n[ActivityRecord、TaskRecord、ActivityStack以及Activity启动模式详解](https://www.jianshu.com/p/94816e52cd77)\n\n","slug":"2022-09-19-LaunchMode","published":1,"date":"2020-10-25T09:32:52.000Z","updated":"2022-09-19T01:34:13.411Z","comments":1,"photos":[],"link":"","_id":"cldqukh9h001bpcjggx9x5pxy","content":"<p>此文是阅读<a href=\"https://zhuanlan.zhihu.com/p/265946165\">《Android 面试黑洞——当我按下 Home 键再切回来，会发生什么？》</a>一文后的总结，视频地址<a href=\"https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1CA41177Se/\">Bilibili</a>、<a href=\"https://link.zhihu.com/?target=https://youtu.be/r4T9zkhpmII\">Youtube</a>。</p>\n<p>演示代码：</p>\n<p>在正式讲解launchMode前，先要理解三个概念：<strong>ActivityStack</strong>, <strong>TaskRecord</strong>, <strong>ActivityRecord</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">style TaskRecord-A fill:#aaddff;</span><br><span class=\"line\">style TaskRecord-B fill:#aaddff;</span><br><span class=\"line\">subgraph ActivityStack</span><br><span class=\"line\">subgraph TaskRecord-A</span><br><span class=\"line\">A[ActivityRecord-1]</span><br><span class=\"line\">B[ActivityRecord-2]</span><br><span class=\"line\">end</span><br><span class=\"line\">subgraph TaskRecord-B</span><br><span class=\"line\">C[ActivityRecord-3]</span><br><span class=\"line\">D[ActivityRecord-4]</span><br><span class=\"line\">end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>他们的一般结构是这样的。</p>\n<p>通过adb命令可以查看当前的ActivityStack、TaskRecord和ActivityRecord的结构。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell dumpsys activity</span><br></pre></td></tr></table></figure>\n\n<p>结果如下(搜索<code>ACTIVITY MANAGER STARTER (dumpsys activity containers)</code>)：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">ACTIVITY MANAGER STARTER (dumpsys activity containers)</span><br><span class=\"line\">com.android.server.am.ActivityStackSupervisor@<span class=\"number\">299</span>f1c5 <span class=\"built_in\">type</span>=undefined mode=fullscreen</span><br><span class=\"line\">  <span class=\"comment\">#0 ActivityDisplay=&#123;0 numStacks=2&#125; type=undefined mode=fullscreen</span></span><br><span class=\"line\">   <span class=\"comment\">#1 ActivityStack&#123;694271a stackId=0 type=home mode=fullscreen visible=true translucent=false, 1 tasks&#125; type=home mode=fullscreen</span></span><br><span class=\"line\">    <span class=\"comment\">#0 TaskRecord&#123;e42980e #2 I=com.android.launcher3/.Launcher U=0 StackId=0 sz=1&#125; type=home mode=fullscreen</span></span><br><span class=\"line\">     <span class=\"comment\">#0 ActivityRecord&#123;5efeaf4 u0 com.android.launcher3/.Launcher t2&#125; type=home mode=fullscreen</span></span><br><span class=\"line\">   <span class=\"comment\">#0 ActivityStack&#123;91ac24b stackId=1 type=standard mode=fullscreen visible=false translucent=true, 1 tasks&#125; type=standard mode=fullscreen</span></span><br><span class=\"line\">    <span class=\"comment\">#0 TaskRecord&#123;583322f #72 A=com.github.boybeak.hellolaunchmode U=0 StackId=1 sz=1&#125; type=standard mode=fullscreen</span></span><br><span class=\"line\">     <span class=\"comment\">#0 ActivityRecord&#123;a126ec8 u0 com.github.boybeak.hellolaunchmode/.MainActivity t72&#125; type=standard mode=fullscreen</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，此时有两个ActivityStack，索引为0的ActivityStack中，有一个TaskRecord，这个TaskRecord里有一个ActivityRecord，就是我们实验App的MainActivity；索引为1的ActivityStack为我们的Home界面。</p>\n<h2 id=\"四种launchMode的一般行为\"><a href=\"#四种launchMode的一般行为\" class=\"headerlink\" title=\"四种launchMode的一般行为\"></a>四种launchMode的一般行为</h2><p>LaunchMode共有4个值可以选择：<strong>Standard</strong>、<strong>SingleTop</strong>、<strong>SingleTask</strong>、<strong>SingleInstance</strong>。接下来将分开讲这4个值的作用，实际上，由于Activity的跳转会涉及到两个Activity，比如ActivityA -&gt; ActivityB，ActivityB的跳转行为模式，不止受到自己launchMode的影响，还会受到ActivityA的launchMode的影响。除此以外，还会有其他属性的影响，比如<code>taskAffinity</code>、<code>allowTaskReparenting</code>、<a href=\"https://developer.android.com/guide/topics/manifest/activity-element#dlmode\"><code>documentLaunchMode</code></a>等。</p>\n<p><strong>Standard</strong></p>\n<p>这是launchMode的值。它的默认行为是：在当前TaskRecord下创建新Activity。</p>\n<p><strong>SingleTop</strong></p>\n<p>SingleTop的行为是：如果有一个同类型的Activity在当前TaskRecord的栈顶，那么就直接使用这个栈顶的Activity并调用其<code>onNewIntent()</code>方法；如果栈顶没有同类型的Activity，则在栈顶创建一个对应的Activity。</p>\n<p><strong>SingleTask</strong></p>\n<p>SingleTask的行为是：在对应<code>taskAffinity</code>的TaskRecord中，如果已经有了对应类型的Activity，则直接使用该Activity，并调用<code>onNewIntent()</code>方法，如果有其他Activity压在该Activity上，则这些Activity都将出栈，该Activity重回栈顶；如果对应<code>taskAffinity</code>的TaskRecord中没有对应类型的Activity，则创建对应类型的Activity并压入栈顶。</p>\n<blockquote>\n<p>这里需要注意的是<code>taskAffinity</code>对该属性的影响，如果没有为<code>android:launchMode=&quot;singleTask&quot;</code>的Activity指定<code>taskAffinity</code>，则默认值为Application的<code>taskAffinity</code>，而Application的默认<code>taskAffinity</code>为包名。</p>\n</blockquote>\n<p><strong>SingleInstance</strong></p>\n<p>SingleInstance的行为是：1，只允许有一个栈中有此Activity，并且这个栈只允许有这一个Activity；2，如果已经有一个栈中有对应的Activity，则直接使用该Activity，并调用<code>onNewIntent()</code>方法。</p>\n<h2 id=\"SingleInstance对其他三种launchMode的影响\"><a href=\"#SingleInstance对其他三种launchMode的影响\" class=\"headerlink\" title=\"SingleInstance对其他三种launchMode的影响\"></a>SingleInstance对其他三种launchMode的影响</h2><p>由于SingleInstance是如此的霸道，导致从一个SingleInstance的Activity启动其他类型Activity的话，会改变其他三种模式的一般行为。</p>\n<p><strong>SingleInstanceA -&gt; StandardB</strong></p>\n<p>StandardActivityB将无法在当前栈中创建，会回到默认栈中创建。</p>\n<p><strong>SingleInstanceA -&gt; SingleTopB</strong></p>\n<p>这个行为就很复杂了，可以按照SingleTopB有无<code>taskAffinity</code>属性分为两种情况：</p>\n<ul>\n<li>无<code>taskAffinity</code>：则直接在默认的栈中，创建新的SingleTopB或者使用已经存在的SingleTopB。</li>\n<li>有<code>taskAffinity</code>：则在指定<code>taskAffinity</code>的栈中创建创建新的SingleTopB或者使用已经存在的SingleTopB。</li>\n</ul>\n<blockquote>\n<p>这里实际上存在一个更为复杂的行为模式：<strong>StandardA -&gt; SingleTopB -&gt; SingleInstanceC -&gt; SingleTopB</strong>。</p>\n<p>如果SingleTop有<code>taskAffinity</code>属性的话，情况就可以分为两个部分：</p>\n<p><strong>StandardA -&gt; SingleTopB</strong>：在StandardA相同TaskRecord中创建SingleTopB的实例singleTopB1。</p>\n<p><strong>SingleInstanceC -&gt; SingleTopB</strong>：在指定<code>taskAffinity</code>的TaskRecord中，创建SingleTopB的实例singleTopB2。</p>\n<p>也就是说，此时有两个SingleTopB对象——singleTopB1和singleTopB2，分别在两个TaskRecord中。</p>\n</blockquote>\n<p><strong>SingleInstanceA -&gt; SingleTaskB</strong></p>\n<p>比照<strong>SingleInstanceA -&gt; SingleTopB</strong>的例子，同样可以可以按照SingleTaskB有无<code>taskAffinity</code>属性分为两种情况：</p>\n<ul>\n<li>无<code>taskAffinity</code>：则直接在默认的栈中，创建新的SingleTaskB或者使用已经存在的SingleTaskB。</li>\n<li>有<code>taskAffinity</code>：则在指定<code>taskAffinity</code>的栈中创建创建新的SingleTaskB或者使用已经存在的SingleTaskB。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>大体了解了不同launchMode的行为逻辑，他们的用途可以简单粗暴的归结如下规律：</p>\n<ul>\n<li>standard和singleTop：多用于App内部；</li>\n<li>singleInstance：多用于开放给外部App来共享使用；</li>\n<li>singleTask：内部交互和外部调用都会用得上。</li>\n</ul>\n<p>当然，不能一概而论，还是要看具体需求。</p>\n<p>看起来似乎很复杂，其实只要掌握了<code>adb shell dumpsys activity</code>这个命令工具，就能清晰的看到当前Activity的分布情况，就能分析出，你的Activity应该用什么<code>launchMode</code>，要不要设置<code>taskAffinity</code>。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.jianshu.com/p/94816e52cd77\">ActivityRecord、TaskRecord、ActivityStack以及Activity启动模式详解</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>此文是阅读<a href=\"https://zhuanlan.zhihu.com/p/265946165\">《Android 面试黑洞——当我按下 Home 键再切回来，会发生什么？》</a>一文后的总结，视频地址<a href=\"https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1CA41177Se/\">Bilibili</a>、<a href=\"https://link.zhihu.com/?target=https://youtu.be/r4T9zkhpmII\">Youtube</a>。</p>\n<p>演示代码：</p>\n<p>在正式讲解launchMode前，先要理解三个概念：<strong>ActivityStack</strong>, <strong>TaskRecord</strong>, <strong>ActivityRecord</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR;</span><br><span class=\"line\">style TaskRecord-A fill:#aaddff;</span><br><span class=\"line\">style TaskRecord-B fill:#aaddff;</span><br><span class=\"line\">subgraph ActivityStack</span><br><span class=\"line\">subgraph TaskRecord-A</span><br><span class=\"line\">A[ActivityRecord-1]</span><br><span class=\"line\">B[ActivityRecord-2]</span><br><span class=\"line\">end</span><br><span class=\"line\">subgraph TaskRecord-B</span><br><span class=\"line\">C[ActivityRecord-3]</span><br><span class=\"line\">D[ActivityRecord-4]</span><br><span class=\"line\">end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>他们的一般结构是这样的。</p>\n<p>通过adb命令可以查看当前的ActivityStack、TaskRecord和ActivityRecord的结构。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell dumpsys activity</span><br></pre></td></tr></table></figure>\n\n<p>结果如下(搜索<code>ACTIVITY MANAGER STARTER (dumpsys activity containers)</code>)：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">ACTIVITY MANAGER STARTER (dumpsys activity containers)</span><br><span class=\"line\">com.android.server.am.ActivityStackSupervisor@<span class=\"number\">299</span>f1c5 <span class=\"built_in\">type</span>=undefined mode=fullscreen</span><br><span class=\"line\">  <span class=\"comment\">#0 ActivityDisplay=&#123;0 numStacks=2&#125; type=undefined mode=fullscreen</span></span><br><span class=\"line\">   <span class=\"comment\">#1 ActivityStack&#123;694271a stackId=0 type=home mode=fullscreen visible=true translucent=false, 1 tasks&#125; type=home mode=fullscreen</span></span><br><span class=\"line\">    <span class=\"comment\">#0 TaskRecord&#123;e42980e #2 I=com.android.launcher3/.Launcher U=0 StackId=0 sz=1&#125; type=home mode=fullscreen</span></span><br><span class=\"line\">     <span class=\"comment\">#0 ActivityRecord&#123;5efeaf4 u0 com.android.launcher3/.Launcher t2&#125; type=home mode=fullscreen</span></span><br><span class=\"line\">   <span class=\"comment\">#0 ActivityStack&#123;91ac24b stackId=1 type=standard mode=fullscreen visible=false translucent=true, 1 tasks&#125; type=standard mode=fullscreen</span></span><br><span class=\"line\">    <span class=\"comment\">#0 TaskRecord&#123;583322f #72 A=com.github.boybeak.hellolaunchmode U=0 StackId=1 sz=1&#125; type=standard mode=fullscreen</span></span><br><span class=\"line\">     <span class=\"comment\">#0 ActivityRecord&#123;a126ec8 u0 com.github.boybeak.hellolaunchmode/.MainActivity t72&#125; type=standard mode=fullscreen</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，此时有两个ActivityStack，索引为0的ActivityStack中，有一个TaskRecord，这个TaskRecord里有一个ActivityRecord，就是我们实验App的MainActivity；索引为1的ActivityStack为我们的Home界面。</p>\n<h2 id=\"四种launchMode的一般行为\"><a href=\"#四种launchMode的一般行为\" class=\"headerlink\" title=\"四种launchMode的一般行为\"></a>四种launchMode的一般行为</h2><p>LaunchMode共有4个值可以选择：<strong>Standard</strong>、<strong>SingleTop</strong>、<strong>SingleTask</strong>、<strong>SingleInstance</strong>。接下来将分开讲这4个值的作用，实际上，由于Activity的跳转会涉及到两个Activity，比如ActivityA -&gt; ActivityB，ActivityB的跳转行为模式，不止受到自己launchMode的影响，还会受到ActivityA的launchMode的影响。除此以外，还会有其他属性的影响，比如<code>taskAffinity</code>、<code>allowTaskReparenting</code>、<a href=\"https://developer.android.com/guide/topics/manifest/activity-element#dlmode\"><code>documentLaunchMode</code></a>等。</p>\n<p><strong>Standard</strong></p>\n<p>这是launchMode的值。它的默认行为是：在当前TaskRecord下创建新Activity。</p>\n<p><strong>SingleTop</strong></p>\n<p>SingleTop的行为是：如果有一个同类型的Activity在当前TaskRecord的栈顶，那么就直接使用这个栈顶的Activity并调用其<code>onNewIntent()</code>方法；如果栈顶没有同类型的Activity，则在栈顶创建一个对应的Activity。</p>\n<p><strong>SingleTask</strong></p>\n<p>SingleTask的行为是：在对应<code>taskAffinity</code>的TaskRecord中，如果已经有了对应类型的Activity，则直接使用该Activity，并调用<code>onNewIntent()</code>方法，如果有其他Activity压在该Activity上，则这些Activity都将出栈，该Activity重回栈顶；如果对应<code>taskAffinity</code>的TaskRecord中没有对应类型的Activity，则创建对应类型的Activity并压入栈顶。</p>\n<blockquote>\n<p>这里需要注意的是<code>taskAffinity</code>对该属性的影响，如果没有为<code>android:launchMode=&quot;singleTask&quot;</code>的Activity指定<code>taskAffinity</code>，则默认值为Application的<code>taskAffinity</code>，而Application的默认<code>taskAffinity</code>为包名。</p>\n</blockquote>\n<p><strong>SingleInstance</strong></p>\n<p>SingleInstance的行为是：1，只允许有一个栈中有此Activity，并且这个栈只允许有这一个Activity；2，如果已经有一个栈中有对应的Activity，则直接使用该Activity，并调用<code>onNewIntent()</code>方法。</p>\n<h2 id=\"SingleInstance对其他三种launchMode的影响\"><a href=\"#SingleInstance对其他三种launchMode的影响\" class=\"headerlink\" title=\"SingleInstance对其他三种launchMode的影响\"></a>SingleInstance对其他三种launchMode的影响</h2><p>由于SingleInstance是如此的霸道，导致从一个SingleInstance的Activity启动其他类型Activity的话，会改变其他三种模式的一般行为。</p>\n<p><strong>SingleInstanceA -&gt; StandardB</strong></p>\n<p>StandardActivityB将无法在当前栈中创建，会回到默认栈中创建。</p>\n<p><strong>SingleInstanceA -&gt; SingleTopB</strong></p>\n<p>这个行为就很复杂了，可以按照SingleTopB有无<code>taskAffinity</code>属性分为两种情况：</p>\n<ul>\n<li>无<code>taskAffinity</code>：则直接在默认的栈中，创建新的SingleTopB或者使用已经存在的SingleTopB。</li>\n<li>有<code>taskAffinity</code>：则在指定<code>taskAffinity</code>的栈中创建创建新的SingleTopB或者使用已经存在的SingleTopB。</li>\n</ul>\n<blockquote>\n<p>这里实际上存在一个更为复杂的行为模式：<strong>StandardA -&gt; SingleTopB -&gt; SingleInstanceC -&gt; SingleTopB</strong>。</p>\n<p>如果SingleTop有<code>taskAffinity</code>属性的话，情况就可以分为两个部分：</p>\n<p><strong>StandardA -&gt; SingleTopB</strong>：在StandardA相同TaskRecord中创建SingleTopB的实例singleTopB1。</p>\n<p><strong>SingleInstanceC -&gt; SingleTopB</strong>：在指定<code>taskAffinity</code>的TaskRecord中，创建SingleTopB的实例singleTopB2。</p>\n<p>也就是说，此时有两个SingleTopB对象——singleTopB1和singleTopB2，分别在两个TaskRecord中。</p>\n</blockquote>\n<p><strong>SingleInstanceA -&gt; SingleTaskB</strong></p>\n<p>比照<strong>SingleInstanceA -&gt; SingleTopB</strong>的例子，同样可以可以按照SingleTaskB有无<code>taskAffinity</code>属性分为两种情况：</p>\n<ul>\n<li>无<code>taskAffinity</code>：则直接在默认的栈中，创建新的SingleTaskB或者使用已经存在的SingleTaskB。</li>\n<li>有<code>taskAffinity</code>：则在指定<code>taskAffinity</code>的栈中创建创建新的SingleTaskB或者使用已经存在的SingleTaskB。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>大体了解了不同launchMode的行为逻辑，他们的用途可以简单粗暴的归结如下规律：</p>\n<ul>\n<li>standard和singleTop：多用于App内部；</li>\n<li>singleInstance：多用于开放给外部App来共享使用；</li>\n<li>singleTask：内部交互和外部调用都会用得上。</li>\n</ul>\n<p>当然，不能一概而论，还是要看具体需求。</p>\n<p>看起来似乎很复杂，其实只要掌握了<code>adb shell dumpsys activity</code>这个命令工具，就能清晰的看到当前Activity的分布情况，就能分析出，你的Activity应该用什么<code>launchMode</code>，要不要设置<code>taskAffinity</code>。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.jianshu.com/p/94816e52cd77\">ActivityRecord、TaskRecord、ActivityStack以及Activity启动模式详解</a></p>\n"},{"layout":"post","title":"发布Android库到MavenCentral教程","author":"boybeak","_content":"\n\nJCenter已经宣布，即将在2020年5月1日，停止新的库的提交，在2022年2月21号以前，连库的解析服务也停止，所以，把以前的库或者未来的新库替换到MavenCentral是当务之急了。\n\n我参考的教程来自以下两篇文章：\n\n[Publishing your first Android library to MavenCentral](https://proandroiddev.com/publishing-your-first-android-library-to-mavencentral-be2c51330b88)\n\n[Android库发布到Maven Central全攻略](https://xiaozhuanlan.com/topic/6174835029)\n\nDemo项目地址：\n\n[EasyPack](https://github.com/boybeak/EasyPack)\n\n建议英文能力强的直接第一篇，我是在第二篇遇到问题时候，找到了第一篇文章解决了问题，因为第二篇里用的windows环境，我用的mac环境。\n\n\n\n## 一、 [Sonatype Jira](https://issues.sonatype.org/)相关设置\n\n首先，先去[Sonatype Jira](https://issues.sonatype.org/)这个地址注册一个SonatypeJira的账号；\n\n其次，账号创建后，登录，然后在这个页面https://issues.sonatype.org/projects 点击Create创建一个issue，如下图：\n\n![create](/images/mc_create.jpg)\n\n> 这里group id最好使用你的github地址，这样比较容易验证，如果你想用自己单独的域名，需要做更多的操作。很繁琐，不建议这样做。\n\n创建以后，会有管理员处理你的这个issue，等待管理员回复你的issue，他会告诉你，要在你的github创建一个repo，repo的名字是这个issue的id，比如我的是**OSSRH-66052**。管理员回复我的如下图：\n\n![](/images/mc_replay.jpg)\n\n你创建好repo后，回复管理员就好了，等待这个issue的状态变成**RESOLVED**状态。\n\n![](/images/mc_resolved.jpg)\n\n这样，你就创建好了一个issue，用来承接对应group id下所有的库。\n\n\n\n## 二、Gradle的准备\n\n在你项目根目录下的build.gradle文件添加classpath。\n\n```groovy\nbuildscript {\n    ext {\n        kotlin_version = \"1.4.31\"\n        appcompat = \"1.2.0\"\n        dokka_version = '1.4.10.2'\n    }\n    repositories {\n        google()\n        mavenCentral()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:4.1.3'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n\n        classpath \"org.jetbrains.dokka:dokka-gradle-plugin:$dokka_version\" //新添加的这一classpath\n    }\n}\n```\n\n在你要提交的module下的build.gradle文件中，尾部追加如下代码：\n\n```groovy\next {\n    PUBLISH_ARTIFACT_ID = \"你的artifact_id，一般是module的名字\"\n}\n\napply from: '../publish.gradle'\n```\n\n在根目录下创建publish.gradle，如下：\n\n```groovy\napply plugin: 'maven-publish'\napply plugin: 'signing'\n\ntask androidSourcesJar(type: Jar) {\n    classifier = 'sources'\n    from android.sourceSets.main.java.source\n\n    exclude \"**/R.class\"\n    exclude \"**/BuildConfig.class\"\n}\n\next {\n    PUBLISH_GROUP_ID = '你的group_id'\n    PUBLISH_VERSION = '你的版本号'\n}\n\next[\"signing.keyId\"] = ''\next[\"signing.password\"] = ''\next[\"signing.secretKeyRingFile\"] = ''\next[\"ossrhUsername\"] = ''\next[\"ossrhPassword\"] = ''\n\nFile secretPropsFile = project.rootProject.file('local.properties')\nif (secretPropsFile.exists()) {\n    println \"Found secret props file, loading props\"\n    Properties p = new Properties()\n    p.load(new FileInputStream(secretPropsFile))\n    p.each { name, value ->\n        ext[name] = value\n    }\n} else {\n    println \"No props file, loading env vars\"\n}\npublishing {\n    publications {\n        release(MavenPublication) {\n            // The coordinates of the library, being set from variables that\n            // we'll set up in a moment\n            groupId PUBLISH_GROUP_ID\n            artifactId PUBLISH_ARTIFACT_ID\n            version PUBLISH_VERSION\n\n            // Two artifacts, the `aar` and the sources\n            artifact(\"$buildDir/outputs/aar/${project.getName()}-release.aar\")\n            artifact androidSourcesJar\n\n            // Self-explanatory metadata for the most part\n            pom {\n                name = PUBLISH_ARTIFACT_ID\n                description = '你的项目描述'\n                // If your project has a dedicated site, use its URL here\n                url = 'https://github.com/boybeak/EasyPack'\n                licenses {\n                    license {\n                        //协议类型，一般默认Apache License2.0的话不用改：\n                        name = 'The Apache License, Version 2.0'\n                        url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'\n                    }\n                }\n                developers {\n                    developer {\n                        id = '你的sonatype用户名'\n                        name = '你的sonatype用户名'\n                        email = '你的sonatype注册邮箱'\n                    }\n                }\n                // Version control info, if you're using GitHub, follow the format as seen here\n                scm {\n                    //修改成你的Git地址：\n                    connection = 'scm:git:github.com/你的github账号/你的项目名称.git'\n                    developerConnection = 'scm:git:ssh://github.com/你的github账号/你的项目名称.git'\n                    //分支地址：\n                    url = 'https://github.com/你的github账号/你的项目名称/tree/master'\n                }\n                // A slightly hacky fix so that your POM will include any transitive dependencies\n                // that your library builds upon\n                withXml {\n                    def dependenciesNode = asNode().appendNode('dependencies')\n\n                    project.configurations.implementation.allDependencies.each {\n                        def dependencyNode = dependenciesNode.appendNode('dependency')\n                        dependencyNode.appendNode('groupId', it.group)\n                        dependencyNode.appendNode('artifactId', it.name)\n                        dependencyNode.appendNode('version', it.version)\n                    }\n                }\n            }\n        }\n    }\n    repositories {\n        // The repository to publish to, Sonatype/MavenCentral\n        maven {\n            // This is an arbitrary name, you may also use \"mavencentral\" or\n            // any other name that's descriptive for you\n            name = \"mavencentral\"\n\n            def releasesRepoUrl = \"https://oss.sonatype.org/service/local/staging/deploy/maven2/\"\n            def snapshotsRepoUrl = \"https://oss.sonatype.org/content/repositories/snapshots/\"\n            // You only need this if you want to publish snapshots, otherwise just set the URL\n            // to the release repo directly\n            url = version.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl\n\n            // The username and password we've fetched earlier\n            credentials {\n                username ossrhUsername\n                password ossrhPassword\n            }\n        }\n    }\n}\nsigning {\n    sign publishing.publications\n}\n```\n\n\n\n## 三、创建GPG秘钥\n\n1. https://www.gnupg.org/download/，从这里下载并安装GPG客户端。\n\n2. 在命令行中执行命令`gpg --full-gen-key`，注意，一定要在命令行中执行命令，不能在客户端界面做。\n\n3. 加密方式选择**RSA and RSA**，长度输入**4096**，过期时间直接回车不用管，然后输入一个user ID并且提供一个邮箱，我直接用的我sonatype的用户名和邮箱。最后一步输入'O'，表示OK。\n\n4. 之后会弹出一个对话框，让输入密码。\n\n   ![密码](/images/mc_pwd.png)\n\n   ```shell\n   gpg: revocation certificate stored as '~/.gnupg/openpgp-revocs.d/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXE478F7CC.rev'\n   public and secret key created and signed.\n   \n   pub   rsa4096 2021-03-22 [SC]\n         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXEE478F7CC\n   uid                      boybeak <boybeak@gmail.com>\n   sub   rsa4096 2021-03-22 [E]\n   ```\n\n   \n\n   这会为你在`~/.gnupg/openpgp-revocs.d/`目录下创建一个.rev文件，记住pub的末尾8位。\n\n5. 接下来创建secring.gpg文件，命令行执行`gpg --export-secret-keys -o secring.gpg`，这会要求你输入在步骤4中设置的密码，在你用户根目录下会出现secring.gpg文件。\n\n6. 回到gpg客户端，选择我们刚生成的秘钥条目，右键，选择`Send Public Key to Key Server`。\n\n   ![](/images/mc_cer_push.png)\n\n\n\n## 四、设置local.properties\n\n```groovy\nsigning.keyId=刚才获取的秘钥后8位\nsigning.password=步骤4中设置的密码\nsigning.secretKeyRingFile=刚才生成的secring.gpg文件目录\nossrhUsername=sonatype用户名\nossrhPassword=sonatype密码\n```\n\n\n\n## 五、执行打包和上传\n\n设置完这些后，在AndroidStudio右侧的gradle tasks中找到你想提交的module，先后执行以下两个任务。\n\n![](/images/mc_build_push.jpg)\n\n上传成功后，打开[Nexus Repository Manager](https://oss.sonatype.org/)，登录你的sonatype账号，在左侧`Staging Repositories`页面找到你的group id，选中，点击上边的close，等待几分钟十几分钟后刷新状态，等其状态变为closed后，再点击Release，则所有人都用使用你的库了。\n\n![](/images/mc_publish.jpg)。","source":"_posts/2022-09-19-Mavencentral.md","raw":"---\nlayout: post\ntitle: 发布Android库到MavenCentral教程\nauthor: boybeak\ncategories: Android技巧\ntags: Android\n---\n\n\nJCenter已经宣布，即将在2020年5月1日，停止新的库的提交，在2022年2月21号以前，连库的解析服务也停止，所以，把以前的库或者未来的新库替换到MavenCentral是当务之急了。\n\n我参考的教程来自以下两篇文章：\n\n[Publishing your first Android library to MavenCentral](https://proandroiddev.com/publishing-your-first-android-library-to-mavencentral-be2c51330b88)\n\n[Android库发布到Maven Central全攻略](https://xiaozhuanlan.com/topic/6174835029)\n\nDemo项目地址：\n\n[EasyPack](https://github.com/boybeak/EasyPack)\n\n建议英文能力强的直接第一篇，我是在第二篇遇到问题时候，找到了第一篇文章解决了问题，因为第二篇里用的windows环境，我用的mac环境。\n\n\n\n## 一、 [Sonatype Jira](https://issues.sonatype.org/)相关设置\n\n首先，先去[Sonatype Jira](https://issues.sonatype.org/)这个地址注册一个SonatypeJira的账号；\n\n其次，账号创建后，登录，然后在这个页面https://issues.sonatype.org/projects 点击Create创建一个issue，如下图：\n\n![create](/images/mc_create.jpg)\n\n> 这里group id最好使用你的github地址，这样比较容易验证，如果你想用自己单独的域名，需要做更多的操作。很繁琐，不建议这样做。\n\n创建以后，会有管理员处理你的这个issue，等待管理员回复你的issue，他会告诉你，要在你的github创建一个repo，repo的名字是这个issue的id，比如我的是**OSSRH-66052**。管理员回复我的如下图：\n\n![](/images/mc_replay.jpg)\n\n你创建好repo后，回复管理员就好了，等待这个issue的状态变成**RESOLVED**状态。\n\n![](/images/mc_resolved.jpg)\n\n这样，你就创建好了一个issue，用来承接对应group id下所有的库。\n\n\n\n## 二、Gradle的准备\n\n在你项目根目录下的build.gradle文件添加classpath。\n\n```groovy\nbuildscript {\n    ext {\n        kotlin_version = \"1.4.31\"\n        appcompat = \"1.2.0\"\n        dokka_version = '1.4.10.2'\n    }\n    repositories {\n        google()\n        mavenCentral()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:4.1.3'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n\n        classpath \"org.jetbrains.dokka:dokka-gradle-plugin:$dokka_version\" //新添加的这一classpath\n    }\n}\n```\n\n在你要提交的module下的build.gradle文件中，尾部追加如下代码：\n\n```groovy\next {\n    PUBLISH_ARTIFACT_ID = \"你的artifact_id，一般是module的名字\"\n}\n\napply from: '../publish.gradle'\n```\n\n在根目录下创建publish.gradle，如下：\n\n```groovy\napply plugin: 'maven-publish'\napply plugin: 'signing'\n\ntask androidSourcesJar(type: Jar) {\n    classifier = 'sources'\n    from android.sourceSets.main.java.source\n\n    exclude \"**/R.class\"\n    exclude \"**/BuildConfig.class\"\n}\n\next {\n    PUBLISH_GROUP_ID = '你的group_id'\n    PUBLISH_VERSION = '你的版本号'\n}\n\next[\"signing.keyId\"] = ''\next[\"signing.password\"] = ''\next[\"signing.secretKeyRingFile\"] = ''\next[\"ossrhUsername\"] = ''\next[\"ossrhPassword\"] = ''\n\nFile secretPropsFile = project.rootProject.file('local.properties')\nif (secretPropsFile.exists()) {\n    println \"Found secret props file, loading props\"\n    Properties p = new Properties()\n    p.load(new FileInputStream(secretPropsFile))\n    p.each { name, value ->\n        ext[name] = value\n    }\n} else {\n    println \"No props file, loading env vars\"\n}\npublishing {\n    publications {\n        release(MavenPublication) {\n            // The coordinates of the library, being set from variables that\n            // we'll set up in a moment\n            groupId PUBLISH_GROUP_ID\n            artifactId PUBLISH_ARTIFACT_ID\n            version PUBLISH_VERSION\n\n            // Two artifacts, the `aar` and the sources\n            artifact(\"$buildDir/outputs/aar/${project.getName()}-release.aar\")\n            artifact androidSourcesJar\n\n            // Self-explanatory metadata for the most part\n            pom {\n                name = PUBLISH_ARTIFACT_ID\n                description = '你的项目描述'\n                // If your project has a dedicated site, use its URL here\n                url = 'https://github.com/boybeak/EasyPack'\n                licenses {\n                    license {\n                        //协议类型，一般默认Apache License2.0的话不用改：\n                        name = 'The Apache License, Version 2.0'\n                        url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'\n                    }\n                }\n                developers {\n                    developer {\n                        id = '你的sonatype用户名'\n                        name = '你的sonatype用户名'\n                        email = '你的sonatype注册邮箱'\n                    }\n                }\n                // Version control info, if you're using GitHub, follow the format as seen here\n                scm {\n                    //修改成你的Git地址：\n                    connection = 'scm:git:github.com/你的github账号/你的项目名称.git'\n                    developerConnection = 'scm:git:ssh://github.com/你的github账号/你的项目名称.git'\n                    //分支地址：\n                    url = 'https://github.com/你的github账号/你的项目名称/tree/master'\n                }\n                // A slightly hacky fix so that your POM will include any transitive dependencies\n                // that your library builds upon\n                withXml {\n                    def dependenciesNode = asNode().appendNode('dependencies')\n\n                    project.configurations.implementation.allDependencies.each {\n                        def dependencyNode = dependenciesNode.appendNode('dependency')\n                        dependencyNode.appendNode('groupId', it.group)\n                        dependencyNode.appendNode('artifactId', it.name)\n                        dependencyNode.appendNode('version', it.version)\n                    }\n                }\n            }\n        }\n    }\n    repositories {\n        // The repository to publish to, Sonatype/MavenCentral\n        maven {\n            // This is an arbitrary name, you may also use \"mavencentral\" or\n            // any other name that's descriptive for you\n            name = \"mavencentral\"\n\n            def releasesRepoUrl = \"https://oss.sonatype.org/service/local/staging/deploy/maven2/\"\n            def snapshotsRepoUrl = \"https://oss.sonatype.org/content/repositories/snapshots/\"\n            // You only need this if you want to publish snapshots, otherwise just set the URL\n            // to the release repo directly\n            url = version.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl\n\n            // The username and password we've fetched earlier\n            credentials {\n                username ossrhUsername\n                password ossrhPassword\n            }\n        }\n    }\n}\nsigning {\n    sign publishing.publications\n}\n```\n\n\n\n## 三、创建GPG秘钥\n\n1. https://www.gnupg.org/download/，从这里下载并安装GPG客户端。\n\n2. 在命令行中执行命令`gpg --full-gen-key`，注意，一定要在命令行中执行命令，不能在客户端界面做。\n\n3. 加密方式选择**RSA and RSA**，长度输入**4096**，过期时间直接回车不用管，然后输入一个user ID并且提供一个邮箱，我直接用的我sonatype的用户名和邮箱。最后一步输入'O'，表示OK。\n\n4. 之后会弹出一个对话框，让输入密码。\n\n   ![密码](/images/mc_pwd.png)\n\n   ```shell\n   gpg: revocation certificate stored as '~/.gnupg/openpgp-revocs.d/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXE478F7CC.rev'\n   public and secret key created and signed.\n   \n   pub   rsa4096 2021-03-22 [SC]\n         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXEE478F7CC\n   uid                      boybeak <boybeak@gmail.com>\n   sub   rsa4096 2021-03-22 [E]\n   ```\n\n   \n\n   这会为你在`~/.gnupg/openpgp-revocs.d/`目录下创建一个.rev文件，记住pub的末尾8位。\n\n5. 接下来创建secring.gpg文件，命令行执行`gpg --export-secret-keys -o secring.gpg`，这会要求你输入在步骤4中设置的密码，在你用户根目录下会出现secring.gpg文件。\n\n6. 回到gpg客户端，选择我们刚生成的秘钥条目，右键，选择`Send Public Key to Key Server`。\n\n   ![](/images/mc_cer_push.png)\n\n\n\n## 四、设置local.properties\n\n```groovy\nsigning.keyId=刚才获取的秘钥后8位\nsigning.password=步骤4中设置的密码\nsigning.secretKeyRingFile=刚才生成的secring.gpg文件目录\nossrhUsername=sonatype用户名\nossrhPassword=sonatype密码\n```\n\n\n\n## 五、执行打包和上传\n\n设置完这些后，在AndroidStudio右侧的gradle tasks中找到你想提交的module，先后执行以下两个任务。\n\n![](/images/mc_build_push.jpg)\n\n上传成功后，打开[Nexus Repository Manager](https://oss.sonatype.org/)，登录你的sonatype账号，在左侧`Staging Repositories`页面找到你的group id，选中，点击上边的close，等待几分钟十几分钟后刷新状态，等其状态变为closed后，再点击Release，则所有人都用使用你的库了。\n\n![](/images/mc_publish.jpg)。","slug":"2022-09-19-Mavencentral","published":1,"date":"2021-03-23T06:41:00.000Z","updated":"2023-02-05T04:18:27.022Z","_id":"cldqukh9j001epcjgfnrxdz5w","comments":1,"photos":[],"link":"","content":"<p>JCenter已经宣布，即将在2020年5月1日，停止新的库的提交，在2022年2月21号以前，连库的解析服务也停止，所以，把以前的库或者未来的新库替换到MavenCentral是当务之急了。</p>\n<p>我参考的教程来自以下两篇文章：</p>\n<p><a href=\"https://proandroiddev.com/publishing-your-first-android-library-to-mavencentral-be2c51330b88\">Publishing your first Android library to MavenCentral</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/6174835029\">Android库发布到Maven Central全攻略</a></p>\n<p>Demo项目地址：</p>\n<p><a href=\"https://github.com/boybeak/EasyPack\">EasyPack</a></p>\n<p>建议英文能力强的直接第一篇，我是在第二篇遇到问题时候，找到了第一篇文章解决了问题，因为第二篇里用的windows环境，我用的mac环境。</p>\n<h2 id=\"一、-Sonatype-Jira相关设置\"><a href=\"#一、-Sonatype-Jira相关设置\" class=\"headerlink\" title=\"一、 Sonatype Jira相关设置\"></a>一、 <a href=\"https://issues.sonatype.org/\">Sonatype Jira</a>相关设置</h2><p>首先，先去<a href=\"https://issues.sonatype.org/\">Sonatype Jira</a>这个地址注册一个SonatypeJira的账号；</p>\n<p>其次，账号创建后，登录，然后在这个页面<a href=\"https://issues.sonatype.org/projects\">https://issues.sonatype.org/projects</a> 点击Create创建一个issue，如下图：</p>\n<p><img src=\"/images/mc_create.jpg\" alt=\"create\"></p>\n<blockquote>\n<p>这里group id最好使用你的github地址，这样比较容易验证，如果你想用自己单独的域名，需要做更多的操作。很繁琐，不建议这样做。</p>\n</blockquote>\n<p>创建以后，会有管理员处理你的这个issue，等待管理员回复你的issue，他会告诉你，要在你的github创建一个repo，repo的名字是这个issue的id，比如我的是<strong>OSSRH-66052</strong>。管理员回复我的如下图：</p>\n<p><img src=\"/images/mc_replay.jpg\"></p>\n<p>你创建好repo后，回复管理员就好了，等待这个issue的状态变成<strong>RESOLVED</strong>状态。</p>\n<p><img src=\"/images/mc_resolved.jpg\"></p>\n<p>这样，你就创建好了一个issue，用来承接对应group id下所有的库。</p>\n<h2 id=\"二、Gradle的准备\"><a href=\"#二、Gradle的准备\" class=\"headerlink\" title=\"二、Gradle的准备\"></a>二、Gradle的准备</h2><p>在你项目根目录下的build.gradle文件添加classpath。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        kotlin_version = <span class=\"string\">&quot;1.4.31&quot;</span></span><br><span class=\"line\">        appcompat = <span class=\"string\">&quot;1.2.0&quot;</span></span><br><span class=\"line\">        dokka_version = <span class=\"string\">&#x27;1.4.10.2&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">&#x27;com.android.tools.build:gradle:4.1.3&#x27;</span></span><br><span class=\"line\">        classpath <span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        classpath <span class=\"string\">&quot;org.jetbrains.dokka:dokka-gradle-plugin:$dokka_version&quot;</span> <span class=\"comment\">//新添加的这一classpath</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在你要提交的module下的build.gradle文件中，尾部追加如下代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext &#123;</span><br><span class=\"line\">    PUBLISH_ARTIFACT_ID = <span class=\"string\">&quot;你的artifact_id，一般是module的名字&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">apply <span class=\"attr\">from:</span> <span class=\"string\">&#x27;../publish.gradle&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在根目录下创建publish.gradle，如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;maven-publish&#x27;</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;signing&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">task androidSourcesJar(<span class=\"attr\">type:</span> Jar) &#123;</span><br><span class=\"line\">    classifier = <span class=\"string\">&#x27;sources&#x27;</span></span><br><span class=\"line\">    from android.sourceSets.main.java.source</span><br><span class=\"line\"></span><br><span class=\"line\">    exclude <span class=\"string\">&quot;**/R.class&quot;</span></span><br><span class=\"line\">    exclude <span class=\"string\">&quot;**/BuildConfig.class&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ext &#123;</span><br><span class=\"line\">    PUBLISH_GROUP_ID = <span class=\"string\">&#x27;你的group_id&#x27;</span></span><br><span class=\"line\">    PUBLISH_VERSION = <span class=\"string\">&#x27;你的版本号&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ext[<span class=\"string\">&quot;signing.keyId&quot;</span>] = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">ext[<span class=\"string\">&quot;signing.password&quot;</span>] = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">ext[<span class=\"string\">&quot;signing.secretKeyRingFile&quot;</span>] = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">ext[<span class=\"string\">&quot;ossrhUsername&quot;</span>] = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">ext[<span class=\"string\">&quot;ossrhPassword&quot;</span>] = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">File secretPropsFile = project.rootProject.file(<span class=\"string\">&#x27;local.properties&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (secretPropsFile.exists()) &#123;</span><br><span class=\"line\">    println <span class=\"string\">&quot;Found secret props file, loading props&quot;</span></span><br><span class=\"line\">    Properties p = <span class=\"keyword\">new</span> Properties()</span><br><span class=\"line\">    p.load(<span class=\"keyword\">new</span> FileInputStream(secretPropsFile))</span><br><span class=\"line\">    p.each &#123; name, value -&gt;</span><br><span class=\"line\">        ext[name] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    println <span class=\"string\">&quot;No props file, loading env vars&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">publishing &#123;</span><br><span class=\"line\">    publications &#123;</span><br><span class=\"line\">        release(MavenPublication) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The coordinates of the library, being set from variables that</span></span><br><span class=\"line\">            <span class=\"comment\">// we&#x27;ll set up in a moment</span></span><br><span class=\"line\">            groupId PUBLISH_GROUP_ID</span><br><span class=\"line\">            artifactId PUBLISH_ARTIFACT_ID</span><br><span class=\"line\">            version PUBLISH_VERSION</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Two artifacts, the `aar` and the sources</span></span><br><span class=\"line\">            artifact(<span class=\"string\">&quot;$buildDir/outputs/aar/$&#123;project.getName()&#125;-release.aar&quot;</span>)</span><br><span class=\"line\">            artifact androidSourcesJar</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Self-explanatory metadata for the most part</span></span><br><span class=\"line\">            pom &#123;</span><br><span class=\"line\">                name = PUBLISH_ARTIFACT_ID</span><br><span class=\"line\">                description = <span class=\"string\">&#x27;你的项目描述&#x27;</span></span><br><span class=\"line\">                <span class=\"comment\">// If your project has a dedicated site, use its URL here</span></span><br><span class=\"line\">                url = <span class=\"string\">&#x27;https://github.com/boybeak/EasyPack&#x27;</span></span><br><span class=\"line\">                licenses &#123;</span><br><span class=\"line\">                    license &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//协议类型，一般默认Apache License2.0的话不用改：</span></span><br><span class=\"line\">                        name = <span class=\"string\">&#x27;The Apache License, Version 2.0&#x27;</span></span><br><span class=\"line\">                        url = <span class=\"string\">&#x27;http://www.apache.org/licenses/LICENSE-2.0.txt&#x27;</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                developers &#123;</span><br><span class=\"line\">                    developer &#123;</span><br><span class=\"line\">                        id = <span class=\"string\">&#x27;你的sonatype用户名&#x27;</span></span><br><span class=\"line\">                        name = <span class=\"string\">&#x27;你的sonatype用户名&#x27;</span></span><br><span class=\"line\">                        email = <span class=\"string\">&#x27;你的sonatype注册邮箱&#x27;</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// Version control info, if you&#x27;re using GitHub, follow the format as seen here</span></span><br><span class=\"line\">                scm &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//修改成你的Git地址：</span></span><br><span class=\"line\">                    connection = <span class=\"string\">&#x27;scm:git:github.com/你的github账号/你的项目名称.git&#x27;</span></span><br><span class=\"line\">                    developerConnection = <span class=\"string\">&#x27;scm:git:ssh://github.com/你的github账号/你的项目名称.git&#x27;</span></span><br><span class=\"line\">                    <span class=\"comment\">//分支地址：</span></span><br><span class=\"line\">                    url = <span class=\"string\">&#x27;https://github.com/你的github账号/你的项目名称/tree/master&#x27;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// A slightly hacky fix so that your POM will include any transitive dependencies</span></span><br><span class=\"line\">                <span class=\"comment\">// that your library builds upon</span></span><br><span class=\"line\">                withXml &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">def</span> dependenciesNode = asNode().appendNode(<span class=\"string\">&#x27;dependencies&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">                    project.configurations.implementation.allDependencies.each &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">def</span> dependencyNode = dependenciesNode.appendNode(<span class=\"string\">&#x27;dependency&#x27;</span>)</span><br><span class=\"line\">                        dependencyNode.appendNode(<span class=\"string\">&#x27;groupId&#x27;</span>, it.group)</span><br><span class=\"line\">                        dependencyNode.appendNode(<span class=\"string\">&#x27;artifactId&#x27;</span>, it.name)</span><br><span class=\"line\">                        dependencyNode.appendNode(<span class=\"string\">&#x27;version&#x27;</span>, it.version)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The repository to publish to, Sonatype/MavenCentral</span></span><br><span class=\"line\">        maven &#123;</span><br><span class=\"line\">            <span class=\"comment\">// This is an arbitrary name, you may also use &quot;mavencentral&quot; or</span></span><br><span class=\"line\">            <span class=\"comment\">// any other name that&#x27;s descriptive for you</span></span><br><span class=\"line\">            name = <span class=\"string\">&quot;mavencentral&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">def</span> releasesRepoUrl = <span class=\"string\">&quot;https://oss.sonatype.org/service/local/staging/deploy/maven2/&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">def</span> snapshotsRepoUrl = <span class=\"string\">&quot;https://oss.sonatype.org/content/repositories/snapshots/&quot;</span></span><br><span class=\"line\">            <span class=\"comment\">// You only need this if you want to publish snapshots, otherwise just set the URL</span></span><br><span class=\"line\">            <span class=\"comment\">// to the release repo directly</span></span><br><span class=\"line\">            url = version.endsWith(<span class=\"string\">&#x27;SNAPSHOT&#x27;</span>) ? snapshotsRepoUrl : releasesRepoUrl</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// The username and password we&#x27;ve fetched earlier</span></span><br><span class=\"line\">            credentials &#123;</span><br><span class=\"line\">                username ossrhUsername</span><br><span class=\"line\">                password ossrhPassword</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">signing &#123;</span><br><span class=\"line\">    sign publishing.publications</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"三、创建GPG秘钥\"><a href=\"#三、创建GPG秘钥\" class=\"headerlink\" title=\"三、创建GPG秘钥\"></a>三、创建GPG秘钥</h2><ol>\n<li><p><a href=\"https://www.gnupg.org/download/%EF%BC%8C%E4%BB%8E%E8%BF%99%E9%87%8C%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85GPG%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%82\">https://www.gnupg.org/download/，从这里下载并安装GPG客户端。</a></p>\n</li>\n<li><p>在命令行中执行命令<code>gpg --full-gen-key</code>，注意，一定要在命令行中执行命令，不能在客户端界面做。</p>\n</li>\n<li><p>加密方式选择<strong>RSA and RSA</strong>，长度输入<strong>4096</strong>，过期时间直接回车不用管，然后输入一个user ID并且提供一个邮箱，我直接用的我sonatype的用户名和邮箱。最后一步输入’O’，表示OK。</p>\n</li>\n<li><p>之后会弹出一个对话框，让输入密码。</p>\n<p><img src=\"/images/mc_pwd.png\" alt=\"密码\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpg: revocation certificate stored as &#x27;~/.gnupg/openpgp-revocs.d/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXE478F7CC.rev&#x27;</span><br><span class=\"line\">public and secret key created and signed.</span><br><span class=\"line\"></span><br><span class=\"line\">pub   rsa4096 2021-03-22 [SC]</span><br><span class=\"line\">      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXEE478F7CC</span><br><span class=\"line\">uid                      boybeak &lt;boybeak@gmail.com&gt;</span><br><span class=\"line\">sub   rsa4096 2021-03-22 [E]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这会为你在<code>~/.gnupg/openpgp-revocs.d/</code>目录下创建一个.rev文件，记住pub的末尾8位。</p>\n</li>\n<li><p>接下来创建secring.gpg文件，命令行执行<code>gpg --export-secret-keys -o secring.gpg</code>，这会要求你输入在步骤4中设置的密码，在你用户根目录下会出现secring.gpg文件。</p>\n</li>\n<li><p>回到gpg客户端，选择我们刚生成的秘钥条目，右键，选择<code>Send Public Key to Key Server</code>。</p>\n<p><img src=\"/images/mc_cer_push.png\"></p>\n</li>\n</ol>\n<h2 id=\"四、设置local-properties\"><a href=\"#四、设置local-properties\" class=\"headerlink\" title=\"四、设置local.properties\"></a>四、设置local.properties</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">signing.keyId=刚才获取的秘钥后<span class=\"number\">8</span>位</span><br><span class=\"line\">signing.password=步骤<span class=\"number\">4</span>中设置的密码</span><br><span class=\"line\">signing.secretKeyRingFile=刚才生成的secring.gpg文件目录</span><br><span class=\"line\">ossrhUsername=sonatype用户名</span><br><span class=\"line\">ossrhPassword=sonatype密码</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"五、执行打包和上传\"><a href=\"#五、执行打包和上传\" class=\"headerlink\" title=\"五、执行打包和上传\"></a>五、执行打包和上传</h2><p>设置完这些后，在AndroidStudio右侧的gradle tasks中找到你想提交的module，先后执行以下两个任务。</p>\n<p><img src=\"/images/mc_build_push.jpg\"></p>\n<p>上传成功后，打开<a href=\"https://oss.sonatype.org/\">Nexus Repository Manager</a>，登录你的sonatype账号，在左侧<code>Staging Repositories</code>页面找到你的group id，选中，点击上边的close，等待几分钟十几分钟后刷新状态，等其状态变为closed后，再点击Release，则所有人都用使用你的库了。</p>\n<p><img src=\"/images/mc_publish.jpg\">。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>JCenter已经宣布，即将在2020年5月1日，停止新的库的提交，在2022年2月21号以前，连库的解析服务也停止，所以，把以前的库或者未来的新库替换到MavenCentral是当务之急了。</p>\n<p>我参考的教程来自以下两篇文章：</p>\n<p><a href=\"https://proandroiddev.com/publishing-your-first-android-library-to-mavencentral-be2c51330b88\">Publishing your first Android library to MavenCentral</a></p>\n<p><a href=\"https://xiaozhuanlan.com/topic/6174835029\">Android库发布到Maven Central全攻略</a></p>\n<p>Demo项目地址：</p>\n<p><a href=\"https://github.com/boybeak/EasyPack\">EasyPack</a></p>\n<p>建议英文能力强的直接第一篇，我是在第二篇遇到问题时候，找到了第一篇文章解决了问题，因为第二篇里用的windows环境，我用的mac环境。</p>\n<h2 id=\"一、-Sonatype-Jira相关设置\"><a href=\"#一、-Sonatype-Jira相关设置\" class=\"headerlink\" title=\"一、 Sonatype Jira相关设置\"></a>一、 <a href=\"https://issues.sonatype.org/\">Sonatype Jira</a>相关设置</h2><p>首先，先去<a href=\"https://issues.sonatype.org/\">Sonatype Jira</a>这个地址注册一个SonatypeJira的账号；</p>\n<p>其次，账号创建后，登录，然后在这个页面<a href=\"https://issues.sonatype.org/projects\">https://issues.sonatype.org/projects</a> 点击Create创建一个issue，如下图：</p>\n<p><img src=\"/images/mc_create.jpg\" alt=\"create\"></p>\n<blockquote>\n<p>这里group id最好使用你的github地址，这样比较容易验证，如果你想用自己单独的域名，需要做更多的操作。很繁琐，不建议这样做。</p>\n</blockquote>\n<p>创建以后，会有管理员处理你的这个issue，等待管理员回复你的issue，他会告诉你，要在你的github创建一个repo，repo的名字是这个issue的id，比如我的是<strong>OSSRH-66052</strong>。管理员回复我的如下图：</p>\n<p><img src=\"/images/mc_replay.jpg\"></p>\n<p>你创建好repo后，回复管理员就好了，等待这个issue的状态变成<strong>RESOLVED</strong>状态。</p>\n<p><img src=\"/images/mc_resolved.jpg\"></p>\n<p>这样，你就创建好了一个issue，用来承接对应group id下所有的库。</p>\n<h2 id=\"二、Gradle的准备\"><a href=\"#二、Gradle的准备\" class=\"headerlink\" title=\"二、Gradle的准备\"></a>二、Gradle的准备</h2><p>在你项目根目录下的build.gradle文件添加classpath。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        kotlin_version = <span class=\"string\">&quot;1.4.31&quot;</span></span><br><span class=\"line\">        appcompat = <span class=\"string\">&quot;1.2.0&quot;</span></span><br><span class=\"line\">        dokka_version = <span class=\"string\">&#x27;1.4.10.2&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">&#x27;com.android.tools.build:gradle:4.1.3&#x27;</span></span><br><span class=\"line\">        classpath <span class=\"string\">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        classpath <span class=\"string\">&quot;org.jetbrains.dokka:dokka-gradle-plugin:$dokka_version&quot;</span> <span class=\"comment\">//新添加的这一classpath</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在你要提交的module下的build.gradle文件中，尾部追加如下代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext &#123;</span><br><span class=\"line\">    PUBLISH_ARTIFACT_ID = <span class=\"string\">&quot;你的artifact_id，一般是module的名字&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">apply <span class=\"attr\">from:</span> <span class=\"string\">&#x27;../publish.gradle&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在根目录下创建publish.gradle，如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;maven-publish&#x27;</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;signing&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">task androidSourcesJar(<span class=\"attr\">type:</span> Jar) &#123;</span><br><span class=\"line\">    classifier = <span class=\"string\">&#x27;sources&#x27;</span></span><br><span class=\"line\">    from android.sourceSets.main.java.source</span><br><span class=\"line\"></span><br><span class=\"line\">    exclude <span class=\"string\">&quot;**/R.class&quot;</span></span><br><span class=\"line\">    exclude <span class=\"string\">&quot;**/BuildConfig.class&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ext &#123;</span><br><span class=\"line\">    PUBLISH_GROUP_ID = <span class=\"string\">&#x27;你的group_id&#x27;</span></span><br><span class=\"line\">    PUBLISH_VERSION = <span class=\"string\">&#x27;你的版本号&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ext[<span class=\"string\">&quot;signing.keyId&quot;</span>] = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">ext[<span class=\"string\">&quot;signing.password&quot;</span>] = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">ext[<span class=\"string\">&quot;signing.secretKeyRingFile&quot;</span>] = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">ext[<span class=\"string\">&quot;ossrhUsername&quot;</span>] = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">ext[<span class=\"string\">&quot;ossrhPassword&quot;</span>] = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">File secretPropsFile = project.rootProject.file(<span class=\"string\">&#x27;local.properties&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (secretPropsFile.exists()) &#123;</span><br><span class=\"line\">    println <span class=\"string\">&quot;Found secret props file, loading props&quot;</span></span><br><span class=\"line\">    Properties p = <span class=\"keyword\">new</span> Properties()</span><br><span class=\"line\">    p.load(<span class=\"keyword\">new</span> FileInputStream(secretPropsFile))</span><br><span class=\"line\">    p.each &#123; name, value -&gt;</span><br><span class=\"line\">        ext[name] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    println <span class=\"string\">&quot;No props file, loading env vars&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">publishing &#123;</span><br><span class=\"line\">    publications &#123;</span><br><span class=\"line\">        release(MavenPublication) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The coordinates of the library, being set from variables that</span></span><br><span class=\"line\">            <span class=\"comment\">// we&#x27;ll set up in a moment</span></span><br><span class=\"line\">            groupId PUBLISH_GROUP_ID</span><br><span class=\"line\">            artifactId PUBLISH_ARTIFACT_ID</span><br><span class=\"line\">            version PUBLISH_VERSION</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Two artifacts, the `aar` and the sources</span></span><br><span class=\"line\">            artifact(<span class=\"string\">&quot;$buildDir/outputs/aar/$&#123;project.getName()&#125;-release.aar&quot;</span>)</span><br><span class=\"line\">            artifact androidSourcesJar</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Self-explanatory metadata for the most part</span></span><br><span class=\"line\">            pom &#123;</span><br><span class=\"line\">                name = PUBLISH_ARTIFACT_ID</span><br><span class=\"line\">                description = <span class=\"string\">&#x27;你的项目描述&#x27;</span></span><br><span class=\"line\">                <span class=\"comment\">// If your project has a dedicated site, use its URL here</span></span><br><span class=\"line\">                url = <span class=\"string\">&#x27;https://github.com/boybeak/EasyPack&#x27;</span></span><br><span class=\"line\">                licenses &#123;</span><br><span class=\"line\">                    license &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//协议类型，一般默认Apache License2.0的话不用改：</span></span><br><span class=\"line\">                        name = <span class=\"string\">&#x27;The Apache License, Version 2.0&#x27;</span></span><br><span class=\"line\">                        url = <span class=\"string\">&#x27;http://www.apache.org/licenses/LICENSE-2.0.txt&#x27;</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                developers &#123;</span><br><span class=\"line\">                    developer &#123;</span><br><span class=\"line\">                        id = <span class=\"string\">&#x27;你的sonatype用户名&#x27;</span></span><br><span class=\"line\">                        name = <span class=\"string\">&#x27;你的sonatype用户名&#x27;</span></span><br><span class=\"line\">                        email = <span class=\"string\">&#x27;你的sonatype注册邮箱&#x27;</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// Version control info, if you&#x27;re using GitHub, follow the format as seen here</span></span><br><span class=\"line\">                scm &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//修改成你的Git地址：</span></span><br><span class=\"line\">                    connection = <span class=\"string\">&#x27;scm:git:github.com/你的github账号/你的项目名称.git&#x27;</span></span><br><span class=\"line\">                    developerConnection = <span class=\"string\">&#x27;scm:git:ssh://github.com/你的github账号/你的项目名称.git&#x27;</span></span><br><span class=\"line\">                    <span class=\"comment\">//分支地址：</span></span><br><span class=\"line\">                    url = <span class=\"string\">&#x27;https://github.com/你的github账号/你的项目名称/tree/master&#x27;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// A slightly hacky fix so that your POM will include any transitive dependencies</span></span><br><span class=\"line\">                <span class=\"comment\">// that your library builds upon</span></span><br><span class=\"line\">                withXml &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">def</span> dependenciesNode = asNode().appendNode(<span class=\"string\">&#x27;dependencies&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">                    project.configurations.implementation.allDependencies.each &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">def</span> dependencyNode = dependenciesNode.appendNode(<span class=\"string\">&#x27;dependency&#x27;</span>)</span><br><span class=\"line\">                        dependencyNode.appendNode(<span class=\"string\">&#x27;groupId&#x27;</span>, it.group)</span><br><span class=\"line\">                        dependencyNode.appendNode(<span class=\"string\">&#x27;artifactId&#x27;</span>, it.name)</span><br><span class=\"line\">                        dependencyNode.appendNode(<span class=\"string\">&#x27;version&#x27;</span>, it.version)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The repository to publish to, Sonatype/MavenCentral</span></span><br><span class=\"line\">        maven &#123;</span><br><span class=\"line\">            <span class=\"comment\">// This is an arbitrary name, you may also use &quot;mavencentral&quot; or</span></span><br><span class=\"line\">            <span class=\"comment\">// any other name that&#x27;s descriptive for you</span></span><br><span class=\"line\">            name = <span class=\"string\">&quot;mavencentral&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">def</span> releasesRepoUrl = <span class=\"string\">&quot;https://oss.sonatype.org/service/local/staging/deploy/maven2/&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">def</span> snapshotsRepoUrl = <span class=\"string\">&quot;https://oss.sonatype.org/content/repositories/snapshots/&quot;</span></span><br><span class=\"line\">            <span class=\"comment\">// You only need this if you want to publish snapshots, otherwise just set the URL</span></span><br><span class=\"line\">            <span class=\"comment\">// to the release repo directly</span></span><br><span class=\"line\">            url = version.endsWith(<span class=\"string\">&#x27;SNAPSHOT&#x27;</span>) ? snapshotsRepoUrl : releasesRepoUrl</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// The username and password we&#x27;ve fetched earlier</span></span><br><span class=\"line\">            credentials &#123;</span><br><span class=\"line\">                username ossrhUsername</span><br><span class=\"line\">                password ossrhPassword</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">signing &#123;</span><br><span class=\"line\">    sign publishing.publications</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"三、创建GPG秘钥\"><a href=\"#三、创建GPG秘钥\" class=\"headerlink\" title=\"三、创建GPG秘钥\"></a>三、创建GPG秘钥</h2><ol>\n<li><p><a href=\"https://www.gnupg.org/download/%EF%BC%8C%E4%BB%8E%E8%BF%99%E9%87%8C%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85GPG%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%82\">https://www.gnupg.org/download/，从这里下载并安装GPG客户端。</a></p>\n</li>\n<li><p>在命令行中执行命令<code>gpg --full-gen-key</code>，注意，一定要在命令行中执行命令，不能在客户端界面做。</p>\n</li>\n<li><p>加密方式选择<strong>RSA and RSA</strong>，长度输入<strong>4096</strong>，过期时间直接回车不用管，然后输入一个user ID并且提供一个邮箱，我直接用的我sonatype的用户名和邮箱。最后一步输入’O’，表示OK。</p>\n</li>\n<li><p>之后会弹出一个对话框，让输入密码。</p>\n<p><img src=\"/images/mc_pwd.png\" alt=\"密码\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpg: revocation certificate stored as &#x27;~/.gnupg/openpgp-revocs.d/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXE478F7CC.rev&#x27;</span><br><span class=\"line\">public and secret key created and signed.</span><br><span class=\"line\"></span><br><span class=\"line\">pub   rsa4096 2021-03-22 [SC]</span><br><span class=\"line\">      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXEE478F7CC</span><br><span class=\"line\">uid                      boybeak &lt;boybeak@gmail.com&gt;</span><br><span class=\"line\">sub   rsa4096 2021-03-22 [E]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这会为你在<code>~/.gnupg/openpgp-revocs.d/</code>目录下创建一个.rev文件，记住pub的末尾8位。</p>\n</li>\n<li><p>接下来创建secring.gpg文件，命令行执行<code>gpg --export-secret-keys -o secring.gpg</code>，这会要求你输入在步骤4中设置的密码，在你用户根目录下会出现secring.gpg文件。</p>\n</li>\n<li><p>回到gpg客户端，选择我们刚生成的秘钥条目，右键，选择<code>Send Public Key to Key Server</code>。</p>\n<p><img src=\"/images/mc_cer_push.png\"></p>\n</li>\n</ol>\n<h2 id=\"四、设置local-properties\"><a href=\"#四、设置local-properties\" class=\"headerlink\" title=\"四、设置local.properties\"></a>四、设置local.properties</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">signing.keyId=刚才获取的秘钥后<span class=\"number\">8</span>位</span><br><span class=\"line\">signing.password=步骤<span class=\"number\">4</span>中设置的密码</span><br><span class=\"line\">signing.secretKeyRingFile=刚才生成的secring.gpg文件目录</span><br><span class=\"line\">ossrhUsername=sonatype用户名</span><br><span class=\"line\">ossrhPassword=sonatype密码</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"五、执行打包和上传\"><a href=\"#五、执行打包和上传\" class=\"headerlink\" title=\"五、执行打包和上传\"></a>五、执行打包和上传</h2><p>设置完这些后，在AndroidStudio右侧的gradle tasks中找到你想提交的module，先后执行以下两个任务。</p>\n<p><img src=\"/images/mc_build_push.jpg\"></p>\n<p>上传成功后，打开<a href=\"https://oss.sonatype.org/\">Nexus Repository Manager</a>，登录你的sonatype账号，在左侧<code>Staging Repositories</code>页面找到你的group id，选中，点击上边的close，等待几分钟十几分钟后刷新状态，等其状态变为closed后，再点击Release，则所有人都用使用你的库了。</p>\n<p><img src=\"/images/mc_publish.jpg\">。</p>\n"},{"layout":"post","title":"难忘的bug","author":"boybeak","_content":"\n此贴是为了记录日常开发过程中，遇到的一些让人难忘的bug。\n* MediaPlayer: surface has already been released\n* kotlin ?.的陷阱与缺陷\n\n## surface has already been released\n**场景**：MediaPlayer做跨进程的视频播放发现的，由于有无画面的后台播放场景，所以，MediaPlayer的相关操作放在独立进程的Service中，通过跨进程的调度，进行相关媒体操作，包括设置用于展示画面的Surface，Surface是一个Parcable类，所以是可以通过跨进程传输的。\n**归因**：在播放进程中，用成员变量缓存了通过`setSurface`设置的surface变量，以便于从后台恢复前台播放时候，可以直接使用，而不需要再次传入surface参数。但是这样做是不可以的，会爆出`surface has already been released`的错误。\nIPlayer.aidl如下：\n```aidl\ninterface IPlayer {\n    void setSurface(inout Surface surface);\n}\n```\n需要注意的是，此处surface的修饰符包括一个inout。这样设置，是为了适配IjkMediaPlayer切换全屏的场景。如果把这个修饰符改成`in`，则IjkMediaPlayer在通过`setSurface`多次修改surface时候，也会爆出`surface has already been released`这样的问题。\n\n## kotlin ?.的陷阱与缺陷\n`?.`是kotlin的空安全语法。相比Java的if语句判断，这样做要简洁的多，但是这里边有一种“陷阱”，这并不是kotlin本身的问题，而是使用者容易疏忽的问题。\n展示逻辑的伪代码如下：\n```\n方法A(回调) {\n    结果1 = 动作1\n    结果2 = 动作2\n    回调(结果1, 结果2)\n}\n```\n简单解释一下，一个`方法A`，带有一个Nullable的`回调`，需要执行`动作1`和`动作2`，分别返回了`结果1`和`结果2`，并且在`回调`中返回结果。\n上述逻辑用kotlin实现如下：\n```kotlin\n// 方案一\nfun action1(): Int = 1\nfun action2(): Int = 2\nfun methodA(block: ((Int, Int) -> Unit)? = null) {\n    val result1 = action1()\n    val result2 = action2()\n    block?.invoke(result1, result2)\n}\n```\n或者\n```kotlin\n// 方案二\nfun action1(): Int = 1\nfun action2(): Int = 2\nfun methodA(block: ((Int, Int) -> Unit)? = null) {\n    block?.invoke(action1(), action2())\n}\n```\n如果你选择了方案二，那么你就掉入\"陷阱\"了。\n因为方法内执行的逻辑，不应该收到回调的影响。如果在`methodA`中传入了null作为参数，或者直接调用`methodA()`，这样参数`block`就为null，那么`方案二`是不等价于`方案一`的，我只是不需要知道方法的执行结果，不是让你不执行方法。","source":"_posts/2022-09-22-难忘的bug.md","raw":"---\nlayout: post\ntitle: 难忘的bug\nauthor: boybeak\ncategories: 陷阱与缺陷\ntags: 陷阱与缺陷\n---\n\n此贴是为了记录日常开发过程中，遇到的一些让人难忘的bug。\n* MediaPlayer: surface has already been released\n* kotlin ?.的陷阱与缺陷\n\n## surface has already been released\n**场景**：MediaPlayer做跨进程的视频播放发现的，由于有无画面的后台播放场景，所以，MediaPlayer的相关操作放在独立进程的Service中，通过跨进程的调度，进行相关媒体操作，包括设置用于展示画面的Surface，Surface是一个Parcable类，所以是可以通过跨进程传输的。\n**归因**：在播放进程中，用成员变量缓存了通过`setSurface`设置的surface变量，以便于从后台恢复前台播放时候，可以直接使用，而不需要再次传入surface参数。但是这样做是不可以的，会爆出`surface has already been released`的错误。\nIPlayer.aidl如下：\n```aidl\ninterface IPlayer {\n    void setSurface(inout Surface surface);\n}\n```\n需要注意的是，此处surface的修饰符包括一个inout。这样设置，是为了适配IjkMediaPlayer切换全屏的场景。如果把这个修饰符改成`in`，则IjkMediaPlayer在通过`setSurface`多次修改surface时候，也会爆出`surface has already been released`这样的问题。\n\n## kotlin ?.的陷阱与缺陷\n`?.`是kotlin的空安全语法。相比Java的if语句判断，这样做要简洁的多，但是这里边有一种“陷阱”，这并不是kotlin本身的问题，而是使用者容易疏忽的问题。\n展示逻辑的伪代码如下：\n```\n方法A(回调) {\n    结果1 = 动作1\n    结果2 = 动作2\n    回调(结果1, 结果2)\n}\n```\n简单解释一下，一个`方法A`，带有一个Nullable的`回调`，需要执行`动作1`和`动作2`，分别返回了`结果1`和`结果2`，并且在`回调`中返回结果。\n上述逻辑用kotlin实现如下：\n```kotlin\n// 方案一\nfun action1(): Int = 1\nfun action2(): Int = 2\nfun methodA(block: ((Int, Int) -> Unit)? = null) {\n    val result1 = action1()\n    val result2 = action2()\n    block?.invoke(result1, result2)\n}\n```\n或者\n```kotlin\n// 方案二\nfun action1(): Int = 1\nfun action2(): Int = 2\nfun methodA(block: ((Int, Int) -> Unit)? = null) {\n    block?.invoke(action1(), action2())\n}\n```\n如果你选择了方案二，那么你就掉入\"陷阱\"了。\n因为方法内执行的逻辑，不应该收到回调的影响。如果在`methodA`中传入了null作为参数，或者直接调用`methodA()`，这样参数`block`就为null，那么`方案二`是不等价于`方案一`的，我只是不需要知道方法的执行结果，不是让你不执行方法。","slug":"2022-09-22-难忘的bug","published":1,"date":"2022-09-22T12:48:16.340Z","updated":"2022-09-23T10:02:34.640Z","comments":1,"photos":[],"link":"","_id":"cldqukh9k001hpcjg70zl3svl","content":"<p>此贴是为了记录日常开发过程中，遇到的一些让人难忘的bug。</p>\n<ul>\n<li>MediaPlayer: surface has already been released</li>\n<li>kotlin ?.的陷阱与缺陷</li>\n</ul>\n<h2 id=\"surface-has-already-been-released\"><a href=\"#surface-has-already-been-released\" class=\"headerlink\" title=\"surface has already been released\"></a>surface has already been released</h2><p><strong>场景</strong>：MediaPlayer做跨进程的视频播放发现的，由于有无画面的后台播放场景，所以，MediaPlayer的相关操作放在独立进程的Service中，通过跨进程的调度，进行相关媒体操作，包括设置用于展示画面的Surface，Surface是一个Parcable类，所以是可以通过跨进程传输的。<br><strong>归因</strong>：在播放进程中，用成员变量缓存了通过<code>setSurface</code>设置的surface变量，以便于从后台恢复前台播放时候，可以直接使用，而不需要再次传入surface参数。但是这样做是不可以的，会爆出<code>surface has already been released</code>的错误。<br>IPlayer.aidl如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface IPlayer &#123;</span><br><span class=\"line\">    void setSurface(inout Surface surface);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，此处surface的修饰符包括一个inout。这样设置，是为了适配IjkMediaPlayer切换全屏的场景。如果把这个修饰符改成<code>in</code>，则IjkMediaPlayer在通过<code>setSurface</code>多次修改surface时候，也会爆出<code>surface has already been released</code>这样的问题。</p>\n<h2 id=\"kotlin-的陷阱与缺陷\"><a href=\"#kotlin-的陷阱与缺陷\" class=\"headerlink\" title=\"kotlin ?.的陷阱与缺陷\"></a>kotlin ?.的陷阱与缺陷</h2><p><code>?.</code>是kotlin的空安全语法。相比Java的if语句判断，这样做要简洁的多，但是这里边有一种“陷阱”，这并不是kotlin本身的问题，而是使用者容易疏忽的问题。<br>展示逻辑的伪代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法A(回调) &#123;</span><br><span class=\"line\">    结果1 = 动作1</span><br><span class=\"line\">    结果2 = 动作2</span><br><span class=\"line\">    回调(结果1, 结果2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单解释一下，一个<code>方法A</code>，带有一个Nullable的<code>回调</code>，需要执行<code>动作1</code>和<code>动作2</code>，分别返回了<code>结果1</code>和<code>结果2</code>，并且在<code>回调</code>中返回结果。<br>上述逻辑用kotlin实现如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案一</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">action1</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">action2</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">methodA</span><span class=\"params\">(block: ((<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)? = <span class=\"literal\">null</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result1 = action1()</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result2 = action2()</span><br><span class=\"line\">    block?.invoke(result1, result2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案二</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">action1</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">action2</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">methodA</span><span class=\"params\">(block: ((<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)? = <span class=\"literal\">null</span>)</span></span> &#123;</span><br><span class=\"line\">    block?.invoke(action1(), action2())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你选择了方案二，那么你就掉入”陷阱”了。<br>因为方法内执行的逻辑，不应该收到回调的影响。如果在<code>methodA</code>中传入了null作为参数，或者直接调用<code>methodA()</code>，这样参数<code>block</code>就为null，那么<code>方案二</code>是不等价于<code>方案一</code>的，我只是不需要知道方法的执行结果，不是让你不执行方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>此贴是为了记录日常开发过程中，遇到的一些让人难忘的bug。</p>\n<ul>\n<li>MediaPlayer: surface has already been released</li>\n<li>kotlin ?.的陷阱与缺陷</li>\n</ul>\n<h2 id=\"surface-has-already-been-released\"><a href=\"#surface-has-already-been-released\" class=\"headerlink\" title=\"surface has already been released\"></a>surface has already been released</h2><p><strong>场景</strong>：MediaPlayer做跨进程的视频播放发现的，由于有无画面的后台播放场景，所以，MediaPlayer的相关操作放在独立进程的Service中，通过跨进程的调度，进行相关媒体操作，包括设置用于展示画面的Surface，Surface是一个Parcable类，所以是可以通过跨进程传输的。<br><strong>归因</strong>：在播放进程中，用成员变量缓存了通过<code>setSurface</code>设置的surface变量，以便于从后台恢复前台播放时候，可以直接使用，而不需要再次传入surface参数。但是这样做是不可以的，会爆出<code>surface has already been released</code>的错误。<br>IPlayer.aidl如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface IPlayer &#123;</span><br><span class=\"line\">    void setSurface(inout Surface surface);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，此处surface的修饰符包括一个inout。这样设置，是为了适配IjkMediaPlayer切换全屏的场景。如果把这个修饰符改成<code>in</code>，则IjkMediaPlayer在通过<code>setSurface</code>多次修改surface时候，也会爆出<code>surface has already been released</code>这样的问题。</p>\n<h2 id=\"kotlin-的陷阱与缺陷\"><a href=\"#kotlin-的陷阱与缺陷\" class=\"headerlink\" title=\"kotlin ?.的陷阱与缺陷\"></a>kotlin ?.的陷阱与缺陷</h2><p><code>?.</code>是kotlin的空安全语法。相比Java的if语句判断，这样做要简洁的多，但是这里边有一种“陷阱”，这并不是kotlin本身的问题，而是使用者容易疏忽的问题。<br>展示逻辑的伪代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法A(回调) &#123;</span><br><span class=\"line\">    结果1 = 动作1</span><br><span class=\"line\">    结果2 = 动作2</span><br><span class=\"line\">    回调(结果1, 结果2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单解释一下，一个<code>方法A</code>，带有一个Nullable的<code>回调</code>，需要执行<code>动作1</code>和<code>动作2</code>，分别返回了<code>结果1</code>和<code>结果2</code>，并且在<code>回调</code>中返回结果。<br>上述逻辑用kotlin实现如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案一</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">action1</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">action2</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">methodA</span><span class=\"params\">(block: ((<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)? = <span class=\"literal\">null</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result1 = action1()</span><br><span class=\"line\">    <span class=\"keyword\">val</span> result2 = action2()</span><br><span class=\"line\">    block?.invoke(result1, result2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案二</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">action1</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">action2</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">methodA</span><span class=\"params\">(block: ((<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Unit</span>)? = <span class=\"literal\">null</span>)</span></span> &#123;</span><br><span class=\"line\">    block?.invoke(action1(), action2())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你选择了方案二，那么你就掉入”陷阱”了。<br>因为方法内执行的逻辑，不应该收到回调的影响。如果在<code>methodA</code>中传入了null作为参数，或者直接调用<code>methodA()</code>，这样参数<code>block</code>就为null，那么<code>方案二</code>是不等价于<code>方案一</code>的，我只是不需要知道方法的执行结果，不是让你不执行方法。</p>\n"},{"layout":"post","title":"Kotlin Native从初识到放弃","author":"boybeak","_content":"\n此贴用于记录对Kotlin Native从初识到放弃的过程，因为还不清楚这一平台的开发能力上限多高，不排除用的好，会一直用下去。\n以下Kotlin Native会用KN来代替。\n\n## 开始\n首先，下载IDEA，我这里用的是社区版，社区版已经足以应对大多数情况了。\n然后，新建一个KN的项目。\n![kotlin-native-start.jpg](/images/kotlin-native-starter.jpg)\nIDE会自动生成hello world代码，直接点运行，如果工具栏的运行按钮没有可执行的配置，那就直接在Main.kt文件上右键运行。相比直接用Clion写**C/C++**代码的运行速度，KN项目运行要慢得多，因为要先执行gradle脚本。\n即便是这样，你也很可能第一次运行不成功，在macOs上，要安装*XCode command line tools*工具，我这里直接安装了完整版的XCode。\n然后继续尝试运行，你很可能会发现，依然执行不成功，报如下错误：\n```log\nThe /usr/bin/xcrun command returned non-zero exit code: 72\n```\n这时候，你需要打开XCode，执行一系列同意操作后，进入**Preferences** -> **Locations**，选中一个版本。如下：\n![xcode-select](/images/xcode-select.jpg)\n如果你没有安装完整XCode，可以尝试`xcode select`这个命令，这里具体不做详述。\n经过这个设置后，再次尝试运行，这次终于运行成功。\n```log\n21:41:11: Executing 'runDebugExecutableNative'...\n\nStarting Gradle Daemon...\nGradle Daemon started in 3 s 569 ms\n\n> Configure project :\nKotlin Multiplatform Projects are an Alpha feature. See: https://kotlinlang.org/docs/reference/evolution/components-stability.html. To hide this message, add 'kotlin.mpp.stability.nowarn=true' to the Gradle properties.\n\nThe property 'kotlin.mpp.enableGranularSourceSetsMetadata=true' has no effect in this and future Kotlin versions, as Hierarchical Structures support is now enabled by default. It is safe to remove the property.\n\nThe property 'kotlin.native.enableDependencyPropagation=false' has no effect in this and future Kotlin versions, as Kotlin/Native dependency commonization is now enabled by default. It is safe to remove the property.\n\n\n> Task :wrapper\n\nBUILD SUCCESSFUL in 21s\n1 actionable task: 1 executed\n\n> Configure project :\nKotlin Multiplatform Projects are an Alpha feature. See: https://kotlinlang.org/docs/reference/evolution/components-stability.html. To hide this message, add 'kotlin.mpp.stability.nowarn=true' to the Gradle properties.\n\nThe property 'kotlin.mpp.enableGranularSourceSetsMetadata=true' has no effect in this and future Kotlin versions, as Hierarchical Structures support is now enabled by default. It is safe to remove the property.\n\nThe property 'kotlin.native.enableDependencyPropagation=false' has no effect in this and future Kotlin versions, as Kotlin/Native dependency commonization is now enabled by default. It is safe to remove the property.\n\n\n> Task :compileKotlinNative UP-TO-DATE\n> Task :linkDebugExecutableNative UP-TO-DATE\n\n> Task :runDebugExecutableNative\nHello, Kotlin/Native!\n\nBUILD SUCCESSFUL in 3s\n3 actionable tasks: 1 executed, 2 up-to-date\n21:41:44: Execution finished 'runDebugExecutableNative'.\n```\n请在上述输出日志中寻找`Hello, Kotlin/Native`字符串，很不起眼。\n","source":"_posts/2022-09-23-Kotlin Native.md","raw":"---\nlayout: post\ntitle: Kotlin Native从初识到放弃\nauthor: boybeak\ncategories: Kotlin Native\ntags: Kotlin\n---\n\n此贴用于记录对Kotlin Native从初识到放弃的过程，因为还不清楚这一平台的开发能力上限多高，不排除用的好，会一直用下去。\n以下Kotlin Native会用KN来代替。\n\n## 开始\n首先，下载IDEA，我这里用的是社区版，社区版已经足以应对大多数情况了。\n然后，新建一个KN的项目。\n![kotlin-native-start.jpg](/images/kotlin-native-starter.jpg)\nIDE会自动生成hello world代码，直接点运行，如果工具栏的运行按钮没有可执行的配置，那就直接在Main.kt文件上右键运行。相比直接用Clion写**C/C++**代码的运行速度，KN项目运行要慢得多，因为要先执行gradle脚本。\n即便是这样，你也很可能第一次运行不成功，在macOs上，要安装*XCode command line tools*工具，我这里直接安装了完整版的XCode。\n然后继续尝试运行，你很可能会发现，依然执行不成功，报如下错误：\n```log\nThe /usr/bin/xcrun command returned non-zero exit code: 72\n```\n这时候，你需要打开XCode，执行一系列同意操作后，进入**Preferences** -> **Locations**，选中一个版本。如下：\n![xcode-select](/images/xcode-select.jpg)\n如果你没有安装完整XCode，可以尝试`xcode select`这个命令，这里具体不做详述。\n经过这个设置后，再次尝试运行，这次终于运行成功。\n```log\n21:41:11: Executing 'runDebugExecutableNative'...\n\nStarting Gradle Daemon...\nGradle Daemon started in 3 s 569 ms\n\n> Configure project :\nKotlin Multiplatform Projects are an Alpha feature. See: https://kotlinlang.org/docs/reference/evolution/components-stability.html. To hide this message, add 'kotlin.mpp.stability.nowarn=true' to the Gradle properties.\n\nThe property 'kotlin.mpp.enableGranularSourceSetsMetadata=true' has no effect in this and future Kotlin versions, as Hierarchical Structures support is now enabled by default. It is safe to remove the property.\n\nThe property 'kotlin.native.enableDependencyPropagation=false' has no effect in this and future Kotlin versions, as Kotlin/Native dependency commonization is now enabled by default. It is safe to remove the property.\n\n\n> Task :wrapper\n\nBUILD SUCCESSFUL in 21s\n1 actionable task: 1 executed\n\n> Configure project :\nKotlin Multiplatform Projects are an Alpha feature. See: https://kotlinlang.org/docs/reference/evolution/components-stability.html. To hide this message, add 'kotlin.mpp.stability.nowarn=true' to the Gradle properties.\n\nThe property 'kotlin.mpp.enableGranularSourceSetsMetadata=true' has no effect in this and future Kotlin versions, as Hierarchical Structures support is now enabled by default. It is safe to remove the property.\n\nThe property 'kotlin.native.enableDependencyPropagation=false' has no effect in this and future Kotlin versions, as Kotlin/Native dependency commonization is now enabled by default. It is safe to remove the property.\n\n\n> Task :compileKotlinNative UP-TO-DATE\n> Task :linkDebugExecutableNative UP-TO-DATE\n\n> Task :runDebugExecutableNative\nHello, Kotlin/Native!\n\nBUILD SUCCESSFUL in 3s\n3 actionable tasks: 1 executed, 2 up-to-date\n21:41:44: Execution finished 'runDebugExecutableNative'.\n```\n请在上述输出日志中寻找`Hello, Kotlin/Native`字符串，很不起眼。\n","slug":"2022-09-23-Kotlin Native","published":1,"date":"2022-09-23T13:28:20.360Z","updated":"2023-02-05T04:18:19.758Z","_id":"cldqukh9l001kpcjgfqx537jp","comments":1,"photos":[],"link":"","content":"<p>此贴用于记录对Kotlin Native从初识到放弃的过程，因为还不清楚这一平台的开发能力上限多高，不排除用的好，会一直用下去。<br>以下Kotlin Native会用KN来代替。</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>首先，下载IDEA，我这里用的是社区版，社区版已经足以应对大多数情况了。<br>然后，新建一个KN的项目。<br><img src=\"/images/kotlin-native-starter.jpg\" alt=\"kotlin-native-start.jpg\"><br>IDE会自动生成hello world代码，直接点运行，如果工具栏的运行按钮没有可执行的配置，那就直接在Main.kt文件上右键运行。相比直接用Clion写**C&#x2F;C++*<em>代码的运行速度，KN项目运行要慢得多，因为要先执行gradle脚本。<br>即便是这样，你也很可能第一次运行不成功，在macOs上，要安装</em>XCode command line tools*工具，我这里直接安装了完整版的XCode。<br>然后继续尝试运行，你很可能会发现，依然执行不成功，报如下错误：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The /usr/bin/xcrun command returned non-zero exit code: 72</span><br></pre></td></tr></table></figure>\n<p>这时候，你需要打开XCode，执行一系列同意操作后，进入<strong>Preferences</strong> -&gt; <strong>Locations</strong>，选中一个版本。如下：<br><img src=\"/images/xcode-select.jpg\" alt=\"xcode-select\"><br>如果你没有安装完整XCode，可以尝试<code>xcode select</code>这个命令，这里具体不做详述。<br>经过这个设置后，再次尝试运行，这次终于运行成功。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">21:41:11: Executing &#x27;runDebugExecutableNative&#x27;...</span><br><span class=\"line\"></span><br><span class=\"line\">Starting Gradle Daemon...</span><br><span class=\"line\">Gradle Daemon started in 3 s 569 ms</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Configure project :</span><br><span class=\"line\">Kotlin Multiplatform Projects are an Alpha feature. See: https://kotlinlang.org/docs/reference/evolution/components-stability.html. To hide this message, add &#x27;kotlin.mpp.stability.nowarn=true&#x27; to the Gradle properties.</span><br><span class=\"line\"></span><br><span class=\"line\">The property &#x27;kotlin.mpp.enableGranularSourceSetsMetadata=true&#x27; has no effect in this and future Kotlin versions, as Hierarchical Structures support is now enabled by default. It is safe to remove the property.</span><br><span class=\"line\"></span><br><span class=\"line\">The property &#x27;kotlin.native.enableDependencyPropagation=false&#x27; has no effect in this and future Kotlin versions, as Kotlin/Native dependency commonization is now enabled by default. It is safe to remove the property.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Task :wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 21s</span><br><span class=\"line\">1 actionable task: 1 executed</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Configure project :</span><br><span class=\"line\">Kotlin Multiplatform Projects are an Alpha feature. See: https://kotlinlang.org/docs/reference/evolution/components-stability.html. To hide this message, add &#x27;kotlin.mpp.stability.nowarn=true&#x27; to the Gradle properties.</span><br><span class=\"line\"></span><br><span class=\"line\">The property &#x27;kotlin.mpp.enableGranularSourceSetsMetadata=true&#x27; has no effect in this and future Kotlin versions, as Hierarchical Structures support is now enabled by default. It is safe to remove the property.</span><br><span class=\"line\"></span><br><span class=\"line\">The property &#x27;kotlin.native.enableDependencyPropagation=false&#x27; has no effect in this and future Kotlin versions, as Kotlin/Native dependency commonization is now enabled by default. It is safe to remove the property.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Task :compileKotlinNative UP-TO-DATE</span><br><span class=\"line\">&gt; Task :linkDebugExecutableNative UP-TO-DATE</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Task :runDebugExecutableNative</span><br><span class=\"line\">Hello, Kotlin/Native!</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 3s</span><br><span class=\"line\">3 actionable tasks: 1 executed, 2 up-to-date</span><br><span class=\"line\">21:41:44: Execution finished &#x27;runDebugExecutableNative&#x27;.</span><br></pre></td></tr></table></figure>\n<p>请在上述输出日志中寻找<code>Hello, Kotlin/Native</code>字符串，很不起眼。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>此贴用于记录对Kotlin Native从初识到放弃的过程，因为还不清楚这一平台的开发能力上限多高，不排除用的好，会一直用下去。<br>以下Kotlin Native会用KN来代替。</p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>首先，下载IDEA，我这里用的是社区版，社区版已经足以应对大多数情况了。<br>然后，新建一个KN的项目。<br><img src=\"/images/kotlin-native-starter.jpg\" alt=\"kotlin-native-start.jpg\"><br>IDE会自动生成hello world代码，直接点运行，如果工具栏的运行按钮没有可执行的配置，那就直接在Main.kt文件上右键运行。相比直接用Clion写**C&#x2F;C++*<em>代码的运行速度，KN项目运行要慢得多，因为要先执行gradle脚本。<br>即便是这样，你也很可能第一次运行不成功，在macOs上，要安装</em>XCode command line tools*工具，我这里直接安装了完整版的XCode。<br>然后继续尝试运行，你很可能会发现，依然执行不成功，报如下错误：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The /usr/bin/xcrun command returned non-zero exit code: 72</span><br></pre></td></tr></table></figure>\n<p>这时候，你需要打开XCode，执行一系列同意操作后，进入<strong>Preferences</strong> -&gt; <strong>Locations</strong>，选中一个版本。如下：<br><img src=\"/images/xcode-select.jpg\" alt=\"xcode-select\"><br>如果你没有安装完整XCode，可以尝试<code>xcode select</code>这个命令，这里具体不做详述。<br>经过这个设置后，再次尝试运行，这次终于运行成功。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">21:41:11: Executing &#x27;runDebugExecutableNative&#x27;...</span><br><span class=\"line\"></span><br><span class=\"line\">Starting Gradle Daemon...</span><br><span class=\"line\">Gradle Daemon started in 3 s 569 ms</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Configure project :</span><br><span class=\"line\">Kotlin Multiplatform Projects are an Alpha feature. See: https://kotlinlang.org/docs/reference/evolution/components-stability.html. To hide this message, add &#x27;kotlin.mpp.stability.nowarn=true&#x27; to the Gradle properties.</span><br><span class=\"line\"></span><br><span class=\"line\">The property &#x27;kotlin.mpp.enableGranularSourceSetsMetadata=true&#x27; has no effect in this and future Kotlin versions, as Hierarchical Structures support is now enabled by default. It is safe to remove the property.</span><br><span class=\"line\"></span><br><span class=\"line\">The property &#x27;kotlin.native.enableDependencyPropagation=false&#x27; has no effect in this and future Kotlin versions, as Kotlin/Native dependency commonization is now enabled by default. It is safe to remove the property.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Task :wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 21s</span><br><span class=\"line\">1 actionable task: 1 executed</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Configure project :</span><br><span class=\"line\">Kotlin Multiplatform Projects are an Alpha feature. See: https://kotlinlang.org/docs/reference/evolution/components-stability.html. To hide this message, add &#x27;kotlin.mpp.stability.nowarn=true&#x27; to the Gradle properties.</span><br><span class=\"line\"></span><br><span class=\"line\">The property &#x27;kotlin.mpp.enableGranularSourceSetsMetadata=true&#x27; has no effect in this and future Kotlin versions, as Hierarchical Structures support is now enabled by default. It is safe to remove the property.</span><br><span class=\"line\"></span><br><span class=\"line\">The property &#x27;kotlin.native.enableDependencyPropagation=false&#x27; has no effect in this and future Kotlin versions, as Kotlin/Native dependency commonization is now enabled by default. It is safe to remove the property.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Task :compileKotlinNative UP-TO-DATE</span><br><span class=\"line\">&gt; Task :linkDebugExecutableNative UP-TO-DATE</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Task :runDebugExecutableNative</span><br><span class=\"line\">Hello, Kotlin/Native!</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL in 3s</span><br><span class=\"line\">3 actionable tasks: 1 executed, 2 up-to-date</span><br><span class=\"line\">21:41:44: Execution finished &#x27;runDebugExecutableNative&#x27;.</span><br></pre></td></tr></table></figure>\n<p>请在上述输出日志中寻找<code>Hello, Kotlin/Native</code>字符串，很不起眼。</p>\n"},{"layout":"post","title":"Android的clipToXXX","author":"boybeak","_content":"\n最近处理工作bug的过程中，有一个需求是这样的，两层view，父view包含着子view，然后子view能显示出的区域，要以父view的背景来过滤。没看懂是不是？参考下图：\n![playground](/images/playground.jpg)\n简单说，就是子view的背景显示区域，不能超过父view的背景区域。\n\n## clipToOutline\n经过一番搜索尝试，终于查到，可以通过`clipToOutline` + `outlineProvider`来实现，说来惭愧，做了将近20年android开发，竟然到现在才知道这样的特性。\n具体代码如下：\n```xml\n<FrameLayout\n    android:id=\"@+id/togetherParent\"\n    android:layout_width=\"100dp\"\n    android:layout_height=\"100dp\"\n    android:layout_margin=\"8dp\"\n    android:background=\"@drawable/bg_parent\"\n    android:clipToOutline=\"true\"\n    android:outlineProvider=\"background\"\n    >\n    <View\n        android:id=\"@+id/togetherChild\"\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        android:background=\"@drawable/bg_child\"/>\n</FrameLayout>\n```\n但是以上代码只可以在API Level 31及以上使用，要增大适用版本范围，可以用以下代码，在kotlin中实现：\n```kotlin\nparent.clipToOutline = true\nparent.outlineProvider = ViewOutlineProvider.BACKGROUND\n```\nkotlin中代码，就可以实现，低至API Level 21及以上使用。\n\n除了`clipToOutline`，我还发现了其他`clipToXXX`有关的API。\n\n## clipChildren","source":"_posts/2022-10-13-clipToXXX.md","raw":"---\nlayout: post\ntitle: Android的clipToXXX\nauthor: boybeak\ncategories: Android技巧\ntags: Android\n---\n\n最近处理工作bug的过程中，有一个需求是这样的，两层view，父view包含着子view，然后子view能显示出的区域，要以父view的背景来过滤。没看懂是不是？参考下图：\n![playground](/images/playground.jpg)\n简单说，就是子view的背景显示区域，不能超过父view的背景区域。\n\n## clipToOutline\n经过一番搜索尝试，终于查到，可以通过`clipToOutline` + `outlineProvider`来实现，说来惭愧，做了将近20年android开发，竟然到现在才知道这样的特性。\n具体代码如下：\n```xml\n<FrameLayout\n    android:id=\"@+id/togetherParent\"\n    android:layout_width=\"100dp\"\n    android:layout_height=\"100dp\"\n    android:layout_margin=\"8dp\"\n    android:background=\"@drawable/bg_parent\"\n    android:clipToOutline=\"true\"\n    android:outlineProvider=\"background\"\n    >\n    <View\n        android:id=\"@+id/togetherChild\"\n        android:layout_width=\"100dp\"\n        android:layout_height=\"100dp\"\n        android:background=\"@drawable/bg_child\"/>\n</FrameLayout>\n```\n但是以上代码只可以在API Level 31及以上使用，要增大适用版本范围，可以用以下代码，在kotlin中实现：\n```kotlin\nparent.clipToOutline = true\nparent.outlineProvider = ViewOutlineProvider.BACKGROUND\n```\nkotlin中代码，就可以实现，低至API Level 21及以上使用。\n\n除了`clipToOutline`，我还发现了其他`clipToXXX`有关的API。\n\n## clipChildren","slug":"2022-10-13-clipToXXX","published":1,"date":"2022-10-13T08:30:18.670Z","updated":"2023-02-05T04:11:58.206Z","_id":"cldqukh9n001ppcjghusj5ev5","comments":1,"photos":[],"link":"","content":"<p>最近处理工作bug的过程中，有一个需求是这样的，两层view，父view包含着子view，然后子view能显示出的区域，要以父view的背景来过滤。没看懂是不是？参考下图：<br><img src=\"/images/playground.jpg\" alt=\"playground\"><br>简单说，就是子view的背景显示区域，不能超过父view的背景区域。</p>\n<h2 id=\"clipToOutline\"><a href=\"#clipToOutline\" class=\"headerlink\" title=\"clipToOutline\"></a>clipToOutline</h2><p>经过一番搜索尝试，终于查到，可以通过<code>clipToOutline</code> + <code>outlineProvider</code>来实现，说来惭愧，做了将近20年android开发，竟然到现在才知道这样的特性。<br>具体代码如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">FrameLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/togetherParent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_margin</span>=<span class=\"string\">&quot;8dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@drawable/bg_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:clipToOutline</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:outlineProvider</span>=<span class=\"string\">&quot;background&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">View</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/togetherChild&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@drawable/bg_child&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但是以上代码只可以在API Level 31及以上使用，要增大适用版本范围，可以用以下代码，在kotlin中实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parent.clipToOutline = <span class=\"literal\">true</span></span><br><span class=\"line\">parent.outlineProvider = ViewOutlineProvider.BACKGROUND</span><br></pre></td></tr></table></figure>\n<p>kotlin中代码，就可以实现，低至API Level 21及以上使用。</p>\n<p>除了<code>clipToOutline</code>，我还发现了其他<code>clipToXXX</code>有关的API。</p>\n<h2 id=\"clipChildren\"><a href=\"#clipChildren\" class=\"headerlink\" title=\"clipChildren\"></a>clipChildren</h2>","site":{"data":{}},"excerpt":"","more":"<p>最近处理工作bug的过程中，有一个需求是这样的，两层view，父view包含着子view，然后子view能显示出的区域，要以父view的背景来过滤。没看懂是不是？参考下图：<br><img src=\"/images/playground.jpg\" alt=\"playground\"><br>简单说，就是子view的背景显示区域，不能超过父view的背景区域。</p>\n<h2 id=\"clipToOutline\"><a href=\"#clipToOutline\" class=\"headerlink\" title=\"clipToOutline\"></a>clipToOutline</h2><p>经过一番搜索尝试，终于查到，可以通过<code>clipToOutline</code> + <code>outlineProvider</code>来实现，说来惭愧，做了将近20年android开发，竟然到现在才知道这样的特性。<br>具体代码如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">FrameLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/togetherParent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_margin</span>=<span class=\"string\">&quot;8dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@drawable/bg_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:clipToOutline</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:outlineProvider</span>=<span class=\"string\">&quot;background&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">View</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/togetherChild&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:background</span>=<span class=\"string\">&quot;@drawable/bg_child&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但是以上代码只可以在API Level 31及以上使用，要增大适用版本范围，可以用以下代码，在kotlin中实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parent.clipToOutline = <span class=\"literal\">true</span></span><br><span class=\"line\">parent.outlineProvider = ViewOutlineProvider.BACKGROUND</span><br></pre></td></tr></table></figure>\n<p>kotlin中代码，就可以实现，低至API Level 21及以上使用。</p>\n<p>除了<code>clipToOutline</code>，我还发现了其他<code>clipToXXX</code>有关的API。</p>\n<h2 id=\"clipChildren\"><a href=\"#clipChildren\" class=\"headerlink\" title=\"clipChildren\"></a>clipChildren</h2>"},{"layout":"doc","title":"Translator","author":"boybeak","_content":"\n<h1>\n    <img style=\"vertical-align: bottom;\" src=\"/images/translator-logo-512.png\" width=\"48\" height=\"48\" />\n    Translator\n    <img src=\"https://img.shields.io/badge/Translator-0.1-blue\" />\n</h1>\n\nTranslator is a simple translation app based on [Tencent Machine Translation](https://cloud.tencent.com/document/product/551/15611) API. Only macOs version is available at this moment.\n\n<img src=\"/images/preview.jpg\" width=\"285\" height=\"195\" />\n\n## Releases\n","source":"_posts/2022-11-02-Translator.md","raw":"---\nlayout: doc\ntitle: Translator\nauthor: boybeak\ncategories: Translator\ntags: Translator\n---\n\n<h1>\n    <img style=\"vertical-align: bottom;\" src=\"/images/translator-logo-512.png\" width=\"48\" height=\"48\" />\n    Translator\n    <img src=\"https://img.shields.io/badge/Translator-0.1-blue\" />\n</h1>\n\nTranslator is a simple translation app based on [Tencent Machine Translation](https://cloud.tencent.com/document/product/551/15611) API. Only macOs version is available at this moment.\n\n<img src=\"/images/preview.jpg\" width=\"285\" height=\"195\" />\n\n## Releases\n","slug":"2022-11-02-Translator","published":1,"date":"2022-11-02T16:41:03.736Z","updated":"2023-02-05T04:36:10.481Z","_id":"cldqukh9o001spcjghq1vh30m","comments":1,"photos":[],"link":"","content":"<h1>\n    <img style=\"vertical-align: bottom;\" src=\"/images/translator-logo-512.png\" width=\"48\" height=\"48\" />\n    Translator\n    <img src=\"https://img.shields.io/badge/Translator-0.1-blue\" />\n</h1>\n\n<p>Translator is a simple translation app based on <a href=\"https://cloud.tencent.com/document/product/551/15611\">Tencent Machine Translation</a> API. Only macOs version is available at this moment.</p>\n<img src=\"/images/preview.jpg\" width=\"285\" height=\"195\" />\n\n<h2 id=\"Releases\"><a href=\"#Releases\" class=\"headerlink\" title=\"Releases\"></a>Releases</h2>","site":{"data":{}},"excerpt":"","more":"<h1>\n    <img style=\"vertical-align: bottom;\" src=\"/images/translator-logo-512.png\" width=\"48\" height=\"48\" />\n    Translator\n    <img src=\"https://img.shields.io/badge/Translator-0.1-blue\" />\n</h1>\n\n<p>Translator is a simple translation app based on <a href=\"https://cloud.tencent.com/document/product/551/15611\">Tencent Machine Translation</a> API. Only macOs version is available at this moment.</p>\n<img src=\"/images/preview.jpg\" width=\"285\" height=\"195\" />\n\n<h2 id=\"Releases\"><a href=\"#Releases\" class=\"headerlink\" title=\"Releases\"></a>Releases</h2>"},{"title":"Hello 2023","date":"2023-02-04T18:11:55.000Z","_content":"绩效评分并不理想，上年度Q4产出实在是差，分配的任务，属于那种谁做谁死型的难度，用V8引擎执行webgl代码，再用原生的OpengGL的API对接对应的webgl的API，从而实现将webgl的小游戏，在原生上运行的目的。但是实际上，对接远不是想象的那样顺利，本身J2V8使用不熟悉，而且相关生态真的很差，没有太多参考资料，官方连调试都没有实现，有太多的坑需要自己去边踩边解，这还只是V8这边的坑，webgl与OpenGL对接的坑就更多了，双坑合璧，绝世无敌。","source":"_posts/2023-02-05-Hello-2023.md","raw":"---\ntitle: 'Hello 2023'\ndate: 2023-02-05 02:11:55\ntags: 随想录\n---\n绩效评分并不理想，上年度Q4产出实在是差，分配的任务，属于那种谁做谁死型的难度，用V8引擎执行webgl代码，再用原生的OpengGL的API对接对应的webgl的API，从而实现将webgl的小游戏，在原生上运行的目的。但是实际上，对接远不是想象的那样顺利，本身J2V8使用不熟悉，而且相关生态真的很差，没有太多参考资料，官方连调试都没有实现，有太多的坑需要自己去边踩边解，这还只是V8这边的坑，webgl与OpenGL对接的坑就更多了，双坑合璧，绝世无敌。","slug":"2023-02-05-Hello-2023","published":1,"updated":"2023-02-04T18:23:09.744Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldqukh9q001vpcjghhbrbkqz","content":"<p>绩效评分并不理想，上年度Q4产出实在是差，分配的任务，属于那种谁做谁死型的难度，用V8引擎执行webgl代码，再用原生的OpengGL的API对接对应的webgl的API，从而实现将webgl的小游戏，在原生上运行的目的。但是实际上，对接远不是想象的那样顺利，本身J2V8使用不熟悉，而且相关生态真的很差，没有太多参考资料，官方连调试都没有实现，有太多的坑需要自己去边踩边解，这还只是V8这边的坑，webgl与OpenGL对接的坑就更多了，双坑合璧，绝世无敌。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>绩效评分并不理想，上年度Q4产出实在是差，分配的任务，属于那种谁做谁死型的难度，用V8引擎执行webgl代码，再用原生的OpengGL的API对接对应的webgl的API，从而实现将webgl的小游戏，在原生上运行的目的。但是实际上，对接远不是想象的那样顺利，本身J2V8使用不熟悉，而且相关生态真的很差，没有太多参考资料，官方连调试都没有实现，有太多的坑需要自己去边踩边解，这还只是V8这边的坑，webgl与OpenGL对接的坑就更多了，双坑合璧，绝世无敌。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cldqukh830005pcjg58g70mq2","category_id":"cldqukh7v0002pcjg073e6yai","_id":"cldqukh8n000dpcjgg1y47i33"},{"post_id":"cldqukh7g0000pcjg9h9tbnsd","category_id":"cldqukh7v0002pcjg073e6yai","_id":"cldqukh8p000ipcjg5ows3zm2"},{"post_id":"cldqukh880006pcjg8qov3zk6","category_id":"cldqukh7v0002pcjg073e6yai","_id":"cldqukh8r000lpcjg7bhq8iel"},{"post_id":"cldqukh8h000apcjg797a0h3u","category_id":"cldqukh7v0002pcjg073e6yai","_id":"cldqukh8s000opcjg7cpz164x"},{"post_id":"cldqukh7r0001pcjggk4gcmu5","category_id":"cldqukh7v0002pcjg073e6yai","_id":"cldqukh8v000rpcjghtxl8q05"},{"post_id":"cldqukh8n000cpcjgd7ccb2wi","category_id":"cldqukh7v0002pcjg073e6yai","_id":"cldqukh8x000vpcjgdb0n8puq"},{"post_id":"cldqukh8p000hpcjgfwnobl3h","category_id":"cldqukh7v0002pcjg073e6yai","_id":"cldqukh8z000ypcjggmju8qzw"},{"post_id":"cldqukh7y0004pcjgc9tkbuxw","category_id":"cldqukh7v0002pcjg073e6yai","_id":"cldqukh920012pcjg9b13e6s0"},{"post_id":"cldqukh8q000kpcjgdk5rgugm","category_id":"cldqukh7v0002pcjg073e6yai","_id":"cldqukh9d0015pcjgd4xwe2on"},{"post_id":"cldqukh8y000xpcjg5u08dsoq","category_id":"cldqukh8w000spcjgfnhk5vu6","_id":"cldqukh9g0019pcjgfoao3cs0"},{"post_id":"cldqukh8r000npcjg53ej6ibx","category_id":"cldqukh8w000spcjgfnhk5vu6","_id":"cldqukh9j001cpcjggi0i3z8d"},{"post_id":"cldqukh8z0010pcjg98yodi8j","category_id":"cldqukh8w000spcjgfnhk5vu6","_id":"cldqukh9k001fpcjg7f9i9fr4"},{"post_id":"cldqukh990014pcjge58fb4hb","category_id":"cldqukh8w000spcjgfnhk5vu6","_id":"cldqukh9l001ipcjg683r7mpf"},{"post_id":"cldqukh8s000qpcjgc18i7s5d","category_id":"cldqukh8w000spcjgfnhk5vu6","_id":"cldqukh9m001lpcjggyoobysf"},{"post_id":"cldqukh9d0017pcjgawkhadw7","category_id":"cldqukh8w000spcjgfnhk5vu6","_id":"cldqukh9o001qpcjgaueya4av"},{"post_id":"cldqukh9h001bpcjggx9x5pxy","category_id":"cldqukh8w000spcjgfnhk5vu6","_id":"cldqukh9p001tpcjge4gagju2"},{"post_id":"cldqukh8w000upcjgdztd9rgd","category_id":"cldqukh8w000spcjgfnhk5vu6","_id":"cldqukh9r001ypcjgczqxbe1n"},{"post_id":"cldqukh9j001epcjgfnrxdz5w","category_id":"cldqukh8w000spcjgfnhk5vu6","_id":"cldqukh9s0020pcjg1nljbp2o"},{"post_id":"cldqukh9n001ppcjghusj5ev5","category_id":"cldqukh8w000spcjgfnhk5vu6","_id":"cldqukh9t0022pcjgasbocvhs"},{"post_id":"cldqukh9k001hpcjg70zl3svl","category_id":"cldqukh9m001mpcjg10qy39tx","_id":"cldqukh9t0026pcjg09dtgcoa"},{"post_id":"cldqukh9l001kpcjgfqx537jp","category_id":"cldqukh9r001wpcjg4h8t648u","_id":"cldqukh9u0027pcjggph8bokc"},{"post_id":"cldqukh9o001spcjghq1vh30m","category_id":"cldqukh9t0023pcjg9ko5f73g","_id":"cldqukh9u002apcjg2kyr3wdw"}],"PostTag":[{"post_id":"cldqukh830005pcjg58g70mq2","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh8h0009pcjg4jf09hp6"},{"post_id":"cldqukh7g0000pcjg9h9tbnsd","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh8m000bpcjgh64u27cd"},{"post_id":"cldqukh880006pcjg8qov3zk6","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh8p000gpcjg3lss3fs9"},{"post_id":"cldqukh8h000apcjg797a0h3u","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh8q000jpcjg5x3icgjo"},{"post_id":"cldqukh7r0001pcjggk4gcmu5","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh8r000mpcjg3o865c03"},{"post_id":"cldqukh8n000cpcjgd7ccb2wi","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh8s000ppcjg1yoq2j27"},{"post_id":"cldqukh8p000hpcjgfwnobl3h","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh8w000tpcjgbsysa8ra"},{"post_id":"cldqukh7y0004pcjgc9tkbuxw","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh8x000wpcjg4c9ycj5a"},{"post_id":"cldqukh8q000kpcjgdk5rgugm","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh8z000zpcjghdahd62r"},{"post_id":"cldqukh8r000npcjg53ej6ibx","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh980013pcjgavnp8ypx"},{"post_id":"cldqukh8s000qpcjgc18i7s5d","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh9d0016pcjgddhqhun3"},{"post_id":"cldqukh8w000upcjgdztd9rgd","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh9h001apcjg3k8g92zw"},{"post_id":"cldqukh8y000xpcjg5u08dsoq","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh9j001dpcjgc0769afj"},{"post_id":"cldqukh8z0010pcjg98yodi8j","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh9k001gpcjga89v9dmf"},{"post_id":"cldqukh990014pcjge58fb4hb","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh9l001jpcjg169o0f0a"},{"post_id":"cldqukh9d0017pcjgawkhadw7","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh9n001opcjg6i09dxd1"},{"post_id":"cldqukh9h001bpcjggx9x5pxy","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh9o001rpcjg9aly2ibn"},{"post_id":"cldqukh9j001epcjgfnrxdz5w","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh9q001upcjg9vw244ld"},{"post_id":"cldqukh9n001ppcjghusj5ev5","tag_id":"cldqukh7w0003pcjg2ucia13n","_id":"cldqukh9s001zpcjg748m3owo"},{"post_id":"cldqukh9k001hpcjg70zl3svl","tag_id":"cldqukh9n001npcjg6q3fahap","_id":"cldqukh9s0021pcjg7in46m75"},{"post_id":"cldqukh9l001kpcjgfqx537jp","tag_id":"cldqukh9r001xpcjgck31h0k1","_id":"cldqukh9t0025pcjg15vtc570"},{"post_id":"cldqukh9o001spcjghq1vh30m","tag_id":"cldqukh9t0024pcjg9aijdnwx","_id":"cldqukh9u0029pcjg59fc22c5"},{"post_id":"cldqukh9q001vpcjghhbrbkqz","tag_id":"cldqukh9u0028pcjgfe0c5198","_id":"cldqukh9u002bpcjg3h251ihd"}],"Tag":[{"name":"Android","_id":"cldqukh7w0003pcjg2ucia13n"},{"name":"陷阱与缺陷","_id":"cldqukh9n001npcjg6q3fahap"},{"name":"Kotlin","_id":"cldqukh9r001xpcjgck31h0k1"},{"name":"Translator","_id":"cldqukh9t0024pcjg9aijdnwx"},{"name":"随想录","_id":"cldqukh9u0028pcjgfe0c5198"}]}}