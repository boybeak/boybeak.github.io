<!DOCTYPE html><html lang="zh-CN" id="theme-light-mode"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="boybeak"><meta name="google-site-verification" content="Dw6K7nrSaFd0T-q4SAzzloGzxypfdeMRnSHyid3trNI"><meta name="msvalidate.01" content="FF63C4E8F966AF567DA7288160196C79"><title>App保活术 · HikingMan</title><meta name="description" content="为什么要保活？
因为Android的Low memory killer机制，在系统内存不足的情况下，系统开始根据自身的一套进程回收机制结束一些进程，以便腾出内存给需要的进程。
如何判断内存不足？
判断的阈值在不同手机上是不一样的，一旦低于该阈值，系统就会杀死对应优先级的进程。
在adb shell下"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon-32x32.png"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/sitemap.xml">sitemap</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-search" onclick="openWindow();"></a></li><li><a class="fa fa-sun-o" onclick="darkLightToggle();"></a></li></div><div class="avatar"><img src="/images/logo.jpg"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo-large.png" style="width:192px;" alt="favicon"><h3 title=""><a href="/">HikingMan</a></h3><div class="description"><p>不是去哪里，而是去看日出</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/boybeak"><i class="fa fa-github"></i></a></li><li><a href="mailto:boybeak@gmail.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/gao-yun-fei-65"><i class="fa fa-mortar-board"></i></a></li></ul><h4>我的作品</h4><ul class="app-links"><li> <a target="_blank" rel="noopener" href="https://github.com/boybeak/JustTodo"> <img src="/images/justtodo-icon-256.png" alt="_"><p>JustTodo</p></a></li><li> <a target="_blank" rel="noopener" href="https://github.com/boybeak/TranslatorDocs"> <img src="/images/translator-icon-256.png" alt="_"><p>Translator</p></a></li><li> <a target="_blank" rel="noopener" href="https://github.com/boybeak/DeskNote"> <img src="/images/desknote-icon-256.png" alt="_"><p>DeskNote</p></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> boybeak</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>App保活术</a></h3></div><div class="post-content"><p><p><strong>为什么要保活？</strong></p>
<p>因为Android的Low memory killer机制，在系统内存不足的情况下，系统开始根据自身的一套进程回收机制结束一些进程，以便腾出内存给需要的进程。</p>
<p><strong>如何判断内存不足？</strong></p>
<p>判断的阈值在不同手机上是不一样的，一旦低于该阈值，系统就会杀死对应优先级的进程。</p>
<p>在adb shell下，通过如下命令来查看阈值：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/module/lowmemorykiller/parameters/minfree</span><br></pre></td></tr></table></figure>

<p><em>注意: 这可能需要root手机。</em></p>
<p>返回的结果如下示例：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18432</span>, <span class="number">23040</span>, <span class="number">27648</span>, <span class="number">32256</span>, <span class="number">55296</span>, <span class="number">80640</span></span><br></pre></td></tr></table></figure>

<p>其单位为4kb，也就是内存1页大小。</p>
<p>该值表示的是剩余内存大小，优先级为从高到低，比如当内存小于18432*4kb时，杀死对应的优先级的进程。</p>
<p><img src="/images/process_priority.jpg" alt="oom_adj"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">style 关键优先级 fill:#5befb9</span><br><span class="line">style 高级优先级 fill:#6998c6</span><br><span class="line">style 低优先级 fill:#d38a49</span><br><span class="line">subgraph 关键优先级</span><br><span class="line">A(前台进程)</span><br><span class="line">end</span><br><span class="line">A(前台进程) --&gt; B(可见进程);</span><br><span class="line">subgraph 高级优先级</span><br><span class="line">B --&gt; C(服务进程);</span><br><span class="line">end</span><br><span class="line">C --&gt; D(后台进程);</span><br><span class="line">subgraph 低优先级</span><br><span class="line">D --&gt; E(空进程);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>优先级从高到低依次是，<code>前台进程</code>、<code>可见进程</code>、<code>服务进程</code>、<code>后台进程</code>、<code>空进程</code>。</p>
<p><strong>阈值有6个数，而进程有5种优先级，是如何对应呢？</strong></p>
<p>实际上，第5个数是ContentProvider的阈值，其他的5个数与线程优先级对应。</p>
<p><strong>如何判断线程的优先级？</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/&lt;pid&gt;/oom_adj</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中的<pid>应替换为对应的<strong>进程ID</strong>，从logcat中可以查看对应的pid。</p>
</blockquote>
<p><img src="/images/oom_adj.png" alt="oom_adj"></p>
<p>取值范围绿色代表比较安全，红色代表比较容易被杀死，白色代表为系统进程。</p>
<h2 id="1像素保活"><a href="#1像素保活" class="headerlink" title="1像素保活"></a>1像素保活</h2><p>监听锁屏广播，当屏幕关闭，偷偷创建一个1像素的activity，当屏幕开启，关闭掉这个1像素activity。</p>
<p>关键代码如下:</p>
<p><code>ScreenObserverService.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建后台service，监听屏幕事件。</span></span><br><span class="line"><span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(Intent.ACTION_SCREEN_ON);</span><br><span class="line">filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">registerReceiver(theReceiver, filter);</span><br><span class="line"><span class="comment">//别忘了在service结束时候，注销掉这个receiver。</span></span><br></pre></td></tr></table></figure>

<p><code>OnePixelActivity.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> getWindow();</span><br><span class="line">window.setGravity(Gravity.START | Gravity.TOP);</span><br><span class="line">WindowManager.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> window.getAttributes();</span><br><span class="line">params.width = <span class="number">1</span>;</span><br><span class="line">params.height = <span class="number">1</span>;</span><br><span class="line">params.x = <span class="number">0</span>;</span><br><span class="line">params.y = <span class="number">0</span>;</span><br><span class="line">window.setAttributes(params);</span><br></pre></td></tr></table></figure>

<p>别忘了在Manifest文件中，为这个activity设置一个透明主题。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.onepixel.OnePixelActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:excludeFromRecents</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:taskAffinity</span>=<span class="string">&quot;com.github.boybeak.livestock.onepixel&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/OnePixelTheme&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>android:excludeFromRecents&#x3D;”true” &#x2F;&#x2F;不会出现在任务管理器中</p>
<p>android:taskAffinity&#x3D;”xxxx”				&#x2F;&#x2F;在新的任务栈中创建，不会将其他界面带到前台，配合启动OnePixelActivity时候的Intent.FLAG_ACTIVITY_NEW_TASK使用.</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：经过实验，这个方案在真机上已经大概率失效了。</p>
<ol>
<li>收到锁屏广播会有1~3秒延迟；</li>
<li>当OnePixelActivity设置了<code>excludeFromRecents=&quot;true&quot;</code>后，在锁屏下是启动不起来的；</li>
<li>屏幕重新点亮的广播会有十几秒延迟。</li>
</ol>
<p>我在一架5T上实验的，其他机型不保证。</p>
</blockquote>
<h2 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h2><p>这一方案就是利用一个前台服务，配合Notification，来达到保活。弊端就是，当你的应用没有Notification需求的时候，对于一些敏感用户来说，这就容易引起方案。如下图。</p>
<p><img src="/images/forground_service.png" alt="forground_service"></p>
<p>所以当你的应用是音乐类播放器，可以将这个通知作为音乐播放控制来使用，但是如果你的应用没有这样的需求，就会引起敏感用户注意，反而有可能被手动杀死甚至卸载。在Android8.0以前，可以通过如下方案消除这个无意义的敏感通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    startForground(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Notification</span>());</span><br><span class="line">    startService(<span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, InnerService.class));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">      startForground(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Notification</span>());</span><br><span class="line">      stopSelf();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是利用系统漏洞来消除的这个通知，但是在Android8.0以后，同一个ID下，不允许重复创建前台服务，所以使用该方法需要判断版本。</p>
<h2 id="系统广播拉活"><a href="#系统广播拉活" class="headerlink" title="系统广播拉活"></a>系统广播拉活</h2><p><strong>系统拉活</strong></p>
<p>比如开机广播，电量变化，信号变化，网络变化等。但是在Android7.0后增加了限制，在Android8.0后限制更加严格。所以，这类保活方案已经不可靠了。</p>
<blockquote>
<p>Oreo: <a target="_blank" rel="noopener" href="https://developer.android.google.cn/about/versions/oreo/background.html#Broadcasts">https://developer.android.google.cn/about/versions/oreo/background.html#Broadcasts</a></p>
<p>Pie: <a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/components/broadcast-exceptions.html">https://developer.android.google.cn/guide/components/broadcast-exceptions.html</a></p>
</blockquote>
<p><strong>用户拉活</strong></p>
<p>大厂的多个APP之间可以互相之间拉活。 </p>
<h2 id="Service系统机制拉活"><a href="#Service系统机制拉活" class="headerlink" title="Service系统机制拉活"></a>Service系统机制拉活</h2><p>根据Service的onStartCommand方法的返回值，系统会执行不同的拉活方案。一般按照默认返回<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/app/Service#START_STICKY">START_STICKY</a>就可以。</p>
<p>优点是使用成本低，缺点是不稳定。</p>
<h2 id="账户同步拉活"><a href="#账户同步拉活" class="headerlink" title="账户同步拉活"></a>账户同步拉活</h2><p>优点：非常稳定。</p>
<h2 id="JobScheduler拉活"><a href="#JobScheduler拉活" class="headerlink" title="JobScheduler拉活"></a>JobScheduler拉活</h2><h2 id="双进程守护"><a href="#双进程守护" class="headerlink" title="双进程守护"></a>双进程守护</h2><h2 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h2><h2 id="厂商推送"><a href="#厂商推送" class="headerlink" title="厂商推送"></a>厂商推送</h2><h2 id="播放无声音乐"><a href="#播放无声音乐" class="headerlink" title="播放无声音乐"></a>播放无声音乐</h2><h2 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h2><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p><a target="_blank" rel="noopener" href="https://github.com/boybeak/Livestock">示例代码Livestock</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="http://gityuan.com/2018/05/19/android-process-adj/">解读Android进程优先级ADJ算法</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/training/id-auth/custom_auth">创建自定义账号类型</a></p>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>Author: boybeak</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-10-21</span><a class="tag" href="/categories/Android技巧/" title="Android技巧">Android技巧 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Android/" title="Android">Android </a><span class="leancloud_visitors"></span><span>About 1306 words, 4 min 21 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/intent/tweet?text=I%20have%20found%20a%20great%20blog.%0A%0AHikingMan%20%C2%B7%20App%E4%BF%9D%E6%B4%BB%E6%9C%AF%0Ahttp://example.com/2020/10/21/2022-09-19-App%E4%BF%9D%E6%B4%BB%E6%9C%AF/%0A"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/10/21/2022-09-19-AMS%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="AMS启动流程">Previous</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/10/20/2022-09-19-Binder%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/" title="Binder机制分析">Next</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="gitalk_container" style="padding:10px"></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>const gitalk = new Gitalk({
    clientID: '39e6af26be4db13bc1c2',
    clientSecret: '6958fae781c21e07373de773717a847710e3dc98',
    repo: 'blog-comments',      // The repository of store comments,
    owner: 'boybeak',
    admin: ['boybeak'],
    id: 'App保活术',      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
})
gitalk.render('gitalk_container')</script></div></div></div></div><script src="/js/darkLightToggle.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>