<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2024-11-25T06:41:47+00:00</updated><id>/feed.xml</id><title type="html">Boybeak</title><subtitle>The fortress besieged of an independent developer</subtitle><author><name>boybeak</name></author><entry><title type="html">我写了一个Jekyll的Material Design的主题</title><link href="/2024/09/25/%E6%88%91%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AAJekyll%E7%9A%84Material-Design%E7%9A%84%E4%B8%BB%E9%A2%98.html" rel="alternate" type="text/html" title="我写了一个Jekyll的Material Design的主题" /><published>2024-09-25T17:41:32+00:00</published><updated>2024-09-25T17:41:32+00:00</updated><id>/2024/09/25/%E6%88%91%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AAJekyll%E7%9A%84Material-Design%E7%9A%84%E4%B8%BB%E9%A2%98</id><content type="html" xml:base="/2024/09/25/%E6%88%91%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AAJekyll%E7%9A%84Material-Design%E7%9A%84%E4%B8%BB%E9%A2%98.html"><![CDATA[<p>使用了很久的Hexo作为博客模板引擎，最近出了一些莫名其妙的问题，简单来说，就是部署在github pages的博客，在没有修改任何环境变量的前提下，突然就无法执行任何构建了，报出版本号的一系列问题，尝试修复无果，最终选择切换回老牌博客模板引擎Jekyll。
<!-- more -->
其实，Hexo还是挺不错的，Node驱动，对于相比Jekyll的Ruby还是要更常用一些。但是Github pages对Jekyll支持还是更友好一些。
作为一个Android开发者，对于Material Design更为熟悉，也比较喜欢这种简洁的风格，以前曾尝试过他人写的类似风格主题，但是总觉得不是自己想要的，这次就“票友起义”，自己来搞一个Material Design的Jekyll主题。
该主题的名称为<strong>Sobekyll</strong>，因为是基于<a href="https://soberjs.com/">SoberJS</a>这个框架，为Jekyll所写，故得名。
主题地址: <a href="https://sobekyll.github.io/">Sobekyll</a>
开源地址: <a href="https://github.com/sobekyll/sobekyll.github.io">Sobekyll</a>。</p>]]></content><author><name>boybeak</name></author><category term="Jekyll" /><category term="Material Design" /><summary type="html"><![CDATA[使用了很久的Hexo作为博客模板引擎，最近出了一些莫名其妙的问题，简单来说，就是部署在github pages的博客，在没有修改任何环境变量的前提下，突然就无法执行任何构建了，报出版本号的一系列问题，尝试修复无果，最终选择切换回老牌博客模板引擎Jekyll。 其实，Hexo还是挺不错的，Node驱动，对于相比Jekyll的Ruby还是要更常用一些。但是Github pages对Jekyll支持还是更友好一些。 作为一个Android开发者，对于Material Design更为熟悉，也比较喜欢这种简洁的风格，以前曾尝试过他人写的类似风格主题，但是总觉得不是自己想要的，这次就“票友起义”，自己来搞一个Material Design的Jekyll主题。 该主题的名称为Sobekyll，因为是基于SoberJS这个框架，为Jekyll所写，故得名。 主题地址: Sobekyll 开源地址: Sobekyll。]]></summary></entry><entry><title type="html">写了一个Hexo主题与插件</title><link href="/2024/09/22/%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B8%8E%E6%8F%92%E4%BB%B6.html" rel="alternate" type="text/html" title="写了一个Hexo主题与插件" /><published>2024-09-22T17:41:32+00:00</published><updated>2024-09-22T17:41:32+00:00</updated><id>/2024/09/22/%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B8%8E%E6%8F%92%E4%BB%B6</id><content type="html" xml:base="/2024/09/22/%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B8%8E%E6%8F%92%E4%BB%B6.html"><![CDATA[<p>最近写了一个Hexo的主题，同时为了配合主题<a href="https://github.com/hexober/hexober.github.io">Hexober</a>，写了一个插件<a href="https://github.com/boybeak/hexo-auto-photos">hexo-auto-photos</a>。</p>

<h2 id="hexober">Hexober</h2>
<p><a href="https://github.com/hexober/hexober.github.io">Hexober</a>是一个基于<a href="https://soberjs.com/">soberJS</a>的Material Design风格的Hexo主题。本博客即将切换到该主题下。</p>

<h2 id="hexo-auto-photos">hexo-auto-photos</h2>
<p><a href="https://github.com/boybeak/hexo-auto-photos">hexo-auto-photos</a>是一个自动从文章内容中，提取出photos字段的库，该库可配合<a href="https://github.com/hexober/hexober.github.io">Hexober</a>或者其它支持文章列表展示图片的主题使用。当使用该库以后，如果用户没有指定文章的photos字段，将会自动从文章中找到图片部分，并填充到文章的photos字段中。</p>]]></content><author><name>boybeak</name></author><category term="Hexo" /><summary type="html"><![CDATA[最近写了一个Hexo的主题，同时为了配合主题Hexober，写了一个插件hexo-auto-photos。]]></summary></entry><entry><title type="html">我写了一个app——AOD Volume</title><link href="/2024/09/22/AOD-Volume.html" rel="alternate" type="text/html" title="我写了一个app——AOD Volume" /><published>2024-09-22T17:41:32+00:00</published><updated>2024-09-22T17:41:32+00:00</updated><id>/2024/09/22/AOD-Volume</id><content type="html" xml:base="/2024/09/22/AOD-Volume.html"><![CDATA[<p>使用手机时，经常因为忘记之前音量调得过大，在播放视频/音乐时，造成音量过大的尴尬或者吵醒别人。因此，我写了一个常显音量条，用来时刻提醒自己音量，避免音量过大的尴尬。
<a href="https://play.google.com/store/apps/details?id=com.github.boybeak.aodvolumebar" target="_blank">
<img src="/assets/images/googleplay-badge.webp" width="200" />
</a></p>

<p><img src="/assets/images/aod-volume.png" alt="aod-volume" width="320" /></p>

<video width="320" controls="" autoplay="">
  <source src="/assets/videos/aod-volume-fg-service.webm" type="video/webm" />
  您的浏览器不支持 video 标签。
</video>]]></content><author><name>boybeak</name></author><category term="Android" /><summary type="html"><![CDATA[使用手机时，经常因为忘记之前音量调得过大，在播放视频/音乐时，造成音量过大的尴尬或者吵醒别人。因此，我写了一个常显音量条，用来时刻提醒自己音量，避免音量过大的尴尬。]]></summary></entry><entry><title type="html">面试笔记</title><link href="/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/2024/06/16/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%931.html" rel="alternate" type="text/html" title="面试笔记" /><published>2024-06-16T17:03:00+00:00</published><updated>2024-06-16T17:03:00+00:00</updated><id>/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/2024/06/16/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%931</id><content type="html" xml:base="/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/2024/06/16/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%931.html"><![CDATA[<p>边独立，边面试，两手都要抓，两手都要硬。</p>
<h3 id="1-给定数组array与一个数字num要求从array中找出两个数其和为num并返回这两个数的下标">1. 给定数组array与一个数字num，要求从array中找出两个数，其和为num，并返回这两个数的下标</h3>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">findTwoSum</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">Pair</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">,</span> <span class="nc">Int</span><span class="p">&gt;?</span> <span class="p">{</span>
    <span class="c1">// 创建一个哈希表来存储数组中的数字及其索引</span>
    <span class="kd">val</span> <span class="py">map</span> <span class="p">=</span> <span class="n">mutableMapOf</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">,</span> <span class="nc">Int</span><span class="p">&gt;()</span>

    <span class="c1">// 遍历数组</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">array</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">val</span> <span class="py">complement</span> <span class="p">=</span> <span class="n">num</span> <span class="p">-</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1">// 检查哈希表中是否存在这个补数</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="nf">containsKey</span><span class="p">(</span><span class="n">complement</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// 如果存在，返回这个数及其补数的索引</span>
            <span class="k">return</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">complement</span><span class="p">]</span><span class="o">!!</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1">// 将当前数字及其索引存入哈希表</span>
        <span class="n">map</span><span class="p">[</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="p">=</span> <span class="n">i</span>
    <span class="p">}</span>

    <span class="c1">// 如果没有找到符合条件的数对，返回null</span>
    <span class="k">return</span> <span class="k">null</span>
<span class="p">}</span>
</code></pre></div></div>
<p><strong>解读：</strong></p>
<ol>
  <li>创建一个map，在遍历的过程中，报错所有数字以及其对应的坐标，数字为键，坐标为值；</li>
  <li>遍历时，计算出num与当前元素的差值，然后试图从map中索引，如果有索引，则命中，如果没有则继续遍历；</li>
  <li>map的作用，相当于取代了双层遍历法其中的一层遍历；</li>
</ol>

<h3 id="2-jvm如何判断一个对象可以被回收">2. jvm如何判断一个对象可以被回收？</h3>
<ol>
  <li>引用计数法
优点：实现简单，时间复杂度低；
缺点：无法解决循环引用问题；</li>
  <li>可达性分析算法
通过GC Roots开始标记所有可达的对象；可以被标记的，认为是活的对象，未被标记的，则认为已经不需要，可以被回收；</li>
</ol>

<h4 id="21-有哪些可以作为gc-root">2.1 有哪些可以作为GC Root?</h4>
<ul>
  <li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
  <li>方法区中的类静态属性引用的对象。</li>
  <li>方法区中常量引用的对象。</li>
  <li>本地方法栈中JNI（即Native方法）引用的对象。</li>
</ul>

<h4 id="22-垃圾回收的过程是怎样的">2.2 垃圾回收的过程是怎样的？</h4>
<p>有三种策略：</p>
<ul>
  <li>标记清除：首先标记所有可达对象，然后清除所有未被标记的对象；</li>
  <li>复制算法：将存活的对象，从一块内存复制到另外一块内存，然后清空原来的内存；</li>
  <li>标记-压缩： 首先标记所有可达的对象，然后将所有存活的对象压缩到内存的一端，清除便捷以外的空间；</li>
</ul>

<h3 id="3-android的handler是如何造成内存泄露的">3. Android的Handler是如何造成内存泄露的？</h3>
<p>非静态内部类或者匿名内部类，会隐式的持有外部类的对象，如果在Activity中声明一个Handler，而Handler执行延迟任务，在任务结束前，Activity已经被销毁了，则Activiey泄露了；</p>

<p>#### 3.1 如何解决Handler的内存泄露？</p>
<ol>
  <li>将<code class="language-plaintext highlighter-rouge">Handler</code>声明为静态内部类，并且使用弱引用持有外部类的引用；</li>
  <li>在Activity的onDestroy中，使用<code class="language-plaintext highlighter-rouge">Handler</code>的<code class="language-plaintext highlighter-rouge">removeCallbacksAndMessages</code>方法，移除所有未执行的消息和回调；</li>
</ol>

<p>#### 3.2 有没有非Activity的其他内存泄露的场景？</p>
<ol>
  <li>单例持有外部对象；</li>
  <li>静态持有外部对象；</li>
  <li>未取消注册监听器或者回调；</li>
  <li>WebView导致内存泄露；</li>
  <li>异步任务；
 总结来说，就是生命周期长的对象，持有了一个生命周期短的对象的引用；</li>
</ol>

<p>### 4. 应用启动白屏如何排查？如何解决？</p>
<ol>
  <li>在应用入口，比如Application的onCreate、启动Activity的onCreate中，做耗时检查，如果耗时异常，具体检查代码；</li>
  <li>如果是Activity的onCreate中耗时长，检查是否为布局过于复杂，造成的布局解析耗时长，可以使用异步布局处理；</li>
  <li>如果为系统机制问题导致，可以配置主题或者使用Splash库来做过渡；</li>
</ol>

<h3 id="5-线上问题如何排查">5. 线上问题如何排查？</h3>
<ol>
  <li>运营种子用户，提前内测，按照用户反馈，复现问题场景；</li>
  <li>集成bugly等线上日志抓取工具，按照机型、系统等信息，复现问题场景；</li>
  <li>如果有可能，可以通过热更新修复问题；</li>
</ol>

<h3 id="6-不同任务类型io密集型计算密集型任务如何分配线程池策略">6. 不同任务类型(IO密集型/计算密集型)任务，如何分配线程池策略？</h3>
<h4 id="io密集型任务">IO密集型任务</h4>
<p><strong>特点</strong>
IO密集型任务主要涉及等待外部资源（如文件系统、网络请求、数据库操作等），因此大部分时间处于等待状态，而非消耗CPU。</p>

<p><strong>策略</strong>
对于IO密集型任务，可以使用较大的线程池，因为线程在等待IO操作完成时不会消耗大量CPU资源。</p>

<p><strong>线程池配置</strong>
通常，线程池的大小可以设置为CPU核心数的2倍或更多。一个常见的公式是：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>线程池大小 <span class="o">=</span> CPU核心数 <span class="k">*</span> 2
或更大，根据实际情况调整。
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IOIntensiveTaskExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">N_THREADS</span> <span class="o">=</span> <span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">()</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ExecutorService</span> <span class="n">ioThreadPool</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="no">N_THREADS</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">ioThreadPool</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="c1">// 模拟IO操作</span>
                <span class="n">performIOOperation</span><span class="o">();</span>
            <span class="o">});</span>
        <span class="o">}</span>

        <span class="n">ioThreadPool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">performIOOperation</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 模拟IO操作</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="计算密集型任务">计算密集型任务</h4>
<p><strong>特点</strong>
计算密集型任务主要消耗CPU资源，执行过程中几乎不涉及等待时间，因此可以充分利用CPU。</p>

<p><strong>策略</strong>
对于计算密集型任务，线程池的大小应设置为接近CPU核心数。过多的线程会导致频繁的上下文切换，反而降低性能。</p>

<p><strong>线程池配置</strong>
通常，线程池的大小可以设置为CPU核心数。一个常见的公式是：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>线程池大小 <span class="o">=</span> CPU核心数
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CPUIntensiveTaskExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">N_THREADS</span> <span class="o">=</span> <span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ExecutorService</span> <span class="n">cpuThreadPool</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="no">N_THREADS</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">cpuThreadPool</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="c1">// 模拟计算操作</span>
                <span class="n">performCPUTask</span><span class="o">();</span>
            <span class="o">});</span>
        <span class="o">}</span>

        <span class="n">cpuThreadPool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">performCPUTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 模拟计算操作</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>混合任务</strong>
在实际应用中，有些任务可能既包含IO操作又包含计算操作。这种情况下，可以考虑使用不同的线程池分别处理不同类型的任务，或者根据任务的主要特征选择适当的线程池配置。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MixedTaskExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">IO_THREADS</span> <span class="o">=</span> <span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">()</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">CPU_THREADS</span> <span class="o">=</span> <span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ExecutorService</span> <span class="n">ioThreadPool</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="no">IO_THREADS</span><span class="o">);</span>
        <span class="nc">ExecutorService</span> <span class="n">cpuThreadPool</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="no">CPU_THREADS</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">ioThreadPool</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="c1">// 模拟IO操作</span>
                <span class="n">performIOOperation</span><span class="o">();</span>
            <span class="o">});</span>

            <span class="n">cpuThreadPool</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="c1">// 模拟计算操作</span>
                <span class="n">performCPUTask</span><span class="o">();</span>
            <span class="o">});</span>
        <span class="o">}</span>

        <span class="n">ioThreadPool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
        <span class="n">cpuThreadPool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">performIOOperation</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 模拟IO操作</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">performCPUTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 模拟计算操作</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h4 id="总结">总结</h4>
<p><strong>IO密集型任务</strong>：使用较大的线程池，通常为CPU核心数的2倍或更多，以应对大量的IO等待时间。
<strong>计算密集型任务</strong>：使用较小的线程池，接近CPU核心数，以充分利用CPU资源，避免过多的线程上下文切换。
<strong>混合任务</strong>：根据任务的主要特征，分别使用不同的线程池处理IO操作和计算操作。
通过合理配置线程池，可以有效提高应用程序的性能和资源利用率。</p>]]></content><author><name>boybeak</name></author><category term="面试笔记" /><category term="面试" /><summary type="html"><![CDATA[边独立，边面试，两手都要抓，两手都要硬。 1. 给定数组array与一个数字num，要求从array中找出两个数，其和为num，并返回这两个数的下标 ```kotlin fun findTwoSum(array: IntArray, num: Int): Pair&lt;Int, Int&gt;? { // 创建一个哈希表来存储数组中的数字及其索引 val map = mutableMapOf&lt;Int, Int&gt;()]]></summary></entry><entry><title type="html">Tray - macOS菜单栏app开发库</title><link href="/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/06/14/Tray-macOS%E8%8F%9C%E5%8D%95%E6%A0%8Fapp%E5%BC%80%E5%8F%91%E5%BA%93.html" rel="alternate" type="text/html" title="Tray - macOS菜单栏app开发库" /><published>2024-06-14T15:15:00+00:00</published><updated>2024-06-14T15:15:00+00:00</updated><id>/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/06/14/Tray-macOS%E8%8F%9C%E5%8D%95%E6%A0%8Fapp%E5%BC%80%E5%8F%91%E5%BA%93</id><content type="html" xml:base="/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/06/14/Tray-macOS%E8%8F%9C%E5%8D%95%E6%A0%8Fapp%E5%BC%80%E5%8F%91%E5%BA%93.html"><![CDATA[<p>最近开发了<a href="https://github.com/boybeak/JustTodo">JustTodo</a>和<a href="https://github.com/boybeak/DeskNote">DeskNote</a>两个macOS应用，都是启动入口在菜单栏的，通过菜单栏上图标点击，快速执行相关操作，这让我想起我开发第一款菜单栏app <a href="https://github.com/boybeak/TranslatorDocs">Translator</a>时的痛苦。因为想使用最新的SwiftUI作为UI框架，但是此框架构建菜单栏app的资料很少，大多数都是生成一个简单菜单，而不是可以自定义的复杂界面，尤其是用swiftUI构建的界面。
为了解决这一痛点，在总结了<a href="https://github.com/boybeak/JustTodo">JustTodo</a>和<a href="https://github.com/boybeak/DeskNote">DeskNote</a>两个macOS应用开发经验后，决心自己做了一个菜单栏应用快捷库<a href="https://github.com/boybeak/Tray">Tray</a>，方便以后使用。</p>

<h2 id="一引入">一、引入</h2>
<p>在macOS项目中，点击<strong>File</strong> -&gt; <strong>Add Package Dependencies …</strong>，在包管理窗口的搜索框中，复制粘贴<code class="language-plaintext highlighter-rouge">https://github.com/boybeak/Tray.git</code>，待检索到库信息，点击<strong>Add Package</strong>按钮。</p>

<h2 id="二使用">二、使用</h2>
<p>以SwiftUI应用为例，在代码入口处，声明一个<code class="language-plaintext highlighter-rouge">AppDelegate</code>.</p>

<h3 id="21-初始化">2.1 初始化</h3>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">DeskNoteApp</span><span class="p">:</span> <span class="kt">App</span> <span class="p">{</span>

    <span class="kd">@NSApplicationDelegateAdaptor</span><span class="p">(</span><span class="kt">AppDelegate</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">var</span> <span class="nv">app</span><span class="p">:</span> <span class="kt">AppDelegate</span>

    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">Scene</span> <span class="p">{</span>
        <span class="kt">Settings</span> <span class="p">{}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p>这里body中的<code class="language-plaintext highlighter-rouge">Settings {}</code>代码，是为了隐藏启动时的主窗口。</p>
</blockquote>

<p>然后创建AppDelegate类。</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">AppDelegate</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">NSApplicationDelegate</span> <span class="p">{</span>

    <span class="kd">private</span> <span class="k">var</span> <span class="nv">tray</span><span class="p">:</span> <span class="kt">Tray</span><span class="o">!</span>
    
    <span class="kd">func</span> <span class="nf">applicationDidFinishLaunching</span><span class="p">(</span><span class="n">_</span> <span class="nv">notification</span><span class="p">:</span> <span class="kt">Notification</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">tray</span> <span class="o">=</span> <span class="kt">Tray</span><span class="o">.</span><span class="nf">install</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span> <span class="s">"TrayIcon"</span><span class="p">)</span> <span class="p">{</span> <span class="n">tray</span> <span class="k">in</span> 
            <span class="k">self</span><span class="o">.</span><span class="nf">configTray</span><span class="p">(</span><span class="nv">tray</span><span class="p">:</span> <span class="n">tray</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>引入相关的类Tray并声明我们的托盘管理对象<code class="language-plaintext highlighter-rouge">var tray: Tray</code>，并在<code class="language-plaintext highlighter-rouge">applicationDidFinishLaunching</code>中为改对象赋值，传入资源文件名称，或者使用<code class="language-plaintext highlighter-rouge">SF Symbols</code>也可以，只是参数名要改为systemSymbolName，如果有更多要求，也可以直接以icon为参数名，传入一个NSImage对象。
然后在闭包中配置tray.</p>

<h3 id="22-配置托盘信息">2.2 配置托盘信息</h3>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">configTray</span><span class="p">(</span><span class="nv">tray</span><span class="p">:</span> <span class="kt">Tray</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 配置左键弹出view</span>
    <span class="n">tray</span><span class="o">.</span><span class="nf">setView</span><span class="p">(</span><span class="nv">content</span><span class="p">:</span> <span class="kt">ContentView</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里设置的是一个SwiftUI的View，你也可以设置NSView或者NSViewController，除了界面参数，还有其他三个可选参数：</p>
<ol>
  <li>behavior: NSPopover的behavior，默认值为.transient，即点击窗口以外区域隐藏弹出界面；</li>
  <li>level: NSPopover的窗口层级，默认为.floating；</li>
  <li>size: NSPopover的大小，默认为nil，即使用View自己配置的大小；</li>
</ol>

<p>在JustTodo应用中，其效果如下图：
<img src="/assets/images/just-todo.gif" alt="" /></p>

<p>到这里，主要的配置就完成了，如果你不想弹出一个NSPopover，你也可以接管托盘图标的左键事件。</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tray</span><span class="o">.</span><span class="n">setOnLeftClick</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div></div>
<p>返回true，表示事件完全处理，会阻止默认行为。默认行为就是弹出NSPopover，前提是设置了view。比如在DeskNote中，我接管了此事件，改为弹出笔记的编辑页面。
<img src="/assets/images/dest-note.gif" alt="" />
当然，同样你也可以为右键增加事件。</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tray</span><span class="o">.</span><span class="n">setOnRightClick</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div></div>
<p>返回true，表示事件完成处理，阻止默认行为。默认行为是弹出菜单，前提是设置了菜单，正如下边代码。</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">menu</span> <span class="o">=</span> <span class="kt">NSMenu</span><span class="p">()</span>
        
<span class="k">let</span> <span class="nv">newNoteMenuItem</span> <span class="o">=</span> <span class="kt">NSMenuItem</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="kt">NSLocalizedString</span><span class="p">(</span><span class="s">"Menu_item_new_note"</span><span class="p">,</span> <span class="nv">comment</span><span class="p">:</span> <span class="s">""</span><span class="p">),</span> <span class="nv">action</span><span class="p">:</span> <span class="kd">#selector(</span><span class="nf">onNewNoteAction</span><span class="kd">)</span><span class="p">,</span> <span class="nv">keyEquivalent</span><span class="p">:</span> <span class="s">""</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">quitMenuItem</span> <span class="o">=</span> <span class="kt">NSMenuItem</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="kt">NSLocalizedString</span><span class="p">(</span><span class="s">"Menu_item_quit"</span><span class="p">,</span> <span class="nv">comment</span><span class="p">:</span> <span class="s">""</span><span class="p">),</span> <span class="nv">action</span><span class="p">:</span> <span class="kd">#selector(</span><span class="nf">onQuitAction</span><span class="kd">)</span><span class="p">,</span> <span class="nv">keyEquivalent</span><span class="p">:</span> <span class="s">""</span><span class="p">)</span>

<span class="n">menu</span><span class="o">.</span><span class="nf">addItem</span><span class="p">(</span><span class="n">newNoteMenuItem</span><span class="p">)</span>
<span class="n">menu</span><span class="o">.</span><span class="nf">addItem</span><span class="p">(</span><span class="n">quitMenuItem</span><span class="p">)</span>

<span class="n">tray</span><span class="o">.</span><span class="nf">setMenu</span><span class="p">(</span><span class="nv">menu</span><span class="p">:</span> <span class="n">menu</span><span class="p">)</span>
</code></pre></div></div>
<p>效果如下：
<img src="/assets/images/dest-note-right.gif" alt="" /></p>

<p>这就是一些基本的使用和配置步骤。接下来是一些相关的小建议。</p>

<h2 id="三建议">三、建议</h2>
<h3 id="31-托盘图标尺寸">3.1 托盘图标尺寸</h3>
<p>1x: 18<em>18
2x: 36</em>36
3x: 54*54</p>

<h3 id="32-隐藏docker栏中应用的图标">3.2 隐藏Docker栏中应用的图标</h3>
<p>在Info.plist中，增加一个配置项: <strong>Application is agent(UIElement)</strong> - <strong>YES</strong>.</p>]]></content><author><name>boybeak</name></author><category term="独立开发笔记" /><category term="macOS" /><summary type="html"><![CDATA[最近开发了JustTodo和DeskNote两个macOS应用，都是启动入口在菜单栏的，通过菜单栏上图标点击，快速执行相关操作，这让我想起我开发第一款菜单栏app Translator时的痛苦。因为想使用最新的SwiftUI作为UI框架，但是此框架构建菜单栏app的资料很少，大多数都是生成一个简单菜单，而不是可以自定义的复杂界面，尤其是用swiftUI构建的界面。 为了解决这一痛点，在总结了JustTodo和DeskNote两个macOS应用开发经验后，决心自己做了一个菜单栏应用快捷库Tray，方便以后使用。]]></summary></entry><entry><title type="html">发布Swift Package库</title><link href="/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/06/04/%E5%8F%91%E5%B8%83Swift-Package%E5%BA%93.html" rel="alternate" type="text/html" title="发布Swift Package库" /><published>2024-06-04T22:19:00+00:00</published><updated>2024-06-04T22:19:00+00:00</updated><id>/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/06/04/%E5%8F%91%E5%B8%83Swift%20Package%E5%BA%93</id><content type="html" xml:base="/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/06/04/%E5%8F%91%E5%B8%83Swift-Package%E5%BA%93.html"><![CDATA[<p>最近开发<a href="https://github.com/boybeak/JustTodo">JustTodo</a>时，发觉把处理托盘应用的代码封装起来是很有必要的，这样的话，在以后开发其他应用时，便不需要一而再的写重复代码。以前发布过很多Android平台的类库，但是对于macOS平台的swift库，我还是第一次。</p>
<blockquote>
  <p>再次吐槽一下苹果生态下的包管理，挺混乱的，最终我选择使用最新的Swift Package Manager</p>
</blockquote>

<p>该文章中涉及到的所有代码都在<a href="https://github.com/boybeak/Tray">boybeak/Tray</a></p>

<h2 id="一创建github仓库">一、创建Github仓库</h2>
<p>我们需要先创建一个Github仓库，我的仓库名称为Tray，将其clone到本地。</p>

<h2 id="二在仓库目录下初始化一个swift-package">二、在仓库目录下，初始化一个Swift Package。</h2>
<p>在Tray仓库目录下，执行以下脚本。</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tray % swift package init <span class="nt">--type</span> library
</code></pre></div></div>
<p>该命令，会自动按照目录名称，初始化一个Swift Package，其目录如下：</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">Tray</span>
  <span class="nt">-</span> <span class="nt">Package</span><span class="nc">.swift</span>
  <span class="nt">-</span> <span class="nc">.gitignore</span>
  <span class="nt">-</span> <span class="nt">Sources</span><span class="o">/</span>
    <span class="nt">-</span> <span class="nt">Tray</span><span class="o">/</span><span class="nt">Tray</span><span class="nc">.swift</span>
  <span class="nt">-</span> <span class="nt">Tests</span><span class="o">/</span>
    <span class="nt">-</span> <span class="nt">TrayTests</span><span class="o">/</span><span class="nt">TrayTests</span><span class="nc">.swift</span>
</code></pre></div></div>
<p>其中，Package.swift为库的索引入口，当Xcode在按照Github链接查找库时，会以查到此文件为准则。其内容如下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// swift-tools-version: 5.10</span>
<span class="c1">// The swift-tools-version declares the minimum version of Swift required to build this package.</span>

<span class="kd">import</span> <span class="kt">PackageDescription</span>

<span class="k">let</span> <span class="nv">package</span> <span class="o">=</span> <span class="kt">Package</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"Tray"</span><span class="p">,</span>
    <span class="nv">products</span><span class="p">:</span> <span class="p">[</span>
        <span class="c1">// Products define the executables and libraries a package produces, making them visible to other packages.</span>
        <span class="o">.</span><span class="nf">library</span><span class="p">(</span>
            <span class="nv">name</span><span class="p">:</span> <span class="s">"Tray"</span><span class="p">,</span>
            <span class="nv">targets</span><span class="p">:</span> <span class="p">[</span><span class="s">"Tray"</span><span class="p">]),</span>
    <span class="p">],</span>
    <span class="nv">targets</span><span class="p">:</span> <span class="p">[</span>
        <span class="c1">// Targets are the basic building blocks of a package, defining a module or a test suite.</span>
        <span class="c1">// Targets can depend on other targets in this package and products from dependencies.</span>
        <span class="o">.</span><span class="nf">target</span><span class="p">(</span>
            <span class="nv">name</span><span class="p">:</span> <span class="s">"Tray"</span><span class="p">),</span>
        <span class="o">.</span><span class="nf">testTarget</span><span class="p">(</span>
            <span class="nv">name</span><span class="p">:</span> <span class="s">"TrayTests"</span><span class="p">,</span>
            <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="s">"Tray"</span><span class="p">]),</span>
    <span class="p">]</span>
<span class="p">)</span>
</code></pre></div></div>

<h2 id="三发布库">三、发布库</h2>
<p>补充相关逻辑代码，提交/推送到GitHub，便可以在其他库中使用。不需要特别的发布操作。
在正式发布前，也可以本地使用，创建一个新项目，在Xcode中，File -&gt; Add Package Denpendencies…，在弹出的管理窗口中，点击<strong>Add Local</strong>按钮，然后选择Tray文件夹，便可以本地使用，同时，你也可以在项目中，直接编辑该库的代码。</p>

<p>提交代码到Github后，你可以把自己的库提交到<a href="https://swiftpackageindex.com/">Swift Package Index</a>，方便他人查找。进入页面后，点击<strong>Add a package</strong>，进入新页面后，会有一个绿色的<strong>Add Package(s)</strong>按钮，此点击此按钮，会自动跳转到Swift Package Index的Github的issue页面，并会有一个提交模板，输入自己库的Github链接后，提issue，机器人会处理这个issue，并再提一个新的issue，点击链接到新的issue中，点击链接，对你的代码进行code review，注意勾选<strong>viewed</strong>复选框，完成code review后，机器人会自动处理接下来的流程。</p>

<h2 id="四使用库">四、使用库</h2>
<p>在Xcode中，File -&gt; Add Package Denpendencies…，在弹出的管理窗口中，复制<code class="language-plaintext highlighter-rouge">https://github.com/boybeak/Tray.git</code>到搜索库，然后就可以添加库了。</p>]]></content><author><name>boybeak</name></author><category term="独立开发笔记" /><category term="macOS" /><summary type="html"><![CDATA[最近开发JustTodo时，发觉把处理托盘应用的代码封装起来是很有必要的，这样的话，在以后开发其他应用时，便不需要一而再的写重复代码。以前发布过很多Android平台的类库，但是对于macOS平台的swift库，我还是第一次。 再次吐槽一下苹果生态下的包管理，挺混乱的，最终我选择使用最新的Swift Package Manager]]></summary></entry><entry><title type="html">JustTodo开发(五) SwiftUI + web</title><link href="/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/05/26/JustTodo%E5%BC%80%E5%8F%91(%E4%BA%94)-SwiftUI-+-web.html" rel="alternate" type="text/html" title="JustTodo开发(五) SwiftUI + web" /><published>2024-05-26T17:41:00+00:00</published><updated>2024-05-26T17:41:00+00:00</updated><id>/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/05/26/JustTodo%E5%BC%80%E5%8F%91(%E4%BA%94)%20SwiftUI%20+%20web</id><content type="html" xml:base="/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/05/26/JustTodo%E5%BC%80%E5%8F%91(%E4%BA%94)-SwiftUI-+-web.html"><![CDATA[<p>初版完成以后，发现了一个问题，就是web中的输入框不接受复制/粘贴的快捷键(cmd+c, cmd+v)，触发快捷键时，会弹“咚”一声系统音，暂时在AppKit下没能解决这个问题，搜了很多资料，比如这里-<a href="https://stackoverflow.com/questions/49637675/cut-copy-paste-keyboard-shortcuts-not-working-in-nspopover">Cut/copy/paste keyboard shortcuts not working in NSPopover</a>，想要支持这两个快捷键还是很不容易的，其实包括cmd+x, cmd+a也都不支持，但是我想到之前写的同样是托盘应用<a href="https://github.com/boybeak/TranslatorDocs">Translator</a>，这个就支持这些快捷键，让我突然想到，是不是可以在SwiftUI下，封装一个WKWebView，然后再加载web内容呢？</p>

<p>经过简单验证，封装一个WebView，然后先价值一个最简单的输入框的测试页面，发现这些快捷键是完全工作正常的，所以现在代码已经切换到SwiftUI+web了。</p>

<p><img src="/assets/images/just-todo.gif" alt="demo" />
接下来的一个功能就是增加tab上的图标显示。</p>

<p><strong>源码地址</strong>: <a href="https://github.com/boybeak/JustTodo">JustTodo</a>
<strong>下载地址</strong>: <a href="https://github.com/boybeak/JustTodo/releases">JustTodo-Releases</a></p>]]></content><author><name>boybeak</name></author><category term="独立开发笔记" /><category term="macOS" /><category term="JustTodo" /><summary type="html"><![CDATA[初版完成以后，发现了一个问题，就是web中的输入框不接受复制/粘贴的快捷键(cmd+c, cmd+v)，触发快捷键时，会弹“咚”一声系统音，暂时在AppKit下没能解决这个问题，搜了很多资料，比如这里-Cut/copy/paste keyboard shortcuts not working in NSPopover，想要支持这两个快捷键还是很不容易的，其实包括cmd+x, cmd+a也都不支持，但是我想到之前写的同样是托盘应用Translator，这个就支持这些快捷键，让我突然想到，是不是可以在SwiftUI下，封装一个WKWebView，然后再加载web内容呢？]]></summary></entry><entry><title type="html">JustTodo开发(四) 初版完成</title><link href="/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/05/23/JustTodo%E5%BC%80%E5%8F%91(%E5%9B%9B)-%E5%88%9D%E7%89%88%E5%AE%8C%E6%88%90.html" rel="alternate" type="text/html" title="JustTodo开发(四) 初版完成" /><published>2024-05-23T21:53:00+00:00</published><updated>2024-05-23T21:53:00+00:00</updated><id>/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/05/23/JustTodo%E5%BC%80%E5%8F%91(%E5%9B%9B)%20%E5%88%9D%E7%89%88%E5%AE%8C%E6%88%90</id><content type="html" xml:base="/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/05/23/JustTodo%E5%BC%80%E5%8F%91(%E5%9B%9B)-%E5%88%9D%E7%89%88%E5%AE%8C%E6%88%90.html"><![CDATA[<p>初版已经完成，从切换到SoberJS，基本上只用了一周，便写出来了，如果是使用macOS的原生开发方案，可能现在还困在各种不兼容中。
<img src="/assets/images/just-todo.gif" alt="demo" /></p>

<h2 id="基本功能">基本功能</h2>
<ol>
  <li>创建/删除 Tab；</li>
  <li>创建/标记/删除 Todo笔记；</li>
  <li>右键菜单，关于/退出；</li>
</ol>

<p><strong>源码地址</strong>: <a href="https://github.com/boybeak/JustTodo">JustTodo</a>
<strong>下载地址</strong>: <a href="https://github.com/boybeak/JustTodo/releases">JustTodo-Releases</a></p>]]></content><author><name>boybeak</name></author><category term="独立开发笔记" /><category term="macOS" /><category term="JustTodo" /><summary type="html"><![CDATA[初版已经完成，从切换到SoberJS，基本上只用了一周，便写出来了，如果是使用macOS的原生开发方案，可能现在还困在各种不兼容中。]]></summary></entry><entry><title type="html">JustTodo开发(三) 更换技术路线，跑步前进</title><link href="/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/05/17/JustTodo%E5%BC%80%E5%8F%91(%E4%B8%89)-%E6%9B%B4%E6%8D%A2%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-%E8%B7%91%E6%AD%A5%E5%89%8D%E8%BF%9B.html" rel="alternate" type="text/html" title="JustTodo开发(三) 更换技术路线，跑步前进" /><published>2024-05-17T23:28:00+00:00</published><updated>2024-05-17T23:28:00+00:00</updated><id>/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/05/17/JustTodo%E5%BC%80%E5%8F%91(%E4%B8%89)%20%E6%9B%B4%E6%8D%A2%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%EF%BC%8C%E8%B7%91%E6%AD%A5%E5%89%8D%E8%BF%9B</id><content type="html" xml:base="/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/05/17/JustTodo%E5%BC%80%E5%8F%91(%E4%B8%89)-%E6%9B%B4%E6%8D%A2%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-%E8%B7%91%E6%AD%A5%E5%89%8D%E8%BF%9B.html"><![CDATA[<p>在尝试使用AppKit原生开发界面几天后，我还是放弃了这种尝试了，其羸弱UI表现力，真的是让搭建界面的我心力交瘁。转而，我尝试使用web的形式来开发，即NSPopover中嵌套WKWebView的方式，配合原生层提供一些数据库接口。</p>

<p>经过一番查找，终于找到了一个Material Design风格的Web UI框架<a href="https://soberjs.com/">SoberJS</a>，作为一个android开发者，对这一套UI相对来说很熟悉了，用起来也驾轻就熟。</p>

<p>经过两天的开发时间，效果图如下：
<img src="/assets/images/sober_my_todo.png" alt="" />
这样既实现了最初的顶部导航设想，又能加快开发速度。</p>

<p>再次吐槽苹果的原生开发在macOS上真的好吃力。</p>]]></content><author><name>boybeak</name></author><category term="独立开发笔记" /><category term="macOS" /><category term="JustTodo" /><summary type="html"><![CDATA[在尝试使用AppKit原生开发界面几天后，我还是放弃了这种尝试了，其羸弱UI表现力，真的是让搭建界面的我心力交瘁。转而，我尝试使用web的形式来开发，即NSPopover中嵌套WKWebView的方式，配合原生层提供一些数据库接口。]]></summary></entry><entry><title type="html">JustTodo开发(二) 界面初始化</title><link href="/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/05/12/JustTodo%E5%BC%80%E5%8F%91(%E4%BA%8C)-%E7%95%8C%E9%9D%A2%E5%88%9D%E5%A7%8B%E5%8C%96.html" rel="alternate" type="text/html" title="JustTodo开发(二) 界面初始化" /><published>2024-05-12T17:18:00+00:00</published><updated>2024-05-12T17:18:00+00:00</updated><id>/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/05/12/JustTodo%E5%BC%80%E5%8F%91(%E4%BA%8C)%20%E7%95%8C%E9%9D%A2%E5%88%9D%E5%A7%8B%E5%8C%96</id><content type="html" xml:base="/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/2024/05/12/JustTodo%E5%BC%80%E5%8F%91(%E4%BA%8C)-%E7%95%8C%E9%9D%A2%E5%88%9D%E5%A7%8B%E5%8C%96.html"><![CDATA[<h2 id="一界面布局">一、界面布局</h2>
<p>一个简单的界面布局描述如下：</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">---------------------</span>
<span class="o">|</span>   <span class="o">|</span>               <span class="o">|</span>
<span class="o">|</span>   <span class="o">|</span>               <span class="o">|</span>
<span class="o">|</span>   <span class="o">|</span>               <span class="o">|</span>
<span class="o">|</span> <span class="err">1</span> <span class="o">|</span>      <span class="err">2</span>        <span class="o">|</span>
<span class="o">|</span>   <span class="o">|</span>               <span class="o">|</span>
<span class="o">|</span>   <span class="o">|</span>               <span class="o">|</span>
<span class="o">|</span>   <span class="o">|</span><span class="nt">---------------</span><span class="o">|</span>
<span class="o">|</span>   <span class="o">|</span>      <span class="err">3</span>        <span class="o">|</span>
<span class="nt">---------------------</span>
</code></pre></div></div>
<p>简单分为3个区域：</p>
<ol>
  <li>导航 - 用于做Todo Item的分类导航，是一个列表；</li>
  <li>内容 - 展示当前分类下的Todo Items；</li>
  <li>输入 - 在当前分类下创建新的Todo。</li>
</ol>

<blockquote>
  <p>这实际上是一个妥协方案，我的理想方案是简单的上中下三部分，上部分上导航，类似于chrome浏览器顶部页面管理那种，但是macOS对于列表横向滑动的滚轮支持实在是太差了，没有找到成熟的方式实现，妥协成当前这样了</p>
</blockquote>

<h2 id="二页面构建">二、页面构建</h2>
<p><a href="">上一章</a>中，我们有一个用于展示界面的ViewController类，这次要在其中填充上述的布局内容。
代码可参考<a href="https://github.com/boybeak/MyTodo">MyTodo</a>，最终实现效果如下：
<img src="/assets/images/my_todo_ui_init.png" alt="my_todo_ui_init" /></p>]]></content><author><name>boybeak</name></author><category term="独立开发笔记" /><category term="macOS" /><category term="JustTodo" /><summary type="html"><![CDATA[一、界面布局 一个简单的界面布局描述如下： --------------------- | | | | | | | | | | 1 | 2 | | | | | | | | |---------------| | | 3 | --------------------- 简单分为3个区域： 导航 - 用于做Todo Item的分类导航，是一个列表； 内容 - 展示当前分类下的Todo Items； 输入 - 在当前分类下创建新的Todo。]]></summary></entry></feed>